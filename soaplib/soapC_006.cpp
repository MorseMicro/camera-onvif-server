/* soapC_nnn.cpp
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.127 2023-11-30 23:29:18 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, std::vector<tt__Profile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const std::vector<tt__Profile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Profile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__Profile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Profile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, std::vector<tt__Profile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__Profile * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Profile, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, sizeof(tt__Profile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Profile(soap, tag, NULL, "tt:Profile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Profile(soap, tag, n, "tt:Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Profile *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, std::vector<tt__Profile *>  *d, std::vector<tt__Profile *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Profile(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Profile *> ::iterator j = d->begin();
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Profile(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Profile(std::vector<tt__Profile *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Profile(&*i);
}

SOAP_FMAC1 std::vector<tt__Profile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Profile *> *p;
	size_t k = sizeof(std::vector<tt__Profile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Profile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Profile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Profile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, std::vector<tt__AudioOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const std::vector<tt__AudioOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioOutput(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioOutput * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, sizeof(tt__AudioOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioOutput(soap, tag, NULL, "tt:AudioOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioOutput(soap, tag, n, "tt:AudioOutput"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioOutput *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, std::vector<tt__AudioOutput *>  *d, std::vector<tt__AudioOutput *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioOutput(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioOutput *> ::iterator j = d->begin();
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioOutput(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioOutput(std::vector<tt__AudioOutput *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioOutput(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioOutput *> *p;
	size_t k = sizeof(std::vector<tt__AudioOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, std::vector<tt__AudioSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const std::vector<tt__AudioSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioSource(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, sizeof(tt__AudioSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioSource(soap, tag, NULL, "tt:AudioSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioSource(soap, tag, n, "tt:AudioSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioSource *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, std::vector<tt__AudioSource *>  *d, std::vector<tt__AudioSource *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioSource(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioSource *> ::iterator j = d->begin();
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioSource(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioSource(std::vector<tt__AudioSource *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioSource(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioSource *> *p;
	size_t k = sizeof(std::vector<tt__AudioSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const std::vector<timg__ImagingPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotimg__ImagingPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, const std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotimg__ImagingPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<timg__ImagingPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
			return NULL;
		a->emplace_back();
		timg__ImagingPreset * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, sizeof(timg__ImagingPreset), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, n, "timg:ImagingPreset"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *>  *d, std::vector<timg__ImagingPreset *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<timg__ImagingPreset *> ::iterator j = d->begin();
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTotimg__ImagingPreset(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTotimg__ImagingPreset(std::vector<timg__ImagingPreset *> const*a)
{
	if (!a)
		return;
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTotimg__ImagingPreset(&*i);
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<timg__ImagingPreset *> *p;
	size_t k = sizeof(std::vector<timg__ImagingPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<timg__ImagingPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<timg__ImagingPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<timg__ImagingPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
		}
		else
		{	a->emplace_back();
		}
		_wsrfbf__BaseFaultType_Description *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description>  *d, std::vector<_wsrfbf__BaseFaultType_Description> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<_wsrfbf__BaseFaultType_Description> ::iterator j = d->begin();
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup__wsrfbf__BaseFaultType_Description(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(std::vector<_wsrfbf__BaseFaultType_Description> const*a)
{
	if (!a)
		return;
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del__wsrfbf__BaseFaultType_Description(&*i);
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const std::vector<wsnt__NotificationMessageHolderType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__NotificationMessageHolderType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, std::vector<wsnt__NotificationMessageHolderType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
			return NULL;
		a->emplace_back();
		wsnt__NotificationMessageHolderType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__NotificationMessageHolderType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, NULL, "wsnt:NotificationMessageHolderType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, n, "wsnt:NotificationMessageHolderType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, std::vector<wsnt__NotificationMessageHolderType *>  *d, std::vector<wsnt__NotificationMessageHolderType *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<wsnt__NotificationMessageHolderType *> ::iterator j = d->begin();
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTowsnt__NotificationMessageHolderType(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(std::vector<wsnt__NotificationMessageHolderType *> const*a)
{
	if (!a)
		return;
	for (std::vector<wsnt__NotificationMessageHolderType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTowsnt__NotificationMessageHolderType(&*i);
}

SOAP_FMAC1 std::vector<wsnt__NotificationMessageHolderType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__NotificationMessageHolderType *> *p;
	size_t k = sizeof(std::vector<wsnt__NotificationMessageHolderType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__NotificationMessageHolderType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__NotificationMessageHolderType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__NotificationMessageHolderType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, std::vector<wsnt__TopicExpressionType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const std::vector<wsnt__TopicExpressionType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, const std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wsnt__TopicExpressionType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, std::vector<wsnt__TopicExpressionType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap)))
			return NULL;
		a->emplace_back();
		wsnt__TopicExpressionType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wsnt__TopicExpressionType, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, NULL, "wsnt:TopicExpressionType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowsnt__TopicExpressionType(soap, tag, n, "wsnt:TopicExpressionType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, std::vector<wsnt__TopicExpressionType *>  *d, std::vector<wsnt__TopicExpressionType *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<wsnt__TopicExpressionType *> ::iterator j = d->begin();
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTowsnt__TopicExpressionType(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(std::vector<wsnt__TopicExpressionType *> const*a)
{
	if (!a)
		return;
	for (std::vector<wsnt__TopicExpressionType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTowsnt__TopicExpressionType(&*i);
}

SOAP_FMAC1 std::vector<wsnt__TopicExpressionType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowsnt__TopicExpressionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wsnt__TopicExpressionType *> *p;
	size_t k = sizeof(std::vector<wsnt__TopicExpressionType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wsnt__TopicExpressionType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wsnt__TopicExpressionType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wsnt__TopicExpressionType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, std::vector<tt__MinimumProfile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, const std::vector<tt__MinimumProfile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__MinimumProfile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__MinimumProfile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, const char *tag, int id, const std::vector<tt__MinimumProfile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__MinimumProfile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__MinimumProfile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__MinimumProfile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, const char *tag, std::vector<tt__MinimumProfile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__MinimumProfile(soap)))
			return NULL;
		a->emplace_back();
		tt__MinimumProfile * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__MinimumProfile, SOAP_TYPE_std__vectorTemplateOfPointerTott__MinimumProfile, sizeof(tt__MinimumProfile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__MinimumProfile(soap, tag, NULL, "tt:MinimumProfile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__MinimumProfile(soap, tag, n, "tt:MinimumProfile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__MinimumProfile *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, std::vector<tt__MinimumProfile *>  *d, std::vector<tt__MinimumProfile *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__MinimumProfile(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__MinimumProfile *> ::iterator j = d->begin();
	for (std::vector<tt__MinimumProfile *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__MinimumProfile(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__MinimumProfile(std::vector<tt__MinimumProfile *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__MinimumProfile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__MinimumProfile(&*i);
}

SOAP_FMAC1 std::vector<tt__MinimumProfile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__MinimumProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__MinimumProfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__MinimumProfile *> *p;
	size_t k = sizeof(std::vector<tt__MinimumProfile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__MinimumProfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__MinimumProfile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__MinimumProfile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__MinimumProfile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, std::vector<tt__VideoEncoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const std::vector<tt__VideoEncoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoEncoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoEncoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoEncoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoEncoderConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, NULL, "tt:VideoEncoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, n, "tt:VideoEncoderConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoEncoderConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, std::vector<tt__VideoEncoderConfiguration *>  *d, std::vector<tt__VideoEncoderConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__VideoEncoderConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__VideoEncoderConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(std::vector<tt__VideoEncoderConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__VideoEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__VideoEncoderConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__VideoEncoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoEncoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoEncoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoEncoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoEncoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoEncoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, std::vector<tt__VideoSourceConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const std::vector<tt__VideoSourceConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoSourceConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoSourceConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoSourceConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoSourceConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoSourceConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoSourceConfiguration(soap, tag, NULL, "tt:VideoSourceConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoSourceConfiguration(soap, tag, n, "tt:VideoSourceConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoSourceConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, std::vector<tt__VideoSourceConfiguration *>  *d, std::vector<tt__VideoSourceConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__VideoSourceConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__VideoSourceConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(std::vector<tt__VideoSourceConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__VideoSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__VideoSourceConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__VideoSourceConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoSourceConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoSourceConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoSourceConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoSourceConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoSourceConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, std::vector<tt__ImagingVideoSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, const std::vector<tt__ImagingVideoSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ImagingVideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ImagingVideoSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, const char *tag, int id, const std::vector<tt__ImagingVideoSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ImagingVideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ImagingVideoSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ImagingVideoSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, const char *tag, std::vector<tt__ImagingVideoSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ImagingVideoSource(soap)))
			return NULL;
		a->emplace_back();
		tt__ImagingVideoSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ImagingVideoSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__ImagingVideoSource, sizeof(tt__ImagingVideoSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ImagingVideoSource(soap, tag, NULL, "tt:ImagingVideoSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ImagingVideoSource(soap, tag, n, "tt:ImagingVideoSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ImagingVideoSource *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, std::vector<tt__ImagingVideoSource *>  *d, std::vector<tt__ImagingVideoSource *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__ImagingVideoSource(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__ImagingVideoSource *> ::iterator j = d->begin();
	for (std::vector<tt__ImagingVideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__ImagingVideoSource(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__ImagingVideoSource(std::vector<tt__ImagingVideoSource *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__ImagingVideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__ImagingVideoSource(&*i);
}

SOAP_FMAC1 std::vector<tt__ImagingVideoSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ImagingVideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ImagingVideoSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ImagingVideoSource *> *p;
	size_t k = sizeof(std::vector<tt__ImagingVideoSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ImagingVideoSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ImagingVideoSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ImagingVideoSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ImagingVideoSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, std::vector<tt__ImagingVideoSourceOptions *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, const std::vector<tt__ImagingVideoSourceOptions *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ImagingVideoSourceOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ImagingVideoSourceOptions(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, const char *tag, int id, const std::vector<tt__ImagingVideoSourceOptions *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ImagingVideoSourceOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ImagingVideoSourceOptions(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ImagingVideoSourceOptions *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, const char *tag, std::vector<tt__ImagingVideoSourceOptions *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap)))
			return NULL;
		a->emplace_back();
		tt__ImagingVideoSourceOptions * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ImagingVideoSourceOptions, SOAP_TYPE_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions, sizeof(tt__ImagingVideoSourceOptions), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ImagingVideoSourceOptions(soap, tag, NULL, "tt:ImagingVideoSourceOptions"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ImagingVideoSourceOptions(soap, tag, n, "tt:ImagingVideoSourceOptions"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ImagingVideoSourceOptions *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, std::vector<tt__ImagingVideoSourceOptions *>  *d, std::vector<tt__ImagingVideoSourceOptions *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__ImagingVideoSourceOptions *> ::iterator j = d->begin();
	for (std::vector<tt__ImagingVideoSourceOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__ImagingVideoSourceOptions(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(std::vector<tt__ImagingVideoSourceOptions *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__ImagingVideoSourceOptions *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__ImagingVideoSourceOptions(&*i);
}

SOAP_FMAC1 std::vector<tt__ImagingVideoSourceOptions *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ImagingVideoSourceOptions *> *p;
	size_t k = sizeof(std::vector<tt__ImagingVideoSourceOptions *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ImagingVideoSourceOptions *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ImagingVideoSourceOptions *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ImagingVideoSourceOptions *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, std::vector<tt__VideoSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const std::vector<tt__VideoSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, const char *tag, std::vector<tt__VideoSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoSource(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource, sizeof(tt__VideoSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoSource(soap, tag, NULL, "tt:VideoSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoSource(soap, tag, n, "tt:VideoSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoSource *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, std::vector<tt__VideoSource *>  *d, std::vector<tt__VideoSource *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__VideoSource(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__VideoSource *> ::iterator j = d->begin();
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__VideoSource(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__VideoSource(std::vector<tt__VideoSource *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__VideoSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__VideoSource(&*i);
}

SOAP_FMAC1 std::vector<tt__VideoSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoSource *> *p;
	size_t k = sizeof(std::vector<tt__VideoSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__OSDType(struct soap *soap, std::vector<tt__OSDType> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__OSDType(struct soap *soap, const std::vector<tt__OSDType> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, int id, const std::vector<tt__OSDType> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OSDType> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__OSDType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OSDType> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__OSDType(struct soap *soap, const char *tag, std::vector<tt__OSDType> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__OSDType(soap)))
			return NULL;
		a->emplace_back();
		tt__OSDType *n = &a->back();
		soap_default_tt__OSDType(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__OSDType, SOAP_TYPE_std__vectorTemplateOftt__OSDType, sizeof(tt__OSDType), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__OSDType(soap, tag, NULL, "tt:OSDType"))
				break;
		}
		else
		{	if (!soap_in_tt__OSDType(soap, tag, n, "tt:OSDType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OSDType>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__OSDType(struct soap *soap, std::vector<tt__OSDType>  *d, std::vector<tt__OSDType> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__OSDType(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__OSDType(std::vector<tt__OSDType> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__OSDType>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__OSDType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__OSDType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OSDType> *p;
	size_t k = sizeof(std::vector<tt__OSDType> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__OSDType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OSDType> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OSDType> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OSDType>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const std::vector<tt__ColorspaceRange *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__ColorspaceRange(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, const std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__ColorspaceRange(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, std::vector<tt__ColorspaceRange *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__ColorspaceRange(soap)))
			return NULL;
		a->emplace_back();
		tt__ColorspaceRange * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, sizeof(tt__ColorspaceRange), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__ColorspaceRange(soap, tag, NULL, "tt:ColorspaceRange"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__ColorspaceRange(soap, tag, n, "tt:ColorspaceRange"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ColorspaceRange *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *>  *d, std::vector<tt__ColorspaceRange *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__ColorspaceRange(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__ColorspaceRange *> ::iterator j = d->begin();
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__ColorspaceRange(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__ColorspaceRange(std::vector<tt__ColorspaceRange *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__ColorspaceRange *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__ColorspaceRange(&*i);
}

SOAP_FMAC1 std::vector<tt__ColorspaceRange *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__ColorspaceRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ColorspaceRange *> *p;
	size_t k = sizeof(std::vector<tt__ColorspaceRange *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ColorspaceRange *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ColorspaceRange *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ColorspaceRange *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const std::vector<tt__Color *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Color(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, int id, const std::vector<tt__Color *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Color(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Color *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, std::vector<tt__Color *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Color(soap)))
			return NULL;
		a->emplace_back();
		tt__Color * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Color, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, sizeof(tt__Color), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Color(soap, tag, NULL, "tt:Color"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Color(soap, tag, n, "tt:Color"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Color *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *>  *d, std::vector<tt__Color *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Color(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Color *> ::iterator j = d->begin();
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Color(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Color(std::vector<tt__Color *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Color *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Color(&*i);
}

SOAP_FMAC1 std::vector<tt__Color *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Color(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Color *> *p;
	size_t k = sizeof(std::vector<tt__Color *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Color *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Color *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Color *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const std::vector<tt__Config *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Config(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, int id, const std::vector<tt__Config *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Config(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Config *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Config(struct soap *soap, const char *tag, std::vector<tt__Config *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Config(soap)))
			return NULL;
		a->emplace_back();
		tt__Config * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Config, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, sizeof(tt__Config), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Config(soap, tag, NULL, "tt:Config"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Config(soap, tag, n, "tt:Config"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Config(struct soap *soap, std::vector<tt__Config *>  *d, std::vector<tt__Config *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Config(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Config *> ::iterator j = d->begin();
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Config(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Config(std::vector<tt__Config *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Config *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Config(&*i);
}

SOAP_FMAC1 std::vector<tt__Config *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Config *> *p;
	size_t k = sizeof(std::vector<tt__Config *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Config *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Config *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Config *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const std::vector<tt__Vector *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Vector(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, int id, const std::vector<tt__Vector *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Vector(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Vector *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, const char *tag, std::vector<tt__Vector *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Vector(soap)))
			return NULL;
		a->emplace_back();
		tt__Vector * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Vector, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, sizeof(tt__Vector), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Vector(soap, tag, NULL, "tt:Vector"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Vector(soap, tag, n, "tt:Vector"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, std::vector<tt__Vector *>  *d, std::vector<tt__Vector *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Vector(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Vector *> ::iterator j = d->begin();
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Vector(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Vector(std::vector<tt__Vector *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Vector *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Vector(&*i);
}

SOAP_FMAC1 std::vector<tt__Vector *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Vector *> *p;
	size_t k = sizeof(std::vector<tt__Vector *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Vector *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Vector *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Vector *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, std::vector<_tt__ItemList_ElementItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const std::vector<_tt__ItemList_ElementItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_ElementItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_ElementItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_ElementItem));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemList_ElementItem *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemList_ElementItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, sizeof(_tt__ItemList_ElementItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_ElementItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_ElementItem(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, std::vector<_tt__ItemList_ElementItem>  *d, std::vector<_tt__ItemList_ElementItem> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOf_tt__ItemList_ElementItem(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<_tt__ItemList_ElementItem> ::iterator j = d->begin();
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup__tt__ItemList_ElementItem(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOf_tt__ItemList_ElementItem(std::vector<_tt__ItemList_ElementItem> const*a)
{
	if (!a)
		return;
	for (std::vector<_tt__ItemList_ElementItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del__tt__ItemList_ElementItem(&*i);
}

SOAP_FMAC1 std::vector<_tt__ItemList_ElementItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_ElementItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_ElementItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_ElementItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_ElementItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_ElementItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_ElementItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, std::vector<_tt__ItemList_SimpleItem> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const std::vector<_tt__ItemList_SimpleItem> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, const std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_tt__ItemList_SimpleItem> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, std::vector<_tt__ItemList_SimpleItem> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_tt__ItemList_SimpleItem));
		}
		else
		{	a->emplace_back();
		}
		_tt__ItemList_SimpleItem *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__tt__ItemList_SimpleItem, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, sizeof(_tt__ItemList_SimpleItem), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__tt__ItemList_SimpleItem(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__tt__ItemList_SimpleItem(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, std::vector<_tt__ItemList_SimpleItem>  *d, std::vector<_tt__ItemList_SimpleItem> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<_tt__ItemList_SimpleItem> ::iterator j = d->begin();
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup__tt__ItemList_SimpleItem(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOf_tt__ItemList_SimpleItem(std::vector<_tt__ItemList_SimpleItem> const*a)
{
	if (!a)
		return;
	for (std::vector<_tt__ItemList_SimpleItem> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del__tt__ItemList_SimpleItem(&*i);
}

SOAP_FMAC1 std::vector<_tt__ItemList_SimpleItem>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_tt__ItemList_SimpleItem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_tt__ItemList_SimpleItem> *p;
	size_t k = sizeof(std::vector<_tt__ItemList_SimpleItem> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_tt__ItemList_SimpleItem> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_tt__ItemList_SimpleItem> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_tt__ItemList_SimpleItem>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<tt__AutoFocusMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const std::vector<tt__AutoFocusMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, int id, const std::vector<tt__AutoFocusMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AutoFocusMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AutoFocusMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AutoFocusMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, const char *tag, std::vector<tt__AutoFocusMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap)))
			return NULL;
		a->emplace_back();
		tt__AutoFocusMode *n = &a->back();
		soap_default_tt__AutoFocusMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AutoFocusMode, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, sizeof(tt__AutoFocusMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AutoFocusMode(soap, tag, NULL, "tt:AutoFocusMode"))
				break;
		}
		else
		{	if (!soap_in_tt__AutoFocusMode(soap, tag, n, "tt:AutoFocusMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AutoFocusMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, std::vector<tt__AutoFocusMode>  *d, std::vector<tt__AutoFocusMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__AutoFocusMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__AutoFocusMode(std::vector<tt__AutoFocusMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__AutoFocusMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AutoFocusMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AutoFocusMode> *p;
	size_t k = sizeof(std::vector<tt__AutoFocusMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AutoFocusMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AutoFocusMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AutoFocusMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<tt__WhiteBalanceMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const std::vector<tt__WhiteBalanceMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, int id, const std::vector<tt__WhiteBalanceMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__WhiteBalanceMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WhiteBalanceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__WhiteBalanceMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, const char *tag, std::vector<tt__WhiteBalanceMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap)))
			return NULL;
		a->emplace_back();
		tt__WhiteBalanceMode *n = &a->back();
		soap_default_tt__WhiteBalanceMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__WhiteBalanceMode, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, sizeof(tt__WhiteBalanceMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WhiteBalanceMode(soap, tag, NULL, "tt:WhiteBalanceMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WhiteBalanceMode(soap, tag, n, "tt:WhiteBalanceMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__WhiteBalanceMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, std::vector<tt__WhiteBalanceMode>  *d, std::vector<tt__WhiteBalanceMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__WhiteBalanceMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__WhiteBalanceMode(std::vector<tt__WhiteBalanceMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__WhiteBalanceMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WhiteBalanceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__WhiteBalanceMode> *p;
	size_t k = sizeof(std::vector<tt__WhiteBalanceMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__WhiteBalanceMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__WhiteBalanceMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__WhiteBalanceMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<tt__ExposurePriority> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const std::vector<tt__ExposurePriority> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, int id, const std::vector<tt__ExposurePriority> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ExposurePriority> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposurePriority(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ExposurePriority> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, const char *tag, std::vector<tt__ExposurePriority> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposurePriority(soap)))
			return NULL;
		a->emplace_back();
		tt__ExposurePriority *n = &a->back();
		soap_default_tt__ExposurePriority(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ExposurePriority, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, sizeof(tt__ExposurePriority), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposurePriority(soap, tag, NULL, "tt:ExposurePriority"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposurePriority(soap, tag, n, "tt:ExposurePriority"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ExposurePriority>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, std::vector<tt__ExposurePriority>  *d, std::vector<tt__ExposurePriority> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__ExposurePriority(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__ExposurePriority(std::vector<tt__ExposurePriority> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__ExposurePriority>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposurePriority(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposurePriority(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ExposurePriority> *p;
	size_t k = sizeof(std::vector<tt__ExposurePriority> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ExposurePriority> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ExposurePriority> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ExposurePriority>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<tt__ExposureMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const std::vector<tt__ExposureMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, int id, const std::vector<tt__ExposureMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ExposureMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ExposureMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ExposureMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ExposureMode(struct soap *soap, const char *tag, std::vector<tt__ExposureMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ExposureMode(soap)))
			return NULL;
		a->emplace_back();
		tt__ExposureMode *n = &a->back();
		soap_default_tt__ExposureMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ExposureMode, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, sizeof(tt__ExposureMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ExposureMode(soap, tag, NULL, "tt:ExposureMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ExposureMode(soap, tag, n, "tt:ExposureMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ExposureMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__ExposureMode(struct soap *soap, std::vector<tt__ExposureMode>  *d, std::vector<tt__ExposureMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__ExposureMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__ExposureMode(std::vector<tt__ExposureMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__ExposureMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ExposureMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ExposureMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ExposureMode> *p;
	size_t k = sizeof(std::vector<tt__ExposureMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ExposureMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ExposureMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ExposureMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ExposureMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<tt__BacklightCompensationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const std::vector<tt__BacklightCompensationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__BacklightCompensationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BacklightCompensationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__BacklightCompensationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BacklightCompensationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, const char *tag, std::vector<tt__BacklightCompensationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__BacklightCompensationMode *n = &a->back();
		soap_default_tt__BacklightCompensationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__BacklightCompensationMode, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, sizeof(tt__BacklightCompensationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__BacklightCompensationMode(soap, tag, NULL, "tt:BacklightCompensationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__BacklightCompensationMode(soap, tag, n, "tt:BacklightCompensationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BacklightCompensationMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, std::vector<tt__BacklightCompensationMode>  *d, std::vector<tt__BacklightCompensationMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__BacklightCompensationMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__BacklightCompensationMode(std::vector<tt__BacklightCompensationMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__BacklightCompensationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__BacklightCompensationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BacklightCompensationMode> *p;
	size_t k = sizeof(std::vector<tt__BacklightCompensationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BacklightCompensationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BacklightCompensationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BacklightCompensationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<tt__WideDynamicMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const std::vector<tt__WideDynamicMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, int id, const std::vector<tt__WideDynamicMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__WideDynamicMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__WideDynamicMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__WideDynamicMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, const char *tag, std::vector<tt__WideDynamicMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap)))
			return NULL;
		a->emplace_back();
		tt__WideDynamicMode *n = &a->back();
		soap_default_tt__WideDynamicMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__WideDynamicMode, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, sizeof(tt__WideDynamicMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__WideDynamicMode(soap, tag, NULL, "tt:WideDynamicMode"))
				break;
		}
		else
		{	if (!soap_in_tt__WideDynamicMode(soap, tag, n, "tt:WideDynamicMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__WideDynamicMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, std::vector<tt__WideDynamicMode>  *d, std::vector<tt__WideDynamicMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__WideDynamicMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__WideDynamicMode(std::vector<tt__WideDynamicMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__WideDynamicMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__WideDynamicMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__WideDynamicMode> *p;
	size_t k = sizeof(std::vector<tt__WideDynamicMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__WideDynamicMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__WideDynamicMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__WideDynamicMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, std::vector<tt__ImageStabilizationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const std::vector<tt__ImageStabilizationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__ImageStabilizationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__ImageStabilizationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ImageStabilizationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__ImageStabilizationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, const char *tag, std::vector<tt__ImageStabilizationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ImageStabilizationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__ImageStabilizationMode *n = &a->back();
		soap_default_tt__ImageStabilizationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ImageStabilizationMode, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, sizeof(tt__ImageStabilizationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ImageStabilizationMode(soap, tag, NULL, "tt:ImageStabilizationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ImageStabilizationMode(soap, tag, n, "tt:ImageStabilizationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__ImageStabilizationMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, std::vector<tt__ImageStabilizationMode>  *d, std::vector<tt__ImageStabilizationMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__ImageStabilizationMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__ImageStabilizationMode(std::vector<tt__ImageStabilizationMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__ImageStabilizationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ImageStabilizationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__ImageStabilizationMode> *p;
	size_t k = sizeof(std::vector<tt__ImageStabilizationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__ImageStabilizationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__ImageStabilizationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__ImageStabilizationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<tt__IrCutFilterMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const std::vector<tt__IrCutFilterMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IrCutFilterMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap)))
			return NULL;
		a->emplace_back();
		tt__IrCutFilterMode *n = &a->back();
		soap_default_tt__IrCutFilterMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IrCutFilterMode, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, sizeof(tt__IrCutFilterMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IrCutFilterMode(soap, tag, NULL, "tt:IrCutFilterMode"))
				break;
		}
		else
		{	if (!soap_in_tt__IrCutFilterMode(soap, tag, n, "tt:IrCutFilterMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, std::vector<tt__IrCutFilterMode>  *d, std::vector<tt__IrCutFilterMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__IrCutFilterMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__IrCutFilterMode(std::vector<tt__IrCutFilterMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IrCutFilterMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterMode> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, std::vector<tt__IrCutFilterAutoAdjustment *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const std::vector<tt__IrCutFilterAutoAdjustment *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IrCutFilterAutoAdjustment(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IrCutFilterAutoAdjustment *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, std::vector<tt__IrCutFilterAutoAdjustment *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap)))
			return NULL;
		a->emplace_back();
		tt__IrCutFilterAutoAdjustment * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, NULL, "tt:IrCutFilterAutoAdjustment"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, n, "tt:IrCutFilterAutoAdjustment"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, std::vector<tt__IrCutFilterAutoAdjustment *>  *d, std::vector<tt__IrCutFilterAutoAdjustment *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__IrCutFilterAutoAdjustment *> ::iterator j = d->begin();
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__IrCutFilterAutoAdjustment(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(std::vector<tt__IrCutFilterAutoAdjustment *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__IrCutFilterAutoAdjustment *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__IrCutFilterAutoAdjustment(&*i);
}

SOAP_FMAC1 std::vector<tt__IrCutFilterAutoAdjustment *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IrCutFilterAutoAdjustment *> *p;
	size_t k = sizeof(std::vector<tt__IrCutFilterAutoAdjustment *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IrCutFilterAutoAdjustment *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IrCutFilterAutoAdjustment *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IrCutFilterAutoAdjustment *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, std::vector<tt__SystemLogUri *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const std::vector<tt__SystemLogUri *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__SystemLogUri(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, const std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__SystemLogUri(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SystemLogUri *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, const char *tag, std::vector<tt__SystemLogUri *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__SystemLogUri(soap)))
			return NULL;
		a->emplace_back();
		tt__SystemLogUri * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, sizeof(tt__SystemLogUri), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__SystemLogUri(soap, tag, NULL, "tt:SystemLogUri"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__SystemLogUri(soap, tag, n, "tt:SystemLogUri"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SystemLogUri *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, std::vector<tt__SystemLogUri *>  *d, std::vector<tt__SystemLogUri *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__SystemLogUri(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__SystemLogUri *> ::iterator j = d->begin();
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__SystemLogUri(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__SystemLogUri(std::vector<tt__SystemLogUri *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__SystemLogUri *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__SystemLogUri(&*i);
}

SOAP_FMAC1 std::vector<tt__SystemLogUri *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SystemLogUri *> *p;
	size_t k = sizeof(std::vector<tt__SystemLogUri *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SystemLogUri *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SystemLogUri *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SystemLogUri *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const std::vector<tt__OnvifVersion *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OnvifVersion(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, const std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OnvifVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OnvifVersion *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, const char *tag, std::vector<tt__OnvifVersion *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap)))
			return NULL;
		a->emplace_back();
		tt__OnvifVersion * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, sizeof(tt__OnvifVersion), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OnvifVersion(soap, tag, NULL, "tt:OnvifVersion"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OnvifVersion(soap, tag, n, "tt:OnvifVersion"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OnvifVersion *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, std::vector<tt__OnvifVersion *>  *d, std::vector<tt__OnvifVersion *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__OnvifVersion(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__OnvifVersion *> ::iterator j = d->begin();
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__OnvifVersion(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__OnvifVersion(std::vector<tt__OnvifVersion *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__OnvifVersion *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__OnvifVersion(&*i);
}

SOAP_FMAC1 std::vector<tt__OnvifVersion *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OnvifVersion *> *p;
	size_t k = sizeof(std::vector<tt__OnvifVersion *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OnvifVersion *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OnvifVersion *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OnvifVersion *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__AuxiliaryData(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{	if (!soap_in_tt__AuxiliaryData(soap, tag, n, "tt:AuxiliaryData"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__AuxiliaryData(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, std::vector<tt__Dot11Cipher> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const std::vector<tt__Dot11Cipher> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Cipher> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Cipher> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11Cipher(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Cipher> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, const char *tag, std::vector<tt__Dot11Cipher> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11Cipher(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11Cipher *n = &a->back();
		soap_default_tt__Dot11Cipher(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11Cipher, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, sizeof(tt__Dot11Cipher), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11Cipher(soap, tag, NULL, "tt:Dot11Cipher"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11Cipher(soap, tag, n, "tt:Dot11Cipher"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Cipher>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, std::vector<tt__Dot11Cipher>  *d, std::vector<tt__Dot11Cipher> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__Dot11Cipher(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__Dot11Cipher(std::vector<tt__Dot11Cipher> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__Dot11Cipher>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11Cipher(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Cipher> *p;
	size_t k = sizeof(std::vector<tt__Dot11Cipher> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Cipher> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Cipher> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Cipher>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, std::vector<tt__Dot11AuthAndMangementSuite> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const std::vector<tt__Dot11AuthAndMangementSuite> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AuthAndMangementSuite> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AuthAndMangementSuite> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, std::vector<tt__Dot11AuthAndMangementSuite> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11AuthAndMangementSuite *n = &a->back();
		soap_default_tt__Dot11AuthAndMangementSuite(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, sizeof(tt__Dot11AuthAndMangementSuite), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, NULL, "tt:Dot11AuthAndMangementSuite"))
				break;
		}
		else
		{	if (!soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, n, "tt:Dot11AuthAndMangementSuite"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AuthAndMangementSuite>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, std::vector<tt__Dot11AuthAndMangementSuite>  *d, std::vector<tt__Dot11AuthAndMangementSuite> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(std::vector<tt__Dot11AuthAndMangementSuite> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__Dot11AuthAndMangementSuite>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AuthAndMangementSuite> *p;
	size_t k = sizeof(std::vector<tt__Dot11AuthAndMangementSuite> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AuthAndMangementSuite> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AuthAndMangementSuite> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AuthAndMangementSuite>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, std::vector<tt__NetworkZeroConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const std::vector<tt__NetworkZeroConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkZeroConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, std::vector<tt__NetworkZeroConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkZeroConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, NULL, "tt:NetworkZeroConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, n, "tt:NetworkZeroConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkZeroConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, std::vector<tt__NetworkZeroConfiguration *>  *d, std::vector<tt__NetworkZeroConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__NetworkZeroConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__NetworkZeroConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(std::vector<tt__NetworkZeroConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__NetworkZeroConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__NetworkZeroConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__NetworkZeroConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkZeroConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__NetworkZeroConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkZeroConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkZeroConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkZeroConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const std::vector<tt__PrefixedIPv6Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv6Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv6Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap)))
			return NULL;
		a->emplace_back();
		tt__PrefixedIPv6Address * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, NULL, "tt:PrefixedIPv6Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv6Address(soap, tag, n, "tt:PrefixedIPv6Address"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, std::vector<tt__PrefixedIPv6Address *>  *d, std::vector<tt__PrefixedIPv6Address *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__PrefixedIPv6Address *> ::iterator j = d->begin();
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__PrefixedIPv6Address(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(std::vector<tt__PrefixedIPv6Address *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__PrefixedIPv6Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__PrefixedIPv6Address(&*i);
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv6Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv6Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv6Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv6Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv6Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv6Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const std::vector<tt__PrefixedIPv4Address *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PrefixedIPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PrefixedIPv4Address *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, std::vector<tt__PrefixedIPv4Address *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap)))
			return NULL;
		a->emplace_back();
		tt__PrefixedIPv4Address * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, NULL, "tt:PrefixedIPv4Address"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PrefixedIPv4Address(soap, tag, n, "tt:PrefixedIPv4Address"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, std::vector<tt__PrefixedIPv4Address *>  *d, std::vector<tt__PrefixedIPv4Address *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__PrefixedIPv4Address *> ::iterator j = d->begin();
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__PrefixedIPv4Address(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(std::vector<tt__PrefixedIPv4Address *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__PrefixedIPv4Address *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__PrefixedIPv4Address(&*i);
}

SOAP_FMAC1 std::vector<tt__PrefixedIPv4Address *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PrefixedIPv4Address *> *p;
	size_t k = sizeof(std::vector<tt__PrefixedIPv4Address *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PrefixedIPv4Address *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PrefixedIPv4Address *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PrefixedIPv4Address *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, std::vector<tt__Dot11Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const std::vector<tt__Dot11Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot11Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11Configuration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11Configuration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, sizeof(tt__Dot11Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11Configuration(soap, tag, NULL, "tt:Dot11Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11Configuration(soap, tag, n, "tt:Dot11Configuration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11Configuration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, std::vector<tt__Dot11Configuration *>  *d, std::vector<tt__Dot11Configuration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Dot11Configuration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Dot11Configuration *> ::iterator j = d->begin();
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Dot11Configuration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Dot11Configuration(std::vector<tt__Dot11Configuration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Dot11Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Dot11Configuration(&*i);
}

SOAP_FMAC1 std::vector<tt__Dot11Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot11Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, std::vector<tt__Dot3Configuration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const std::vector<tt__Dot3Configuration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot3Configuration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot3Configuration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot3Configuration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, const char *tag, std::vector<tt__Dot3Configuration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot3Configuration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot3Configuration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot3Configuration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, sizeof(tt__Dot3Configuration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot3Configuration(soap, tag, NULL, "tt:Dot3Configuration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot3Configuration(soap, tag, n, "tt:Dot3Configuration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot3Configuration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, std::vector<tt__Dot3Configuration *>  *d, std::vector<tt__Dot3Configuration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Dot3Configuration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Dot3Configuration *> ::iterator j = d->begin();
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Dot3Configuration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Dot3Configuration(std::vector<tt__Dot3Configuration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Dot3Configuration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Dot3Configuration(&*i);
}

SOAP_FMAC1 std::vector<tt__Dot3Configuration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot3Configuration *> *p;
	size_t k = sizeof(std::vector<tt__Dot3Configuration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot3Configuration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot3Configuration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot3Configuration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, std::vector<tt__AudioEncoderConfigurationOption *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const std::vector<tt__AudioEncoderConfigurationOption *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfigurationOption *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfigurationOption *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioEncoderConfigurationOption * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, NULL, "tt:AudioEncoderConfigurationOption"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, n, "tt:AudioEncoderConfigurationOption"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfigurationOption *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, std::vector<tt__AudioEncoderConfigurationOption *>  *d, std::vector<tt__AudioEncoderConfigurationOption *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioEncoderConfigurationOption *> ::iterator j = d->begin();
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioEncoderConfigurationOption(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(std::vector<tt__AudioEncoderConfigurationOption *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioEncoderConfigurationOption *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioEncoderConfigurationOption(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfigurationOption *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioEncoderConfigurationOption *> *p;
	size_t k = sizeof(std::vector<tt__AudioEncoderConfigurationOption *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioEncoderConfigurationOption *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioEncoderConfigurationOption *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioEncoderConfigurationOption *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__H264Profile(struct soap *soap, std::vector<tt__H264Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__H264Profile(struct soap *soap, const std::vector<tt__H264Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__H264Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__H264Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__H264Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__H264Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__H264Profile(struct soap *soap, const char *tag, std::vector<tt__H264Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__H264Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__H264Profile *n = &a->back();
		soap_default_tt__H264Profile(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__H264Profile, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, sizeof(tt__H264Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__H264Profile(soap, tag, NULL, "tt:H264Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__H264Profile(soap, tag, n, "tt:H264Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__H264Profile>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__H264Profile(struct soap *soap, std::vector<tt__H264Profile>  *d, std::vector<tt__H264Profile> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__H264Profile(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__H264Profile(std::vector<tt__H264Profile> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__H264Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__H264Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__H264Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__H264Profile> *p;
	size_t k = sizeof(std::vector<tt__H264Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__H264Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__H264Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__H264Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__H264Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, std::vector<tt__Mpeg4Profile> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const std::vector<tt__Mpeg4Profile> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__Mpeg4Profile> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Mpeg4Profile> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__Mpeg4Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Mpeg4Profile> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, const char *tag, std::vector<tt__Mpeg4Profile> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__Mpeg4Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__Mpeg4Profile *n = &a->back();
		soap_default_tt__Mpeg4Profile(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Mpeg4Profile, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, sizeof(tt__Mpeg4Profile), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__Mpeg4Profile(soap, tag, NULL, "tt:Mpeg4Profile"))
				break;
		}
		else
		{	if (!soap_in_tt__Mpeg4Profile(soap, tag, n, "tt:Mpeg4Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Mpeg4Profile>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, std::vector<tt__Mpeg4Profile>  *d, std::vector<tt__Mpeg4Profile> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__Mpeg4Profile(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__Mpeg4Profile(std::vector<tt__Mpeg4Profile> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__Mpeg4Profile>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__Mpeg4Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Mpeg4Profile> *p;
	size_t k = sizeof(std::vector<tt__Mpeg4Profile> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Mpeg4Profile> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Mpeg4Profile> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Mpeg4Profile>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, std::vector<tt__VideoResolution *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const std::vector<tt__VideoResolution *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoResolution(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoResolution(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoResolution *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, const char *tag, std::vector<tt__VideoResolution *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoResolution(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoResolution * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, sizeof(tt__VideoResolution), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoResolution(soap, tag, NULL, "tt:VideoResolution"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoResolution(soap, tag, n, "tt:VideoResolution"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoResolution *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, std::vector<tt__VideoResolution *>  *d, std::vector<tt__VideoResolution *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__VideoResolution(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__VideoResolution *> ::iterator j = d->begin();
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__VideoResolution(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__VideoResolution(std::vector<tt__VideoResolution *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__VideoResolution *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__VideoResolution(&*i);
}

SOAP_FMAC1 std::vector<tt__VideoResolution *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoResolution *> *p;
	size_t k = sizeof(std::vector<tt__VideoResolution *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoResolution *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoResolution *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoResolution *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__RotateMode(struct soap *soap, std::vector<tt__RotateMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__RotateMode(struct soap *soap, const std::vector<tt__RotateMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, int id, const std::vector<tt__RotateMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RotateMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__RotateMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RotateMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__RotateMode(struct soap *soap, const char *tag, std::vector<tt__RotateMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__RotateMode(soap)))
			return NULL;
		a->emplace_back();
		tt__RotateMode *n = &a->back();
		soap_default_tt__RotateMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RotateMode, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, sizeof(tt__RotateMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__RotateMode(soap, tag, NULL, "tt:RotateMode"))
				break;
		}
		else
		{	if (!soap_in_tt__RotateMode(soap, tag, n, "tt:RotateMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RotateMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__RotateMode(struct soap *soap, std::vector<tt__RotateMode>  *d, std::vector<tt__RotateMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__RotateMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__RotateMode(std::vector<tt__RotateMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__RotateMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__RotateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__RotateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RotateMode> *p;
	size_t k = sizeof(std::vector<tt__RotateMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__RotateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RotateMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RotateMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RotateMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, std::vector<tt__SceneOrientationMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const std::vector<tt__SceneOrientationMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, int id, const std::vector<tt__SceneOrientationMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__SceneOrientationMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__SceneOrientationMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__SceneOrientationMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, const char *tag, std::vector<tt__SceneOrientationMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__SceneOrientationMode(soap)))
			return NULL;
		a->emplace_back();
		tt__SceneOrientationMode *n = &a->back();
		soap_default_tt__SceneOrientationMode(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__SceneOrientationMode, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, sizeof(tt__SceneOrientationMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__SceneOrientationMode(soap, tag, NULL, "tt:SceneOrientationMode"))
				break;
		}
		else
		{	if (!soap_in_tt__SceneOrientationMode(soap, tag, n, "tt:SceneOrientationMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__SceneOrientationMode>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, std::vector<tt__SceneOrientationMode>  *d, std::vector<tt__SceneOrientationMode> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__SceneOrientationMode(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__SceneOrientationMode(std::vector<tt__SceneOrientationMode> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__SceneOrientationMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__SceneOrientationMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__SceneOrientationMode> *p;
	size_t k = sizeof(std::vector<tt__SceneOrientationMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__SceneOrientationMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__SceneOrientationMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__SceneOrientationMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, std::vector<tt__LensProjection *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const std::vector<tt__LensProjection *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensProjection(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, int id, const std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensProjection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensProjection *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, const char *tag, std::vector<tt__LensProjection *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensProjection(soap)))
			return NULL;
		a->emplace_back();
		tt__LensProjection * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, sizeof(tt__LensProjection), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensProjection(soap, tag, NULL, "tt:LensProjection"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensProjection(soap, tag, n, "tt:LensProjection"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, std::vector<tt__LensProjection *>  *d, std::vector<tt__LensProjection *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__LensProjection(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__LensProjection *> ::iterator j = d->begin();
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__LensProjection(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__LensProjection(std::vector<tt__LensProjection *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__LensProjection *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__LensProjection(&*i);
}

SOAP_FMAC1 std::vector<tt__LensProjection *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensProjection *> *p;
	size_t k = sizeof(std::vector<tt__LensProjection *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensProjection *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensProjection *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensProjection *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, std::vector<tt__LensDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const std::vector<tt__LensDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LensDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LensDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LensDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, const char *tag, std::vector<tt__LensDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LensDescription(soap)))
			return NULL;
		a->emplace_back();
		tt__LensDescription * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, sizeof(tt__LensDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LensDescription(soap, tag, NULL, "tt:LensDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LensDescription(soap, tag, n, "tt:LensDescription"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, std::vector<tt__LensDescription *>  *d, std::vector<tt__LensDescription *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__LensDescription(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__LensDescription *> ::iterator j = d->begin();
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__LensDescription(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__LensDescription(std::vector<tt__LensDescription *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__LensDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__LensDescription(&*i);
}

SOAP_FMAC1 std::vector<tt__LensDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LensDescription *> *p;
	size_t k = sizeof(std::vector<tt__LensDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LensDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LensDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LensDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<int> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int> * SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfint(soap)))
			return NULL;
		a->emplace_back();
		int *n = &a->back();
		soap_default_int(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{	if (!soap_in_int(soap, tag, n, "xsd:int"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<int>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfint(struct soap *soap, std::vector<int>  *d, std::vector<int> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfint(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfint(std::vector<int> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<int>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<int> *p;
	size_t k = sizeof(std::vector<int> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<int> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<int> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<int>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, std::vector<tt__LocationEntity *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const std::vector<tt__LocationEntity *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__LocationEntity(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, int id, const std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__LocationEntity(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__LocationEntity *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, const char *tag, std::vector<tt__LocationEntity *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__LocationEntity(soap)))
			return NULL;
		a->emplace_back();
		tt__LocationEntity * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, sizeof(tt__LocationEntity), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__LocationEntity(soap, tag, NULL, "tt:LocationEntity"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__LocationEntity(soap, tag, n, "tt:LocationEntity"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__LocationEntity *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, std::vector<tt__LocationEntity *>  *d, std::vector<tt__LocationEntity *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__LocationEntity(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__LocationEntity *> ::iterator j = d->begin();
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__LocationEntity(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__LocationEntity(std::vector<tt__LocationEntity *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__LocationEntity *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__LocationEntity(&*i);
}

SOAP_FMAC1 std::vector<tt__LocationEntity *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__LocationEntity *> *p;
	size_t k = sizeof(std::vector<tt__LocationEntity *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__LocationEntity *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__LocationEntity *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__LocationEntity *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, std::vector<tds__StorageConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const std::vector<tds__StorageConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__StorageConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__StorageConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__StorageConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, const char *tag, std::vector<tds__StorageConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tds__StorageConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, sizeof(tds__StorageConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, NULL, "tds:StorageConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__StorageConfiguration(soap, tag, n, "tds:StorageConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__StorageConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, std::vector<tds__StorageConfiguration *>  *d, std::vector<tds__StorageConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tds__StorageConfiguration *> ::iterator j = d->begin();
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTotds__StorageConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTotds__StorageConfiguration(std::vector<tds__StorageConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tds__StorageConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTotds__StorageConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tds__StorageConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__StorageConfiguration *> *p;
	size_t k = sizeof(std::vector<tds__StorageConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__StorageConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__StorageConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__StorageConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, std::vector<tt__Dot11AvailableNetworks *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const std::vector<tt__Dot11AvailableNetworks *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot11AvailableNetworks(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot11AvailableNetworks *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, std::vector<tt__Dot11AvailableNetworks *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot11AvailableNetworks * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, NULL, "tt:Dot11AvailableNetworks"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, n, "tt:Dot11AvailableNetworks"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot11AvailableNetworks *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, std::vector<tt__Dot11AvailableNetworks *>  *d, std::vector<tt__Dot11AvailableNetworks *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Dot11AvailableNetworks *> ::iterator j = d->begin();
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Dot11AvailableNetworks(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(std::vector<tt__Dot11AvailableNetworks *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Dot11AvailableNetworks *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Dot11AvailableNetworks(&*i);
}

SOAP_FMAC1 std::vector<tt__Dot11AvailableNetworks *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot11AvailableNetworks *> *p;
	size_t k = sizeof(std::vector<tt__Dot11AvailableNetworks *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot11AvailableNetworks *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot11AvailableNetworks *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot11AvailableNetworks *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, std::vector<tt__RelayOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const std::vector<tt__RelayOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__RelayOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__RelayOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__RelayOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, const char *tag, std::vector<tt__RelayOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__RelayOutput(soap)))
			return NULL;
		a->emplace_back();
		tt__RelayOutput * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, sizeof(tt__RelayOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__RelayOutput(soap, tag, NULL, "tt:RelayOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__RelayOutput(soap, tag, n, "tt:RelayOutput"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__RelayOutput *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, std::vector<tt__RelayOutput *>  *d, std::vector<tt__RelayOutput *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__RelayOutput(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__RelayOutput *> ::iterator j = d->begin();
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__RelayOutput(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__RelayOutput(std::vector<tt__RelayOutput *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__RelayOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__RelayOutput(&*i);
}

SOAP_FMAC1 std::vector<tt__RelayOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__RelayOutput *> *p;
	size_t k = sizeof(std::vector<tt__RelayOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__RelayOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__RelayOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__RelayOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__ReferenceToken(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{	if (!soap_in_tt__ReferenceToken(soap, tag, n, "tt:ReferenceToken"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__ReferenceToken(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, std::vector<tt__Dot1XConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const std::vector<tt__Dot1XConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Dot1XConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Dot1XConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Dot1XConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, std::vector<tt__Dot1XConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__Dot1XConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, NULL, "tt:Dot1XConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Dot1XConfiguration(soap, tag, n, "tt:Dot1XConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Dot1XConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, std::vector<tt__Dot1XConfiguration *>  *d, std::vector<tt__Dot1XConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Dot1XConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Dot1XConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Dot1XConfiguration(std::vector<tt__Dot1XConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Dot1XConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Dot1XConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__Dot1XConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Dot1XConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__Dot1XConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Dot1XConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Dot1XConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Dot1XConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, std::vector<tt__CertificateWithPrivateKey *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const std::vector<tt__CertificateWithPrivateKey *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateWithPrivateKey(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateWithPrivateKey *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, std::vector<tt__CertificateWithPrivateKey *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap)))
			return NULL;
		a->emplace_back();
		tt__CertificateWithPrivateKey * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, NULL, "tt:CertificateWithPrivateKey"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, n, "tt:CertificateWithPrivateKey"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateWithPrivateKey *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, std::vector<tt__CertificateWithPrivateKey *>  *d, std::vector<tt__CertificateWithPrivateKey *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__CertificateWithPrivateKey *> ::iterator j = d->begin();
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__CertificateWithPrivateKey(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(std::vector<tt__CertificateWithPrivateKey *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__CertificateWithPrivateKey *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__CertificateWithPrivateKey(&*i);
}

SOAP_FMAC1 std::vector<tt__CertificateWithPrivateKey *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateWithPrivateKey *> *p;
	size_t k = sizeof(std::vector<tt__CertificateWithPrivateKey *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateWithPrivateKey *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateWithPrivateKey *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateWithPrivateKey *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, std::vector<tt__CertificateStatus *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const std::vector<tt__CertificateStatus *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__CertificateStatus(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, const std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__CertificateStatus(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CertificateStatus *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, const char *tag, std::vector<tt__CertificateStatus *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__CertificateStatus(soap)))
			return NULL;
		a->emplace_back();
		tt__CertificateStatus * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, sizeof(tt__CertificateStatus), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__CertificateStatus(soap, tag, NULL, "tt:CertificateStatus"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__CertificateStatus(soap, tag, n, "tt:CertificateStatus"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CertificateStatus *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, std::vector<tt__CertificateStatus *>  *d, std::vector<tt__CertificateStatus *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__CertificateStatus(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__CertificateStatus *> ::iterator j = d->begin();
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__CertificateStatus(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__CertificateStatus(std::vector<tt__CertificateStatus *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__CertificateStatus *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__CertificateStatus(&*i);
}

SOAP_FMAC1 std::vector<tt__CertificateStatus *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CertificateStatus *> *p;
	size_t k = sizeof(std::vector<tt__CertificateStatus *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CertificateStatus *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CertificateStatus *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CertificateStatus *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, std::vector<tt__Certificate *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const std::vector<tt__Certificate *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Certificate(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, int id, const std::vector<tt__Certificate *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Certificate(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Certificate *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, const char *tag, std::vector<tt__Certificate *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Certificate(soap)))
			return NULL;
		a->emplace_back();
		tt__Certificate * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Certificate, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, sizeof(tt__Certificate), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Certificate(soap, tag, NULL, "tt:Certificate"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Certificate(soap, tag, n, "tt:Certificate"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Certificate *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, std::vector<tt__Certificate *>  *d, std::vector<tt__Certificate *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Certificate(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Certificate *> ::iterator j = d->begin();
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Certificate(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Certificate(std::vector<tt__Certificate *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Certificate *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Certificate(&*i);
}

SOAP_FMAC1 std::vector<tt__Certificate *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Certificate *> *p;
	size_t k = sizeof(std::vector<tt__Certificate *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Certificate *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Certificate *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Certificate *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv6Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv6Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv6Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv6Address(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__IPv6Address(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPv6Address, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv6Address(soap, tag, NULL, "tt:IPv6Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv6Address(soap, tag, n, "tt:IPv6Address"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__IPv6Address(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__IPv6Address(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__IPv6Address(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__IPv4Address(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__IPv4Address(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__IPv4Address(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__IPv4Address(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_tt__IPv4Address(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPv4Address, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__IPv4Address(soap, tag, NULL, "tt:IPv4Address"))
				break;
		}
		else
		{	if (!soap_in_tt__IPv4Address(soap, tag, n, "tt:IPv4Address"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__IPv4Address(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__IPv4Address(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__IPv4Address(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__IPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__IPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__IPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, std::vector<tt__NetworkProtocol *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const std::vector<tt__NetworkProtocol *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkProtocol(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkProtocol(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkProtocol *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, const char *tag, std::vector<tt__NetworkProtocol *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkProtocol(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkProtocol * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, sizeof(tt__NetworkProtocol), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkProtocol(soap, tag, NULL, "tt:NetworkProtocol"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkProtocol(soap, tag, n, "tt:NetworkProtocol"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkProtocol *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, std::vector<tt__NetworkProtocol *>  *d, std::vector<tt__NetworkProtocol *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__NetworkProtocol(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__NetworkProtocol *> ::iterator j = d->begin();
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__NetworkProtocol(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__NetworkProtocol(std::vector<tt__NetworkProtocol *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__NetworkProtocol *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__NetworkProtocol(&*i);
}

SOAP_FMAC1 std::vector<tt__NetworkProtocol *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkProtocol *> *p;
	size_t k = sizeof(std::vector<tt__NetworkProtocol *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkProtocol *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkProtocol *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkProtocol *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, std::vector<tt__NetworkInterface *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const std::vector<tt__NetworkInterface *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkInterface(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkInterface(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkInterface *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, const char *tag, std::vector<tt__NetworkInterface *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkInterface(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkInterface * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, sizeof(tt__NetworkInterface), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkInterface(soap, tag, NULL, "tt:NetworkInterface"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkInterface(soap, tag, n, "tt:NetworkInterface"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkInterface *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, std::vector<tt__NetworkInterface *>  *d, std::vector<tt__NetworkInterface *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__NetworkInterface(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__NetworkInterface *> ::iterator j = d->begin();
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__NetworkInterface(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__NetworkInterface(std::vector<tt__NetworkInterface *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__NetworkInterface *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__NetworkInterface(&*i);
}

SOAP_FMAC1 std::vector<tt__NetworkInterface *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkInterface *> *p;
	size_t k = sizeof(std::vector<tt__NetworkInterface *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkInterface *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkInterface *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkInterface *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const std::vector<tt__IPAddress *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__IPAddress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, int id, const std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__IPAddress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__IPAddress *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, const char *tag, std::vector<tt__IPAddress *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap)))
			return NULL;
		a->emplace_back();
		tt__IPAddress * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, sizeof(tt__IPAddress), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__IPAddress(soap, tag, NULL, "tt:IPAddress"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__IPAddress(soap, tag, n, "tt:IPAddress"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__IPAddress *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, std::vector<tt__IPAddress *>  *d, std::vector<tt__IPAddress *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__IPAddress(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__IPAddress *> ::iterator j = d->begin();
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__IPAddress(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__IPAddress(std::vector<tt__IPAddress *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__IPAddress *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__IPAddress(&*i);
}

SOAP_FMAC1 std::vector<tt__IPAddress *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__IPAddress *> *p;
	size_t k = sizeof(std::vector<tt__IPAddress *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__IPAddress *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__IPAddress *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__IPAddress *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__token(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__token(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__token(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__token(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__token(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__token(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__token, SOAP_TYPE_std__vectorTemplateOfxsd__token, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__token(soap, tag, NULL, "xsd:token"))
				break;
		}
		else
		{	if (!soap_in_xsd__token(soap, tag, n, "xsd:token"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfxsd__token(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfxsd__token(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfxsd__token(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__token(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__token(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__token, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, std::vector<tt__CapabilityCategory> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const std::vector<tt__CapabilityCategory> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, int id, const std::vector<tt__CapabilityCategory> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__CapabilityCategory> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__CapabilityCategory(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__CapabilityCategory> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, const char *tag, std::vector<tt__CapabilityCategory> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__CapabilityCategory(soap)))
			return NULL;
		a->emplace_back();
		tt__CapabilityCategory *n = &a->back();
		soap_default_tt__CapabilityCategory(soap, n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__CapabilityCategory, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, sizeof(tt__CapabilityCategory), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__CapabilityCategory(soap, tag, NULL, "tt:CapabilityCategory"))
				break;
		}
		else
		{	if (!soap_in_tt__CapabilityCategory(soap, tag, n, "tt:CapabilityCategory"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__CapabilityCategory>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, std::vector<tt__CapabilityCategory>  *d, std::vector<tt__CapabilityCategory> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOftt__CapabilityCategory(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOftt__CapabilityCategory(std::vector<tt__CapabilityCategory> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<tt__CapabilityCategory>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__CapabilityCategory(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__CapabilityCategory> *p;
	size_t k = sizeof(std::vector<tt__CapabilityCategory> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__CapabilityCategory> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__CapabilityCategory> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__CapabilityCategory>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_std__string(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{	if (!soap_in_std__string(soap, tag, n, "xsd:string"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfstd__string(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfstd__string(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__User(struct soap *soap, std::vector<tt__User *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__User(struct soap *soap, const std::vector<tt__User *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__User(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, int id, const std::vector<tt__User *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__User(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__User *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__User(struct soap *soap, const char *tag, std::vector<tt__User *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__User(soap)))
			return NULL;
		a->emplace_back();
		tt__User * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__User, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, sizeof(tt__User), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__User(soap, tag, NULL, "tt:User"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__User(soap, tag, n, "tt:User"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__User *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__User(struct soap *soap, std::vector<tt__User *>  *d, std::vector<tt__User *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__User(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__User *> ::iterator j = d->begin();
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__User(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__User(std::vector<tt__User *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__User *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__User(&*i);
}

SOAP_FMAC1 std::vector<tt__User *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__User *> *p;
	size_t k = sizeof(std::vector<tt__User *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__User *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__User *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__User *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const std::vector<tt__NetworkHost *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__NetworkHost(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, int id, const std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__NetworkHost(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__NetworkHost *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, const char *tag, std::vector<tt__NetworkHost *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap)))
			return NULL;
		a->emplace_back();
		tt__NetworkHost * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, sizeof(tt__NetworkHost), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__NetworkHost(soap, tag, NULL, "tt:NetworkHost"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__NetworkHost(soap, tag, n, "tt:NetworkHost"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__NetworkHost *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, std::vector<tt__NetworkHost *>  *d, std::vector<tt__NetworkHost *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__NetworkHost(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__NetworkHost *> ::iterator j = d->begin();
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__NetworkHost(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__NetworkHost(std::vector<tt__NetworkHost *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__NetworkHost *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__NetworkHost(&*i);
}

SOAP_FMAC1 std::vector<tt__NetworkHost *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__NetworkHost *> *p;
	size_t k = sizeof(std::vector<tt__NetworkHost *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__NetworkHost *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__NetworkHost *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__NetworkHost *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__anyURI(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__anyURI(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__anyURI(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__anyURI(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI"))
				break;
		}
		else
		{	if (!soap_in_xsd__anyURI(soap, tag, n, "xsd:anyURI"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfxsd__anyURI(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfxsd__anyURI(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfxsd__anyURI(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__anyURI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__anyURI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__anyURI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, std::vector<tt__Scope *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const std::vector<tt__Scope *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Scope(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, int id, const std::vector<tt__Scope *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Scope(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Scope *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, const char *tag, std::vector<tt__Scope *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Scope(soap)))
			return NULL;
		a->emplace_back();
		tt__Scope * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Scope, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, sizeof(tt__Scope), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Scope(soap, tag, NULL, "tt:Scope"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Scope(soap, tag, n, "tt:Scope"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Scope *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, std::vector<tt__Scope *>  *d, std::vector<tt__Scope *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Scope(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Scope *> ::iterator j = d->begin();
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Scope(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Scope(std::vector<tt__Scope *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Scope *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Scope(&*i);
}

SOAP_FMAC1 std::vector<tt__Scope *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Scope *> *p;
	size_t k = sizeof(std::vector<tt__Scope *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Scope *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Scope *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Scope *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, std::vector<tt__BackupFile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const std::vector<tt__BackupFile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__BackupFile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, int id, const std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__BackupFile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__BackupFile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, const char *tag, std::vector<tt__BackupFile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__BackupFile(soap)))
			return NULL;
		a->emplace_back();
		tt__BackupFile * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, sizeof(tt__BackupFile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__BackupFile(soap, tag, NULL, "tt:BackupFile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__BackupFile(soap, tag, n, "tt:BackupFile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__BackupFile *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, std::vector<tt__BackupFile *>  *d, std::vector<tt__BackupFile *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__BackupFile(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__BackupFile *> ::iterator j = d->begin();
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__BackupFile(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__BackupFile(std::vector<tt__BackupFile *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__BackupFile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__BackupFile(&*i);
}

SOAP_FMAC1 std::vector<tt__BackupFile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__BackupFile *> *p;
	size_t k = sizeof(std::vector<tt__BackupFile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__BackupFile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__BackupFile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__BackupFile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, std::vector<tds__Service *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const std::vector<tds__Service *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotds__Service(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, int id, const std::vector<tds__Service *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotds__Service(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tds__Service *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, const char *tag, std::vector<tds__Service *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotds__Service(soap)))
			return NULL;
		a->emplace_back();
		tds__Service * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tds__Service, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, sizeof(tds__Service), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotds__Service(soap, tag, NULL, "tds:Service"))
				break;
		}
		else
		{	if (!soap_in_PointerTotds__Service(soap, tag, n, "tds:Service"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tds__Service *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, std::vector<tds__Service *>  *d, std::vector<tds__Service *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTotds__Service(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tds__Service *> ::iterator j = d->begin();
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTotds__Service(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTotds__Service(std::vector<tds__Service *> const*a)
{
	if (!a)
		return;
	for (std::vector<tds__Service *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTotds__Service(&*i);
}

SOAP_FMAC1 std::vector<tds__Service *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tds__Service *> *p;
	size_t k = sizeof(std::vector<tds__Service *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tds__Service *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tds__Service *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tds__Service *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
