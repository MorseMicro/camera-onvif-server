/* soapC_nnn.cpp
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.127 2023-08-11 04:39:10 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, int id, _trt__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUri, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetStreamUri ? type : NULL);
}

SOAP_FMAC3 _trt__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, _trt__GetStreamUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetStreamUri **)soap_malloc(soap, sizeof(_trt__GetStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetStreamUri *)soap_instantiate__trt__GetStreamUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(_trt__GetStreamUri), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetStreamUri * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri * *d, _trt__GetStreamUri *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetStreamUri **)soap_malloc(soap, sizeof(_trt__GetStreamUri *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetStreamUri(_trt__GetStreamUri *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetStreamUri);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetStreamUri(soap, tag ? tag : "trt:GetStreamUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances ? type : NULL);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, _trt__GetGuaranteedNumberOfVideoEncoderInstances **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_malloc(soap, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstances), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstances * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances * *d, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_malloc(soap, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstances *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(_trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetGuaranteedNumberOfVideoEncoderInstances);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag ? tag : "trt:GetGuaranteedNumberOfVideoEncoderInstances", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurationOptions *)soap_instantiate__trt__GetAudioDecoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(_trt__GetAudioDecoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions * *d, _trt__GetAudioDecoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioDecoderConfigurationOptions(_trt__GetAudioDecoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioDecoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioOutputConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurationOptions *)soap_instantiate__trt__GetAudioOutputConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(_trt__GetAudioOutputConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions * *d, _trt__GetAudioOutputConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioOutputConfigurationOptions(_trt__GetAudioOutputConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioOutputConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag ? tag : "trt:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetMetadataConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, _trt__GetMetadataConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurationOptions *)soap_instantiate__trt__GetMetadataConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetMetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(_trt__GetMetadataConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetMetadataConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions * *d, _trt__GetMetadataConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetMetadataConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetMetadataConfigurationOptions(_trt__GetMetadataConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetMetadataConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag ? tag : "trt:GetMetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurationOptions *)soap_instantiate__trt__GetAudioEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(_trt__GetAudioEncoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions * *d, _trt__GetAudioEncoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioEncoderConfigurationOptions(_trt__GetAudioEncoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioEncoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag ? tag : "trt:GetAudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioSourceConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurationOptions *)soap_instantiate__trt__GetAudioSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(_trt__GetAudioSourceConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions * *d, _trt__GetAudioSourceConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioSourceConfigurationOptions(_trt__GetAudioSourceConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioSourceConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag ? tag : "trt:GetAudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurationOptions *)soap_instantiate__trt__GetVideoEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(_trt__GetVideoEncoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions * *d, _trt__GetVideoEncoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoEncoderConfigurationOptions(_trt__GetVideoEncoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoEncoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag ? tag : "trt:GetVideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoSourceConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurationOptions *)soap_instantiate__trt__GetVideoSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(_trt__GetVideoSourceConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions * *d, _trt__GetVideoSourceConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoSourceConfigurationOptions(_trt__GetVideoSourceConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoSourceConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag ? tag : "trt:GetVideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetAudioDecoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__SetAudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioDecoderConfiguration *)soap_instantiate__trt__SetAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(_trt__SetAudioDecoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetAudioDecoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration * *d, _trt__SetAudioDecoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioDecoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetAudioDecoderConfiguration(_trt__SetAudioDecoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetAudioDecoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag ? tag : "trt:SetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetAudioOutputConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__SetAudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioOutputConfiguration *)soap_instantiate__trt__SetAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(_trt__SetAudioOutputConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetAudioOutputConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration * *d, _trt__SetAudioOutputConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioOutputConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetAudioOutputConfiguration(_trt__SetAudioOutputConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetAudioOutputConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, tag ? tag : "trt:SetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__SetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetMetadataConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, _trt__SetMetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__SetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetMetadataConfiguration *)soap_instantiate__trt__SetMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(_trt__SetMetadataConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetMetadataConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration * *d, _trt__SetMetadataConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__SetMetadataConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetMetadataConfiguration(_trt__SetMetadataConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetMetadataConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, tag ? tag : "trt:SetMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetVideoAnalyticsConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__SetVideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoAnalyticsConfiguration *)soap_instantiate__trt__SetVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(_trt__SetVideoAnalyticsConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetVideoAnalyticsConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration * *d, _trt__SetVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoAnalyticsConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetVideoAnalyticsConfiguration(_trt__SetVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetVideoAnalyticsConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag ? tag : "trt:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetAudioEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__SetAudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioEncoderConfiguration *)soap_instantiate__trt__SetAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(_trt__SetAudioEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetAudioEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration * *d, _trt__SetAudioEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetAudioEncoderConfiguration(_trt__SetAudioEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetAudioEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag ? tag : "trt:SetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetAudioSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__SetAudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioSourceConfiguration *)soap_instantiate__trt__SetAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(_trt__SetAudioSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetAudioSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration * *d, _trt__SetAudioSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetAudioSourceConfiguration(_trt__SetAudioSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetAudioSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, tag ? tag : "trt:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetVideoEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__SetVideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoEncoderConfiguration *)soap_instantiate__trt__SetVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(_trt__SetVideoEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetVideoEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration * *d, _trt__SetVideoEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetVideoEncoderConfiguration(_trt__SetVideoEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetVideoEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag ? tag : "trt:SetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetVideoSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__SetVideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoSourceConfiguration *)soap_instantiate__trt__SetVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(_trt__SetVideoSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetVideoSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration * *d, _trt__SetVideoSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetVideoSourceConfiguration(_trt__SetVideoSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetVideoSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, tag ? tag : "trt:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioDecoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioDecoderConfigurations *)soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(_trt__GetCompatibleAudioDecoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations * *d, _trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioDecoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(_trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleAudioDecoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag ? tag : "trt:GetCompatibleAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioOutputConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioOutputConfigurations *)soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(_trt__GetCompatibleAudioOutputConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations * *d, _trt__GetCompatibleAudioOutputConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioOutputConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleAudioOutputConfigurations(_trt__GetCompatibleAudioOutputConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleAudioOutputConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag ? tag : "trt:GetCompatibleAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleMetadataConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleMetadataConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleMetadataConfigurations *)soap_instantiate__trt__GetCompatibleMetadataConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(_trt__GetCompatibleMetadataConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations * *d, _trt__GetCompatibleMetadataConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleMetadataConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleMetadataConfigurations(_trt__GetCompatibleMetadataConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleMetadataConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag ? tag : "trt:GetCompatibleMetadataConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoAnalyticsConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoAnalyticsConfigurations *)soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations * *d, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(_trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleVideoAnalyticsConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag ? tag : "trt:GetCompatibleVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioSourceConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioSourceConfigurations *)soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(_trt__GetCompatibleAudioSourceConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations * *d, _trt__GetCompatibleAudioSourceConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioSourceConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleAudioSourceConfigurations(_trt__GetCompatibleAudioSourceConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleAudioSourceConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag ? tag : "trt:GetCompatibleAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioEncoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioEncoderConfigurations *)soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(_trt__GetCompatibleAudioEncoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations * *d, _trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioEncoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(_trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleAudioEncoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag ? tag : "trt:GetCompatibleAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoSourceConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoSourceConfigurations *)soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(_trt__GetCompatibleVideoSourceConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations * *d, _trt__GetCompatibleVideoSourceConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoSourceConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleVideoSourceConfigurations(_trt__GetCompatibleVideoSourceConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleVideoSourceConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag ? tag : "trt:GetCompatibleVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoEncoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoEncoderConfigurations *)soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetCompatibleVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(_trt__GetCompatibleVideoEncoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations * *d, _trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetCompatibleVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoEncoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(_trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetCompatibleVideoEncoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag ? tag : "trt:GetCompatibleVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioDecoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfiguration *)soap_instantiate__trt__GetAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(_trt__GetAudioDecoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioDecoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration * *d, _trt__GetAudioDecoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioDecoderConfiguration(_trt__GetAudioDecoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioDecoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag ? tag : "trt:GetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioOutputConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__GetAudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfiguration *)soap_instantiate__trt__GetAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(_trt__GetAudioOutputConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioOutputConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration * *d, _trt__GetAudioOutputConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioOutputConfiguration(_trt__GetAudioOutputConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioOutputConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, tag ? tag : "trt:GetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetMetadataConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, _trt__GetMetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__GetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfiguration *)soap_instantiate__trt__GetMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(_trt__GetMetadataConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetMetadataConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration * *d, _trt__GetMetadataConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__GetMetadataConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetMetadataConfiguration(_trt__GetMetadataConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetMetadataConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, tag ? tag : "trt:GetMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoAnalyticsConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfiguration *)soap_instantiate__trt__GetVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(_trt__GetVideoAnalyticsConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoAnalyticsConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration * *d, _trt__GetVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoAnalyticsConfiguration(_trt__GetVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoAnalyticsConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag ? tag : "trt:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfiguration *)soap_instantiate__trt__GetAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(_trt__GetAudioEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration * *d, _trt__GetAudioEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioEncoderConfiguration(_trt__GetAudioEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag ? tag : "trt:GetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__GetAudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfiguration *)soap_instantiate__trt__GetAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(_trt__GetAudioSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration * *d, _trt__GetAudioSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioSourceConfiguration(_trt__GetAudioSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, tag ? tag : "trt:GetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfiguration *)soap_instantiate__trt__GetVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(_trt__GetVideoEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration * *d, _trt__GetVideoEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoEncoderConfiguration(_trt__GetVideoEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag ? tag : "trt:GetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__GetVideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfiguration *)soap_instantiate__trt__GetVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(_trt__GetVideoSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration * *d, _trt__GetVideoSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoSourceConfiguration(_trt__GetVideoSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, tag ? tag : "trt:GetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioDecoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurations *)soap_instantiate__trt__GetAudioDecoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(_trt__GetAudioDecoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioDecoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations * *d, _trt__GetAudioDecoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioDecoderConfigurations(_trt__GetAudioDecoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioDecoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag ? tag : "trt:GetAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioOutputConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurations *)soap_instantiate__trt__GetAudioOutputConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(_trt__GetAudioOutputConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioOutputConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations * *d, _trt__GetAudioOutputConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioOutputConfigurations(_trt__GetAudioOutputConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioOutputConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, tag ? tag : "trt:GetAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetMetadataConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, _trt__GetMetadataConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurations *)soap_instantiate__trt__GetMetadataConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(_trt__GetMetadataConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetMetadataConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations * *d, _trt__GetMetadataConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetMetadataConfigurations(_trt__GetMetadataConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetMetadataConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, tag ? tag : "trt:GetMetadataConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoAnalyticsConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfigurations *)soap_instantiate__trt__GetVideoAnalyticsConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(_trt__GetVideoAnalyticsConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations * *d, _trt__GetVideoAnalyticsConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoAnalyticsConfigurations(_trt__GetVideoAnalyticsConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoAnalyticsConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag ? tag : "trt:GetVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioEncoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurations *)soap_instantiate__trt__GetAudioEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(_trt__GetAudioEncoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioEncoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations * *d, _trt__GetAudioEncoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioEncoderConfigurations(_trt__GetAudioEncoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioEncoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag ? tag : "trt:GetAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioSourceConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurations *)soap_instantiate__trt__GetAudioSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(_trt__GetAudioSourceConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioSourceConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations * *d, _trt__GetAudioSourceConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioSourceConfigurations(_trt__GetAudioSourceConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioSourceConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, tag ? tag : "trt:GetAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoEncoderConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurations *)soap_instantiate__trt__GetVideoEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(_trt__GetVideoEncoderConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoEncoderConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations * *d, _trt__GetVideoEncoderConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoEncoderConfigurations(_trt__GetVideoEncoderConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoEncoderConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag ? tag : "trt:GetVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoSourceConfigurations ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurations *)soap_instantiate__trt__GetVideoSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(_trt__GetVideoSourceConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoSourceConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations * *d, _trt__GetVideoSourceConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoSourceConfigurations(_trt__GetVideoSourceConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoSourceConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, tag ? tag : "trt:GetVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, int id, _trt__DeleteProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__DeleteProfile ? type : NULL);
}

SOAP_FMAC3 _trt__DeleteProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, _trt__DeleteProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__DeleteProfile **)soap_malloc(soap, sizeof(_trt__DeleteProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__DeleteProfile *)soap_instantiate__trt__DeleteProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfile, sizeof(_trt__DeleteProfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__DeleteProfile * * SOAP_FMAC2 soap_dup_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile * *d, _trt__DeleteProfile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__DeleteProfile **)soap_malloc(soap, sizeof(_trt__DeleteProfile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__DeleteProfile(_trt__DeleteProfile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__DeleteProfile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__DeleteProfile(soap, tag ? tag : "trt:DeleteProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__DeleteProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveAudioDecoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioDecoderConfiguration *)soap_instantiate__trt__RemoveAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(_trt__RemoveAudioDecoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveAudioDecoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration * *d, _trt__RemoveAudioDecoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioDecoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveAudioDecoderConfiguration(_trt__RemoveAudioDecoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveAudioDecoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag ? tag : "trt:RemoveAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveAudioOutputConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioOutputConfiguration *)soap_instantiate__trt__RemoveAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(_trt__RemoveAudioOutputConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveAudioOutputConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration * *d, _trt__RemoveAudioOutputConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioOutputConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveAudioOutputConfiguration(_trt__RemoveAudioOutputConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveAudioOutputConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag ? tag : "trt:RemoveAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveMetadataConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, _trt__RemoveMetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveMetadataConfiguration *)soap_instantiate__trt__RemoveMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(_trt__RemoveMetadataConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveMetadataConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration * *d, _trt__RemoveMetadataConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveMetadataConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveMetadataConfiguration(_trt__RemoveMetadataConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveMetadataConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, tag ? tag : "trt:RemoveMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoAnalyticsConfiguration *)soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(_trt__RemoveVideoAnalyticsConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration * *d, _trt__RemoveVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoAnalyticsConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveVideoAnalyticsConfiguration(_trt__RemoveVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveVideoAnalyticsConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag ? tag : "trt:RemoveVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, _trt__RemovePTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemovePTZConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, _trt__RemovePTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemovePTZConfiguration **)soap_malloc(soap, sizeof(_trt__RemovePTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemovePTZConfiguration *)soap_instantiate__trt__RemovePTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemovePTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(_trt__RemovePTZConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemovePTZConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration * *d, _trt__RemovePTZConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemovePTZConfiguration **)soap_malloc(soap, sizeof(_trt__RemovePTZConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemovePTZConfiguration(_trt__RemovePTZConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemovePTZConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, tag ? tag : "trt:RemovePTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveAudioSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioSourceConfiguration *)soap_instantiate__trt__RemoveAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(_trt__RemoveAudioSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveAudioSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration * *d, _trt__RemoveAudioSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveAudioSourceConfiguration(_trt__RemoveAudioSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveAudioSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag ? tag : "trt:RemoveAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveAudioEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioEncoderConfiguration *)soap_instantiate__trt__RemoveAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(_trt__RemoveAudioEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveAudioEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration * *d, _trt__RemoveAudioEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveAudioEncoderConfiguration(_trt__RemoveAudioEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveAudioEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag ? tag : "trt:RemoveAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveVideoSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoSourceConfiguration *)soap_instantiate__trt__RemoveVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(_trt__RemoveVideoSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveVideoSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration * *d, _trt__RemoveVideoSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveVideoSourceConfiguration(_trt__RemoveVideoSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveVideoSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag ? tag : "trt:RemoveVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__RemoveVideoEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoEncoderConfiguration *)soap_instantiate__trt__RemoveVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__RemoveVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(_trt__RemoveVideoEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__RemoveVideoEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration * *d, _trt__RemoveVideoEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__RemoveVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__RemoveVideoEncoderConfiguration(_trt__RemoveVideoEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__RemoveVideoEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag ? tag : "trt:RemoveVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddAudioDecoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__AddAudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioDecoderConfiguration *)soap_instantiate__trt__AddAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(_trt__AddAudioDecoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddAudioDecoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration * *d, _trt__AddAudioDecoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioDecoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddAudioDecoderConfiguration(_trt__AddAudioDecoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddAudioDecoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag ? tag : "trt:AddAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddAudioOutputConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__AddAudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioOutputConfiguration *)soap_instantiate__trt__AddAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(_trt__AddAudioOutputConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddAudioOutputConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration * *d, _trt__AddAudioOutputConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioOutputConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddAudioOutputConfiguration(_trt__AddAudioOutputConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddAudioOutputConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, tag ? tag : "trt:AddAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__AddMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddMetadataConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, _trt__AddMetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__AddMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddMetadataConfiguration *)soap_instantiate__trt__AddMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(_trt__AddMetadataConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddMetadataConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration * *d, _trt__AddMetadataConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__AddMetadataConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddMetadataConfiguration(_trt__AddMetadataConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddMetadataConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, tag ? tag : "trt:AddMetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddVideoAnalyticsConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__AddVideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoAnalyticsConfiguration *)soap_instantiate__trt__AddVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(_trt__AddVideoAnalyticsConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddVideoAnalyticsConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration * *d, _trt__AddVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoAnalyticsConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddVideoAnalyticsConfiguration(_trt__AddVideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddVideoAnalyticsConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag ? tag : "trt:AddVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, _trt__AddPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddPTZConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, _trt__AddPTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddPTZConfiguration **)soap_malloc(soap, sizeof(_trt__AddPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddPTZConfiguration *)soap_instantiate__trt__AddPTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(_trt__AddPTZConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddPTZConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration * *d, _trt__AddPTZConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddPTZConfiguration **)soap_malloc(soap, sizeof(_trt__AddPTZConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddPTZConfiguration(_trt__AddPTZConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddPTZConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, tag ? tag : "trt:AddPTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddAudioSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__AddAudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioSourceConfiguration *)soap_instantiate__trt__AddAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(_trt__AddAudioSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddAudioSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration * *d, _trt__AddAudioSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddAudioSourceConfiguration(_trt__AddAudioSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddAudioSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, tag ? tag : "trt:AddAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddAudioEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__AddAudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioEncoderConfiguration *)soap_instantiate__trt__AddAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(_trt__AddAudioEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddAudioEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration * *d, _trt__AddAudioEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddAudioEncoderConfiguration(_trt__AddAudioEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddAudioEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag ? tag : "trt:AddAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddVideoSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__AddVideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoSourceConfiguration *)soap_instantiate__trt__AddVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(_trt__AddVideoSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddVideoSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration * *d, _trt__AddVideoSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddVideoSourceConfiguration(_trt__AddVideoSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddVideoSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, tag ? tag : "trt:AddVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__AddVideoEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__AddVideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoEncoderConfiguration *)soap_instantiate__trt__AddVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__AddVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(_trt__AddVideoEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__AddVideoEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration * *d, _trt__AddVideoEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__AddVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__AddVideoEncoderConfiguration(_trt__AddVideoEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__AddVideoEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag ? tag : "trt:AddVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetProfiles ? type : NULL);
}

SOAP_FMAC3 _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, _trt__GetProfiles **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfiles **)soap_malloc(soap, sizeof(_trt__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfiles *)soap_instantiate__trt__GetProfiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(_trt__GetProfiles), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetProfiles * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles * *d, _trt__GetProfiles *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetProfiles **)soap_malloc(soap, sizeof(_trt__GetProfiles *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetProfiles(_trt__GetProfiles *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetProfiles);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag ? tag : "trt:GetProfiles", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, int id, _trt__GetProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetProfile ? type : NULL);
}

SOAP_FMAC3 _trt__GetProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, _trt__GetProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfile **)soap_malloc(soap, sizeof(_trt__GetProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfile *)soap_instantiate__trt__GetProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(_trt__GetProfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetProfile * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile * *d, _trt__GetProfile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetProfile **)soap_malloc(soap, sizeof(_trt__GetProfile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetProfile(_trt__GetProfile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetProfile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetProfile(soap, tag ? tag : "trt:GetProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, int id, _trt__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__CreateProfile ? type : NULL);
}

SOAP_FMAC3 _trt__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, _trt__CreateProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__CreateProfile **)soap_malloc(soap, sizeof(_trt__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__CreateProfile *)soap_instantiate__trt__CreateProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(_trt__CreateProfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__CreateProfile * * SOAP_FMAC2 soap_dup_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile * *d, _trt__CreateProfile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__CreateProfile **)soap_malloc(soap, sizeof(_trt__CreateProfile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__CreateProfile(_trt__CreateProfile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__CreateProfile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateProfile(soap, tag ? tag : "trt:CreateProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioOutputs ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioOutputs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, _trt__GetAudioOutputs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputs **)soap_malloc(soap, sizeof(_trt__GetAudioOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputs *)soap_instantiate__trt__GetAudioOutputs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(_trt__GetAudioOutputs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioOutputs * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs * *d, _trt__GetAudioOutputs *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioOutputs **)soap_malloc(soap, sizeof(_trt__GetAudioOutputs *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioOutputs(_trt__GetAudioOutputs *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioOutputs);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, tag ? tag : "trt:GetAudioOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSources))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, int id, _trt__GetAudioSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSources, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetAudioSources ? type : NULL);
}

SOAP_FMAC3 _trt__GetAudioSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, _trt__GetAudioSources **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSources **)soap_malloc(soap, sizeof(_trt__GetAudioSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSources *)soap_instantiate__trt__GetAudioSources(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetAudioSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSources, sizeof(_trt__GetAudioSources), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetAudioSources * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources * *d, _trt__GetAudioSources *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetAudioSources **)soap_malloc(soap, sizeof(_trt__GetAudioSources *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetAudioSources(_trt__GetAudioSources *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetAudioSources);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetAudioSources(soap, tag ? tag : "trt:GetAudioSources", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSources))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, int id, _trt__GetVideoSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSources, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoSources ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, _trt__GetVideoSources **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSources **)soap_malloc(soap, sizeof(_trt__GetVideoSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSources *)soap_instantiate__trt__GetVideoSources(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSources, sizeof(_trt__GetVideoSources), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoSources * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources * *d, _trt__GetVideoSources *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoSources **)soap_malloc(soap, sizeof(_trt__GetVideoSources *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoSources(_trt__GetVideoSources *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoSources);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSources(soap, tag ? tag : "trt:GetVideoSources", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _trt__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, _trt__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(_trt__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetServiceCapabilities *)soap_instantiate__trt__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(_trt__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetServiceCapabilities * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities * *d, _trt__GetServiceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(_trt__GetServiceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetServiceCapabilities(_trt__GetServiceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetServiceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag ? tag : "trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetCurrentPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, _timg__SetCurrentPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetCurrentPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__SetCurrentPreset ? type : NULL);
}

SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__SetCurrentPreset(struct soap *soap, const char *tag, _timg__SetCurrentPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetCurrentPreset **)soap_malloc(soap, sizeof(_timg__SetCurrentPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetCurrentPreset *)soap_instantiate__timg__SetCurrentPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__SetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetCurrentPreset, sizeof(_timg__SetCurrentPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetCurrentPreset * * SOAP_FMAC2 soap_dup_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset * *d, _timg__SetCurrentPreset *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__SetCurrentPreset **)soap_malloc(soap, sizeof(_timg__SetCurrentPreset *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__SetCurrentPreset(_timg__SetCurrentPreset *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__SetCurrentPreset);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__SetCurrentPreset(soap, tag ? tag : "timg:SetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__SetCurrentPreset(struct soap *soap, _timg__SetCurrentPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetCurrentPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, _timg__GetCurrentPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetCurrentPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetCurrentPreset ? type : NULL);
}

SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_in_PointerTo_timg__GetCurrentPreset(struct soap *soap, const char *tag, _timg__GetCurrentPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetCurrentPreset **)soap_malloc(soap, sizeof(_timg__GetCurrentPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetCurrentPreset *)soap_instantiate__timg__GetCurrentPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetCurrentPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetCurrentPreset, sizeof(_timg__GetCurrentPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetCurrentPreset * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset * *d, _timg__GetCurrentPreset *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetCurrentPreset **)soap_malloc(soap, sizeof(_timg__GetCurrentPreset *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetCurrentPreset(_timg__GetCurrentPreset *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetCurrentPreset);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetCurrentPreset(soap, tag ? tag : "timg:GetCurrentPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetCurrentPreset ** SOAP_FMAC4 soap_get_PointerTo_timg__GetCurrentPreset(struct soap *soap, _timg__GetCurrentPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetPresets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetPresets(struct soap *soap, const char *tag, int id, _timg__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetPresets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetPresets ? type : NULL);
}

SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_timg__GetPresets(struct soap *soap, const char *tag, _timg__GetPresets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetPresets **)soap_malloc(soap, sizeof(_timg__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetPresets *)soap_instantiate__timg__GetPresets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetPresets, sizeof(_timg__GetPresets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetPresets * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets * *d, _timg__GetPresets *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetPresets **)soap_malloc(soap, sizeof(_timg__GetPresets *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetPresets(_timg__GetPresets *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetPresets);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetPresets(soap, tag ? tag : "timg:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_timg__GetPresets(struct soap *soap, _timg__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, int id, _timg__GetMoveOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetMoveOptions ? type : NULL);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, _timg__GetMoveOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetMoveOptions **)soap_malloc(soap, sizeof(_timg__GetMoveOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetMoveOptions *)soap_instantiate__timg__GetMoveOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(_timg__GetMoveOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetMoveOptions * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions * *d, _timg__GetMoveOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetMoveOptions **)soap_malloc(soap, sizeof(_timg__GetMoveOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetMoveOptions(_timg__GetMoveOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetMoveOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, tag ? tag : "timg:GetMoveOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, int id, _timg__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetStatus ? type : NULL);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, _timg__GetStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetStatus **)soap_malloc(soap, sizeof(_timg__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetStatus *)soap_instantiate__timg__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(_timg__GetStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetStatus * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus * *d, _timg__GetStatus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetStatus **)soap_malloc(soap, sizeof(_timg__GetStatus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetStatus(_timg__GetStatus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetStatus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetStatus(soap, tag ? tag : "timg:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Stop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap *soap, const char *tag, int id, _timg__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Stop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__Stop ? type : NULL);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap *soap, const char *tag, _timg__Stop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Stop **)soap_malloc(soap, sizeof(_timg__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Stop *)soap_instantiate__timg__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(_timg__Stop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__Stop * * SOAP_FMAC2 soap_dup_PointerTo_timg__Stop(struct soap *soap, _timg__Stop * *d, _timg__Stop *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__Stop **)soap_malloc(soap, sizeof(_timg__Stop *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__Stop(_timg__Stop *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__Stop);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__Stop(soap, tag ? tag : "timg:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap *soap, _timg__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Move))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap *soap, const char *tag, int id, _timg__Move *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Move, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__Move ? type : NULL);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap *soap, const char *tag, _timg__Move **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Move **)soap_malloc(soap, sizeof(_timg__Move *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Move *)soap_instantiate__timg__Move(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(_timg__Move), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__Move * * SOAP_FMAC2 soap_dup_PointerTo_timg__Move(struct soap *soap, _timg__Move * *d, _timg__Move *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__Move **)soap_malloc(soap, sizeof(_timg__Move *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__Move(_timg__Move *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__Move);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__Move(soap, tag ? tag : "timg:Move", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap *soap, _timg__Move **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, int id, _timg__GetOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetOptions ? type : NULL);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, _timg__GetOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetOptions **)soap_malloc(soap, sizeof(_timg__GetOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetOptions *)soap_instantiate__timg__GetOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(_timg__GetOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetOptions * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions * *d, _timg__GetOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetOptions **)soap_malloc(soap, sizeof(_timg__GetOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetOptions(_timg__GetOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetOptions(soap, tag ? tag : "timg:GetOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__SetImagingSettings ? type : NULL);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, _timg__SetImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetImagingSettings **)soap_malloc(soap, sizeof(_timg__SetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetImagingSettings *)soap_instantiate__timg__SetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(_timg__SetImagingSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__SetImagingSettings * * SOAP_FMAC2 soap_dup_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings * *d, _timg__SetImagingSettings *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__SetImagingSettings **)soap_malloc(soap, sizeof(_timg__SetImagingSettings *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__SetImagingSettings(_timg__SetImagingSettings *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__SetImagingSettings);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag ? tag : "timg:SetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetImagingSettings ? type : NULL);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, _timg__GetImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetImagingSettings **)soap_malloc(soap, sizeof(_timg__GetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetImagingSettings *)soap_instantiate__timg__GetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(_timg__GetImagingSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetImagingSettings * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings * *d, _timg__GetImagingSettings *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetImagingSettings **)soap_malloc(soap, sizeof(_timg__GetImagingSettings *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetImagingSettings(_timg__GetImagingSettings *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetImagingSettings);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag ? tag : "timg:GetImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _timg__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__timg__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, _timg__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(_timg__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetServiceCapabilities *)soap_instantiate__timg__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(_timg__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _timg__GetServiceCapabilities * * SOAP_FMAC2 soap_dup_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities * *d, _timg__GetServiceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(_timg__GetServiceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_timg__GetServiceCapabilities(_timg__GetServiceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _timg__GetServiceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag ? tag : "timg:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHashingAlgorithm))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, _tds__SetHashingAlgorithm *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHashingAlgorithm, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHashingAlgorithm ? type : NULL);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, const char *tag, _tds__SetHashingAlgorithm **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHashingAlgorithm **)soap_malloc(soap, sizeof(_tds__SetHashingAlgorithm *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHashingAlgorithm *)soap_instantiate__tds__SetHashingAlgorithm(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHashingAlgorithm **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHashingAlgorithm * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm * *d, _tds__SetHashingAlgorithm *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetHashingAlgorithm **)soap_malloc(soap, sizeof(_tds__SetHashingAlgorithm *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetHashingAlgorithm(_tds__SetHashingAlgorithm *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetHashingAlgorithm);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHashingAlgorithm(soap, tag ? tag : "tds:SetHashingAlgorithm", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, _tds__DeleteGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteGeoLocation(struct soap *soap, const char *tag, _tds__DeleteGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteGeoLocation **)soap_malloc(soap, sizeof(_tds__DeleteGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteGeoLocation *)soap_instantiate__tds__DeleteGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocation * * SOAP_FMAC2 soap_dup_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation * *d, _tds__DeleteGeoLocation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__DeleteGeoLocation **)soap_malloc(soap, sizeof(_tds__DeleteGeoLocation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__DeleteGeoLocation(_tds__DeleteGeoLocation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__DeleteGeoLocation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteGeoLocation(soap, tag ? tag : "tds:DeleteGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetGeoLocation(struct soap *soap, const char *tag, int id, _tds__SetGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__SetGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__SetGeoLocation(struct soap *soap, const char *tag, _tds__SetGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetGeoLocation **)soap_malloc(soap, sizeof(_tds__SetGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetGeoLocation *)soap_instantiate__tds__SetGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocation * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation * *d, _tds__SetGeoLocation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetGeoLocation **)soap_malloc(soap, sizeof(_tds__SetGeoLocation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetGeoLocation(_tds__SetGeoLocation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetGeoLocation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetGeoLocation(soap, tag ? tag : "tds:SetGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetGeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetGeoLocation(struct soap *soap, const char *tag, int id, _tds__GetGeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetGeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetGeoLocation ? type : NULL);
}

SOAP_FMAC3 _tds__GetGeoLocation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetGeoLocation(struct soap *soap, const char *tag, _tds__GetGeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetGeoLocation **)soap_malloc(soap, sizeof(_tds__GetGeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetGeoLocation *)soap_instantiate__tds__GetGeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetGeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocation * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation * *d, _tds__GetGeoLocation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetGeoLocation **)soap_malloc(soap, sizeof(_tds__GetGeoLocation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetGeoLocation(_tds__GetGeoLocation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetGeoLocation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetGeoLocation(soap, tag ? tag : "tds:GetGeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetGeoLocation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__DeleteStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, _tds__DeleteStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteStorageConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteStorageConfiguration *)soap_instantiate__tds__DeleteStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration * *d, _tds__DeleteStorageConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__DeleteStorageConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteStorageConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__DeleteStorageConfiguration(_tds__DeleteStorageConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__DeleteStorageConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__SetStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetStorageConfiguration(struct soap *soap, const char *tag, _tds__SetStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__SetStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetStorageConfiguration *)soap_instantiate__tds__SetStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration * *d, _tds__SetStorageConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__SetStorageConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetStorageConfiguration(_tds__SetStorageConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetStorageConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__GetStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetStorageConfiguration(struct soap *soap, const char *tag, _tds__GetStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__GetStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetStorageConfiguration *)soap_instantiate__tds__GetStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration * *d, _tds__GetStorageConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetStorageConfiguration **)soap_malloc(soap, sizeof(_tds__GetStorageConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetStorageConfiguration(_tds__GetStorageConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetStorageConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateStorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, _tds__CreateStorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateStorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateStorageConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, const char *tag, _tds__CreateStorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateStorageConfiguration **)soap_malloc(soap, sizeof(_tds__CreateStorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateStorageConfiguration *)soap_instantiate__tds__CreateStorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateStorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration * *d, _tds__CreateStorageConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__CreateStorageConfiguration **)soap_malloc(soap, sizeof(_tds__CreateStorageConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__CreateStorageConfiguration(_tds__CreateStorageConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__CreateStorageConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetStorageConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, _tds__GetStorageConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetStorageConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetStorageConfigurations ? type : NULL);
}

SOAP_FMAC3 _tds__GetStorageConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetStorageConfigurations(struct soap *soap, const char *tag, _tds__GetStorageConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetStorageConfigurations **)soap_malloc(soap, sizeof(_tds__GetStorageConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetStorageConfigurations *)soap_instantiate__tds__GetStorageConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetStorageConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations * *d, _tds__GetStorageConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetStorageConfigurations **)soap_malloc(soap, sizeof(_tds__GetStorageConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetStorageConfigurations(_tds__GetStorageConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetStorageConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetStorageConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, int id, _tds__StartSystemRestore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestore, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StartSystemRestore ? type : NULL);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartSystemRestore **)soap_malloc(soap, sizeof(_tds__StartSystemRestore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartSystemRestore *)soap_instantiate__tds__StartSystemRestore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestore * * SOAP_FMAC2 soap_dup_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore * *d, _tds__StartSystemRestore *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__StartSystemRestore **)soap_malloc(soap, sizeof(_tds__StartSystemRestore *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__StartSystemRestore(_tds__StartSystemRestore *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__StartSystemRestore);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgrade))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, _tds__StartFirmwareUpgrade *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgrade, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StartFirmwareUpgrade ? type : NULL);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(_tds__StartFirmwareUpgrade *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartFirmwareUpgrade *)soap_instantiate__tds__StartFirmwareUpgrade(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * * SOAP_FMAC2 soap_dup_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade * *d, _tds__StartFirmwareUpgrade *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(_tds__StartFirmwareUpgrade *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__StartFirmwareUpgrade(_tds__StartFirmwareUpgrade *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__StartFirmwareUpgrade);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUris))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, int id, _tds__GetSystemUris *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUris, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemUris ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUris **)soap_malloc(soap, sizeof(_tds__GetSystemUris *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUris *)soap_instantiate__tds__GetSystemUris(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUris * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris * *d, _tds__GetSystemUris *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemUris **)soap_malloc(soap, sizeof(_tds__GetSystemUris *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemUris(_tds__GetSystemUris *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemUris);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11Networks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, _tds__ScanAvailableDot11Networks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11Networks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__ScanAvailableDot11Networks ? type : NULL);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(_tds__ScanAvailableDot11Networks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__ScanAvailableDot11Networks *)soap_instantiate__tds__ScanAvailableDot11Networks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * * SOAP_FMAC2 soap_dup_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks * *d, _tds__ScanAvailableDot11Networks *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(_tds__ScanAvailableDot11Networks *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__ScanAvailableDot11Networks(_tds__ScanAvailableDot11Networks *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__ScanAvailableDot11Networks);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, int id, _tds__GetDot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot11Status ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Status **)soap_malloc(soap, sizeof(_tds__GetDot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Status *)soap_instantiate__tds__GetDot11Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Status * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status * *d, _tds__GetDot11Status *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDot11Status **)soap_malloc(soap, sizeof(_tds__GetDot11Status *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDot11Status(_tds__GetDot11Status *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDot11Status);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, _tds__GetDot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot11Capabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(_tds__GetDot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Capabilities *)soap_instantiate__tds__GetDot11Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities * *d, _tds__GetDot11Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(_tds__GetDot11Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDot11Capabilities(_tds__GetDot11Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDot11Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__DeleteDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteDot1XConfiguration *)soap_instantiate__tds__DeleteDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration * *d, _tds__DeleteDot1XConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteDot1XConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__DeleteDot1XConfiguration(_tds__DeleteDot1XConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__DeleteDot1XConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot1XConfigurations ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfigurations *)soap_instantiate__tds__GetDot1XConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations * *d, _tds__GetDot1XConfigurations *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurations *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDot1XConfigurations(_tds__GetDot1XConfigurations *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDot1XConfigurations);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__GetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfiguration *)soap_instantiate__tds__GetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration * *d, _tds__GetDot1XConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__GetDot1XConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDot1XConfiguration(_tds__GetDot1XConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDot1XConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__SetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__SetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDot1XConfiguration *)soap_instantiate__tds__SetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration * *d, _tds__SetDot1XConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__SetDot1XConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetDot1XConfiguration(_tds__SetDot1XConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetDot1XConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__CreateDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateDot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__CreateDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateDot1XConfiguration *)soap_instantiate__tds__CreateDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration * *d, _tds__CreateDot1XConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__CreateDot1XConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__CreateDot1XConfiguration(_tds__CreateDot1XConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__CreateDot1XConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, int id, _tds__LoadCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCACertificates ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCACertificates **)soap_malloc(soap, sizeof(_tds__LoadCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCACertificates *)soap_instantiate__tds__LoadCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificates * * SOAP_FMAC2 soap_dup_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates * *d, _tds__LoadCACertificates *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__LoadCACertificates **)soap_malloc(soap, sizeof(_tds__LoadCACertificates *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__LoadCACertificates(_tds__LoadCACertificates *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__LoadCACertificates);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, _tds__GetCertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificateInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificateInformation **)soap_malloc(soap, sizeof(_tds__GetCertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificateInformation *)soap_instantiate__tds__GetCertificateInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformation * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation * *d, _tds__GetCertificateInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetCertificateInformation **)soap_malloc(soap, sizeof(_tds__GetCertificateInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetCertificateInformation(_tds__GetCertificateInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetCertificateInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, _tds__LoadCertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCertificateWithPrivateKey ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(_tds__LoadCertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificateWithPrivateKey *)soap_instantiate__tds__LoadCertificateWithPrivateKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * * SOAP_FMAC2 soap_dup_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey * *d, _tds__LoadCertificateWithPrivateKey *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(_tds__LoadCertificateWithPrivateKey *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__LoadCertificateWithPrivateKey(_tds__LoadCertificateWithPrivateKey *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__LoadCertificateWithPrivateKey);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, int id, _tds__GetCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCACertificates ? type : NULL);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCACertificates **)soap_malloc(soap, sizeof(_tds__GetCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCACertificates *)soap_instantiate__tds__GetCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificates * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates * *d, _tds__GetCACertificates *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetCACertificates **)soap_malloc(soap, sizeof(_tds__GetCACertificates *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetCACertificates(_tds__GetCACertificates *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetCACertificates);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SendAuxiliaryCommand ? type : NULL);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tds__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SendAuxiliaryCommand *)soap_instantiate__tds__SendAuxiliaryCommand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * * SOAP_FMAC2 soap_dup_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand * *d, _tds__SendAuxiliaryCommand *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tds__SendAuxiliaryCommand *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SendAuxiliaryCommand(_tds__SendAuxiliaryCommand *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SendAuxiliaryCommand);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRelayOutputState ? type : NULL);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputState **)soap_malloc(soap, sizeof(_tds__SetRelayOutputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputState *)soap_instantiate__tds__SetRelayOutputState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputState * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState * *d, _tds__SetRelayOutputState *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetRelayOutputState **)soap_malloc(soap, sizeof(_tds__SetRelayOutputState *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetRelayOutputState(_tds__SetRelayOutputState *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetRelayOutputState);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRelayOutputSettings ? type : NULL);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(_tds__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputSettings *)soap_instantiate__tds__SetRelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings * *d, _tds__SetRelayOutputSettings *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(_tds__SetRelayOutputSettings *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetRelayOutputSettings(_tds__SetRelayOutputSettings *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetRelayOutputSettings);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRelayOutputs ? type : NULL);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRelayOutputs **)soap_malloc(soap, sizeof(_tds__GetRelayOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRelayOutputs *)soap_instantiate__tds__GetRelayOutputs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputs * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs * *d, _tds__GetRelayOutputs *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetRelayOutputs **)soap_malloc(soap, sizeof(_tds__GetRelayOutputs *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetRelayOutputs(_tds__GetRelayOutputs *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetRelayOutputs);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__SetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetClientCertificateMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__SetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetClientCertificateMode *)soap_instantiate__tds__SetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode * *d, _tds__SetClientCertificateMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__SetClientCertificateMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetClientCertificateMode(_tds__SetClientCertificateMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetClientCertificateMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__GetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetClientCertificateMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__GetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetClientCertificateMode *)soap_instantiate__tds__GetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode * *d, _tds__GetClientCertificateMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__GetClientCertificateMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetClientCertificateMode(_tds__GetClientCertificateMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetClientCertificateMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, int id, _tds__LoadCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__LoadCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificates **)soap_malloc(soap, sizeof(_tds__LoadCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificates *)soap_instantiate__tds__LoadCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificates * * SOAP_FMAC2 soap_dup_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates * *d, _tds__LoadCertificates *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__LoadCertificates **)soap_malloc(soap, sizeof(_tds__LoadCertificates *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__LoadCertificates(_tds__LoadCertificates *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__LoadCertificates);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10Request))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, _tds__GetPkcs10Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10Request, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPkcs10Request ? type : NULL);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPkcs10Request **)soap_malloc(soap, sizeof(_tds__GetPkcs10Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPkcs10Request *)soap_instantiate__tds__GetPkcs10Request(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10Request * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request * *d, _tds__GetPkcs10Request *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetPkcs10Request **)soap_malloc(soap, sizeof(_tds__GetPkcs10Request *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetPkcs10Request(_tds__GetPkcs10Request *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetPkcs10Request);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, int id, _tds__DeleteCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteCertificates **)soap_malloc(soap, sizeof(_tds__DeleteCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteCertificates *)soap_instantiate__tds__DeleteCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificates * * SOAP_FMAC2 soap_dup_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates * *d, _tds__DeleteCertificates *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__DeleteCertificates **)soap_malloc(soap, sizeof(_tds__DeleteCertificates *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__DeleteCertificates(_tds__DeleteCertificates *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__DeleteCertificates);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__SetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetCertificatesStatus ? type : NULL);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__SetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetCertificatesStatus *)soap_instantiate__tds__SetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatus * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus * *d, _tds__SetCertificatesStatus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__SetCertificatesStatus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetCertificatesStatus(_tds__SetCertificatesStatus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetCertificatesStatus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__GetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificatesStatus ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__GetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificatesStatus *)soap_instantiate__tds__GetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus * *d, _tds__GetCertificatesStatus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__GetCertificatesStatus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetCertificatesStatus(_tds__GetCertificatesStatus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetCertificatesStatus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, int id, _tds__GetCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificates, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCertificates ? type : NULL);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificates **)soap_malloc(soap, sizeof(_tds__GetCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificates *)soap_instantiate__tds__GetCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificates * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates * *d, _tds__GetCertificates *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetCertificates **)soap_malloc(soap, sizeof(_tds__GetCertificates *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetCertificates(_tds__GetCertificates *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetCertificates);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, int id, _tds__CreateCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateCertificate ? type : NULL);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateCertificate **)soap_malloc(soap, sizeof(_tds__CreateCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateCertificate *)soap_instantiate__tds__CreateCertificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificate * * SOAP_FMAC2 soap_dup_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate * *d, _tds__CreateCertificate *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__CreateCertificate **)soap_malloc(soap, sizeof(_tds__CreateCertificate *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__CreateCertificate(_tds__CreateCertificate *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__CreateCertificate);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__SetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetAccessPolicy ? type : NULL);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAccessPolicy **)soap_malloc(soap, sizeof(_tds__SetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAccessPolicy *)soap_instantiate__tds__SetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicy * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy * *d, _tds__SetAccessPolicy *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetAccessPolicy **)soap_malloc(soap, sizeof(_tds__SetAccessPolicy *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetAccessPolicy(_tds__SetAccessPolicy *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetAccessPolicy);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__GetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAccessPolicy ? type : NULL);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAccessPolicy **)soap_malloc(soap, sizeof(_tds__GetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAccessPolicy *)soap_instantiate__tds__GetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicy * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy * *d, _tds__GetAccessPolicy *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetAccessPolicy **)soap_malloc(soap, sizeof(_tds__GetAccessPolicy *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetAccessPolicy(_tds__GetAccessPolicy *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetAccessPolicy);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RemoveIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(_tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveIPAddressFilter *)soap_instantiate__tds__RemoveIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * * SOAP_FMAC2 soap_dup_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter * *d, _tds__RemoveIPAddressFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(_tds__RemoveIPAddressFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__RemoveIPAddressFilter(_tds__RemoveIPAddressFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__RemoveIPAddressFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__AddIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(_tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddIPAddressFilter *)soap_instantiate__tds__AddIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilter * * SOAP_FMAC2 soap_dup_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter * *d, _tds__AddIPAddressFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(_tds__AddIPAddressFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__AddIPAddressFilter(_tds__AddIPAddressFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__AddIPAddressFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetIPAddressFilter *)soap_instantiate__tds__SetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilter * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter * *d, _tds__SetIPAddressFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__SetIPAddressFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetIPAddressFilter(_tds__SetIPAddressFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetIPAddressFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetIPAddressFilter ? type : NULL);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetIPAddressFilter *)soap_instantiate__tds__GetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter * *d, _tds__GetIPAddressFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__GetIPAddressFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetIPAddressFilter(_tds__GetIPAddressFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetIPAddressFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__SetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__SetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetZeroConfiguration *)soap_instantiate__tds__SetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration * *d, _tds__SetZeroConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__SetZeroConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetZeroConfiguration(_tds__SetZeroConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetZeroConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__GetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__GetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetZeroConfiguration *)soap_instantiate__tds__GetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration * *d, _tds__GetZeroConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__GetZeroConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetZeroConfiguration(_tds__GetZeroConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetZeroConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkDefaultGateway ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkDefaultGateway *)soap_instantiate__tds__SetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway * *d, _tds__SetNetworkDefaultGateway *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__SetNetworkDefaultGateway *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetNetworkDefaultGateway(_tds__SetNetworkDefaultGateway *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetNetworkDefaultGateway);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkDefaultGateway ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkDefaultGateway *)soap_instantiate__tds__GetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway * *d, _tds__GetNetworkDefaultGateway *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__GetNetworkDefaultGateway *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetNetworkDefaultGateway(_tds__GetNetworkDefaultGateway *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetNetworkDefaultGateway);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkProtocols ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkProtocols *)soap_instantiate__tds__SetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocols * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols * *d, _tds__SetNetworkProtocols *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__SetNetworkProtocols *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetNetworkProtocols(_tds__SetNetworkProtocols *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetNetworkProtocols);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkProtocols ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkProtocols *)soap_instantiate__tds__GetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols * *d, _tds__GetNetworkProtocols *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__GetNetworkProtocols *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetNetworkProtocols(_tds__GetNetworkProtocols *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetNetworkProtocols);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNetworkInterfaces ? type : NULL);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkInterfaces *)soap_instantiate__tds__SetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces * *d, _tds__SetNetworkInterfaces *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__SetNetworkInterfaces *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetNetworkInterfaces(_tds__SetNetworkInterfaces *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetNetworkInterfaces);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNetworkInterfaces ? type : NULL);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkInterfaces *)soap_instantiate__tds__GetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces * *d, _tds__GetNetworkInterfaces *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__GetNetworkInterfaces *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetNetworkInterfaces(_tds__GetNetworkInterfaces *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetNetworkInterfaces);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDynamicDNS ? type : NULL);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDynamicDNS **)soap_malloc(soap, sizeof(_tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDynamicDNS *)soap_instantiate__tds__SetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNS * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS * *d, _tds__SetDynamicDNS *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetDynamicDNS **)soap_malloc(soap, sizeof(_tds__SetDynamicDNS *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetDynamicDNS(_tds__SetDynamicDNS *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetDynamicDNS);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDynamicDNS ? type : NULL);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDynamicDNS **)soap_malloc(soap, sizeof(_tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDynamicDNS *)soap_instantiate__tds__GetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNS * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS * *d, _tds__GetDynamicDNS *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDynamicDNS **)soap_malloc(soap, sizeof(_tds__GetDynamicDNS *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDynamicDNS(_tds__GetDynamicDNS *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDynamicDNS);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetNTP ? type : NULL);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNTP **)soap_malloc(soap, sizeof(_tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNTP *)soap_instantiate__tds__SetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTP * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP * *d, _tds__SetNTP *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetNTP **)soap_malloc(soap, sizeof(_tds__SetNTP *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetNTP(_tds__SetNTP *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetNTP);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetNTP ? type : NULL);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNTP **)soap_malloc(soap, sizeof(_tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNTP *)soap_instantiate__tds__GetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTP * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP * *d, _tds__GetNTP *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetNTP **)soap_malloc(soap, sizeof(_tds__GetNTP *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetNTP(_tds__GetNTP *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetNTP);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDNS ? type : NULL);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDNS **)soap_malloc(soap, sizeof(_tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDNS *)soap_instantiate__tds__SetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNS * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS * *d, _tds__SetDNS *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetDNS **)soap_malloc(soap, sizeof(_tds__SetDNS *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetDNS(_tds__SetDNS *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetDNS);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDNS ? type : NULL);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDNS **)soap_malloc(soap, sizeof(_tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDNS *)soap_instantiate__tds__GetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNS * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS * *d, _tds__GetDNS *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDNS **)soap_malloc(soap, sizeof(_tds__GetDNS *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDNS(_tds__GetDNS *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDNS);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHostnameFromDHCP ? type : NULL);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(_tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostnameFromDHCP *)soap_instantiate__tds__SetHostnameFromDHCP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP * *d, _tds__SetHostnameFromDHCP *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(_tds__SetHostnameFromDHCP *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetHostnameFromDHCP(_tds__SetHostnameFromDHCP *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetHostnameFromDHCP);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetHostname ? type : NULL);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostname **)soap_malloc(soap, sizeof(_tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostname *)soap_instantiate__tds__SetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostname * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname * *d, _tds__SetHostname *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetHostname **)soap_malloc(soap, sizeof(_tds__SetHostname *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetHostname(_tds__SetHostname *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetHostname);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetHostname ? type : NULL);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetHostname **)soap_malloc(soap, sizeof(_tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetHostname *)soap_instantiate__tds__GetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostname * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname * *d, _tds__GetHostname *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetHostname **)soap_malloc(soap, sizeof(_tds__GetHostname *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetHostname(_tds__GetHostname *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetHostname);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, int id, _tds__SetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddresses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDPAddresses ? type : NULL);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, _tds__SetDPAddresses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDPAddresses **)soap_malloc(soap, sizeof(_tds__SetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDPAddresses *)soap_instantiate__tds__SetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDPAddresses * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses * *d, _tds__SetDPAddresses *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetDPAddresses **)soap_malloc(soap, sizeof(_tds__SetDPAddresses *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetDPAddresses(_tds__SetDPAddresses *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetDPAddresses);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetCapabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCapabilities **)soap_malloc(soap, sizeof(_tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCapabilities *)soap_instantiate__tds__GetCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilities * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities * *d, _tds__GetCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetCapabilities **)soap_malloc(soap, sizeof(_tds__GetCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetCapabilities(_tds__GetCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, _tds__SetAuthFailureWarningConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetAuthFailureWarningConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__SetAuthFailureWarningConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAuthFailureWarningConfiguration *)soap_instantiate__tds__SetAuthFailureWarningConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration * *d, _tds__SetAuthFailureWarningConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__SetAuthFailureWarningConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetAuthFailureWarningConfiguration(_tds__SetAuthFailureWarningConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetAuthFailureWarningConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:SetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, _tds__GetAuthFailureWarningConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAuthFailureWarningConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAuthFailureWarningConfiguration *)soap_instantiate__tds__GetAuthFailureWarningConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration * *d, _tds__GetAuthFailureWarningConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetAuthFailureWarningConfiguration **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetAuthFailureWarningConfiguration(_tds__GetAuthFailureWarningConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetAuthFailureWarningConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:GetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAuthFailureWarningOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, _tds__GetAuthFailureWarningOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAuthFailureWarningOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetAuthFailureWarningOptions ? type : NULL);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAuthFailureWarningOptions **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAuthFailureWarningOptions *)soap_instantiate__tds__GetAuthFailureWarningOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptions * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions * *d, _tds__GetAuthFailureWarningOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetAuthFailureWarningOptions **)soap_malloc(soap, sizeof(_tds__GetAuthFailureWarningOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetAuthFailureWarningOptions(_tds__GetAuthFailureWarningOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetAuthFailureWarningOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag ? tag : "tds:GetAuthFailureWarningOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, _tds__SetPasswordHistoryConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetPasswordHistoryConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordHistoryConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetPasswordHistoryConfiguration *)soap_instantiate__tds__SetPasswordHistoryConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetPasswordHistoryConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration * *d, _tds__SetPasswordHistoryConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordHistoryConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetPasswordHistoryConfiguration(_tds__SetPasswordHistoryConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetPasswordHistoryConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "tds:SetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, _tds__GetPasswordHistoryConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordHistoryConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordHistoryConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordHistoryConfiguration *)soap_instantiate__tds__GetPasswordHistoryConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordHistoryConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration * *d, _tds__GetPasswordHistoryConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetPasswordHistoryConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordHistoryConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetPasswordHistoryConfiguration(_tds__GetPasswordHistoryConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetPasswordHistoryConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "tds:GetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, _tds__SetPasswordComplexityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetPasswordComplexityConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordComplexityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetPasswordComplexityConfiguration *)soap_instantiate__tds__SetPasswordComplexityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetPasswordComplexityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration * *d, _tds__SetPasswordComplexityConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__SetPasswordComplexityConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetPasswordComplexityConfiguration(_tds__SetPasswordComplexityConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetPasswordComplexityConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "tds:SetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, _tds__GetPasswordComplexityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordComplexityConfiguration ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordComplexityConfiguration *)soap_instantiate__tds__GetPasswordComplexityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordComplexityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfiguration * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration * *d, _tds__GetPasswordComplexityConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetPasswordComplexityConfiguration **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetPasswordComplexityConfiguration(_tds__GetPasswordComplexityConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetPasswordComplexityConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "tds:GetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPasswordComplexityOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, _tds__GetPasswordComplexityOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPasswordComplexityOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetPasswordComplexityOptions ? type : NULL);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPasswordComplexityOptions **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPasswordComplexityOptions *)soap_instantiate__tds__GetPasswordComplexityOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetPasswordComplexityOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptions * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions * *d, _tds__GetPasswordComplexityOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetPasswordComplexityOptions **)soap_malloc(soap, sizeof(_tds__GetPasswordComplexityOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetPasswordComplexityOptions(_tds__GetPasswordComplexityOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetPasswordComplexityOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetPasswordComplexityOptions(soap, tag ? tag : "tds:GetPasswordComplexityOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, _tds__GetWsdlUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetWsdlUrl ? type : NULL);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetWsdlUrl **)soap_malloc(soap, sizeof(_tds__GetWsdlUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetWsdlUrl *)soap_instantiate__tds__GetWsdlUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrl * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl * *d, _tds__GetWsdlUrl *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetWsdlUrl **)soap_malloc(soap, sizeof(_tds__GetWsdlUrl *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetWsdlUrl(_tds__GetWsdlUrl *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetWsdlUrl);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetUser ? type : NULL);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetUser **)soap_malloc(soap, sizeof(_tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetUser *)soap_instantiate__tds__SetUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetUser * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser * *d, _tds__SetUser *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetUser **)soap_malloc(soap, sizeof(_tds__SetUser *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetUser(_tds__SetUser *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetUser);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__DeleteUsers ? type : NULL);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteUsers **)soap_malloc(soap, sizeof(_tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteUsers *)soap_instantiate__tds__DeleteUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteUsers * * SOAP_FMAC2 soap_dup_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers * *d, _tds__DeleteUsers *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__DeleteUsers **)soap_malloc(soap, sizeof(_tds__DeleteUsers *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__DeleteUsers(_tds__DeleteUsers *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__DeleteUsers);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__CreateUsers ? type : NULL);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, _tds__CreateUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateUsers **)soap_malloc(soap, sizeof(_tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateUsers *)soap_instantiate__tds__CreateUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateUsers * * SOAP_FMAC2 soap_dup_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers * *d, _tds__CreateUsers *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__CreateUsers **)soap_malloc(soap, sizeof(_tds__CreateUsers *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__CreateUsers(_tds__CreateUsers *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__CreateUsers);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetUsers ? type : NULL);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, _tds__GetUsers **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetUsers **)soap_malloc(soap, sizeof(_tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetUsers *)soap_instantiate__tds__GetUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetUsers * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers * *d, _tds__GetUsers *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetUsers **)soap_malloc(soap, sizeof(_tds__GetUsers *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetUsers(_tds__GetUsers *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetUsers);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, int id, _tds__SetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRemoteUser ? type : NULL);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, _tds__SetRemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteUser **)soap_malloc(soap, sizeof(_tds__SetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteUser *)soap_instantiate__tds__SetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteUser * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser * *d, _tds__SetRemoteUser *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetRemoteUser **)soap_malloc(soap, sizeof(_tds__SetRemoteUser *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetRemoteUser(_tds__SetRemoteUser *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetRemoteUser);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, int id, _tds__GetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRemoteUser ? type : NULL);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, _tds__GetRemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteUser **)soap_malloc(soap, sizeof(_tds__GetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteUser *)soap_instantiate__tds__GetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteUser * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser * *d, _tds__GetRemoteUser *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetRemoteUser **)soap_malloc(soap, sizeof(_tds__GetRemoteUser *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetRemoteUser(_tds__GetRemoteUser *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetRemoteUser);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, int id, _tds__GetEndpointReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetEndpointReference ? type : NULL);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, _tds__GetEndpointReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetEndpointReference **)soap_malloc(soap, sizeof(_tds__GetEndpointReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetEndpointReference *)soap_instantiate__tds__GetEndpointReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetEndpointReference * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference * *d, _tds__GetEndpointReference *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetEndpointReference **)soap_malloc(soap, sizeof(_tds__GetEndpointReference *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetEndpointReference(_tds__GetEndpointReference *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetEndpointReference);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, int id, _tds__GetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddresses, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDPAddresses ? type : NULL);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, _tds__GetDPAddresses **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDPAddresses **)soap_malloc(soap, sizeof(_tds__GetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDPAddresses *)soap_instantiate__tds__GetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDPAddresses * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses * *d, _tds__GetDPAddresses *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDPAddresses **)soap_malloc(soap, sizeof(_tds__GetDPAddresses *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDPAddresses(_tds__GetDPAddresses *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDPAddresses);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetRemoteDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteDiscoveryMode *)soap_instantiate__tds__SetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode * *d, _tds__SetRemoteDiscoveryMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetRemoteDiscoveryMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetRemoteDiscoveryMode(_tds__SetRemoteDiscoveryMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetRemoteDiscoveryMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetRemoteDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteDiscoveryMode *)soap_instantiate__tds__GetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode * *d, _tds__GetRemoteDiscoveryMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetRemoteDiscoveryMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetRemoteDiscoveryMode(_tds__GetRemoteDiscoveryMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetRemoteDiscoveryMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, _tds__SetDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDiscoveryMode *)soap_instantiate__tds__SetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDiscoveryMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode * *d, _tds__SetDiscoveryMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetDiscoveryMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetDiscoveryMode(_tds__SetDiscoveryMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetDiscoveryMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDiscoveryMode ? type : NULL);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, _tds__GetDiscoveryMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDiscoveryMode *)soap_instantiate__tds__GetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDiscoveryMode * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode * *d, _tds__GetDiscoveryMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetDiscoveryMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDiscoveryMode(_tds__GetDiscoveryMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDiscoveryMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, int id, _tds__RemoveScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RemoveScopes ? type : NULL);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, _tds__RemoveScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveScopes **)soap_malloc(soap, sizeof(_tds__RemoveScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveScopes *)soap_instantiate__tds__RemoveScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveScopes * * SOAP_FMAC2 soap_dup_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes * *d, _tds__RemoveScopes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__RemoveScopes **)soap_malloc(soap, sizeof(_tds__RemoveScopes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__RemoveScopes(_tds__RemoveScopes *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__RemoveScopes);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, int id, _tds__AddScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__AddScopes ? type : NULL);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, _tds__AddScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddScopes **)soap_malloc(soap, sizeof(_tds__AddScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddScopes *)soap_instantiate__tds__AddScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddScopes * * SOAP_FMAC2 soap_dup_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes * *d, _tds__AddScopes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__AddScopes **)soap_malloc(soap, sizeof(_tds__AddScopes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__AddScopes(_tds__AddScopes *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__AddScopes);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetScopes **)soap_malloc(soap, sizeof(_tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetScopes *)soap_instantiate__tds__SetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetScopes * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes * *d, _tds__SetScopes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetScopes **)soap_malloc(soap, sizeof(_tds__SetScopes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetScopes(_tds__SetScopes *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetScopes);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetScopes ? type : NULL);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetScopes **)soap_malloc(soap, sizeof(_tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetScopes *)soap_instantiate__tds__GetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetScopes * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes * *d, _tds__GetScopes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetScopes **)soap_malloc(soap, sizeof(_tds__GetScopes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetScopes(_tds__GetScopes *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetScopes);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemSupportInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemSupportInformation *)soap_instantiate__tds__GetSystemSupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemSupportInformation * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation * *d, _tds__GetSystemSupportInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemSupportInformation(_tds__GetSystemSupportInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemSupportInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemLog ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemLog **)soap_malloc(soap, sizeof(_tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemLog *)soap_instantiate__tds__GetSystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemLog * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog * *d, _tds__GetSystemLog *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemLog **)soap_malloc(soap, sizeof(_tds__GetSystemLog *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemLog(_tds__GetSystemLog *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemLog);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemBackup ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemBackup **)soap_malloc(soap, sizeof(_tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemBackup *)soap_instantiate__tds__GetSystemBackup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemBackup * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup * *d, _tds__GetSystemBackup *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemBackup **)soap_malloc(soap, sizeof(_tds__GetSystemBackup *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemBackup(_tds__GetSystemBackup *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemBackup);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__RestoreSystem ? type : NULL);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RestoreSystem **)soap_malloc(soap, sizeof(_tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RestoreSystem *)soap_instantiate__tds__RestoreSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RestoreSystem * * SOAP_FMAC2 soap_dup_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem * *d, _tds__RestoreSystem *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__RestoreSystem **)soap_malloc(soap, sizeof(_tds__RestoreSystem *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__RestoreSystem(_tds__RestoreSystem *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__RestoreSystem);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SystemReboot ? type : NULL);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SystemReboot **)soap_malloc(soap, sizeof(_tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SystemReboot *)soap_instantiate__tds__SystemReboot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SystemReboot * * SOAP_FMAC2 soap_dup_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot * *d, _tds__SystemReboot *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SystemReboot **)soap_malloc(soap, sizeof(_tds__SystemReboot *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SystemReboot(_tds__SystemReboot *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SystemReboot);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__UpgradeSystemFirmware ? type : NULL);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UpgradeSystemFirmware *)soap_instantiate__tds__UpgradeSystemFirmware(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UpgradeSystemFirmware * * SOAP_FMAC2 soap_dup_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware * *d, _tds__UpgradeSystemFirmware *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmware *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__UpgradeSystemFirmware(_tds__UpgradeSystemFirmware *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__UpgradeSystemFirmware);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemFactoryDefault ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemFactoryDefault *)soap_instantiate__tds__SetSystemFactoryDefault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefault * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault * *d, _tds__SetSystemFactoryDefault *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefault *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetSystemFactoryDefault(_tds__SetSystemFactoryDefault *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetSystemFactoryDefault);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemDateAndTime *)soap_instantiate__tds__GetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemDateAndTime * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime * *d, _tds__GetSystemDateAndTime *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTime *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemDateAndTime(_tds__GetSystemDateAndTime *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemDateAndTime);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__SetSystemDateAndTime ? type : NULL);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemDateAndTime *)soap_instantiate__tds__SetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemDateAndTime * * SOAP_FMAC2 soap_dup_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime * *d, _tds__SetSystemDateAndTime *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTime *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__SetSystemDateAndTime(_tds__SetSystemDateAndTime *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__SetSystemDateAndTime);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetDeviceInformation ? type : NULL);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDeviceInformation **)soap_malloc(soap, sizeof(_tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDeviceInformation *)soap_instantiate__tds__GetDeviceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDeviceInformation * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation * *d, _tds__GetDeviceInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetDeviceInformation **)soap_malloc(soap, sizeof(_tds__GetDeviceInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetDeviceInformation(_tds__GetDeviceInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetDeviceInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServiceCapabilities *)soap_instantiate__tds__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServiceCapabilities * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities * *d, _tds__GetServiceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetServiceCapabilities(_tds__GetServiceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetServiceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetServices ? type : NULL);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServices **)soap_malloc(soap, sizeof(_tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServices *)soap_instantiate__tds__GetServices(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServices * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices * *d, _tds__GetServices *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetServices **)soap_malloc(soap, sizeof(_tds__GetServices *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetServices(_tds__GetServices *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetServices);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__NCName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__NCName))
		soap_serialize_xsd__NCName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__NCName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__NCName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__NCName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__NCName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__NCName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__NCName(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__NCName(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__NCName(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__NCName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__NCName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression))
		soap_serialize_wstop__ConcreteTopicExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__ConcreteTopicExpression, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__ConcreteTopicExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowstop__ConcreteTopicExpression(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__ConcreteTopicExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__ConcreteTopicExpression, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_wstop__ConcreteTopicExpression(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowstop__ConcreteTopicExpression(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__ConcreteTopicExpression(soap, tag ? tag : "wstop:ConcreteTopicExpression", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowstop__ConcreteTopicExpression(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__QName(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__QName(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__QName(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicType ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)soap_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicType * * SOAP_FMAC2 soap_dup_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType * *d, wstop__TopicType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowstop__TopicType(wstop__TopicType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wstop__TopicType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicType(soap, tag ? tag : "wstop:TopicType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__QueryExpressionType ? type : NULL);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)soap_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__QueryExpressionType * * SOAP_FMAC2 soap_dup_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType * *d, wstop__QueryExpressionType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowstop__QueryExpressionType(wstop__QueryExpressionType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wstop__QueryExpressionType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag ? tag : "wstop:QueryExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationExtension(struct soap *soap, const char *tag, tt__OSDConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfigurationExtension *)soap_instantiate_tt__OSDConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(tt__OSDConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension * *d, tt__OSDConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDConfigurationExtension(tt__OSDConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, int id, tt__OSDImgConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfiguration(struct soap *soap, const char *tag, tt__OSDImgConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgConfiguration **)soap_malloc(soap, sizeof(tt__OSDImgConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgConfiguration *)soap_instantiate_tt__OSDImgConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration * *d, tt__OSDImgConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDImgConfiguration **)soap_malloc(soap, sizeof(tt__OSDImgConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDImgConfiguration(tt__OSDImgConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDImgConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, int id, tt__OSDTextConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfiguration(struct soap *soap, const char *tag, tt__OSDTextConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextConfiguration **)soap_malloc(soap, sizeof(tt__OSDTextConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextConfiguration *)soap_instantiate_tt__OSDTextConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration * *d, tt__OSDTextConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDTextConfiguration **)soap_malloc(soap, sizeof(tt__OSDTextConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDTextConfiguration(tt__OSDTextConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDTextConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, int id, tt__OSDPosConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDPosConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDPosConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfiguration(struct soap *soap, const char *tag, tt__OSDPosConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDPosConfiguration **)soap_malloc(soap, sizeof(tt__OSDPosConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDPosConfiguration *)soap_instantiate_tt__OSDPosConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDPosConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDPosConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration * *d, tt__OSDPosConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDPosConfiguration **)soap_malloc(soap, sizeof(tt__OSDPosConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDPosConfiguration(tt__OSDPosConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDPosConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDPosConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDReference(struct soap *soap, tt__OSDReference *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDReference(struct soap *soap, const char *tag, int id, tt__OSDReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDReference, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDReference ? type : NULL);
}

SOAP_FMAC3 tt__OSDReference ** SOAP_FMAC4 soap_in_PointerTott__OSDReference(struct soap *soap, const char *tag, tt__OSDReference **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDReference **)soap_malloc(soap, sizeof(tt__OSDReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDReference *)soap_instantiate_tt__OSDReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDReference, sizeof(tt__OSDReference), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDReference * * SOAP_FMAC2 soap_dup_PointerTott__OSDReference(struct soap *soap, tt__OSDReference * *d, tt__OSDReference *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDReference **)soap_malloc(soap, sizeof(tt__OSDReference *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDReference(tt__OSDReference *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDReference);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDReference(struct soap *soap, tt__OSDReference *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDReference ** SOAP_FMAC4 soap_get_PointerTott__OSDReference(struct soap *soap, tt__OSDReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension * *d, tt__PTZConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZConfigurationExtension(tt__PTZConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ZoomLimits ? type : NULL);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)soap_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ZoomLimits * * SOAP_FMAC2 soap_dup_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits * *d, tt__ZoomLimits *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ZoomLimits(tt__ZoomLimits *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ZoomLimits);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? type : NULL);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)soap_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PanTiltLimits * * SOAP_FMAC2 soap_dup_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits * *d, tt__PanTiltLimits *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PanTiltLimits(tt__PanTiltLimits *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PanTiltLimits);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZSpeed ? type : NULL);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpeed **)soap_malloc(soap, sizeof(tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpeed *)soap_instantiate_tt__PTZSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpeed * * SOAP_FMAC2 soap_dup_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed * *d, tt__PTZSpeed *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZSpeed **)soap_malloc(soap, sizeof(tt__PTZSpeed *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZSpeed(tt__PTZSpeed *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZSpeed);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension *)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension * *d, tt__NetworkInterfaceExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceExtension(tt__NetworkInterfaceExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterface *)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterface * * SOAP_FMAC2 soap_dup_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface * *d, tt__IPv6NetworkInterface *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6NetworkInterface(tt__IPv6NetworkInterface *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv6NetworkInterface);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterface *)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterface * * SOAP_FMAC2 soap_dup_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface * *d, tt__IPv4NetworkInterface *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv4NetworkInterface(tt__IPv4NetworkInterface *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv4NetworkInterface);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceLink ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceLink *)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceLink * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink * *d, tt__NetworkInterfaceLink *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceLink(tt__NetworkInterfaceLink *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceLink);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceInfo ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceInfo *)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo * *d, tt__NetworkInterfaceInfo *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceInfo(tt__NetworkInterfaceInfo *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceInfo);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationExtension *)soap_instantiate_tt__MetadataConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension * *d, tt__MetadataConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MetadataConfigurationExtension(tt__MetadataConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MetadataConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventSubscription ? type : NULL);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventSubscription *)soap_instantiate_tt__EventSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventSubscription * * SOAP_FMAC2 soap_dup_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription * *d, tt__EventSubscription *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EventSubscription(tt__EventSubscription *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EventSubscription);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZFilter ? type : NULL);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZFilter *)soap_instantiate_tt__PTZFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZFilter * * SOAP_FMAC2 soap_dup_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter * *d, tt__PTZFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZFilter(tt__PTZFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfiguration *)soap_instantiate_tt__RuleEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration * *d, tt__RuleEngineConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RuleEngineConfiguration(tt__RuleEngineConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RuleEngineConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfiguration *)soap_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration * *d, tt__AnalyticsEngineConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsEngineConfiguration(tt__AnalyticsEngineConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsEngineConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MulticastConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MulticastConfiguration *)soap_instantiate_tt__MulticastConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MulticastConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration * *d, tt__MulticastConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MulticastConfiguration(tt__MulticastConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MulticastConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__H264Configuration ? type : NULL);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Configuration *)soap_instantiate_tt__H264Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Configuration * * SOAP_FMAC2 soap_dup_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration * *d, tt__H264Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__H264Configuration(tt__H264Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__H264Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Mpeg4Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Configuration *)soap_instantiate_tt__Mpeg4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Configuration * * SOAP_FMAC2 soap_dup_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration * *d, tt__Mpeg4Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Mpeg4Configuration(tt__Mpeg4Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Mpeg4Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoRateControl ? type : NULL);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl *)soap_instantiate_tt__VideoRateControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoRateControl * * SOAP_FMAC2 soap_dup_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl * *d, tt__VideoRateControl *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoRateControl(tt__VideoRateControl *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoRateControl);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension *)soap_instantiate_tt__VideoSourceConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension * *d, tt__VideoSourceConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfigurationExtension(tt__VideoSourceConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRectangle ? type : NULL);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangle *)soap_instantiate_tt__IntRectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangle * * SOAP_FMAC2 soap_dup_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle * *d, tt__IntRectangle *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IntRectangle(tt__IntRectangle *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IntRectangle);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceExtension **)soap_malloc(soap, sizeof(tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceExtension *)soap_instantiate_tt__VideoSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension * *d, tt__VideoSourceExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceExtension **)soap_malloc(soap, sizeof(tt__VideoSourceExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceExtension(tt__VideoSourceExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettings ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings **)soap_malloc(soap, sizeof(tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings *)soap_instantiate_tt__ImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings * *d, tt__ImagingSettings *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettings **)soap_malloc(soap, sizeof(tt__ImagingSettings *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettings(tt__ImagingSettings *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettings);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, tt__OSDConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptions(struct soap *soap, const char *tag, tt__OSDConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfigurationOptions **)soap_malloc(soap, sizeof(tt__OSDConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfigurationOptions *)soap_instantiate_tt__OSDConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(tt__OSDConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions * *d, tt__OSDConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDConfigurationOptions **)soap_malloc(soap, sizeof(tt__OSDConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDConfigurationOptions(tt__OSDConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfiguration(struct soap *soap, tt__OSDConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, int id, tt__OSDConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfiguration ** SOAP_FMAC4 soap_in_PointerTott__OSDConfiguration(struct soap *soap, const char *tag, tt__OSDConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfiguration **)soap_malloc(soap, sizeof(tt__OSDConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfiguration *)soap_instantiate_tt__OSDConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfiguration, sizeof(tt__OSDConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__OSDConfiguration(struct soap *soap, tt__OSDConfiguration * *d, tt__OSDConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDConfiguration **)soap_malloc(soap, sizeof(tt__OSDConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDConfiguration(tt__OSDConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfiguration(struct soap *soap, tt__OSDConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfiguration ** SOAP_FMAC4 soap_get_PointerTott__OSDConfiguration(struct soap *soap, tt__OSDConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceMode(struct soap *soap, trt__VideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, int id, trt__VideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_trt__VideoSourceMode ? type : NULL);
}

SOAP_FMAC3 trt__VideoSourceMode ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, trt__VideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__VideoSourceMode **)soap_malloc(soap, sizeof(trt__VideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__VideoSourceMode *)soap_instantiate_trt__VideoSourceMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (trt__VideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceMode, sizeof(trt__VideoSourceMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 trt__VideoSourceMode * * SOAP_FMAC2 soap_dup_PointerTotrt__VideoSourceMode(struct soap *soap, trt__VideoSourceMode * *d, trt__VideoSourceMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (trt__VideoSourceMode **)soap_malloc(soap, sizeof(trt__VideoSourceMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotrt__VideoSourceMode(trt__VideoSourceMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, trt__VideoSourceMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceMode(struct soap *soap, trt__VideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceMode(soap, tag ? tag : "trt:VideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__VideoSourceMode ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceMode(struct soap *soap, trt__VideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, tt__MediaUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaUri ? type : NULL);
}

SOAP_FMAC3 tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, tt__MediaUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaUri **)soap_malloc(soap, sizeof(tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaUri *)soap_instantiate_tt__MediaUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaUri * * SOAP_FMAC2 soap_dup_PointerTott__MediaUri(struct soap *soap, tt__MediaUri * *d, tt__MediaUri *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MediaUri **)soap_malloc(soap, sizeof(tt__MediaUri *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MediaUri(tt__MediaUri *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MediaUri);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, tt__MediaUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__StreamSetup ? type : NULL);
}

SOAP_FMAC3 tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, tt__StreamSetup **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__StreamSetup **)soap_malloc(soap, sizeof(tt__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__StreamSetup *)soap_instantiate_tt__StreamSetup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__StreamSetup * * SOAP_FMAC2 soap_dup_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup * *d, tt__StreamSetup *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__StreamSetup **)soap_malloc(soap, sizeof(tt__StreamSetup *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__StreamSetup(tt__StreamSetup *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__StreamSetup);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioDecoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioDecoderConfigurationOptions *)soap_instantiate_tt__AudioDecoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions * *d, tt__AudioDecoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioDecoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioDecoderConfigurationOptions(tt__AudioDecoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioDecoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioOutputConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, tt__AudioOutputConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioOutputConfigurationOptions *)soap_instantiate_tt__AudioOutputConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions * *d, tt__AudioOutputConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioOutputConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioOutputConfigurationOptions(tt__AudioOutputConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioOutputConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, tt__MetadataConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationOptions *)soap_instantiate_tt__MetadataConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions * *d, tt__MetadataConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MetadataConfigurationOptions(tt__MetadataConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MetadataConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioEncoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfigurationOptions *)soap_instantiate_tt__AudioEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions * *d, tt__AudioEncoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioEncoderConfigurationOptions(tt__AudioEncoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioEncoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioSourceConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceConfigurationOptions *)soap_instantiate_tt__AudioSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions * *d, tt__AudioSourceConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioSourceConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioSourceConfigurationOptions(tt__AudioSourceConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioSourceConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, tt__Profile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Profile ? type : NULL);
}

SOAP_FMAC3 tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, tt__Profile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Profile **)soap_malloc(soap, sizeof(tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Profile *)soap_instantiate_tt__Profile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Profile * * SOAP_FMAC2 soap_dup_PointerTott__Profile(struct soap *soap, tt__Profile * *d, tt__Profile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Profile **)soap_malloc(soap, sizeof(tt__Profile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Profile(tt__Profile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Profile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, tt__Profile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Profile(soap, tag ? tag : "tt:Profile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutput(struct soap *soap, const char *tag, int id, tt__AudioOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioOutput ? type : NULL);
}

SOAP_FMAC3 tt__AudioOutput ** SOAP_FMAC4 soap_in_PointerTott__AudioOutput(struct soap *soap, const char *tag, tt__AudioOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutput **)soap_malloc(soap, sizeof(tt__AudioOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioOutput *)soap_instantiate_tt__AudioOutput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(tt__AudioOutput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutput * * SOAP_FMAC2 soap_dup_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput * *d, tt__AudioOutput *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioOutput **)soap_malloc(soap, sizeof(tt__AudioOutput *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioOutput(tt__AudioOutput *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioOutput);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutput ** SOAP_FMAC4 soap_get_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSource(struct soap *soap, tt__AudioSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSource(struct soap *soap, const char *tag, int id, tt__AudioSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioSource ? type : NULL);
}

SOAP_FMAC3 tt__AudioSource ** SOAP_FMAC4 soap_in_PointerTott__AudioSource(struct soap *soap, const char *tag, tt__AudioSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSource **)soap_malloc(soap, sizeof(tt__AudioSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSource *)soap_instantiate_tt__AudioSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSource * * SOAP_FMAC2 soap_dup_PointerTott__AudioSource(struct soap *soap, tt__AudioSource * *d, tt__AudioSource *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioSource **)soap_malloc(soap, sizeof(tt__AudioSource *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioSource(tt__AudioSource *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioSource);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSource(struct soap *soap, tt__AudioSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSource ** SOAP_FMAC4 soap_get_PointerTott__AudioSource(struct soap *soap, tt__AudioSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_trt__Capabilities ? type : NULL);
}

SOAP_FMAC3 trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, trt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__Capabilities **)soap_malloc(soap, sizeof(trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__Capabilities *)soap_instantiate_trt__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(trt__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 trt__Capabilities * * SOAP_FMAC2 soap_dup_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities * *d, trt__Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (trt__Capabilities **)soap_malloc(soap, sizeof(trt__Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotrt__Capabilities(trt__Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, trt__Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__Capabilities(soap, tag ? tag : "trt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__VideoSourceModeExtension(struct soap *soap, trt__VideoSourceModeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__VideoSourceModeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, int id, trt__VideoSourceModeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__VideoSourceModeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_trt__VideoSourceModeExtension ? type : NULL);
}

SOAP_FMAC3 trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_in_PointerTotrt__VideoSourceModeExtension(struct soap *soap, const char *tag, trt__VideoSourceModeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__VideoSourceModeExtension **)soap_malloc(soap, sizeof(trt__VideoSourceModeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__VideoSourceModeExtension *)soap_instantiate_trt__VideoSourceModeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (trt__VideoSourceModeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__VideoSourceModeExtension, sizeof(trt__VideoSourceModeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 trt__VideoSourceModeExtension * * SOAP_FMAC2 soap_dup_PointerTotrt__VideoSourceModeExtension(struct soap *soap, trt__VideoSourceModeExtension * *d, trt__VideoSourceModeExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (trt__VideoSourceModeExtension **)soap_malloc(soap, sizeof(trt__VideoSourceModeExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotrt__VideoSourceModeExtension(trt__VideoSourceModeExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, trt__VideoSourceModeExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__VideoSourceModeExtension(struct soap *soap, trt__VideoSourceModeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__VideoSourceModeExtension(soap, tag ? tag : "trt:VideoSourceModeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__VideoSourceModeExtension ** SOAP_FMAC4 soap_get_PointerTotrt__VideoSourceModeExtension(struct soap *soap, trt__VideoSourceModeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__VideoSourceModeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Description(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Description))
		soap_serialize_tt__Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Description(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Description, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__Description(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Description, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__Description(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__Description(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Description(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Description(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Description(soap, tag ? tag : "tt:Description", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__Description(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__StreamingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, int id, trt__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__StreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_trt__StreamingCapabilities ? type : NULL);
}

SOAP_FMAC3 trt__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, trt__StreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__StreamingCapabilities **)soap_malloc(soap, sizeof(trt__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__StreamingCapabilities *)soap_instantiate_trt__StreamingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(trt__StreamingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 trt__StreamingCapabilities * * SOAP_FMAC2 soap_dup_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities * *d, trt__StreamingCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (trt__StreamingCapabilities **)soap_malloc(soap, sizeof(trt__StreamingCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotrt__StreamingCapabilities(trt__StreamingCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, trt__StreamingCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__StreamingCapabilities(soap, tag ? tag : "trt:StreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_trt__ProfileCapabilities ? type : NULL);
}

SOAP_FMAC3 trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, trt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__ProfileCapabilities **)soap_malloc(soap, sizeof(trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__ProfileCapabilities *)soap_instantiate_trt__ProfileCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(trt__ProfileCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 trt__ProfileCapabilities * * SOAP_FMAC2 soap_dup_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities * *d, trt__ProfileCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (trt__ProfileCapabilities **)soap_malloc(soap, sizeof(trt__ProfileCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotrt__ProfileCapabilities(trt__ProfileCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, trt__ProfileCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag ? tag : "trt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__ImagingPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, timg__ImagingPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__ImagingPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_timg__ImagingPreset ? type : NULL);
}

SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_in_PointerTotimg__ImagingPreset(struct soap *soap, const char *tag, timg__ImagingPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (timg__ImagingPreset **)soap_malloc(soap, sizeof(timg__ImagingPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (timg__ImagingPreset *)soap_instantiate_timg__ImagingPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (timg__ImagingPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__ImagingPreset, sizeof(timg__ImagingPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 timg__ImagingPreset * * SOAP_FMAC2 soap_dup_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset * *d, timg__ImagingPreset *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (timg__ImagingPreset **)soap_malloc(soap, sizeof(timg__ImagingPreset *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotimg__ImagingPreset(timg__ImagingPreset *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, timg__ImagingPreset);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__ImagingPreset(soap, tag ? tag : "timg:ImagingPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 timg__ImagingPreset ** SOAP_FMAC4 soap_get_PointerTotimg__ImagingPreset(struct soap *soap, timg__ImagingPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__ImagingPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, int id, tt__ImagingStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingStatus20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20 **)soap_malloc(soap, sizeof(tt__ImagingStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20 *)soap_instantiate_tt__ImagingStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 * *d, tt__ImagingStatus20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingStatus20 **)soap_malloc(soap, sizeof(tt__ImagingStatus20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingStatus20(tt__ImagingStatus20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingStatus20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MoveOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap *soap, const char *tag, int id, tt__MoveOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MoveOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MoveOptions20 **)soap_malloc(soap, sizeof(tt__MoveOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MoveOptions20 *)soap_instantiate_tt__MoveOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MoveOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 * *d, tt__MoveOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MoveOptions20 **)soap_malloc(soap, sizeof(tt__MoveOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MoveOptions20(tt__MoveOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MoveOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap *soap, const char *tag, int id, tt__FocusMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusMove ? type : NULL);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap *soap, const char *tag, tt__FocusMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusMove **)soap_malloc(soap, sizeof(tt__FocusMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusMove *)soap_instantiate_tt__FocusMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusMove * * SOAP_FMAC2 soap_dup_PointerTott__FocusMove(struct soap *soap, tt__FocusMove * *d, tt__FocusMove *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusMove **)soap_malloc(soap, sizeof(tt__FocusMove *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusMove(tt__FocusMove *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusMove);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap *soap, tt__FocusMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap *soap, const char *tag, int id, timg__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_timg__Capabilities ? type : NULL);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap *soap, const char *tag, timg__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (timg__Capabilities **)soap_malloc(soap, sizeof(timg__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (timg__Capabilities *)soap_instantiate_timg__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(timg__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 timg__Capabilities * * SOAP_FMAC2 soap_dup_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities * *d, timg__Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (timg__Capabilities **)soap_malloc(soap, sizeof(timg__Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotimg__Capabilities(timg__Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, timg__Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotimg__Capabilities(soap, tag ? tag : "timg:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__Documentation ? type : NULL);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)soap_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__Documentation * * SOAP_FMAC2 soap_dup_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation * *d, wstop__Documentation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowstop__Documentation(wstop__Documentation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wstop__Documentation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__Documentation(soap, tag ? tag : "wstop:Documentation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * * SOAP_FMAC2 soap_dup_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause * *d, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsrfbf__BaseFaultType_FaultCause(_wsrfbf__BaseFaultType_FaultCause *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _wsrfbf__BaseFaultType_FaultCause);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag ? tag : "wsrfbf:BaseFaultType-FaultCause", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xml__lang(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xml__lang))
		soap_serialize__xml__lang(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xml__lang(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xml__lang, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__xml__lang(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTo_xml__lang(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xml__lang(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xml__lang, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTo_xml__lang(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new__xml__lang(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_xml__lang(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xml__lang(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTo_xml__lang(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xml__lang(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode ? type : NULL);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * * SOAP_FMAC2 soap_dup_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode * *d, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsrfbf__BaseFaultType_ErrorCode(_wsrfbf__BaseFaultType_ErrorCode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _wsrfbf__BaseFaultType_ErrorCode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag ? tag : "wsrfbf:BaseFaultType-ErrorCode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger))
		soap_serialize_xsd__nonNegativeInteger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__nonNegativeInteger, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__nonNegativeInteger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__nonNegativeInteger(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__nonNegativeInteger(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__nonNegativeInteger(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * * SOAP_FMAC2 soap_dup_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy * *d, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsnt__Subscribe_SubscriptionPolicy(_wsnt__Subscribe_SubscriptionPolicy *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _wsnt__Subscribe_SubscriptionPolicy);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag ? tag : "wsnt:Subscribe-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType))
		soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_wsnt__AbsoluteOrRelativeTimeType(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsnt__AbsoluteOrRelativeTimeType(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag ? tag : "wsnt:AbsoluteOrRelativeTimeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTowsnt__AbsoluteOrRelativeTimeType(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__NotificationMessageHolderType ? type : NULL);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__NotificationMessageHolderType *)soap_instantiate_wsnt__NotificationMessageHolderType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__NotificationMessageHolderType * * SOAP_FMAC2 soap_dup_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType * *d, wsnt__NotificationMessageHolderType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsnt__NotificationMessageHolderType(wsnt__NotificationMessageHolderType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wsnt__NotificationMessageHolderType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag ? tag : "wsnt:NotificationMessageHolderType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__SubscriptionPolicyType ? type : NULL);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscriptionPolicyType *)soap_instantiate_wsnt__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__SubscriptionPolicyType * * SOAP_FMAC2 soap_dup_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType * *d, wsnt__SubscriptionPolicyType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsnt__SubscriptionPolicyType(wsnt__SubscriptionPolicyType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wsnt__SubscriptionPolicyType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag ? tag : "wsnt:SubscriptionPolicyType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wstop__TopicSetType ? type : NULL);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)soap_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wstop__TopicSetType * * SOAP_FMAC2 soap_dup_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType * *d, wstop__TopicSetType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowstop__TopicSetType(wstop__TopicSetType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wstop__TopicSetType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowstop__TopicSetType(soap, tag ? tag : "wstop:TopicSetType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__TopicExpressionType ? type : NULL);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionType *)soap_instantiate_wsnt__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__TopicExpressionType * * SOAP_FMAC2 soap_dup_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType * *d, wsnt__TopicExpressionType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsnt__TopicExpressionType(wsnt__TopicExpressionType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wsnt__TopicExpressionType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag ? tag : "wsnt:TopicExpressionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * * SOAP_FMAC2 soap_dup_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType * *d, struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsa5__EndpointReferenceType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsa5__EndpointReferenceType(struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsa5__EndpointReferenceType(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__EndpointReferenceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingServiceConfiguration(struct soap *soap, tt__ImagingServiceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingServiceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingServiceConfiguration(struct soap *soap, const char *tag, int id, tt__ImagingServiceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingServiceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingServiceConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__ImagingServiceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ImagingServiceConfiguration(struct soap *soap, const char *tag, tt__ImagingServiceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingServiceConfiguration **)soap_malloc(soap, sizeof(tt__ImagingServiceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingServiceConfiguration *)soap_instantiate_tt__ImagingServiceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingServiceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingServiceConfiguration, sizeof(tt__ImagingServiceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingServiceConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__ImagingServiceConfiguration(struct soap *soap, tt__ImagingServiceConfiguration * *d, tt__ImagingServiceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingServiceConfiguration **)soap_malloc(soap, sizeof(tt__ImagingServiceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingServiceConfiguration(tt__ImagingServiceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingServiceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingServiceConfiguration(struct soap *soap, tt__ImagingServiceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingServiceConfiguration(soap, tag ? tag : "tt:ImagingServiceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingServiceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ImagingServiceConfiguration(struct soap *soap, tt__ImagingServiceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingServiceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaServiceConfiguration(struct soap *soap, tt__MediaServiceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaServiceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaServiceConfiguration(struct soap *soap, const char *tag, int id, tt__MediaServiceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaServiceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaServiceConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__MediaServiceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MediaServiceConfiguration(struct soap *soap, const char *tag, tt__MediaServiceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaServiceConfiguration **)soap_malloc(soap, sizeof(tt__MediaServiceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaServiceConfiguration *)soap_instantiate_tt__MediaServiceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaServiceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaServiceConfiguration, sizeof(tt__MediaServiceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaServiceConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__MediaServiceConfiguration(struct soap *soap, tt__MediaServiceConfiguration * *d, tt__MediaServiceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MediaServiceConfiguration **)soap_malloc(soap, sizeof(tt__MediaServiceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MediaServiceConfiguration(tt__MediaServiceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MediaServiceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaServiceConfiguration(struct soap *soap, tt__MediaServiceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaServiceConfiguration(soap, tag ? tag : "tt:MediaServiceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaServiceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MediaServiceConfiguration(struct soap *soap, tt__MediaServiceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaServiceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingServiceProperties))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingServiceProperties(struct soap *soap, const char *tag, int id, tt__ImagingServiceProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingServiceProperties, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingServiceProperties ? type : NULL);
}

SOAP_FMAC3 tt__ImagingServiceProperties ** SOAP_FMAC4 soap_in_PointerTott__ImagingServiceProperties(struct soap *soap, const char *tag, tt__ImagingServiceProperties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingServiceProperties **)soap_malloc(soap, sizeof(tt__ImagingServiceProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingServiceProperties *)soap_instantiate_tt__ImagingServiceProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingServiceProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingServiceProperties, sizeof(tt__ImagingServiceProperties), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingServiceProperties * * SOAP_FMAC2 soap_dup_PointerTott__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties * *d, tt__ImagingServiceProperties *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingServiceProperties **)soap_malloc(soap, sizeof(tt__ImagingServiceProperties *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingServiceProperties(tt__ImagingServiceProperties *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingServiceProperties);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingServiceProperties(soap, tag ? tag : "tt:ImagingServiceProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingServiceProperties ** SOAP_FMAC4 soap_get_PointerTott__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaServiceProperties))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaServiceProperties(struct soap *soap, const char *tag, int id, tt__MediaServiceProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaServiceProperties, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaServiceProperties ? type : NULL);
}

SOAP_FMAC3 tt__MediaServiceProperties ** SOAP_FMAC4 soap_in_PointerTott__MediaServiceProperties(struct soap *soap, const char *tag, tt__MediaServiceProperties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaServiceProperties **)soap_malloc(soap, sizeof(tt__MediaServiceProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaServiceProperties *)soap_instantiate_tt__MediaServiceProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaServiceProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaServiceProperties, sizeof(tt__MediaServiceProperties), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaServiceProperties * * SOAP_FMAC2 soap_dup_PointerTott__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties * *d, tt__MediaServiceProperties *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MediaServiceProperties **)soap_malloc(soap, sizeof(tt__MediaServiceProperties *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MediaServiceProperties(tt__MediaServiceProperties *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MediaServiceProperties);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaServiceProperties(soap, tag ? tag : "tt:MediaServiceProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaServiceProperties ** SOAP_FMAC4 soap_get_PointerTott__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RTSPStream(struct soap *soap, tt__RTSPStream *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RTSPStream))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RTSPStream(struct soap *soap, const char *tag, int id, tt__RTSPStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RTSPStream, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RTSPStream ? type : NULL);
}

SOAP_FMAC3 tt__RTSPStream ** SOAP_FMAC4 soap_in_PointerTott__RTSPStream(struct soap *soap, const char *tag, tt__RTSPStream **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RTSPStream **)soap_malloc(soap, sizeof(tt__RTSPStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RTSPStream *)soap_instantiate_tt__RTSPStream(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RTSPStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RTSPStream, sizeof(tt__RTSPStream), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RTSPStream * * SOAP_FMAC2 soap_dup_PointerTott__RTSPStream(struct soap *soap, tt__RTSPStream * *d, tt__RTSPStream *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RTSPStream **)soap_malloc(soap, sizeof(tt__RTSPStream *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RTSPStream(tt__RTSPStream *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RTSPStream);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RTSPStream(struct soap *soap, tt__RTSPStream *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RTSPStream(soap, tag ? tag : "tt:RTSPStream", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RTSPStream ** SOAP_FMAC4 soap_get_PointerTott__RTSPStream(struct soap *soap, tt__RTSPStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RTSPStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceManagementServiceProperties))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceManagementServiceProperties(struct soap *soap, const char *tag, int id, tt__DeviceManagementServiceProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceManagementServiceProperties, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceManagementServiceProperties ? type : NULL);
}

SOAP_FMAC3 tt__DeviceManagementServiceProperties ** SOAP_FMAC4 soap_in_PointerTott__DeviceManagementServiceProperties(struct soap *soap, const char *tag, tt__DeviceManagementServiceProperties **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceManagementServiceProperties **)soap_malloc(soap, sizeof(tt__DeviceManagementServiceProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceManagementServiceProperties *)soap_instantiate_tt__DeviceManagementServiceProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceManagementServiceProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceManagementServiceProperties, sizeof(tt__DeviceManagementServiceProperties), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceManagementServiceProperties * * SOAP_FMAC2 soap_dup_PointerTott__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties * *d, tt__DeviceManagementServiceProperties *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceManagementServiceProperties **)soap_malloc(soap, sizeof(tt__DeviceManagementServiceProperties *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceManagementServiceProperties(tt__DeviceManagementServiceProperties *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceManagementServiceProperties);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceManagementServiceProperties(soap, tag ? tag : "tt:DeviceManagementServiceProperties", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceManagementServiceProperties ** SOAP_FMAC4 soap_get_PointerTott__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceManagementServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, tt__PropertyOperation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PropertyOperation **)soap_malloc(soap, sizeof(tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(tt__PropertyOperation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PropertyOperation * * SOAP_FMAC2 soap_dup_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation * *d, tt__PropertyOperation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PropertyOperation **)soap_malloc(soap, sizeof(tt__PropertyOperation *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__PropertyOperation *)soap_malloc(soap, sizeof(tt__PropertyOperation))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PropertyOperation(tt__PropertyOperation *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PropertyOperation(soap, tag ? tag : "tt:PropertyOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MessageExtension ? type : NULL);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageExtension *)soap_instantiate_tt__MessageExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MessageExtension * * SOAP_FMAC2 soap_dup_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension * *d, tt__MessageExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MessageExtension(tt__MessageExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MessageExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MinimumProfile(struct soap *soap, tt__MinimumProfile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MinimumProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MinimumProfile(struct soap *soap, const char *tag, int id, tt__MinimumProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MinimumProfile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MinimumProfile ? type : NULL);
}

SOAP_FMAC3 tt__MinimumProfile ** SOAP_FMAC4 soap_in_PointerTott__MinimumProfile(struct soap *soap, const char *tag, tt__MinimumProfile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MinimumProfile **)soap_malloc(soap, sizeof(tt__MinimumProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MinimumProfile *)soap_instantiate_tt__MinimumProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MinimumProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MinimumProfile, sizeof(tt__MinimumProfile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MinimumProfile * * SOAP_FMAC2 soap_dup_PointerTott__MinimumProfile(struct soap *soap, tt__MinimumProfile * *d, tt__MinimumProfile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MinimumProfile **)soap_malloc(soap, sizeof(tt__MinimumProfile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MinimumProfile(tt__MinimumProfile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MinimumProfile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MinimumProfile(struct soap *soap, tt__MinimumProfile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MinimumProfile(soap, tag ? tag : "tt:MinimumProfile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MinimumProfile ** SOAP_FMAC4 soap_get_PointerTott__MinimumProfile(struct soap *soap, tt__MinimumProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MinimumProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingVideoSource(struct soap *soap, tt__ImagingVideoSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingVideoSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingVideoSource(struct soap *soap, const char *tag, int id, tt__ImagingVideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingVideoSource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingVideoSource ? type : NULL);
}

SOAP_FMAC3 tt__ImagingVideoSource ** SOAP_FMAC4 soap_in_PointerTott__ImagingVideoSource(struct soap *soap, const char *tag, tt__ImagingVideoSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingVideoSource **)soap_malloc(soap, sizeof(tt__ImagingVideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingVideoSource *)soap_instantiate_tt__ImagingVideoSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingVideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingVideoSource, sizeof(tt__ImagingVideoSource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingVideoSource * * SOAP_FMAC2 soap_dup_PointerTott__ImagingVideoSource(struct soap *soap, tt__ImagingVideoSource * *d, tt__ImagingVideoSource *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingVideoSource **)soap_malloc(soap, sizeof(tt__ImagingVideoSource *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingVideoSource(tt__ImagingVideoSource *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingVideoSource);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingVideoSource(struct soap *soap, tt__ImagingVideoSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingVideoSource(soap, tag ? tag : "tt:ImagingVideoSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingVideoSource ** SOAP_FMAC4 soap_get_PointerTott__ImagingVideoSource(struct soap *soap, tt__ImagingVideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingVideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceInformation(struct soap *soap, tt__DeviceInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceInformation(struct soap *soap, const char *tag, int id, tt__DeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceInformation ? type : NULL);
}

SOAP_FMAC3 tt__DeviceInformation ** SOAP_FMAC4 soap_in_PointerTott__DeviceInformation(struct soap *soap, const char *tag, tt__DeviceInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceInformation **)soap_malloc(soap, sizeof(tt__DeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceInformation *)soap_instantiate_tt__DeviceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceInformation, sizeof(tt__DeviceInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceInformation * * SOAP_FMAC2 soap_dup_PointerTott__DeviceInformation(struct soap *soap, tt__DeviceInformation * *d, tt__DeviceInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceInformation **)soap_malloc(soap, sizeof(tt__DeviceInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceInformation(tt__DeviceInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceInformation(struct soap *soap, tt__DeviceInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceInformation(soap, tag ? tag : "tt:DeviceInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceInformation ** SOAP_FMAC4 soap_get_PointerTott__DeviceInformation(struct soap *soap, tt__DeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingVideoSourceOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingVideoSourceOptions(struct soap *soap, const char *tag, int id, tt__ImagingVideoSourceOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingVideoSourceOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingVideoSourceOptions ? type : NULL);
}

SOAP_FMAC3 tt__ImagingVideoSourceOptions ** SOAP_FMAC4 soap_in_PointerTott__ImagingVideoSourceOptions(struct soap *soap, const char *tag, tt__ImagingVideoSourceOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingVideoSourceOptions **)soap_malloc(soap, sizeof(tt__ImagingVideoSourceOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingVideoSourceOptions *)soap_instantiate_tt__ImagingVideoSourceOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingVideoSourceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingVideoSourceOptions, sizeof(tt__ImagingVideoSourceOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingVideoSourceOptions * * SOAP_FMAC2 soap_dup_PointerTott__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions * *d, tt__ImagingVideoSourceOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingVideoSourceOptions **)soap_malloc(soap, sizeof(tt__ImagingVideoSourceOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingVideoSourceOptions(tt__ImagingVideoSourceOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingVideoSourceOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingVideoSourceOptions(soap, tag ? tag : "tt:ImagingVideoSourceOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingVideoSourceOptions ** SOAP_FMAC4 soap_get_PointerTott__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingVideoSourceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, int id, tt__ImagingOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20 **)soap_malloc(soap, sizeof(tt__ImagingOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20 *)soap_instantiate_tt__ImagingOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 * *d, tt__ImagingOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingOptions20 **)soap_malloc(soap, sizeof(tt__ImagingOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingOptions20(tt__ImagingOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoEncoderConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderConfigurationOptions *)soap_instantiate_tt__VideoEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions * *d, tt__VideoEncoderConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoEncoderConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoEncoderConfigurationOptions(tt__VideoEncoderConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoEncoderConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationOptions *)soap_instantiate_tt__VideoSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions * *d, tt__VideoSourceConfigurationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfigurationOptions(tt__VideoSourceConfigurationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfigurationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSource(struct soap *soap, tt__VideoSource *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSource(struct soap *soap, const char *tag, int id, tt__VideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSource, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSource ? type : NULL);
}

SOAP_FMAC3 tt__VideoSource ** SOAP_FMAC4 soap_in_PointerTott__VideoSource(struct soap *soap, const char *tag, tt__VideoSource **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSource **)soap_malloc(soap, sizeof(tt__VideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSource *)soap_instantiate_tt__VideoSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSource * * SOAP_FMAC2 soap_dup_PointerTott__VideoSource(struct soap *soap, tt__VideoSource * *d, tt__VideoSource *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSource **)soap_malloc(soap, sizeof(tt__VideoSource *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSource(tt__VideoSource *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSource);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSource(struct soap *soap, tt__VideoSource *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSource ** SOAP_FMAC4 soap_get_PointerTott__VideoSource(struct soap *soap, tt__VideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalOrientation(struct soap *soap, const char *tag, int id, tt__LocalOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalOrientation ? type : NULL);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_in_PointerTott__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalOrientation **)soap_malloc(soap, sizeof(tt__LocalOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalOrientation *)soap_instantiate_tt__LocalOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalOrientation * * SOAP_FMAC2 soap_dup_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation * *d, tt__LocalOrientation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LocalOrientation **)soap_malloc(soap, sizeof(tt__LocalOrientation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LocalOrientation(tt__LocalOrientation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LocalOrientation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalOrientation ** SOAP_FMAC4 soap_get_PointerTott__LocalOrientation(struct soap *soap, tt__LocalOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocalLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocalLocation(struct soap *soap, const char *tag, int id, tt__LocalLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocalLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocalLocation ? type : NULL);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_in_PointerTott__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocalLocation **)soap_malloc(soap, sizeof(tt__LocalLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocalLocation *)soap_instantiate_tt__LocalLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocalLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocalLocation * * SOAP_FMAC2 soap_dup_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation * *d, tt__LocalLocation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LocalLocation **)soap_malloc(soap, sizeof(tt__LocalLocation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LocalLocation(tt__LocalLocation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LocalLocation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocalLocation ** SOAP_FMAC4 soap_get_PointerTott__LocalLocation(struct soap *soap, tt__LocalLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoOrientation(struct soap *soap, const char *tag, int id, tt__GeoOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoOrientation ? type : NULL);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_in_PointerTott__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoOrientation **)soap_malloc(soap, sizeof(tt__GeoOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoOrientation *)soap_instantiate_tt__GeoOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoOrientation * * SOAP_FMAC2 soap_dup_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation * *d, tt__GeoOrientation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__GeoOrientation **)soap_malloc(soap, sizeof(tt__GeoOrientation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__GeoOrientation(tt__GeoOrientation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__GeoOrientation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoOrientation ** SOAP_FMAC4 soap_get_PointerTott__GeoOrientation(struct soap *soap, tt__GeoOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoLocation ? type : NULL);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoLocation **)soap_malloc(soap, sizeof(tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoLocation *)soap_instantiate_tt__GeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoLocation * * SOAP_FMAC2 soap_dup_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation * *d, tt__GeoLocation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__GeoLocation **)soap_malloc(soap, sizeof(tt__GeoLocation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__GeoLocation(tt__GeoLocation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__GeoLocation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 double * * SOAP_FMAC2 soap_dup_PointerTodouble(struct soap *soap, double * *d, double *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (double **)soap_malloc(soap, sizeof(double *))))
		return NULL; /* ERROR */
	if (*a && (*d = (double *)soap_malloc(soap, sizeof(double))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTodouble(double *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDConfigurationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__OSDConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDConfigurationOptionsExtension *)soap_instantiate_tt__OSDConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(tt__OSDConfigurationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension * *d, tt__OSDConfigurationOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDConfigurationOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDConfigurationOptionsExtension(tt__OSDConfigurationOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDConfigurationOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, int id, tt__OSDImgOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptions(struct soap *soap, const char *tag, tt__OSDImgOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgOptions **)soap_malloc(soap, sizeof(tt__OSDImgOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgOptions *)soap_instantiate_tt__OSDImgOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgOptions * * SOAP_FMAC2 soap_dup_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions * *d, tt__OSDImgOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDImgOptions **)soap_malloc(soap, sizeof(tt__OSDImgOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDImgOptions(tt__OSDImgOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDImgOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptions(struct soap *soap, tt__OSDImgOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, int id, tt__OSDTextOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptions(struct soap *soap, const char *tag, tt__OSDTextOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextOptions **)soap_malloc(soap, sizeof(tt__OSDTextOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextOptions *)soap_instantiate_tt__OSDTextOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextOptions * * SOAP_FMAC2 soap_dup_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions * *d, tt__OSDTextOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDTextOptions **)soap_malloc(soap, sizeof(tt__OSDTextOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDTextOptions(tt__OSDTextOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDTextOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptions(struct soap *soap, tt__OSDTextOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MaximumNumberOfOSDs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, tt__MaximumNumberOfOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MaximumNumberOfOSDs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MaximumNumberOfOSDs ? type : NULL);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_in_PointerTott__MaximumNumberOfOSDs(struct soap *soap, const char *tag, tt__MaximumNumberOfOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MaximumNumberOfOSDs **)soap_malloc(soap, sizeof(tt__MaximumNumberOfOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MaximumNumberOfOSDs *)soap_instantiate_tt__MaximumNumberOfOSDs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MaximumNumberOfOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(tt__MaximumNumberOfOSDs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MaximumNumberOfOSDs * * SOAP_FMAC2 soap_dup_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs * *d, tt__MaximumNumberOfOSDs *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MaximumNumberOfOSDs **)soap_malloc(soap, sizeof(tt__MaximumNumberOfOSDs *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MaximumNumberOfOSDs(tt__MaximumNumberOfOSDs *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MaximumNumberOfOSDs);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs ** SOAP_FMAC4 soap_get_PointerTott__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDImgOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgOptionsExtension(struct soap *soap, const char *tag, tt__OSDImgOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDImgOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgOptionsExtension *)soap_instantiate_tt__OSDImgOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(tt__OSDImgOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension * *d, tt__OSDImgOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDImgOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDImgOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDImgOptionsExtension(tt__OSDImgOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDImgOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDTextOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextOptionsExtension(struct soap *soap, const char *tag, tt__OSDTextOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDTextOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextOptionsExtension *)soap_instantiate_tt__OSDTextOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(tt__OSDTextOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension * *d, tt__OSDTextOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDTextOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDTextOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDTextOptionsExtension(tt__OSDTextOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDTextOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, int id, tt__OSDColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColorOptions ? type : NULL);
}

SOAP_FMAC3 tt__OSDColorOptions ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptions(struct soap *soap, const char *tag, tt__OSDColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColorOptions **)soap_malloc(soap, sizeof(tt__OSDColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColorOptions *)soap_instantiate_tt__OSDColorOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColorOptions * * SOAP_FMAC2 soap_dup_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions * *d, tt__OSDColorOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDColorOptions **)soap_malloc(soap, sizeof(tt__OSDColorOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDColorOptions(tt__OSDColorOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDColorOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColorOptions ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptions(struct soap *soap, tt__OSDColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColorOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, tt__OSDColorOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColorOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColorOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDColorOptionsExtension(struct soap *soap, const char *tag, tt__OSDColorOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColorOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDColorOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColorOptionsExtension *)soap_instantiate_tt__OSDColorOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColorOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(tt__OSDColorOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColorOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension * *d, tt__OSDColorOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDColorOptionsExtension **)soap_malloc(soap, sizeof(tt__OSDColorOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDColorOptionsExtension(tt__OSDColorOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDColorOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorOptions(struct soap *soap, const char *tag, int id, tt__ColorOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ColorOptions ? type : NULL);
}

SOAP_FMAC3 tt__ColorOptions ** SOAP_FMAC4 soap_in_PointerTott__ColorOptions(struct soap *soap, const char *tag, tt__ColorOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorOptions **)soap_malloc(soap, sizeof(tt__ColorOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorOptions *)soap_instantiate_tt__ColorOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ColorOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorOptions * * SOAP_FMAC2 soap_dup_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions * *d, tt__ColorOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ColorOptions **)soap_malloc(soap, sizeof(tt__ColorOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ColorOptions(tt__ColorOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ColorOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorOptions ** SOAP_FMAC4 soap_get_PointerTott__ColorOptions(struct soap *soap, tt__ColorOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange))
		soap_serialize_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, std::vector<tt__ColorspaceRange *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, const char *tag, std::vector<tt__ColorspaceRange *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<tt__ColorspaceRange *> **)soap_malloc(soap, sizeof(std::vector<tt__ColorspaceRange *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC1 std::vector<tt__ColorspaceRange *> * * SOAP_FMAC2 soap_dup_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> * *d, std::vector<tt__ColorspaceRange *> *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::vector<tt__ColorspaceRange *> **)soap_malloc(soap, sizeof(std::vector<tt__ColorspaceRange *> *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_std__vectorTemplateOfPointerTott__ColorspaceRange(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(std::vector<tt__ColorspaceRange *> *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_std__vectorTemplateOfPointerTott__ColorspaceRange(*a);
		SOAP_DELETE(NULL, *a, std::vector<tt__ColorspaceRange *> );
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<tt__ColorspaceRange *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(struct soap *soap, std::vector<tt__ColorspaceRange *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorspaceRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, int id, tt__ColorspaceRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorspaceRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ColorspaceRange ? type : NULL);
}

SOAP_FMAC3 tt__ColorspaceRange ** SOAP_FMAC4 soap_in_PointerTott__ColorspaceRange(struct soap *soap, const char *tag, tt__ColorspaceRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ColorspaceRange **)soap_malloc(soap, sizeof(tt__ColorspaceRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ColorspaceRange *)soap_instantiate_tt__ColorspaceRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ColorspaceRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorspaceRange * * SOAP_FMAC2 soap_dup_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange * *d, tt__ColorspaceRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ColorspaceRange **)soap_malloc(soap, sizeof(tt__ColorspaceRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ColorspaceRange(tt__ColorspaceRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ColorspaceRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ColorspaceRange ** SOAP_FMAC4 soap_get_PointerTott__ColorspaceRange(struct soap *soap, tt__ColorspaceRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__vectorTemplateOfPointerTott__Color))
		soap_serialize_std__vectorTemplateOfPointerTott__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, int id, std::vector<tt__Color *> *const*a, const char *type)
{
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	return soap_out_std__vectorTemplateOfPointerTott__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::vector<tt__Color *> ** SOAP_FMAC4 soap_in_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, const char *tag, std::vector<tt__Color *> **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	soap_revert(soap);
	if (!a)
	{	if (!(a = (std::vector<tt__Color *> **)soap_malloc(soap, sizeof(std::vector<tt__Color *> *))))
			return NULL;
		*a = NULL;
	}
	if (!(*a = soap_in_std__vectorTemplateOfPointerTott__Color(soap, tag, *a, type)))
		return NULL;
	return a;
}

SOAP_FMAC1 std::vector<tt__Color *> * * SOAP_FMAC2 soap_dup_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> * *d, std::vector<tt__Color *> *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::vector<tt__Color *> **)soap_malloc(soap, sizeof(std::vector<tt__Color *> *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_std__vectorTemplateOfPointerTott__Color(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTostd__vectorTemplateOfPointerTott__Color(std::vector<tt__Color *> *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_std__vectorTemplateOfPointerTott__Color(*a);
		SOAP_DELETE(NULL, *a, std::vector<tt__Color *> );
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__vectorTemplateOfPointerTott__Color(soap, tag ? tag : "", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::vector<tt__Color *> ** SOAP_FMAC4 soap_get_PointerTostd__vectorTemplateOfPointerTott__Color(struct soap *soap, std::vector<tt__Color *> **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__vectorTemplateOfPointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDImgConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDImgConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDImgConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDImgConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDImgConfigurationExtension(struct soap *soap, const char *tag, tt__OSDImgConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDImgConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDImgConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDImgConfigurationExtension *)soap_instantiate_tt__OSDImgConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDImgConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(tt__OSDImgConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension * *d, tt__OSDImgConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDImgConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDImgConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDImgConfigurationExtension(tt__OSDImgConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDImgConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDTextConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDTextConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDTextConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDTextConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDTextConfigurationExtension(struct soap *soap, const char *tag, tt__OSDTextConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDTextConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDTextConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDTextConfigurationExtension *)soap_instantiate_tt__OSDTextConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDTextConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(tt__OSDTextConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension * *d, tt__OSDTextConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDTextConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDTextConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDTextConfigurationExtension(tt__OSDTextConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDTextConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDColor(struct soap *soap, tt__OSDColor *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDColor))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDColor(struct soap *soap, const char *tag, int id, tt__OSDColor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDColor, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDColor ? type : NULL);
}

SOAP_FMAC3 tt__OSDColor ** SOAP_FMAC4 soap_in_PointerTott__OSDColor(struct soap *soap, const char *tag, tt__OSDColor **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDColor **)soap_malloc(soap, sizeof(tt__OSDColor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDColor *)soap_instantiate_tt__OSDColor(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDColor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColor * * SOAP_FMAC2 soap_dup_PointerTott__OSDColor(struct soap *soap, tt__OSDColor * *d, tt__OSDColor *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDColor **)soap_malloc(soap, sizeof(tt__OSDColor *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDColor(tt__OSDColor *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDColor);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDColor(struct soap *soap, tt__OSDColor *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDColor ** SOAP_FMAC4 soap_get_PointerTott__OSDColor(struct soap *soap, tt__OSDColor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, tt__Color *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Color ? type : NULL);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, tt__Color **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Color **)soap_malloc(soap, sizeof(tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Color *)soap_instantiate_tt__Color(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(tt__Color), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Color * * SOAP_FMAC2 soap_dup_PointerTott__Color(struct soap *soap, tt__Color * *d, tt__Color *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Color **)soap_malloc(soap, sizeof(tt__Color *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Color(tt__Color *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Color);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, tt__Color *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Color(soap, tag ? tag : "tt:Color", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OSDPosConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, tt__OSDPosConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OSDPosConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OSDPosConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__OSDPosConfigurationExtension(struct soap *soap, const char *tag, tt__OSDPosConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OSDPosConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDPosConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OSDPosConfigurationExtension *)soap_instantiate_tt__OSDPosConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OSDPosConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(tt__OSDPosConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDPosConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension * *d, tt__OSDPosConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OSDPosConfigurationExtension **)soap_malloc(soap, sizeof(tt__OSDPosConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OSDPosConfigurationExtension(tt__OSDPosConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OSDPosConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ItemList ? type : NULL);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, tt__ItemList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemList **)soap_malloc(soap, sizeof(tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemList *)soap_instantiate_tt__ItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemList * * SOAP_FMAC2 soap_dup_PointerTott__ItemList(struct soap *soap, tt__ItemList * *d, tt__ItemList *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ItemList **)soap_malloc(soap, sizeof(tt__ItemList *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ItemList(tt__ItemList *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ItemList);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, tt__ItemList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemList(soap, tag ? tag : "tt:ItemList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RuleEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfigurationExtension *)soap_instantiate_tt__RuleEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension * *d, tt__RuleEngineConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__RuleEngineConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RuleEngineConfigurationExtension(tt__RuleEngineConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RuleEngineConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfigurationExtension *)soap_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension * *d, tt__AnalyticsEngineConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsEngineConfigurationExtension(tt__AnalyticsEngineConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsEngineConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, tt__Config *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Config ? type : NULL);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, tt__Config **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Config **)soap_malloc(soap, sizeof(tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Config *)soap_instantiate_tt__Config(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Config * * SOAP_FMAC2 soap_dup_PointerTott__Config(struct soap *soap, tt__Config * *d, tt__Config *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Config **)soap_malloc(soap, sizeof(tt__Config *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Config(tt__Config *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Config);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, tt__Config *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Config(soap, tag ? tag : "tt:Config", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, tt__Vector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector ? type : NULL);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, tt__Vector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector **)soap_malloc(soap, sizeof(tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector *)soap_instantiate_tt__Vector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector * * SOAP_FMAC2 soap_dup_PointerTott__Vector(struct soap *soap, tt__Vector * *d, tt__Vector *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Vector **)soap_malloc(soap, sizeof(tt__Vector *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Vector(tt__Vector *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Vector);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, tt__Vector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector(soap, tag ? tag : "tt:Vector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ItemListExtension ? type : NULL);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ItemListExtension **)soap_malloc(soap, sizeof(tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ItemListExtension *)soap_instantiate_tt__ItemListExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemListExtension * * SOAP_FMAC2 soap_dup_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension * *d, tt__ItemListExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ItemListExtension **)soap_malloc(soap, sizeof(tt__ItemListExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ItemListExtension(tt__ItemListExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ItemListExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20Extension *)soap_instantiate_tt__FocusOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20Extension * * SOAP_FMAC2 soap_dup_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension * *d, tt__FocusOptions20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(tt__FocusOptions20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusOptions20Extension(tt__FocusOptions20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusOptions20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20Extension *)soap_instantiate_tt__WhiteBalanceOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * * SOAP_FMAC2 soap_dup_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension * *d, tt__WhiteBalanceOptions20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WhiteBalanceOptions20Extension(tt__WhiteBalanceOptions20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WhiteBalanceOptions20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusConfiguration20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20Extension *)soap_instantiate_tt__FocusConfiguration20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * * SOAP_FMAC2 soap_dup_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension * *d, tt__FocusConfiguration20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(tt__FocusConfiguration20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusConfiguration20Extension(tt__FocusConfiguration20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusConfiguration20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalance20Extension ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20Extension *)soap_instantiate_tt__WhiteBalance20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20Extension * * SOAP_FMAC2 soap_dup_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension * *d, tt__WhiteBalance20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(tt__WhiteBalance20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WhiteBalance20Extension(tt__WhiteBalance20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WhiteBalance20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocusOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, tt__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ContinuousFocusOptions ? type : NULL);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(tt__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocusOptions *)soap_instantiate_tt__ContinuousFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocusOptions * * SOAP_FMAC2 soap_dup_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions * *d, tt__ContinuousFocusOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(tt__ContinuousFocusOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ContinuousFocusOptions(tt__ContinuousFocusOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ContinuousFocusOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelativeFocusOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocusOptions20 *)soap_instantiate_tt__RelativeFocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 * *d, tt__RelativeFocusOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(tt__RelativeFocusOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RelativeFocusOptions20(tt__RelativeFocusOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RelativeFocusOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocusOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, tt__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocusOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AbsoluteFocusOptions ? type : NULL);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(tt__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocusOptions *)soap_instantiate_tt__AbsoluteFocusOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * * SOAP_FMAC2 soap_dup_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions * *d, tt__AbsoluteFocusOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(tt__AbsoluteFocusOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AbsoluteFocusOptions(tt__AbsoluteFocusOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AbsoluteFocusOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentOptionsExtension *)soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension * *d, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IrCutFilterAutoAdjustmentOptionsExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IrCutFilterAutoAdjustmentOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DurationRange ? type : NULL);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, tt__DurationRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DurationRange **)soap_malloc(soap, sizeof(tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DurationRange *)soap_instantiate_tt__DurationRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DurationRange * * SOAP_FMAC2 soap_dup_PointerTott__DurationRange(struct soap *soap, tt__DurationRange * *d, tt__DurationRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DurationRange **)soap_malloc(soap, sizeof(tt__DurationRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DurationRange(tt__DurationRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DurationRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, tt__ImageStabilizationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, tt__ImageStabilizationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationOptionsExtension *)soap_instantiate_tt__ImageStabilizationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension * *d, tt__ImageStabilizationOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImageStabilizationOptionsExtension(tt__ImageStabilizationOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImageStabilizationOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension4))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension4 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension4, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension4 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension4(struct soap *soap, const char *tag, tt__ImagingOptions20Extension4 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension4 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension4 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension4 *)soap_instantiate_tt__ImagingOptions20Extension4(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension4 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension4 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 * *d, tt__ImagingOptions20Extension4 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingOptions20Extension4 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension4 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingOptions20Extension4(tt__ImagingOptions20Extension4 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingOptions20Extension4);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReductionOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, int id, tt__NoiseReductionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReductionOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NoiseReductionOptions ? type : NULL);
}

SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_in_PointerTott__NoiseReductionOptions(struct soap *soap, const char *tag, tt__NoiseReductionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NoiseReductionOptions **)soap_malloc(soap, sizeof(tt__NoiseReductionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NoiseReductionOptions *)soap_instantiate_tt__NoiseReductionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NoiseReductionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReductionOptions * * SOAP_FMAC2 soap_dup_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions * *d, tt__NoiseReductionOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NoiseReductionOptions **)soap_malloc(soap, sizeof(tt__NoiseReductionOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NoiseReductionOptions(tt__NoiseReductionOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NoiseReductionOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NoiseReductionOptions ** SOAP_FMAC4 soap_get_PointerTott__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, int id, tt__DefoggingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DefoggingOptions ? type : NULL);
}

SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_in_PointerTott__DefoggingOptions(struct soap *soap, const char *tag, tt__DefoggingOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DefoggingOptions **)soap_malloc(soap, sizeof(tt__DefoggingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DefoggingOptions *)soap_instantiate_tt__DefoggingOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DefoggingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingOptions * * SOAP_FMAC2 soap_dup_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions * *d, tt__DefoggingOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DefoggingOptions **)soap_malloc(soap, sizeof(tt__DefoggingOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DefoggingOptions(tt__DefoggingOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DefoggingOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DefoggingOptions ** SOAP_FMAC4 soap_get_PointerTott__DefoggingOptions(struct soap *soap, tt__DefoggingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, int id, tt__ToneCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensationOptions ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationOptions(struct soap *soap, const char *tag, tt__ToneCompensationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensationOptions **)soap_malloc(soap, sizeof(tt__ToneCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensationOptions *)soap_instantiate_tt__ToneCompensationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationOptions * * SOAP_FMAC2 soap_dup_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions * *d, tt__ToneCompensationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ToneCompensationOptions **)soap_malloc(soap, sizeof(tt__ToneCompensationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ToneCompensationOptions(tt__ToneCompensationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ToneCompensationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension3))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension3 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension3, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension3 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension3(struct soap *soap, const char *tag, tt__ImagingOptions20Extension3 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension3 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension3 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension3 *)soap_instantiate_tt__ImagingOptions20Extension3(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension3 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension3 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 * *d, tt__ImagingOptions20Extension3 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingOptions20Extension3 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension3 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingOptions20Extension3(tt__ImagingOptions20Extension3 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingOptions20Extension3);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentOptions **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentOptions *)soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * * SOAP_FMAC2 soap_dup_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions * *d, tt__IrCutFilterAutoAdjustmentOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IrCutFilterAutoAdjustmentOptions **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IrCutFilterAutoAdjustmentOptions(tt__IrCutFilterAutoAdjustmentOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IrCutFilterAutoAdjustmentOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension2 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, tt__ImagingOptions20Extension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension2 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension2 *)soap_instantiate_tt__ImagingOptions20Extension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension2 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 * *d, tt__ImagingOptions20Extension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingOptions20Extension2 **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingOptions20Extension2(tt__ImagingOptions20Extension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingOptions20Extension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, tt__ImageStabilizationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationOptions ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, tt__ImageStabilizationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationOptions **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationOptions *)soap_instantiate_tt__ImageStabilizationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptions * * SOAP_FMAC2 soap_dup_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions * *d, tt__ImageStabilizationOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImageStabilizationOptions **)soap_malloc(soap, sizeof(tt__ImageStabilizationOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImageStabilizationOptions(tt__ImageStabilizationOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImageStabilizationOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, tt__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingOptions20Extension ? type : NULL);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20Extension *)soap_instantiate_tt__ImagingOptions20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension * * SOAP_FMAC2 soap_dup_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension * *d, tt__ImagingOptions20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(tt__ImagingOptions20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingOptions20Extension(tt__ImagingOptions20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingOptions20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, tt__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalanceOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalanceOptions20 *)soap_instantiate_tt__WhiteBalanceOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 * *d, tt__WhiteBalanceOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(tt__WhiteBalanceOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WhiteBalanceOptions20(tt__WhiteBalanceOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WhiteBalanceOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, tt__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WideDynamicRangeOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(tt__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRangeOptions20 *)soap_instantiate_tt__WideDynamicRangeOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 * *d, tt__WideDynamicRangeOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(tt__WideDynamicRangeOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WideDynamicRangeOptions20(tt__WideDynamicRangeOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WideDynamicRangeOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap *soap, const char *tag, int id, tt__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusOptions20 **)soap_malloc(soap, sizeof(tt__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusOptions20 *)soap_instantiate_tt__FocusOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 * *d, tt__FocusOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusOptions20 **)soap_malloc(soap, sizeof(tt__FocusOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusOptions20(tt__FocusOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap *soap, tt__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, int id, tt__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ExposureOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ExposureOptions20 **)soap_malloc(soap, sizeof(tt__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ExposureOptions20 *)soap_instantiate_tt__ExposureOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposureOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 * *d, tt__ExposureOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ExposureOptions20 **)soap_malloc(soap, sizeof(tt__ExposureOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ExposureOptions20(tt__ExposureOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ExposureOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, tt__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BacklightCompensationOptions20 ? type : NULL);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(tt__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensationOptions20 *)soap_instantiate_tt__BacklightCompensationOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * * SOAP_FMAC2 soap_dup_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 * *d, tt__BacklightCompensationOptions20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(tt__BacklightCompensationOptions20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__BacklightCompensationOptions20(tt__BacklightCompensationOptions20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__BacklightCompensationOptions20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DefoggingExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, int id, tt__DefoggingExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DefoggingExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DefoggingExtension ? type : NULL);
}

SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_in_PointerTott__DefoggingExtension(struct soap *soap, const char *tag, tt__DefoggingExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DefoggingExtension **)soap_malloc(soap, sizeof(tt__DefoggingExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DefoggingExtension *)soap_instantiate_tt__DefoggingExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DefoggingExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingExtension * * SOAP_FMAC2 soap_dup_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension * *d, tt__DefoggingExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DefoggingExtension **)soap_malloc(soap, sizeof(tt__DefoggingExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DefoggingExtension(tt__DefoggingExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DefoggingExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DefoggingExtension ** SOAP_FMAC4 soap_get_PointerTott__DefoggingExtension(struct soap *soap, tt__DefoggingExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, int id, tt__ToneCompensationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensationExtension ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensationExtension(struct soap *soap, const char *tag, tt__ToneCompensationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensationExtension **)soap_malloc(soap, sizeof(tt__ToneCompensationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensationExtension *)soap_instantiate_tt__ToneCompensationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationExtension * * SOAP_FMAC2 soap_dup_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension * *d, tt__ToneCompensationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ToneCompensationExtension **)soap_malloc(soap, sizeof(tt__ToneCompensationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ToneCompensationExtension(tt__ToneCompensationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ToneCompensationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensationExtension ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, tt__ExposurePriority *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, tt__ExposurePriority **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ExposurePriority **)soap_malloc(soap, sizeof(tt__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(tt__ExposurePriority), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposurePriority * * SOAP_FMAC2 soap_dup_PointerTott__ExposurePriority(struct soap *soap, tt__ExposurePriority * *d, tt__ExposurePriority *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ExposurePriority **)soap_malloc(soap, sizeof(tt__ExposurePriority *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__ExposurePriority *)soap_malloc(soap, sizeof(tt__ExposurePriority))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ExposurePriority(tt__ExposurePriority *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ExposurePriority(soap, tag ? tag : "tt:ExposurePriority", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustmentExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustmentExtension *)soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * * SOAP_FMAC2 soap_dup_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension * *d, tt__IrCutFilterAutoAdjustmentExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IrCutFilterAutoAdjustmentExtension **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustmentExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IrCutFilterAutoAdjustmentExtension(tt__IrCutFilterAutoAdjustmentExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IrCutFilterAutoAdjustmentExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, tt__ImageStabilizationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilizationExtension ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, tt__ImageStabilizationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilizationExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilizationExtension *)soap_instantiate_tt__ImageStabilizationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilizationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationExtension * * SOAP_FMAC2 soap_dup_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension * *d, tt__ImageStabilizationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImageStabilizationExtension **)soap_malloc(soap, sizeof(tt__ImageStabilizationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImageStabilizationExtension(tt__ImageStabilizationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImageStabilizationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension204))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension204 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension204, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension204 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension204(struct soap *soap, const char *tag, tt__ImagingSettingsExtension204 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension204 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension204 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension204 *)soap_instantiate_tt__ImagingSettingsExtension204(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension204 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension204 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 * *d, tt__ImagingSettingsExtension204 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettingsExtension204 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension204 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettingsExtension204(tt__ImagingSettingsExtension204 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettingsExtension204);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NoiseReduction))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NoiseReduction(struct soap *soap, const char *tag, int id, tt__NoiseReduction *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NoiseReduction, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NoiseReduction ? type : NULL);
}

SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_in_PointerTott__NoiseReduction(struct soap *soap, const char *tag, tt__NoiseReduction **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NoiseReduction **)soap_malloc(soap, sizeof(tt__NoiseReduction *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NoiseReduction *)soap_instantiate_tt__NoiseReduction(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NoiseReduction **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReduction * * SOAP_FMAC2 soap_dup_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction * *d, tt__NoiseReduction *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NoiseReduction **)soap_malloc(soap, sizeof(tt__NoiseReduction *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NoiseReduction(tt__NoiseReduction *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NoiseReduction);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NoiseReduction ** SOAP_FMAC4 soap_get_PointerTott__NoiseReduction(struct soap *soap, tt__NoiseReduction **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Defogging(struct soap *soap, tt__Defogging *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Defogging))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Defogging(struct soap *soap, const char *tag, int id, tt__Defogging *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Defogging, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Defogging ? type : NULL);
}

SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_in_PointerTott__Defogging(struct soap *soap, const char *tag, tt__Defogging **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Defogging **)soap_malloc(soap, sizeof(tt__Defogging *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Defogging *)soap_instantiate_tt__Defogging(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Defogging **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Defogging * * SOAP_FMAC2 soap_dup_PointerTott__Defogging(struct soap *soap, tt__Defogging * *d, tt__Defogging *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Defogging **)soap_malloc(soap, sizeof(tt__Defogging *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Defogging(tt__Defogging *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Defogging);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Defogging(struct soap *soap, tt__Defogging *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Defogging(soap, tag ? tag : "tt:Defogging", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Defogging ** SOAP_FMAC4 soap_get_PointerTott__Defogging(struct soap *soap, tt__Defogging **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ToneCompensation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ToneCompensation(struct soap *soap, const char *tag, int id, tt__ToneCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ToneCompensation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ToneCompensation ? type : NULL);
}

SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_in_PointerTott__ToneCompensation(struct soap *soap, const char *tag, tt__ToneCompensation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ToneCompensation **)soap_malloc(soap, sizeof(tt__ToneCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ToneCompensation *)soap_instantiate_tt__ToneCompensation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ToneCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensation * * SOAP_FMAC2 soap_dup_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation * *d, tt__ToneCompensation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ToneCompensation **)soap_malloc(soap, sizeof(tt__ToneCompensation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ToneCompensation(tt__ToneCompensation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ToneCompensation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ToneCompensation ** SOAP_FMAC4 soap_get_PointerTott__ToneCompensation(struct soap *soap, tt__ToneCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension203))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension203 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension203, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension203 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension203(struct soap *soap, const char *tag, tt__ImagingSettingsExtension203 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension203 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension203 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension203 *)soap_instantiate_tt__ImagingSettingsExtension203(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension203 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension203 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 * *d, tt__ImagingSettingsExtension203 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettingsExtension203 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension203 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettingsExtension203(tt__ImagingSettingsExtension203 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettingsExtension203);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, tt__IrCutFilterAutoAdjustment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IrCutFilterAutoAdjustment ? type : NULL);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustment **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterAutoAdjustment **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IrCutFilterAutoAdjustment *)soap_instantiate_tt__IrCutFilterAutoAdjustment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * * SOAP_FMAC2 soap_dup_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment * *d, tt__IrCutFilterAutoAdjustment *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IrCutFilterAutoAdjustment **)soap_malloc(soap, sizeof(tt__IrCutFilterAutoAdjustment *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IrCutFilterAutoAdjustment(tt__IrCutFilterAutoAdjustment *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IrCutFilterAutoAdjustment);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension202))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension202 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension202, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension202 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, tt__ImagingSettingsExtension202 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension202 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension202 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension202 *)soap_instantiate_tt__ImagingSettingsExtension202(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension202 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension202 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 * *d, tt__ImagingSettingsExtension202 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettingsExtension202 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension202 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettingsExtension202(tt__ImagingSettingsExtension202 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettingsExtension202);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilization))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilization(struct soap *soap, const char *tag, int id, tt__ImageStabilization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilization, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImageStabilization ? type : NULL);
}

SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilization(struct soap *soap, const char *tag, tt__ImageStabilization **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImageStabilization **)soap_malloc(soap, sizeof(tt__ImageStabilization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImageStabilization *)soap_instantiate_tt__ImageStabilization(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImageStabilization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilization * * SOAP_FMAC2 soap_dup_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization * *d, tt__ImageStabilization *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImageStabilization **)soap_malloc(soap, sizeof(tt__ImageStabilization *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImageStabilization(tt__ImageStabilization *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImageStabilization);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImageStabilization ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilization(struct soap *soap, tt__ImageStabilization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension20 *)soap_instantiate_tt__ImagingSettingsExtension20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 * *d, tt__ImagingSettingsExtension20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettingsExtension20(tt__ImagingSettingsExtension20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettingsExtension20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalance20 ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance20 **)soap_malloc(soap, sizeof(tt__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance20 *)soap_instantiate_tt__WhiteBalance20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20 * * SOAP_FMAC2 soap_dup_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 * *d, tt__WhiteBalance20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WhiteBalance20 **)soap_malloc(soap, sizeof(tt__WhiteBalance20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WhiteBalance20(tt__WhiteBalance20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WhiteBalance20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WideDynamicRange20 ? type : NULL);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(tt__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRange20 *)soap_instantiate_tt__WideDynamicRange20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange20 * * SOAP_FMAC2 soap_dup_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 * *d, tt__WideDynamicRange20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(tt__WideDynamicRange20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WideDynamicRange20(tt__WideDynamicRange20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WideDynamicRange20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusConfiguration20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(tt__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration20 *)soap_instantiate_tt__FocusConfiguration20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20 * * SOAP_FMAC2 soap_dup_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 * *d, tt__FocusConfiguration20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(tt__FocusConfiguration20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusConfiguration20(tt__FocusConfiguration20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusConfiguration20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Exposure20 ? type : NULL);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Exposure20 **)soap_malloc(soap, sizeof(tt__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Exposure20 *)soap_instantiate_tt__Exposure20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure20 * * SOAP_FMAC2 soap_dup_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 * *d, tt__Exposure20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Exposure20 **)soap_malloc(soap, sizeof(tt__Exposure20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Exposure20(tt__Exposure20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Exposure20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BacklightCompensation20 ? type : NULL);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(tt__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensation20 *)soap_instantiate_tt__BacklightCompensation20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation20 * * SOAP_FMAC2 soap_dup_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 * *d, tt__BacklightCompensation20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(tt__BacklightCompensation20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__BacklightCompensation20(tt__BacklightCompensation20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__BacklightCompensation20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, int id, tt__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusStatus20Extension ? type : NULL);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(tt__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20Extension *)soap_instantiate_tt__FocusStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20Extension * * SOAP_FMAC2 soap_dup_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension * *d, tt__FocusStatus20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(tt__FocusStatus20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusStatus20Extension(tt__FocusStatus20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusStatus20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, tt__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingStatus20Extension ? type : NULL);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(tt__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20Extension *)soap_instantiate_tt__ImagingStatus20Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20Extension * * SOAP_FMAC2 soap_dup_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension * *d, tt__ImagingStatus20Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(tt__ImagingStatus20Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingStatus20Extension(tt__ImagingStatus20Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingStatus20Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap *soap, const char *tag, int id, tt__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusStatus20 ? type : NULL);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusStatus20 **)soap_malloc(soap, sizeof(tt__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusStatus20 *)soap_instantiate_tt__FocusStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20 * * SOAP_FMAC2 soap_dup_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 * *d, tt__FocusStatus20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusStatus20 **)soap_malloc(soap, sizeof(tt__FocusStatus20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusStatus20(tt__FocusStatus20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusStatus20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap *soap, tt__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, int id, tt__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ContinuousFocus ? type : NULL);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ContinuousFocus **)soap_malloc(soap, sizeof(tt__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ContinuousFocus *)soap_instantiate_tt__ContinuousFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocus * * SOAP_FMAC2 soap_dup_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus * *d, tt__ContinuousFocus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ContinuousFocus **)soap_malloc(soap, sizeof(tt__ContinuousFocus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ContinuousFocus(tt__ContinuousFocus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ContinuousFocus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap *soap, tt__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap *soap, const char *tag, int id, tt__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelativeFocus ? type : NULL);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelativeFocus **)soap_malloc(soap, sizeof(tt__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelativeFocus *)soap_instantiate_tt__RelativeFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocus * * SOAP_FMAC2 soap_dup_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus * *d, tt__RelativeFocus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RelativeFocus **)soap_malloc(soap, sizeof(tt__RelativeFocus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RelativeFocus(tt__RelativeFocus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RelativeFocus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap *soap, tt__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, int id, tt__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AbsoluteFocus ? type : NULL);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AbsoluteFocus **)soap_malloc(soap, sizeof(tt__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AbsoluteFocus *)soap_instantiate_tt__AbsoluteFocus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocus * * SOAP_FMAC2 soap_dup_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus * *d, tt__AbsoluteFocus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AbsoluteFocus **)soap_malloc(soap, sizeof(tt__AbsoluteFocus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AbsoluteFocus(tt__AbsoluteFocus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AbsoluteFocus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Rectangle ? type : NULL);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, tt__Rectangle **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rectangle **)soap_malloc(soap, sizeof(tt__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rectangle *)soap_instantiate_tt__Rectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rectangle * * SOAP_FMAC2 soap_dup_PointerTott__Rectangle(struct soap *soap, tt__Rectangle * *d, tt__Rectangle *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Rectangle **)soap_malloc(soap, sizeof(tt__Rectangle *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Rectangle(tt__Rectangle *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Rectangle);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, tt__Rectangle *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, tt__ImagingSettingsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettingsExtension ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, tt__ImagingSettingsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettingsExtension **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettingsExtension *)soap_instantiate_tt__ImagingSettingsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension * *d, tt__ImagingSettingsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettingsExtension **)soap_malloc(soap, sizeof(tt__ImagingSettingsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettingsExtension(tt__ImagingSettingsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettingsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, tag ? tag : "tt:ImagingSettingsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance(struct soap *soap, const char *tag, int id, tt__WhiteBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WhiteBalance ? type : NULL);
}

SOAP_FMAC3 tt__WhiteBalance ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance(struct soap *soap, const char *tag, tt__WhiteBalance **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WhiteBalance **)soap_malloc(soap, sizeof(tt__WhiteBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WhiteBalance *)soap_instantiate_tt__WhiteBalance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance * * SOAP_FMAC2 soap_dup_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance * *d, tt__WhiteBalance *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WhiteBalance **)soap_malloc(soap, sizeof(tt__WhiteBalance *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WhiteBalance(tt__WhiteBalance *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WhiteBalance);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WhiteBalance(soap, tag ? tag : "tt:WhiteBalance", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WhiteBalance ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance(struct soap *soap, tt__WhiteBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, int id, tt__WideDynamicRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__WideDynamicRange ? type : NULL);
}

SOAP_FMAC3 tt__WideDynamicRange ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, tt__WideDynamicRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__WideDynamicRange **)soap_malloc(soap, sizeof(tt__WideDynamicRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__WideDynamicRange *)soap_instantiate_tt__WideDynamicRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange * * SOAP_FMAC2 soap_dup_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange * *d, tt__WideDynamicRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__WideDynamicRange **)soap_malloc(soap, sizeof(tt__WideDynamicRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__WideDynamicRange(tt__WideDynamicRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__WideDynamicRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__WideDynamicRange(soap, tag ? tag : "tt:WideDynamicRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__WideDynamicRange ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange(struct soap *soap, tt__WideDynamicRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, tt__IrCutFilterMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, tt__IrCutFilterMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IrCutFilterMode **)soap_malloc(soap, sizeof(tt__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(tt__IrCutFilterMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterMode * * SOAP_FMAC2 soap_dup_PointerTott__IrCutFilterMode(struct soap *soap, tt__IrCutFilterMode * *d, tt__IrCutFilterMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IrCutFilterMode **)soap_malloc(soap, sizeof(tt__IrCutFilterMode *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__IrCutFilterMode *)soap_malloc(soap, sizeof(tt__IrCutFilterMode))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IrCutFilterMode(tt__IrCutFilterMode *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag ? tag : "tt:IrCutFilterMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, int id, tt__FocusConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FocusConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__FocusConfiguration ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, tt__FocusConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusConfiguration **)soap_malloc(soap, sizeof(tt__FocusConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusConfiguration *)soap_instantiate_tt__FocusConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration * *d, tt__FocusConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FocusConfiguration **)soap_malloc(soap, sizeof(tt__FocusConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FocusConfiguration(tt__FocusConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FocusConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FocusConfiguration(soap, tag ? tag : "tt:FocusConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusConfiguration ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration(struct soap *soap, tt__FocusConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure(struct soap *soap, tt__Exposure *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure(struct soap *soap, const char *tag, int id, tt__Exposure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Exposure ? type : NULL);
}

SOAP_FMAC3 tt__Exposure ** SOAP_FMAC4 soap_in_PointerTott__Exposure(struct soap *soap, const char *tag, tt__Exposure **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Exposure **)soap_malloc(soap, sizeof(tt__Exposure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Exposure *)soap_instantiate_tt__Exposure(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure * * SOAP_FMAC2 soap_dup_PointerTott__Exposure(struct soap *soap, tt__Exposure * *d, tt__Exposure *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Exposure **)soap_malloc(soap, sizeof(tt__Exposure *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Exposure(tt__Exposure *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Exposure);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure(struct soap *soap, tt__Exposure *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Exposure(soap, tag ? tag : "tt:Exposure", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Exposure ** SOAP_FMAC4 soap_get_PointerTott__Exposure(struct soap *soap, tt__Exposure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, int id, tt__BacklightCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BacklightCompensation ? type : NULL);
}

SOAP_FMAC3 tt__BacklightCompensation ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, tt__BacklightCompensation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BacklightCompensation **)soap_malloc(soap, sizeof(tt__BacklightCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BacklightCompensation *)soap_instantiate_tt__BacklightCompensation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation * * SOAP_FMAC2 soap_dup_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation * *d, tt__BacklightCompensation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__BacklightCompensation **)soap_malloc(soap, sizeof(tt__BacklightCompensation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__BacklightCompensation(tt__BacklightCompensation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__BacklightCompensation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BacklightCompensation(soap, tag ? tag : "tt:BacklightCompensation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BacklightCompensation ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation(struct soap *soap, tt__BacklightCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector1D ? type : NULL);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, tt__Vector1D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector1D **)soap_malloc(soap, sizeof(tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector1D *)soap_instantiate_tt__Vector1D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector1D * * SOAP_FMAC2 soap_dup_PointerTott__Vector1D(struct soap *soap, tt__Vector1D * *d, tt__Vector1D *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Vector1D **)soap_malloc(soap, sizeof(tt__Vector1D *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Vector1D(tt__Vector1D *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Vector1D);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector2D ? type : NULL);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, tt__Vector2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector2D **)soap_malloc(soap, sizeof(tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector2D *)soap_instantiate_tt__Vector2D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector2D * * SOAP_FMAC2 soap_dup_PointerTott__Vector2D(struct soap *soap, tt__Vector2D * *d, tt__Vector2D *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Vector2D **)soap_malloc(soap, sizeof(tt__Vector2D *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Vector2D(tt__Vector2D *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Vector2D);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FloatRange ? type : NULL);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FloatRange **)soap_malloc(soap, sizeof(tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FloatRange *)soap_instantiate_tt__FloatRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatRange * * SOAP_FMAC2 soap_dup_PointerTott__FloatRange(struct soap *soap, tt__FloatRange * *d, tt__FloatRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__FloatRange **)soap_malloc(soap, sizeof(tt__FloatRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__FloatRange(tt__FloatRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__FloatRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space1DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space1DDescription **)soap_malloc(soap, sizeof(tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space1DDescription *)soap_instantiate_tt__Space1DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space1DDescription * * SOAP_FMAC2 soap_dup_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription * *d, tt__Space1DDescription *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Space1DDescription **)soap_malloc(soap, sizeof(tt__Space1DDescription *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Space1DDescription(tt__Space1DDescription *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Space1DDescription);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space2DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space2DDescription **)soap_malloc(soap, sizeof(tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space2DDescription *)soap_instantiate_tt__Space2DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space2DDescription * * SOAP_FMAC2 soap_dup_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription * *d, tt__Space2DDescription *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Space2DDescription **)soap_malloc(soap, sizeof(tt__Space2DDescription *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Space2DDescription(tt__Space2DDescription *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Space2DDescription);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, tt__PTControlDirectionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(tt__PTControlDirectionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirectionExtension *)soap_instantiate_tt__PTControlDirectionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionExtension * * SOAP_FMAC2 soap_dup_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension * *d, tt__PTControlDirectionExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(tt__PTControlDirectionExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTControlDirectionExtension(tt__PTControlDirectionExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTControlDirectionExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Reverse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap *soap, const char *tag, int id, tt__Reverse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Reverse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Reverse ? type : NULL);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap *soap, const char *tag, tt__Reverse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Reverse **)soap_malloc(soap, sizeof(tt__Reverse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Reverse *)soap_instantiate_tt__Reverse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Reverse * * SOAP_FMAC2 soap_dup_PointerTott__Reverse(struct soap *soap, tt__Reverse * *d, tt__Reverse *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Reverse **)soap_malloc(soap, sizeof(tt__Reverse *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Reverse(tt__Reverse *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Reverse);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap *soap, tt__Reverse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlip))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap *soap, const char *tag, int id, tt__EFlip *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlip, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EFlip ? type : NULL);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap *soap, const char *tag, tt__EFlip **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EFlip **)soap_malloc(soap, sizeof(tt__EFlip *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EFlip *)soap_instantiate_tt__EFlip(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlip * * SOAP_FMAC2 soap_dup_PointerTott__EFlip(struct soap *soap, tt__EFlip * *d, tt__EFlip *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EFlip **)soap_malloc(soap, sizeof(tt__EFlip *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EFlip(tt__EFlip *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EFlip);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap *soap, tt__EFlip **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension2 *)soap_instantiate_tt__PTZConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 * *d, tt__PTZConfigurationExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZConfigurationExtension2(tt__PTZConfigurationExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZConfigurationExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap *soap, const char *tag, int id, tt__PTControlDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirection ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirection **)soap_malloc(soap, sizeof(tt__PTControlDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirection *)soap_instantiate_tt__PTControlDirection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirection * * SOAP_FMAC2 soap_dup_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection * *d, tt__PTControlDirection *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTControlDirection **)soap_malloc(soap, sizeof(tt__PTControlDirection *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTControlDirection(tt__PTControlDirection *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTControlDirection);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EapMethodExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, int id, tt__EapMethodExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EapMethodExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EapMethodExtension ? type : NULL);
}

SOAP_FMAC3 tt__EapMethodExtension ** SOAP_FMAC4 soap_in_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, tt__EapMethodExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EapMethodExtension **)soap_malloc(soap, sizeof(tt__EapMethodExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EapMethodExtension *)soap_instantiate_tt__EapMethodExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EapMethodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EapMethodExtension * * SOAP_FMAC2 soap_dup_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension * *d, tt__EapMethodExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EapMethodExtension **)soap_malloc(soap, sizeof(tt__EapMethodExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EapMethodExtension(tt__EapMethodExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EapMethodExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EapMethodExtension ** SOAP_FMAC4 soap_get_PointerTott__EapMethodExtension(struct soap *soap, tt__EapMethodExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TLSConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, int id, tt__TLSConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TLSConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TLSConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__TLSConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, tt__TLSConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TLSConfiguration **)soap_malloc(soap, sizeof(tt__TLSConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TLSConfiguration *)soap_instantiate_tt__TLSConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TLSConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TLSConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration * *d, tt__TLSConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__TLSConfiguration **)soap_malloc(soap, sizeof(tt__TLSConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__TLSConfiguration(tt__TLSConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__TLSConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TLSConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TLSConfiguration(struct soap *soap, tt__TLSConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, tt__Dot1XConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot1XConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, tt__Dot1XConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot1XConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot1XConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot1XConfigurationExtension *)soap_instantiate_tt__Dot1XConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot1XConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension * *d, tt__Dot1XConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot1XConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot1XConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot1XConfigurationExtension(tt__Dot1XConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot1XConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EAPMethodConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, tt__EAPMethodConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EAPMethodConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EAPMethodConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, tt__EAPMethodConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EAPMethodConfiguration **)soap_malloc(soap, sizeof(tt__EAPMethodConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EAPMethodConfiguration *)soap_instantiate_tt__EAPMethodConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EAPMethodConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EAPMethodConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration * *d, tt__EAPMethodConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EAPMethodConfiguration **)soap_malloc(soap, sizeof(tt__EAPMethodConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EAPMethodConfiguration(tt__EAPMethodConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EAPMethodConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, int id, tt__CertificateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__CertificateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, tt__CertificateInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateInformationExtension **)soap_malloc(soap, sizeof(tt__CertificateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateInformationExtension *)soap_instantiate_tt__CertificateInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformationExtension * * SOAP_FMAC2 soap_dup_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension * *d, tt__CertificateInformationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CertificateInformationExtension **)soap_malloc(soap, sizeof(tt__CertificateInformationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CertificateInformationExtension(tt__CertificateInformationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CertificateInformationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTimeRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTimeRange(struct soap *soap, const char *tag, int id, tt__DateTimeRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTimeRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DateTimeRange ? type : NULL);
}

SOAP_FMAC3 tt__DateTimeRange ** SOAP_FMAC4 soap_in_PointerTott__DateTimeRange(struct soap *soap, const char *tag, tt__DateTimeRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DateTimeRange **)soap_malloc(soap, sizeof(tt__DateTimeRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DateTimeRange *)soap_instantiate_tt__DateTimeRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTimeRange * * SOAP_FMAC2 soap_dup_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange * *d, tt__DateTimeRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DateTimeRange **)soap_malloc(soap, sizeof(tt__DateTimeRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DateTimeRange(tt__DateTimeRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DateTimeRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DateTimeRange ** SOAP_FMAC4 soap_get_PointerTott__DateTimeRange(struct soap *soap, tt__DateTimeRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateUsage))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateUsage(struct soap *soap, const char *tag, int id, tt__CertificateUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateUsage, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateUsage ? type : NULL);
}

SOAP_FMAC3 tt__CertificateUsage ** SOAP_FMAC4 soap_in_PointerTott__CertificateUsage(struct soap *soap, const char *tag, tt__CertificateUsage **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateUsage **)soap_malloc(soap, sizeof(tt__CertificateUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateUsage *)soap_instantiate_tt__CertificateUsage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateUsage, sizeof(tt__CertificateUsage), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateUsage * * SOAP_FMAC2 soap_dup_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage * *d, tt__CertificateUsage *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CertificateUsage **)soap_malloc(soap, sizeof(tt__CertificateUsage *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CertificateUsage(tt__CertificateUsage *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CertificateUsage);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateUsage ** SOAP_FMAC4 soap_get_PointerTott__CertificateUsage(struct soap *soap, tt__CertificateUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__UserExtension ? type : NULL);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, tt__UserExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__UserExtension **)soap_malloc(soap, sizeof(tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__UserExtension *)soap_instantiate_tt__UserExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__UserExtension * * SOAP_FMAC2 soap_dup_PointerTott__UserExtension(struct soap *soap, tt__UserExtension * *d, tt__UserExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__UserExtension **)soap_malloc(soap, sizeof(tt__UserExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__UserExtension(tt__UserExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__UserExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, tt__UserExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, tt__Date *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Date ? type : NULL);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, tt__Date **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Date **)soap_malloc(soap, sizeof(tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Date *)soap_instantiate_tt__Date(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Date * * SOAP_FMAC2 soap_dup_PointerTott__Date(struct soap *soap, tt__Date * *d, tt__Date *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Date **)soap_malloc(soap, sizeof(tt__Date *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Date(tt__Date *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Date);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, tt__Date *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Date(soap, tag ? tag : "tt:Date", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, tt__Time *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Time ? type : NULL);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, tt__Time **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Time **)soap_malloc(soap, sizeof(tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Time *)soap_instantiate_tt__Time(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Time * * SOAP_FMAC2 soap_dup_PointerTott__Time(struct soap *soap, tt__Time * *d, tt__Time *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Time **)soap_malloc(soap, sizeof(tt__Time *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Time(tt__Time *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Time);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, tt__Time *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Time(soap, tag ? tag : "tt:Time", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemDateTimeExtension ? type : NULL);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemDateTimeExtension *)soap_instantiate_tt__SystemDateTimeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTimeExtension * * SOAP_FMAC2 soap_dup_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension * *d, tt__SystemDateTimeExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(tt__SystemDateTimeExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemDateTimeExtension(tt__SystemDateTimeExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemDateTimeExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, tt__SystemLogUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUri, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLogUri ? type : NULL);
}

SOAP_FMAC3 tt__SystemLogUri ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUri(struct soap *soap, const char *tag, tt__SystemLogUri **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLogUri **)soap_malloc(soap, sizeof(tt__SystemLogUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLogUri *)soap_instantiate_tt__SystemLogUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLogUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUri * * SOAP_FMAC2 soap_dup_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri * *d, tt__SystemLogUri *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemLogUri **)soap_malloc(soap, sizeof(tt__SystemLogUri *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemLogUri(tt__SystemLogUri *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemLogUri);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLogUri ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUri(struct soap *soap, tt__SystemLogUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceExtension ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceExtension **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceExtension *)soap_instantiate_tt__AnalyticsDeviceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceExtension * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension * *d, tt__AnalyticsDeviceExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsDeviceExtension **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsDeviceExtension(tt__AnalyticsDeviceExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsDeviceExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__SystemCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilitiesExtension2 *)soap_instantiate_tt__SystemCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 * *d, tt__SystemCapabilitiesExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemCapabilitiesExtension2(tt__SystemCapabilitiesExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemCapabilitiesExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilitiesExtension *)soap_instantiate_tt__SystemCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension * *d, tt__SystemCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SystemCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemCapabilitiesExtension(tt__SystemCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__SecurityCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilitiesExtension2 *)soap_instantiate_tt__SecurityCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 * *d, tt__SecurityCapabilitiesExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SecurityCapabilitiesExtension2(tt__SecurityCapabilitiesExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SecurityCapabilitiesExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilitiesExtension *)soap_instantiate_tt__SecurityCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension * *d, tt__SecurityCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__SecurityCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SecurityCapabilitiesExtension(tt__SecurityCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SecurityCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__NetworkCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilitiesExtension2 *)soap_instantiate_tt__NetworkCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 * *d, tt__NetworkCapabilitiesExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkCapabilitiesExtension2(tt__NetworkCapabilitiesExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkCapabilitiesExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilitiesExtension *)soap_instantiate_tt__NetworkCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension * *d, tt__NetworkCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__NetworkCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkCapabilitiesExtension(tt__NetworkCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilitiesExtension *)soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension * *d, tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RealTimeStreamingCapabilitiesExtension(tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RealTimeStreamingCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ProfileCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileCapabilities **)soap_malloc(soap, sizeof(tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileCapabilities *)soap_instantiate_tt__ProfileCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities * *d, tt__ProfileCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ProfileCapabilities **)soap_malloc(soap, sizeof(tt__ProfileCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ProfileCapabilities(tt__ProfileCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ProfileCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilitiesExtension *)soap_instantiate_tt__MediaCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension * *d, tt__MediaCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__MediaCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MediaCapabilitiesExtension(tt__MediaCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MediaCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RealTimeStreamingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RealTimeStreamingCapabilities *)soap_instantiate_tt__RealTimeStreamingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities * *d, tt__RealTimeStreamingCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(tt__RealTimeStreamingCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RealTimeStreamingCapabilities(tt__RealTimeStreamingCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RealTimeStreamingCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__IOCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilitiesExtension2 *)soap_instantiate_tt__IOCapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 * *d, tt__IOCapabilitiesExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IOCapabilitiesExtension2(tt__IOCapabilitiesExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IOCapabilitiesExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilitiesExtension *)soap_instantiate_tt__IOCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension * *d, tt__IOCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__IOCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IOCapabilitiesExtension(tt__IOCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IOCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceCapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilitiesExtension *)soap_instantiate_tt__DeviceCapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension * *d, tt__DeviceCapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(tt__DeviceCapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceCapabilitiesExtension(tt__DeviceCapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceCapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SecurityCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SecurityCapabilities **)soap_malloc(soap, sizeof(tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SecurityCapabilities *)soap_instantiate_tt__SecurityCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities * *d, tt__SecurityCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SecurityCapabilities **)soap_malloc(soap, sizeof(tt__SecurityCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SecurityCapabilities(tt__SecurityCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SecurityCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IOCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IOCapabilities **)soap_malloc(soap, sizeof(tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IOCapabilities *)soap_instantiate_tt__IOCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities * *d, tt__IOCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IOCapabilities **)soap_malloc(soap, sizeof(tt__IOCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IOCapabilities(tt__IOCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IOCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemCapabilities **)soap_malloc(soap, sizeof(tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemCapabilities *)soap_instantiate_tt__SystemCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities * *d, tt__SystemCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemCapabilities **)soap_malloc(soap, sizeof(tt__SystemCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemCapabilities(tt__SystemCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkCapabilities **)soap_malloc(soap, sizeof(tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkCapabilities *)soap_instantiate_tt__NetworkCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities * *d, tt__NetworkCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkCapabilities **)soap_malloc(soap, sizeof(tt__NetworkCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkCapabilities(tt__NetworkCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, tt__CapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CapabilitiesExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, tt__CapabilitiesExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CapabilitiesExtension2 *)soap_instantiate_tt__CapabilitiesExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 * *d, tt__CapabilitiesExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CapabilitiesExtension2(tt__CapabilitiesExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CapabilitiesExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsDeviceCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, tt__AnalyticsDeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceCapabilities *)soap_instantiate_tt__AnalyticsDeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsDeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities * *d, tt__AnalyticsDeviceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsDeviceCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsDeviceCapabilities(tt__AnalyticsDeviceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsDeviceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, int id, tt__ReceiverCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReceiverCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ReceiverCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, tt__ReceiverCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(tt__ReceiverCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReceiverCapabilities *)soap_instantiate_tt__ReceiverCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities * *d, tt__ReceiverCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(tt__ReceiverCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ReceiverCapabilities(tt__ReceiverCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ReceiverCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReceiverCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, int id, tt__ReplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReplayCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ReplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, tt__ReplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReplayCapabilities **)soap_malloc(soap, sizeof(tt__ReplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReplayCapabilities *)soap_instantiate_tt__ReplayCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReplayCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities * *d, tt__ReplayCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ReplayCapabilities **)soap_malloc(soap, sizeof(tt__ReplayCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ReplayCapabilities(tt__ReplayCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ReplayCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, int id, tt__SearchCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SearchCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__SearchCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, tt__SearchCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SearchCapabilities **)soap_malloc(soap, sizeof(tt__SearchCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SearchCapabilities *)soap_instantiate_tt__SearchCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities * *d, tt__SearchCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SearchCapabilities **)soap_malloc(soap, sizeof(tt__SearchCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SearchCapabilities(tt__SearchCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SearchCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SearchCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SearchCapabilities(struct soap *soap, tt__SearchCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, int id, tt__RecordingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RecordingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__RecordingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, tt__RecordingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingCapabilities **)soap_malloc(soap, sizeof(tt__RecordingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingCapabilities *)soap_instantiate_tt__RecordingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities * *d, tt__RecordingCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RecordingCapabilities **)soap_malloc(soap, sizeof(tt__RecordingCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RecordingCapabilities(tt__RecordingCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RecordingCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DisplayCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, int id, tt__DisplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DisplayCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DisplayCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DisplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, tt__DisplayCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DisplayCapabilities **)soap_malloc(soap, sizeof(tt__DisplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DisplayCapabilities *)soap_instantiate_tt__DisplayCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DisplayCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities * *d, tt__DisplayCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DisplayCapabilities **)soap_malloc(soap, sizeof(tt__DisplayCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DisplayCapabilities(tt__DisplayCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DisplayCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DisplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceIOCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceIOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceIOCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceIOCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, tt__DeviceIOCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(tt__DeviceIOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceIOCapabilities *)soap_instantiate_tt__DeviceIOCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceIOCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities * *d, tt__DeviceIOCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(tt__DeviceIOCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceIOCapabilities(tt__DeviceIOCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceIOCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CapabilitiesExtension ? type : NULL);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CapabilitiesExtension *)soap_instantiate_tt__CapabilitiesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension * * SOAP_FMAC2 soap_dup_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension * *d, tt__CapabilitiesExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(tt__CapabilitiesExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CapabilitiesExtension(tt__CapabilitiesExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CapabilitiesExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZCapabilities **)soap_malloc(soap, sizeof(tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZCapabilities *)soap_instantiate_tt__PTZCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities * *d, tt__PTZCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZCapabilities **)soap_malloc(soap, sizeof(tt__PTZCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZCapabilities(tt__PTZCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MediaCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaCapabilities **)soap_malloc(soap, sizeof(tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaCapabilities *)soap_instantiate_tt__MediaCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities * *d, tt__MediaCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MediaCapabilities **)soap_malloc(soap, sizeof(tt__MediaCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MediaCapabilities(tt__MediaCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MediaCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingCapabilities *)soap_instantiate_tt__ImagingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities * *d, tt__ImagingCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingCapabilities(tt__ImagingCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventCapabilities *)soap_instantiate_tt__EventCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities * *d, tt__EventCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EventCapabilities(tt__EventCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EventCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilities *)soap_instantiate_tt__DeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities * *d, tt__DeviceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceCapabilities(tt__DeviceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsCapabilities *)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities * *d, tt__AnalyticsCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsCapabilities(tt__AnalyticsCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
