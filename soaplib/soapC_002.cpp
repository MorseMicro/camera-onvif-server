/* soapC_nnn.cpp
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.127 2023-11-30 23:29:18 GMT")


void tt__RTSPStream::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RTSPServerType(soap, &this->tt__RTSPStream::Type);
	soap_default_std__string(soap, &this->tt__RTSPStream::Path);
	soap_default_xsd__integer(soap, &this->tt__RTSPStream::Port);
	this->tt__RTSPStream::Executable = NULL;
	this->tt__RTSPStream::API = NULL;
}

void tt__RTSPStream::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RTSPStream::Path, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RTSPStream::Path);
	soap_embedded(soap, &this->tt__RTSPStream::Port, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->tt__RTSPStream::Port);
	soap_serialize_PointerTott__RTSPServerExecutable(soap, &this->tt__RTSPStream::Executable);
	soap_serialize_PointerTott__RTSPServerAPI(soap, &this->tt__RTSPStream::API);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RTSPStream::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RTSPStream(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RTSPStream(struct soap *soap, const char *tag, int id, const tt__RTSPStream *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RTSPStream), type ? type : "tt:RTSPStream"))
		return soap->error;
	if (soap_out_tt__RTSPServerType(soap, "tt:Type", -1, &a->tt__RTSPStream::Type, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Path", -1, &a->tt__RTSPStream::Path, ""))
		return soap->error;
	if (soap_out_xsd__integer(soap, "tt:Port", -1, &a->tt__RTSPStream::Port, ""))
		return soap->error;
	if (soap_out_PointerTott__RTSPServerExecutable(soap, "tt:Executable", -1, &a->tt__RTSPStream::Executable, ""))
		return soap->error;
	if (soap_out_PointerTott__RTSPServerAPI(soap, "tt:API", -1, &a->tt__RTSPStream::API, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RTSPStream::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RTSPStream(soap, tag, this, type);
}

SOAP_FMAC3 tt__RTSPStream * SOAP_FMAC4 soap_in_tt__RTSPStream(struct soap *soap, const char *tag, tt__RTSPStream *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RTSPStream*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RTSPStream, sizeof(tt__RTSPStream), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RTSPStream)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RTSPStream *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Path1 = 1;
	size_t soap_flag_Port1 = 1;
	size_t soap_flag_Executable1 = 1;
	size_t soap_flag_API1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RTSPServerType(soap, "tt:Type", &a->tt__RTSPStream::Type, "tt:RTSPServerType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Path", &a->tt__RTSPStream::Path, "xsd:string"))
				{	soap_flag_Path1--;
					continue;
				}
			}
			if (soap_flag_Port1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "tt:Port", &a->tt__RTSPStream::Port, "xsd:integer"))
				{	soap_flag_Port1--;
					continue;
				}
			}
			if (soap_flag_Executable1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RTSPServerExecutable(soap, "tt:Executable", &a->tt__RTSPStream::Executable, "tt:RTSPServerExecutable"))
				{	soap_flag_Executable1--;
					continue;
				}
			}
			if (soap_flag_API1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RTSPServerAPI(soap, "tt:API", &a->tt__RTSPStream::API, "tt:RTSPServerAPI"))
				{	soap_flag_API1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0 || soap_flag_Path1 > 0 || soap_flag_Port1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RTSPStream *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RTSPStream, SOAP_TYPE_tt__RTSPStream, sizeof(tt__RTSPStream), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RTSPStream * SOAP_FMAC2 soap_dup_tt__RTSPStream(struct soap *soap, tt__RTSPStream *d, tt__RTSPStream const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RTSPStream*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RTSPStream, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RTSPStream(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__RTSPStream::Type = a->tt__RTSPStream::Type;
	soap_dup_std__string(soap, &d->tt__RTSPStream::Path, &a->tt__RTSPStream::Path);
	soap_dup_xsd__integer(soap, &d->tt__RTSPStream::Port, &a->tt__RTSPStream::Port);
	soap_dup_PointerTott__RTSPServerExecutable(soap, &d->tt__RTSPStream::Executable, &a->tt__RTSPStream::Executable);
	soap_dup_PointerTott__RTSPServerAPI(soap, &d->tt__RTSPStream::API, &a->tt__RTSPStream::API);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RTSPStream(tt__RTSPStream const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_std__string(&a->tt__RTSPStream::Path);
	soap_del_xsd__integer(&a->tt__RTSPStream::Port);
	soap_del_PointerTott__RTSPServerExecutable(&a->tt__RTSPStream::Executable);
	soap_del_PointerTott__RTSPServerAPI(&a->tt__RTSPStream::API);
}

SOAP_FMAC1 tt__RTSPStream * SOAP_FMAC2 soap_instantiate_tt__RTSPStream(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RTSPStream(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RTSPStream *p;
	size_t k = sizeof(tt__RTSPStream);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RTSPStream, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RTSPStream);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RTSPStream, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RTSPStream location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RTSPStream::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RTSPStream(soap, tag ? tag : "tt:RTSPStream", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RTSPStream::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RTSPStream(soap, this, tag, type);
}

SOAP_FMAC3 tt__RTSPStream * SOAP_FMAC4 soap_get_tt__RTSPStream(struct soap *soap, tt__RTSPStream *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RTSPStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RTSPServerAPI::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__integer(soap, &this->tt__RTSPServerAPI::Port);
}

void tt__RTSPServerAPI::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RTSPServerAPI::Port, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->tt__RTSPServerAPI::Port);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RTSPServerAPI::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RTSPServerAPI(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RTSPServerAPI(struct soap *soap, const char *tag, int id, const tt__RTSPServerAPI *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RTSPServerAPI), type ? type : "tt:RTSPServerAPI"))
		return soap->error;
	if (soap_out_xsd__integer(soap, "tt:Port", -1, &a->tt__RTSPServerAPI::Port, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RTSPServerAPI::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RTSPServerAPI(soap, tag, this, type);
}

SOAP_FMAC3 tt__RTSPServerAPI * SOAP_FMAC4 soap_in_tt__RTSPServerAPI(struct soap *soap, const char *tag, tt__RTSPServerAPI *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RTSPServerAPI*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RTSPServerAPI, sizeof(tt__RTSPServerAPI), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RTSPServerAPI)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RTSPServerAPI *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Port1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Port1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__integer(soap, "tt:Port", &a->tt__RTSPServerAPI::Port, "xsd:integer"))
				{	soap_flag_Port1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Port1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RTSPServerAPI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RTSPServerAPI, SOAP_TYPE_tt__RTSPServerAPI, sizeof(tt__RTSPServerAPI), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RTSPServerAPI * SOAP_FMAC2 soap_dup_tt__RTSPServerAPI(struct soap *soap, tt__RTSPServerAPI *d, tt__RTSPServerAPI const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RTSPServerAPI*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RTSPServerAPI, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RTSPServerAPI(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__integer(soap, &d->tt__RTSPServerAPI::Port, &a->tt__RTSPServerAPI::Port);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RTSPServerAPI(tt__RTSPServerAPI const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__integer(&a->tt__RTSPServerAPI::Port);
}

SOAP_FMAC1 tt__RTSPServerAPI * SOAP_FMAC2 soap_instantiate_tt__RTSPServerAPI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RTSPServerAPI(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RTSPServerAPI *p;
	size_t k = sizeof(tt__RTSPServerAPI);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RTSPServerAPI, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RTSPServerAPI);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RTSPServerAPI, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RTSPServerAPI location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RTSPServerAPI::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RTSPServerAPI(soap, tag ? tag : "tt:RTSPServerAPI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RTSPServerAPI::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RTSPServerAPI(soap, this, tag, type);
}

SOAP_FMAC3 tt__RTSPServerAPI * SOAP_FMAC4 soap_get_tt__RTSPServerAPI(struct soap *soap, tt__RTSPServerAPI *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RTSPServerAPI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RTSPServerExecutable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__RTSPServerExecutable::Path);
}

void tt__RTSPServerExecutable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RTSPServerExecutable::Path, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RTSPServerExecutable::Path);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RTSPServerExecutable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RTSPServerExecutable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RTSPServerExecutable(struct soap *soap, const char *tag, int id, const tt__RTSPServerExecutable *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RTSPServerExecutable), type ? type : "tt:RTSPServerExecutable"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Path", -1, &a->tt__RTSPServerExecutable::Path, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RTSPServerExecutable::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RTSPServerExecutable(soap, tag, this, type);
}

SOAP_FMAC3 tt__RTSPServerExecutable * SOAP_FMAC4 soap_in_tt__RTSPServerExecutable(struct soap *soap, const char *tag, tt__RTSPServerExecutable *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RTSPServerExecutable*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RTSPServerExecutable, sizeof(tt__RTSPServerExecutable), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RTSPServerExecutable)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RTSPServerExecutable *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Path1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Path1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Path", &a->tt__RTSPServerExecutable::Path, "xsd:string"))
				{	soap_flag_Path1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Path1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RTSPServerExecutable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RTSPServerExecutable, SOAP_TYPE_tt__RTSPServerExecutable, sizeof(tt__RTSPServerExecutable), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RTSPServerExecutable * SOAP_FMAC2 soap_dup_tt__RTSPServerExecutable(struct soap *soap, tt__RTSPServerExecutable *d, tt__RTSPServerExecutable const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RTSPServerExecutable*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RTSPServerExecutable, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RTSPServerExecutable(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__RTSPServerExecutable::Path, &a->tt__RTSPServerExecutable::Path);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RTSPServerExecutable(tt__RTSPServerExecutable const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__RTSPServerExecutable::Path);
}

SOAP_FMAC1 tt__RTSPServerExecutable * SOAP_FMAC2 soap_instantiate_tt__RTSPServerExecutable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RTSPServerExecutable(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RTSPServerExecutable *p;
	size_t k = sizeof(tt__RTSPServerExecutable);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RTSPServerExecutable, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RTSPServerExecutable);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RTSPServerExecutable, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RTSPServerExecutable location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RTSPServerExecutable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RTSPServerExecutable(soap, tag ? tag : "tt:RTSPServerExecutable", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RTSPServerExecutable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RTSPServerExecutable(soap, this, tag, type);
}

SOAP_FMAC3 tt__RTSPServerExecutable * SOAP_FMAC4 soap_get_tt__RTSPServerExecutable(struct soap *soap, tt__RTSPServerExecutable *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RTSPServerExecutable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceManagementServiceProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__DeviceManagementServiceProperties::DeviceInformation = NULL;
}

void tt__DeviceManagementServiceProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DeviceInformation(soap, &this->tt__DeviceManagementServiceProperties::DeviceInformation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceManagementServiceProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceManagementServiceProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceManagementServiceProperties(struct soap *soap, const char *tag, int id, const tt__DeviceManagementServiceProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceManagementServiceProperties), type ? type : "tt:DeviceManagementServiceProperties"))
		return soap->error;
	if (!a->tt__DeviceManagementServiceProperties::DeviceInformation)
	{	if (soap_element_empty(soap, "tt:DeviceInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DeviceInformation(soap, "tt:DeviceInformation", -1, &a->tt__DeviceManagementServiceProperties::DeviceInformation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceManagementServiceProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceManagementServiceProperties(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceManagementServiceProperties * SOAP_FMAC4 soap_in_tt__DeviceManagementServiceProperties(struct soap *soap, const char *tag, tt__DeviceManagementServiceProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceManagementServiceProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceManagementServiceProperties, sizeof(tt__DeviceManagementServiceProperties), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceManagementServiceProperties)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceManagementServiceProperties *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DeviceInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceInformation(soap, "tt:DeviceInformation", &a->tt__DeviceManagementServiceProperties::DeviceInformation, "tt:DeviceInformation"))
				{	soap_flag_DeviceInformation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__DeviceManagementServiceProperties::DeviceInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceManagementServiceProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceManagementServiceProperties, SOAP_TYPE_tt__DeviceManagementServiceProperties, sizeof(tt__DeviceManagementServiceProperties), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceManagementServiceProperties * SOAP_FMAC2 soap_dup_tt__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties *d, tt__DeviceManagementServiceProperties const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceManagementServiceProperties*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceManagementServiceProperties, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceManagementServiceProperties(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__DeviceInformation(soap, &d->tt__DeviceManagementServiceProperties::DeviceInformation, &a->tt__DeviceManagementServiceProperties::DeviceInformation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceManagementServiceProperties(tt__DeviceManagementServiceProperties const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__DeviceInformation(&a->tt__DeviceManagementServiceProperties::DeviceInformation);
}

SOAP_FMAC1 tt__DeviceManagementServiceProperties * SOAP_FMAC2 soap_instantiate_tt__DeviceManagementServiceProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceManagementServiceProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceManagementServiceProperties *p;
	size_t k = sizeof(tt__DeviceManagementServiceProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceManagementServiceProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceManagementServiceProperties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceManagementServiceProperties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceManagementServiceProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceManagementServiceProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceManagementServiceProperties(soap, tag ? tag : "tt:DeviceManagementServiceProperties", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceManagementServiceProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceManagementServiceProperties(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceManagementServiceProperties * SOAP_FMAC4 soap_get_tt__DeviceManagementServiceProperties(struct soap *soap, tt__DeviceManagementServiceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceManagementServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__DeviceInformation::Manufacturer);
	soap_default_std__string(soap, &this->tt__DeviceInformation::Model);
	soap_default_std__string(soap, &this->tt__DeviceInformation::FirmwareVersion);
	soap_default_std__string(soap, &this->tt__DeviceInformation::SerialNumber);
	soap_default_std__string(soap, &this->tt__DeviceInformation::HardwareId);
}

void tt__DeviceInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceInformation::Manufacturer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__DeviceInformation::Manufacturer);
	soap_embedded(soap, &this->tt__DeviceInformation::Model, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__DeviceInformation::Model);
	soap_embedded(soap, &this->tt__DeviceInformation::FirmwareVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__DeviceInformation::FirmwareVersion);
	soap_embedded(soap, &this->tt__DeviceInformation::SerialNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__DeviceInformation::SerialNumber);
	soap_embedded(soap, &this->tt__DeviceInformation::HardwareId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__DeviceInformation::HardwareId);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceInformation(struct soap *soap, const char *tag, int id, const tt__DeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceInformation), type ? type : "tt:DeviceInformation"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Manufacturer", -1, &a->tt__DeviceInformation::Manufacturer, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Model", -1, &a->tt__DeviceInformation::Model, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:FirmwareVersion", -1, &a->tt__DeviceInformation::FirmwareVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:SerialNumber", -1, &a->tt__DeviceInformation::SerialNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:HardwareId", -1, &a->tt__DeviceInformation::HardwareId, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceInformation * SOAP_FMAC4 soap_in_tt__DeviceInformation(struct soap *soap, const char *tag, tt__DeviceInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceInformation, sizeof(tt__DeviceInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Manufacturer1 = 1;
	size_t soap_flag_Model1 = 1;
	size_t soap_flag_FirmwareVersion1 = 1;
	size_t soap_flag_SerialNumber1 = 1;
	size_t soap_flag_HardwareId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Manufacturer", &a->tt__DeviceInformation::Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer1--;
					continue;
				}
			}
			if (soap_flag_Model1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Model", &a->tt__DeviceInformation::Model, "xsd:string"))
				{	soap_flag_Model1--;
					continue;
				}
			}
			if (soap_flag_FirmwareVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:FirmwareVersion", &a->tt__DeviceInformation::FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion1--;
					continue;
				}
			}
			if (soap_flag_SerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:SerialNumber", &a->tt__DeviceInformation::SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber1--;
					continue;
				}
			}
			if (soap_flag_HardwareId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:HardwareId", &a->tt__DeviceInformation::HardwareId, "xsd:string"))
				{	soap_flag_HardwareId1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Manufacturer1 > 0 || soap_flag_Model1 > 0 || soap_flag_FirmwareVersion1 > 0 || soap_flag_SerialNumber1 > 0 || soap_flag_HardwareId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceInformation, SOAP_TYPE_tt__DeviceInformation, sizeof(tt__DeviceInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceInformation * SOAP_FMAC2 soap_dup_tt__DeviceInformation(struct soap *soap, tt__DeviceInformation *d, tt__DeviceInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__DeviceInformation::Manufacturer, &a->tt__DeviceInformation::Manufacturer);
	soap_dup_std__string(soap, &d->tt__DeviceInformation::Model, &a->tt__DeviceInformation::Model);
	soap_dup_std__string(soap, &d->tt__DeviceInformation::FirmwareVersion, &a->tt__DeviceInformation::FirmwareVersion);
	soap_dup_std__string(soap, &d->tt__DeviceInformation::SerialNumber, &a->tt__DeviceInformation::SerialNumber);
	soap_dup_std__string(soap, &d->tt__DeviceInformation::HardwareId, &a->tt__DeviceInformation::HardwareId);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceInformation(tt__DeviceInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__DeviceInformation::Manufacturer);
	soap_del_std__string(&a->tt__DeviceInformation::Model);
	soap_del_std__string(&a->tt__DeviceInformation::FirmwareVersion);
	soap_del_std__string(&a->tt__DeviceInformation::SerialNumber);
	soap_del_std__string(&a->tt__DeviceInformation::HardwareId);
}

SOAP_FMAC1 tt__DeviceInformation * SOAP_FMAC2 soap_instantiate_tt__DeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceInformation *p;
	size_t k = sizeof(tt__DeviceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceInformation(soap, tag ? tag : "tt:DeviceInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceInformation * SOAP_FMAC4 soap_get_tt__DeviceInformation(struct soap *soap, tt__DeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingServiceProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap, &this->tt__ImagingServiceProperties::ImagingVideoSourceOptions);
}

void tt__ImagingServiceProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap, &this->tt__ImagingServiceProperties::ImagingVideoSourceOptions);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingServiceProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingServiceProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingServiceProperties(struct soap *soap, const char *tag, int id, const tt__ImagingServiceProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingServiceProperties), type ? type : "tt:ImagingServiceProperties"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap, "tt:ImagingVideoSourceOptions", -1, &a->tt__ImagingServiceProperties::ImagingVideoSourceOptions, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingServiceProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingServiceProperties(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingServiceProperties * SOAP_FMAC4 soap_in_tt__ImagingServiceProperties(struct soap *soap, const char *tag, tt__ImagingServiceProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingServiceProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingServiceProperties, sizeof(tt__ImagingServiceProperties), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingServiceProperties)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingServiceProperties *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap, "tt:ImagingVideoSourceOptions", &a->tt__ImagingServiceProperties::ImagingVideoSourceOptions, "tt:ImagingVideoSourceOptions"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingServiceProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingServiceProperties, SOAP_TYPE_tt__ImagingServiceProperties, sizeof(tt__ImagingServiceProperties), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingServiceProperties * SOAP_FMAC2 soap_dup_tt__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties *d, tt__ImagingServiceProperties const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingServiceProperties*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingServiceProperties, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingServiceProperties(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(soap, &d->tt__ImagingServiceProperties::ImagingVideoSourceOptions, &a->tt__ImagingServiceProperties::ImagingVideoSourceOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingServiceProperties(tt__ImagingServiceProperties const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__ImagingVideoSourceOptions(&a->tt__ImagingServiceProperties::ImagingVideoSourceOptions);
}

SOAP_FMAC1 tt__ImagingServiceProperties * SOAP_FMAC2 soap_instantiate_tt__ImagingServiceProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingServiceProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingServiceProperties *p;
	size_t k = sizeof(tt__ImagingServiceProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingServiceProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingServiceProperties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingServiceProperties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingServiceProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingServiceProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingServiceProperties(soap, tag ? tag : "tt:ImagingServiceProperties", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingServiceProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingServiceProperties(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingServiceProperties * SOAP_FMAC4 soap_get_tt__ImagingServiceProperties(struct soap *soap, tt__ImagingServiceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingVideoSourceOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__ImagingVideoSourceOptions::VideoSourceToken);
	this->tt__ImagingVideoSourceOptions::ImagingOptions = NULL;
}

void tt__ImagingVideoSourceOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ImagingVideoSourceOptions::VideoSourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__ImagingVideoSourceOptions::VideoSourceToken);
	soap_serialize_PointerTott__ImagingOptions20(soap, &this->tt__ImagingVideoSourceOptions::ImagingOptions);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingVideoSourceOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingVideoSourceOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingVideoSourceOptions(struct soap *soap, const char *tag, int id, const tt__ImagingVideoSourceOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingVideoSourceOptions), type ? type : "tt:ImagingVideoSourceOptions"))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:VideoSourceToken", -1, &a->tt__ImagingVideoSourceOptions::VideoSourceToken, ""))
		return soap->error;
	if (!a->tt__ImagingVideoSourceOptions::ImagingOptions)
	{	if (soap_element_empty(soap, "tt:ImagingOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ImagingOptions20(soap, "tt:ImagingOptions", -1, &a->tt__ImagingVideoSourceOptions::ImagingOptions, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingVideoSourceOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingVideoSourceOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingVideoSourceOptions * SOAP_FMAC4 soap_in_tt__ImagingVideoSourceOptions(struct soap *soap, const char *tag, tt__ImagingVideoSourceOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingVideoSourceOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingVideoSourceOptions, sizeof(tt__ImagingVideoSourceOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingVideoSourceOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingVideoSourceOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_VideoSourceToken1 = 1;
	size_t soap_flag_ImagingOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:VideoSourceToken", &a->tt__ImagingVideoSourceOptions::VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken1--;
					continue;
				}
			}
			if (soap_flag_ImagingOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20(soap, "tt:ImagingOptions", &a->tt__ImagingVideoSourceOptions::ImagingOptions, "tt:ImagingOptions20"))
				{	soap_flag_ImagingOptions1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_VideoSourceToken1 > 0 || !a->tt__ImagingVideoSourceOptions::ImagingOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingVideoSourceOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingVideoSourceOptions, SOAP_TYPE_tt__ImagingVideoSourceOptions, sizeof(tt__ImagingVideoSourceOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingVideoSourceOptions * SOAP_FMAC2 soap_dup_tt__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions *d, tt__ImagingVideoSourceOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingVideoSourceOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingVideoSourceOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingVideoSourceOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__ImagingVideoSourceOptions::VideoSourceToken, &a->tt__ImagingVideoSourceOptions::VideoSourceToken);
	soap_dup_PointerTott__ImagingOptions20(soap, &d->tt__ImagingVideoSourceOptions::ImagingOptions, &a->tt__ImagingVideoSourceOptions::ImagingOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingVideoSourceOptions(tt__ImagingVideoSourceOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__ReferenceToken(&a->tt__ImagingVideoSourceOptions::VideoSourceToken);
	soap_del_PointerTott__ImagingOptions20(&a->tt__ImagingVideoSourceOptions::ImagingOptions);
}

SOAP_FMAC1 tt__ImagingVideoSourceOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingVideoSourceOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingVideoSourceOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingVideoSourceOptions *p;
	size_t k = sizeof(tt__ImagingVideoSourceOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingVideoSourceOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingVideoSourceOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingVideoSourceOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingVideoSourceOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingVideoSourceOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingVideoSourceOptions(soap, tag ? tag : "tt:ImagingVideoSourceOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingVideoSourceOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingVideoSourceOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingVideoSourceOptions * SOAP_FMAC4 soap_get_tt__ImagingVideoSourceOptions(struct soap *soap, tt__ImagingVideoSourceOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingVideoSourceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaServiceProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__VideoSource(soap, &this->tt__MediaServiceProperties::VideoSource);
	this->tt__MediaServiceProperties::VideoSourceConfigurationOptions = NULL;
	this->tt__MediaServiceProperties::VideoEncoderConfigurationOptions = NULL;
}

void tt__MediaServiceProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoSource(soap, &this->tt__MediaServiceProperties::VideoSource);
	soap_serialize_PointerTott__VideoSourceConfigurationOptions(soap, &this->tt__MediaServiceProperties::VideoSourceConfigurationOptions);
	soap_serialize_PointerTott__VideoEncoderConfigurationOptions(soap, &this->tt__MediaServiceProperties::VideoEncoderConfigurationOptions);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MediaServiceProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaServiceProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaServiceProperties(struct soap *soap, const char *tag, int id, const tt__MediaServiceProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaServiceProperties), type ? type : "tt:MediaServiceProperties"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoSource(soap, "tt:VideoSource", -1, &a->tt__MediaServiceProperties::VideoSource, ""))
		return soap->error;
	if (!a->tt__MediaServiceProperties::VideoSourceConfigurationOptions)
	{	if (soap_element_empty(soap, "tt:VideoSourceConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, "tt:VideoSourceConfigurationOptions", -1, &a->tt__MediaServiceProperties::VideoSourceConfigurationOptions, ""))
		return soap->error;
	if (!a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions)
	{	if (soap_element_empty(soap, "tt:VideoEncoderConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, "tt:VideoEncoderConfigurationOptions", -1, &a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaServiceProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaServiceProperties(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaServiceProperties * SOAP_FMAC4 soap_in_tt__MediaServiceProperties(struct soap *soap, const char *tag, tt__MediaServiceProperties *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaServiceProperties*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaServiceProperties, sizeof(tt__MediaServiceProperties), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaServiceProperties)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaServiceProperties *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_VideoSourceConfigurationOptions1 = 1;
	size_t soap_flag_VideoEncoderConfigurationOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoSource(soap, "tt:VideoSource", &a->tt__MediaServiceProperties::VideoSource, "tt:VideoSource"))
					continue;
			}
			if (soap_flag_VideoSourceConfigurationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptions(soap, "tt:VideoSourceConfigurationOptions", &a->tt__MediaServiceProperties::VideoSourceConfigurationOptions, "tt:VideoSourceConfigurationOptions"))
				{	soap_flag_VideoSourceConfigurationOptions1--;
					continue;
				}
			}
			if (soap_flag_VideoEncoderConfigurationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, "tt:VideoEncoderConfigurationOptions", &a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions, "tt:VideoEncoderConfigurationOptions"))
				{	soap_flag_VideoEncoderConfigurationOptions1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__MediaServiceProperties::VideoSource.size() < 1 || !a->tt__MediaServiceProperties::VideoSourceConfigurationOptions || !a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaServiceProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaServiceProperties, SOAP_TYPE_tt__MediaServiceProperties, sizeof(tt__MediaServiceProperties), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaServiceProperties * SOAP_FMAC2 soap_dup_tt__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties *d, tt__MediaServiceProperties const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MediaServiceProperties*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MediaServiceProperties, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MediaServiceProperties(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__VideoSource(soap, &d->tt__MediaServiceProperties::VideoSource, &a->tt__MediaServiceProperties::VideoSource);
	soap_dup_PointerTott__VideoSourceConfigurationOptions(soap, &d->tt__MediaServiceProperties::VideoSourceConfigurationOptions, &a->tt__MediaServiceProperties::VideoSourceConfigurationOptions);
	soap_dup_PointerTott__VideoEncoderConfigurationOptions(soap, &d->tt__MediaServiceProperties::VideoEncoderConfigurationOptions, &a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MediaServiceProperties(tt__MediaServiceProperties const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__VideoSource(&a->tt__MediaServiceProperties::VideoSource);
	soap_del_PointerTott__VideoSourceConfigurationOptions(&a->tt__MediaServiceProperties::VideoSourceConfigurationOptions);
	soap_del_PointerTott__VideoEncoderConfigurationOptions(&a->tt__MediaServiceProperties::VideoEncoderConfigurationOptions);
}

SOAP_FMAC1 tt__MediaServiceProperties * SOAP_FMAC2 soap_instantiate_tt__MediaServiceProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaServiceProperties(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaServiceProperties *p;
	size_t k = sizeof(tt__MediaServiceProperties);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaServiceProperties, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaServiceProperties);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaServiceProperties, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaServiceProperties location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaServiceProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaServiceProperties(soap, tag ? tag : "tt:MediaServiceProperties", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaServiceProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaServiceProperties(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaServiceProperties * SOAP_FMAC4 soap_get_tt__MediaServiceProperties(struct soap *soap, tt__MediaServiceProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaServiceProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LocationEntity::GeoLocation = NULL;
	this->tt__LocationEntity::GeoOrientation = NULL;
	this->tt__LocationEntity::LocalLocation = NULL;
	this->tt__LocationEntity::LocalOrientation = NULL;
	this->tt__LocationEntity::Entity = NULL;
	this->tt__LocationEntity::Token = NULL;
	this->tt__LocationEntity::Fixed = NULL;
	this->tt__LocationEntity::GeoSource = NULL;
	this->tt__LocationEntity::AutoGeo = NULL;
}

void tt__LocationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__GeoLocation(soap, &this->tt__LocationEntity::GeoLocation);
	soap_serialize_PointerTott__GeoOrientation(soap, &this->tt__LocationEntity::GeoOrientation);
	soap_serialize_PointerTott__LocalLocation(soap, &this->tt__LocationEntity::LocalLocation);
	soap_serialize_PointerTott__LocalOrientation(soap, &this->tt__LocationEntity::LocalOrientation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LocationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocationEntity(struct soap *soap, const char *tag, int id, const tt__LocationEntity *a, const char *type)
{
	if (((tt__LocationEntity*)a)->Entity)
	{	soap_set_attr(soap, "Entity", soap_std__string2s(soap, *((tt__LocationEntity*)a)->Entity), 1);
	}
	if (((tt__LocationEntity*)a)->Token)
	{	soap_set_attr(soap, "Token", soap_tt__ReferenceToken2s(soap, *((tt__LocationEntity*)a)->Token), 1);
	}
	if (((tt__LocationEntity*)a)->Fixed)
	{	soap_set_attr(soap, "Fixed", soap_bool2s(soap, *((tt__LocationEntity*)a)->Fixed), 1);
	}
	if (((tt__LocationEntity*)a)->GeoSource)
	{	soap_set_attr(soap, "GeoSource", soap_xsd__anyURI2s(soap, *((tt__LocationEntity*)a)->GeoSource), 1);
	}
	if (((tt__LocationEntity*)a)->AutoGeo)
	{	soap_set_attr(soap, "AutoGeo", soap_bool2s(soap, *((tt__LocationEntity*)a)->AutoGeo), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LocationEntity), type ? type : "tt:LocationEntity"))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tt:GeoLocation", -1, &a->tt__LocationEntity::GeoLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", -1, &a->tt__LocationEntity::GeoOrientation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalLocation(soap, "tt:LocalLocation", -1, &a->tt__LocationEntity::LocalLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", -1, &a->tt__LocationEntity::LocalOrientation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LocationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_in_tt__LocationEntity(struct soap *soap, const char *tag, tt__LocationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LocationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LocationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Entity", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Entity = soap_new_std__string(soap)))
				return NULL;
			if (soap_s2std__string(soap, t, ((tt__LocationEntity*)a)->Entity))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Token", 1, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Token = soap_new_tt__ReferenceToken(soap)))
				return NULL;
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__LocationEntity*)a)->Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Fixed", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->Fixed = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->Fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoSource", 4, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->GeoSource = soap_new_xsd__anyURI(soap)))
				return NULL;
			if (soap_s2xsd__anyURI(soap, t, ((tt__LocationEntity*)a)->GeoSource))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AutoGeo", 5, 0);
		if (t)
		{
			if (!(((tt__LocationEntity*)a)->AutoGeo = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__LocationEntity*)a)->AutoGeo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GeoLocation1 = 1;
	size_t soap_flag_GeoOrientation1 = 1;
	size_t soap_flag_LocalLocation1 = 1;
	size_t soap_flag_LocalOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GeoLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tt:GeoLocation", &a->tt__LocationEntity::GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation1--;
					continue;
				}
			}
			if (soap_flag_GeoOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoOrientation(soap, "tt:GeoOrientation", &a->tt__LocationEntity::GeoOrientation, "tt:GeoOrientation"))
				{	soap_flag_GeoOrientation1--;
					continue;
				}
			}
			if (soap_flag_LocalLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalLocation(soap, "tt:LocalLocation", &a->tt__LocationEntity::LocalLocation, "tt:LocalLocation"))
				{	soap_flag_LocalLocation1--;
					continue;
				}
			}
			if (soap_flag_LocalOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LocalOrientation(soap, "tt:LocalOrientation", &a->tt__LocationEntity::LocalOrientation, "tt:LocalOrientation"))
				{	soap_flag_LocalOrientation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__LocationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LocationEntity, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_dup_tt__LocationEntity(struct soap *soap, tt__LocationEntity *d, tt__LocationEntity const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LocationEntity*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LocationEntity, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LocationEntity(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__GeoLocation(soap, &d->tt__LocationEntity::GeoLocation, &a->tt__LocationEntity::GeoLocation);
	soap_dup_PointerTott__GeoOrientation(soap, &d->tt__LocationEntity::GeoOrientation, &a->tt__LocationEntity::GeoOrientation);
	soap_dup_PointerTott__LocalLocation(soap, &d->tt__LocationEntity::LocalLocation, &a->tt__LocationEntity::LocalLocation);
	soap_dup_PointerTott__LocalOrientation(soap, &d->tt__LocationEntity::LocalOrientation, &a->tt__LocationEntity::LocalOrientation);
	soap_dup_PointerTostd__string(soap, &d->tt__LocationEntity::Entity, &a->tt__LocationEntity::Entity);
	soap_dup_PointerTott__ReferenceToken(soap, &d->tt__LocationEntity::Token, &a->tt__LocationEntity::Token);
	soap_dup_PointerTobool(soap, &d->tt__LocationEntity::Fixed, &a->tt__LocationEntity::Fixed);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__LocationEntity::GeoSource, &a->tt__LocationEntity::GeoSource);
	soap_dup_PointerTobool(soap, &d->tt__LocationEntity::AutoGeo, &a->tt__LocationEntity::AutoGeo);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LocationEntity(tt__LocationEntity const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__GeoLocation(&a->tt__LocationEntity::GeoLocation);
	soap_del_PointerTott__GeoOrientation(&a->tt__LocationEntity::GeoOrientation);
	soap_del_PointerTott__LocalLocation(&a->tt__LocationEntity::LocalLocation);
	soap_del_PointerTott__LocalOrientation(&a->tt__LocationEntity::LocalOrientation);
	soap_del_PointerTostd__string(&a->tt__LocationEntity::Entity);
	soap_del_PointerTott__ReferenceToken(&a->tt__LocationEntity::Token);
	soap_del_PointerTobool(&a->tt__LocationEntity::Fixed);
	soap_del_PointerToxsd__anyURI(&a->tt__LocationEntity::GeoSource);
	soap_del_PointerTobool(&a->tt__LocationEntity::AutoGeo);
}

SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocationEntity *p;
	size_t k = sizeof(tt__LocationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocationEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocationEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocationEntity * SOAP_FMAC4 soap_get_tt__LocationEntity(struct soap *soap, tt__LocationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LocalOrientation::pan = NULL;
	this->tt__LocalOrientation::tilt = NULL;
	this->tt__LocalOrientation::roll = NULL;
}

void tt__LocalOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LocalOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalOrientation(struct soap *soap, const char *tag, int id, const tt__LocalOrientation *a, const char *type)
{
	if (((tt__LocalOrientation*)a)->pan)
	{	soap_set_attr(soap, "pan", soap_float2s(soap, *((tt__LocalOrientation*)a)->pan), 1);
	}
	if (((tt__LocalOrientation*)a)->tilt)
	{	soap_set_attr(soap, "tilt", soap_float2s(soap, *((tt__LocalOrientation*)a)->tilt), 1);
	}
	if (((tt__LocalOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__LocalOrientation*)a)->roll), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:LocalOrientation");
}

void *tt__LocalOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_in_tt__LocalOrientation(struct soap *soap, const char *tag, tt__LocalOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__LocalOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalOrientation, sizeof(tt__LocalOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalOrientation)
		return (tt__LocalOrientation *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "pan", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->pan = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->pan))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "tilt", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->tilt = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->tilt))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__LocalOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_dup_tt__LocalOrientation(struct soap *soap, tt__LocalOrientation *d, tt__LocalOrientation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LocalOrientation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LocalOrientation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LocalOrientation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__LocalOrientation::pan, &a->tt__LocalOrientation::pan);
	soap_dup_PointerTofloat(soap, &d->tt__LocalOrientation::tilt, &a->tt__LocalOrientation::tilt);
	soap_dup_PointerTofloat(soap, &d->tt__LocalOrientation::roll, &a->tt__LocalOrientation::roll);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LocalOrientation(tt__LocalOrientation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__LocalOrientation::pan);
	soap_del_PointerTofloat(&a->tt__LocalOrientation::tilt);
	soap_del_PointerTofloat(&a->tt__LocalOrientation::roll);
}

SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalOrientation *p;
	size_t k = sizeof(tt__LocalOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalOrientation(soap, tag ? tag : "tt:LocalOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalOrientation * SOAP_FMAC4 soap_get_tt__LocalOrientation(struct soap *soap, tt__LocalOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LocalLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LocalLocation::x = NULL;
	this->tt__LocalLocation::y = NULL;
	this->tt__LocalLocation::z = NULL;
}

void tt__LocalLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LocalLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LocalLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LocalLocation(struct soap *soap, const char *tag, int id, const tt__LocalLocation *a, const char *type)
{
	if (((tt__LocalLocation*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LocalLocation*)a)->x), 1);
	}
	if (((tt__LocalLocation*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LocalLocation*)a)->y), 1);
	}
	if (((tt__LocalLocation*)a)->z)
	{	soap_set_attr(soap, "z", soap_float2s(soap, *((tt__LocalLocation*)a)->z), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:LocalLocation");
}

void *tt__LocalLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LocalLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_in_tt__LocalLocation(struct soap *soap, const char *tag, tt__LocalLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__LocalLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LocalLocation, sizeof(tt__LocalLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LocalLocation)
		return (tt__LocalLocation *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "z", 5, 0);
		if (t)
		{
			if (!(((tt__LocalLocation*)a)->z = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LocalLocation*)a)->z))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_dup_tt__LocalLocation(struct soap *soap, tt__LocalLocation *d, tt__LocalLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LocalLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LocalLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LocalLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__LocalLocation::x, &a->tt__LocalLocation::x);
	soap_dup_PointerTofloat(soap, &d->tt__LocalLocation::y, &a->tt__LocalLocation::y);
	soap_dup_PointerTofloat(soap, &d->tt__LocalLocation::z, &a->tt__LocalLocation::z);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LocalLocation(tt__LocalLocation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__LocalLocation::x);
	soap_del_PointerTofloat(&a->tt__LocalLocation::y);
	soap_del_PointerTofloat(&a->tt__LocalLocation::z);
}

SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LocalLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LocalLocation *p;
	size_t k = sizeof(tt__LocalLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LocalLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LocalLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LocalLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LocalLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LocalLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LocalLocation(soap, tag ? tag : "tt:LocalLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LocalLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LocalLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__LocalLocation * SOAP_FMAC4 soap_get_tt__LocalLocation(struct soap *soap, tt__LocalLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LocalLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__GeoOrientation::roll = NULL;
	this->tt__GeoOrientation::pitch = NULL;
	this->tt__GeoOrientation::yaw = NULL;
}

void tt__GeoOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__GeoOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoOrientation(struct soap *soap, const char *tag, int id, const tt__GeoOrientation *a, const char *type)
{
	if (((tt__GeoOrientation*)a)->roll)
	{	soap_set_attr(soap, "roll", soap_float2s(soap, *((tt__GeoOrientation*)a)->roll), 1);
	}
	if (((tt__GeoOrientation*)a)->pitch)
	{	soap_set_attr(soap, "pitch", soap_float2s(soap, *((tt__GeoOrientation*)a)->pitch), 1);
	}
	if (((tt__GeoOrientation*)a)->yaw)
	{	soap_set_attr(soap, "yaw", soap_float2s(soap, *((tt__GeoOrientation*)a)->yaw), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:GeoOrientation");
}

void *tt__GeoOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_in_tt__GeoOrientation(struct soap *soap, const char *tag, tt__GeoOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__GeoOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoOrientation, sizeof(tt__GeoOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoOrientation)
		return (tt__GeoOrientation *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "roll", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->roll = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->roll))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "pitch", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->pitch = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->pitch))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "yaw", 5, 0);
		if (t)
		{
			if (!(((tt__GeoOrientation*)a)->yaw = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoOrientation*)a)->yaw))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_dup_tt__GeoOrientation(struct soap *soap, tt__GeoOrientation *d, tt__GeoOrientation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__GeoOrientation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__GeoOrientation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__GeoOrientation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__GeoOrientation::roll, &a->tt__GeoOrientation::roll);
	soap_dup_PointerTofloat(soap, &d->tt__GeoOrientation::pitch, &a->tt__GeoOrientation::pitch);
	soap_dup_PointerTofloat(soap, &d->tt__GeoOrientation::yaw, &a->tt__GeoOrientation::yaw);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__GeoOrientation(tt__GeoOrientation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__GeoOrientation::roll);
	soap_del_PointerTofloat(&a->tt__GeoOrientation::pitch);
	soap_del_PointerTofloat(&a->tt__GeoOrientation::yaw);
}

SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoOrientation *p;
	size_t k = sizeof(tt__GeoOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoOrientation(soap, tag ? tag : "tt:GeoOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoOrientation * SOAP_FMAC4 soap_get_tt__GeoOrientation(struct soap *soap, tt__GeoOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__GeoLocation::lon = NULL;
	this->tt__GeoLocation::lat = NULL;
	this->tt__GeoLocation::elevation = NULL;
}

void tt__GeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__GeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoLocation(struct soap *soap, const char *tag, int id, const tt__GeoLocation *a, const char *type)
{
	if (((tt__GeoLocation*)a)->lon)
	{	soap_set_attr(soap, "lon", soap_double2s(soap, *((tt__GeoLocation*)a)->lon), 1);
	}
	if (((tt__GeoLocation*)a)->lat)
	{	soap_set_attr(soap, "lat", soap_double2s(soap, *((tt__GeoLocation*)a)->lat), 1);
	}
	if (((tt__GeoLocation*)a)->elevation)
	{	soap_set_attr(soap, "elevation", soap_float2s(soap, *((tt__GeoLocation*)a)->elevation), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:GeoLocation");
}

void *tt__GeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_in_tt__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__GeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoLocation)
		return (tt__GeoLocation *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "lon", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lon = (double *)soap_malloc(soap, sizeof(double))))
				return NULL;
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "lat", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lat = (double *)soap_malloc(soap, sizeof(double))))
				return NULL;
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lat))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "elevation", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->elevation = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__GeoLocation*)a)->elevation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_dup_tt__GeoLocation(struct soap *soap, tt__GeoLocation *d, tt__GeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__GeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__GeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__GeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTodouble(soap, &d->tt__GeoLocation::lon, &a->tt__GeoLocation::lon);
	soap_dup_PointerTodouble(soap, &d->tt__GeoLocation::lat, &a->tt__GeoLocation::lat);
	soap_dup_PointerTofloat(soap, &d->tt__GeoLocation::elevation, &a->tt__GeoLocation::elevation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__GeoLocation(tt__GeoLocation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTodouble(&a->tt__GeoLocation::lon);
	soap_del_PointerTodouble(&a->tt__GeoLocation::lat);
	soap_del_PointerTofloat(&a->tt__GeoLocation::elevation);
}

SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoLocation *p;
	size_t k = sizeof(tt__GeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_get_tt__GeoLocation(struct soap *soap, tt__GeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Color::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__Color::X);
	soap_default_float(soap, &this->tt__Color::Y);
	soap_default_float(soap, &this->tt__Color::Z);
	this->tt__Color::Colorspace = NULL;
	this->tt__Color::Likelihood = NULL;
}

void tt__Color::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Color::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Color(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Color(struct soap *soap, const char *tag, int id, const tt__Color *a, const char *type)
{
	soap_set_attr(soap, "X", soap_float2s(soap, ((tt__Color*)a)->X), 1);
	soap_set_attr(soap, "Y", soap_float2s(soap, ((tt__Color*)a)->Y), 1);
	soap_set_attr(soap, "Z", soap_float2s(soap, ((tt__Color*)a)->Z), 1);
	if (((tt__Color*)a)->Colorspace)
	{	soap_set_attr(soap, "Colorspace", soap_xsd__anyURI2s(soap, *((tt__Color*)a)->Colorspace), 1);
	}
	if (((tt__Color*)a)->Likelihood)
	{	soap_set_attr(soap, "Likelihood", soap_float2s(soap, *((tt__Color*)a)->Likelihood), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Color");
}

void *tt__Color::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Color(soap, tag, this, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_in_tt__Color(struct soap *soap, const char *tag, tt__Color *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Color*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Color, sizeof(tt__Color), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Color)
		return (tt__Color *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "X", 5, 3), &((tt__Color*)a)->X))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Y", 5, 3), &((tt__Color*)a)->Y))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "Z", 5, 3), &((tt__Color*)a)->Z))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Colorspace", 4, 0);
		if (t)
		{
			if (!(((tt__Color*)a)->Colorspace = soap_new_xsd__anyURI(soap)))
				return NULL;
			if (soap_s2xsd__anyURI(soap, t, ((tt__Color*)a)->Colorspace))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Likelihood", 5, 0);
		if (t)
		{
			if (!(((tt__Color*)a)->Likelihood = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Color*)a)->Likelihood))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_dup_tt__Color(struct soap *soap, tt__Color *d, tt__Color const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Color*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Color, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Color(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Color::X = a->tt__Color::X;
	d->tt__Color::Y = a->tt__Color::Y;
	d->tt__Color::Z = a->tt__Color::Z;
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__Color::Colorspace, &a->tt__Color::Colorspace);
	soap_dup_PointerTofloat(soap, &d->tt__Color::Likelihood, &a->tt__Color::Likelihood);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Color(tt__Color const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* X skipped */
	/* Y skipped */
	/* Z skipped */
	soap_del_PointerToxsd__anyURI(&a->tt__Color::Colorspace);
	soap_del_PointerTofloat(&a->tt__Color::Likelihood);
}

SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Color(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Color *p;
	size_t k = sizeof(tt__Color);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Color, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Color);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Color, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Color location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Color::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Color(soap, tag ? tag : "tt:Color", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Color::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Color(soap, this, tag, type);
}

SOAP_FMAC3 tt__Color * SOAP_FMAC4 soap_get_tt__Color(struct soap *soap, tt__Color *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polygon::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
}

void tt__Polygon::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polygon::Point);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Polygon::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polygon(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polygon(struct soap *soap, const char *tag, int id, const tt__Polygon *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polygon), type ? type : "tt:Polygon"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polygon::Point, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polygon::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polygon(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_in_tt__Polygon(struct soap *soap, const char *tag, tt__Polygon *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polygon*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polygon)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polygon *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polygon::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__Polygon::Point.size() < 3))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polygon *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polygon, SOAP_TYPE_tt__Polygon, sizeof(tt__Polygon), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_dup_tt__Polygon(struct soap *soap, tt__Polygon *d, tt__Polygon const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Polygon*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Polygon, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Polygon(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__Vector(soap, &d->tt__Polygon::Point, &a->tt__Polygon::Point);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Polygon(tt__Polygon const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__Vector(&a->tt__Polygon::Point);
}

SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polygon(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polygon *p;
	size_t k = sizeof(tt__Polygon);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polygon, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polygon);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polygon, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polygon location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polygon::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polygon(soap, tag ? tag : "tt:Polygon", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polygon::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polygon(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polygon * SOAP_FMAC4 soap_get_tt__Polygon(struct soap *soap, tt__Polygon *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Rectangle::bottom = NULL;
	this->tt__Rectangle::top = NULL;
	this->tt__Rectangle::right = NULL;
	this->tt__Rectangle::left = NULL;
}

void tt__Rectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Rectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rectangle(struct soap *soap, const char *tag, int id, const tt__Rectangle *a, const char *type)
{
	if (((tt__Rectangle*)a)->bottom)
	{	soap_set_attr(soap, "bottom", soap_float2s(soap, *((tt__Rectangle*)a)->bottom), 1);
	}
	if (((tt__Rectangle*)a)->top)
	{	soap_set_attr(soap, "top", soap_float2s(soap, *((tt__Rectangle*)a)->top), 1);
	}
	if (((tt__Rectangle*)a)->right)
	{	soap_set_attr(soap, "right", soap_float2s(soap, *((tt__Rectangle*)a)->right), 1);
	}
	if (((tt__Rectangle*)a)->left)
	{	soap_set_attr(soap, "left", soap_float2s(soap, *((tt__Rectangle*)a)->left), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Rectangle");
}

void *tt__Rectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_in_tt__Rectangle(struct soap *soap, const char *tag, tt__Rectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Rectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rectangle, sizeof(tt__Rectangle), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rectangle)
		return (tt__Rectangle *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "bottom", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->bottom = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->bottom))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "top", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->top = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->top))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "right", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->right = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->right))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "left", 5, 0);
		if (t)
		{
			if (!(((tt__Rectangle*)a)->left = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Rectangle*)a)->left))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_dup_tt__Rectangle(struct soap *soap, tt__Rectangle *d, tt__Rectangle const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Rectangle*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Rectangle, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Rectangle(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__Rectangle::bottom, &a->tt__Rectangle::bottom);
	soap_dup_PointerTofloat(soap, &d->tt__Rectangle::top, &a->tt__Rectangle::top);
	soap_dup_PointerTofloat(soap, &d->tt__Rectangle::right, &a->tt__Rectangle::right);
	soap_dup_PointerTofloat(soap, &d->tt__Rectangle::left, &a->tt__Rectangle::left);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Rectangle(tt__Rectangle const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__Rectangle::bottom);
	soap_del_PointerTofloat(&a->tt__Rectangle::top);
	soap_del_PointerTofloat(&a->tt__Rectangle::right);
	soap_del_PointerTofloat(&a->tt__Rectangle::left);
}

SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rectangle *p;
	size_t k = sizeof(tt__Rectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rectangle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rectangle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rectangle(soap, tag ? tag : "tt:Rectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rectangle * SOAP_FMAC4 soap_get_tt__Rectangle(struct soap *soap, tt__Rectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Vector::x = NULL;
	this->tt__Vector::y = NULL;
}

void tt__Vector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector(struct soap *soap, const char *tag, int id, const tt__Vector *a, const char *type)
{
	if (((tt__Vector*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__Vector*)a)->x), 1);
	}
	if (((tt__Vector*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__Vector*)a)->y), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector");
}

void *tt__Vector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_in_tt__Vector(struct soap *soap, const char *tag, tt__Vector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector, sizeof(tt__Vector), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector)
		return (tt__Vector *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Vector*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__Vector*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__Vector*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_dup_tt__Vector(struct soap *soap, tt__Vector *d, tt__Vector const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Vector*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Vector, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Vector(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__Vector::x, &a->tt__Vector::x);
	soap_dup_PointerTofloat(soap, &d->tt__Vector::y, &a->tt__Vector::y);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Vector(tt__Vector const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__Vector::x);
	soap_del_PointerTofloat(&a->tt__Vector::y);
}

SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector *p;
	size_t k = sizeof(tt__Vector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector(soap, tag ? tag : "tt:Vector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector * SOAP_FMAC4 soap_get_tt__Vector(struct soap *soap, tt__Vector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector1D::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__Vector1D::x);
	this->tt__Vector1D::space = NULL;
}

void tt__Vector1D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector1D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector1D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector1D*)a)->x), 1);
	if (((tt__Vector1D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector1D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector1D");
}

void *tt__Vector1D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector1D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, tt__Vector1D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector1D)
		return (tt__Vector1D *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 3), &((tt__Vector1D*)a)->x))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector1D*)a)->space = soap_new_xsd__anyURI(soap)))
				return NULL;
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector1D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_dup_tt__Vector1D(struct soap *soap, tt__Vector1D *d, tt__Vector1D const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Vector1D*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Vector1D, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Vector1D(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Vector1D::x = a->tt__Vector1D::x;
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__Vector1D::space, &a->tt__Vector1D::space);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Vector1D(tt__Vector1D const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* x skipped */
	soap_del_PointerToxsd__anyURI(&a->tt__Vector1D::space);
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector1D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector1D *p;
	size_t k = sizeof(tt__Vector1D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector1D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector1D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector1D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector1D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector1D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector1D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector1D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector2D::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__Vector2D::x);
	soap_default_float(soap, &this->tt__Vector2D::y);
	this->tt__Vector2D::space = NULL;
}

void tt__Vector2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Vector2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, ((tt__Vector2D*)a)->y), 1);
	if (((tt__Vector2D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector2D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Vector2D");
}

void *tt__Vector2D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector2D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, tt__Vector2D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector2D)
		return (tt__Vector2D *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 3), &((tt__Vector2D*)a)->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 3), &((tt__Vector2D*)a)->y))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector2D*)a)->space = soap_new_xsd__anyURI(soap)))
				return NULL;
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector2D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_dup_tt__Vector2D(struct soap *soap, tt__Vector2D *d, tt__Vector2D const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Vector2D*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Vector2D, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Vector2D(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Vector2D::x = a->tt__Vector2D::x;
	d->tt__Vector2D::y = a->tt__Vector2D::y;
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__Vector2D::space, &a->tt__Vector2D::space);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Vector2D(tt__Vector2D const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* x skipped */
	/* y skipped */
	soap_del_PointerToxsd__anyURI(&a->tt__Vector2D::space);
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector2D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector2D *p;
	size_t k = sizeof(tt__Vector2D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector2D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector2D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector2D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector2D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector2D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type ? type : "tt:IntRange"))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->tt__IntRange::Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->tt__IntRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->tt__IntRange::Min, "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->tt__IntRange::Max, "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_dup_tt__IntRange(struct soap *soap, tt__IntRange *d, tt__IntRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IntRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IntRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IntRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IntRange::Min = a->tt__IntRange::Min;
	d->tt__IntRange::Max = a->tt__IntRange::Max;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IntRange(tt__IntRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Min skipped */
	/* Max skipped */
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRange *p;
	size_t k = sizeof(tt__IntRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PolygonOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PolygonOptions::RectangleOnly = NULL;
	this->tt__PolygonOptions::VertexLimits = NULL;
}

void tt__PolygonOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__PolygonOptions::RectangleOnly);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__PolygonOptions::VertexLimits);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PolygonOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PolygonOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PolygonOptions(struct soap *soap, const char *tag, int id, const tt__PolygonOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PolygonOptions), type ? type : "tt:PolygonOptions"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RectangleOnly", -1, &a->tt__PolygonOptions::RectangleOnly, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:VertexLimits", -1, &a->tt__PolygonOptions::VertexLimits, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PolygonOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PolygonOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_in_tt__PolygonOptions(struct soap *soap, const char *tag, tt__PolygonOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PolygonOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PolygonOptions, sizeof(tt__PolygonOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PolygonOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PolygonOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_RectangleOnly1 = 1;
	size_t soap_flag_VertexLimits1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RectangleOnly1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RectangleOnly", &a->tt__PolygonOptions::RectangleOnly, "xsd:boolean"))
				{	soap_flag_RectangleOnly1--;
					continue;
				}
			}
			if (soap_flag_VertexLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:VertexLimits", &a->tt__PolygonOptions::VertexLimits, "tt:IntRange"))
				{	soap_flag_VertexLimits1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PolygonOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PolygonOptions, SOAP_TYPE_tt__PolygonOptions, sizeof(tt__PolygonOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 soap_dup_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions *d, tt__PolygonOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PolygonOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PolygonOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PolygonOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__PolygonOptions::RectangleOnly, &a->tt__PolygonOptions::RectangleOnly);
	soap_dup_PointerTott__IntRange(soap, &d->tt__PolygonOptions::VertexLimits, &a->tt__PolygonOptions::VertexLimits);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PolygonOptions(tt__PolygonOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__PolygonOptions::RectangleOnly);
	soap_del_PointerTott__IntRange(&a->tt__PolygonOptions::VertexLimits);
}

SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 soap_instantiate_tt__PolygonOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PolygonOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PolygonOptions *p;
	size_t k = sizeof(tt__PolygonOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PolygonOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PolygonOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PolygonOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PolygonOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PolygonOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PolygonOptions(soap, tag ? tag : "tt:PolygonOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PolygonOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PolygonOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PolygonOptions * SOAP_FMAC4 soap_get_tt__PolygonOptions(struct soap *soap, tt__PolygonOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PolygonOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDConfigurationOptionsExtension");
}

void *tt__OSDConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__OSDConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, sizeof(tt__OSDConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationOptionsExtension)
		return (tt__OSDConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_dup_tt__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *d, tt__OSDConfigurationOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDConfigurationOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDConfigurationOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDConfigurationOptionsExtension(tt__OSDConfigurationOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__OSDConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationOptionsExtension(soap, tag ? tag : "tt:OSDConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptionsExtension(struct soap *soap, tt__OSDConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__OSDConfigurationOptions::MaximumNumberOfOSDs = NULL;
	soap_default_std__vectorTemplateOftt__OSDType(soap, &this->tt__OSDConfigurationOptions::Type);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDConfigurationOptions::PositionOption);
	this->tt__OSDConfigurationOptions::TextOption = NULL;
	this->tt__OSDConfigurationOptions::ImageOption = NULL;
	this->tt__OSDConfigurationOptions::Extension = NULL;
}

void tt__OSDConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MaximumNumberOfOSDs(soap, &this->tt__OSDConfigurationOptions::MaximumNumberOfOSDs);
	soap_serialize_std__vectorTemplateOftt__OSDType(soap, &this->tt__OSDConfigurationOptions::Type);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDConfigurationOptions::PositionOption);
	soap_serialize_PointerTott__OSDTextOptions(soap, &this->tt__OSDConfigurationOptions::TextOption);
	soap_serialize_PointerTott__OSDImgOptions(soap, &this->tt__OSDConfigurationOptions::ImageOption);
	soap_serialize_PointerTott__OSDConfigurationOptionsExtension(soap, &this->tt__OSDConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfigurationOptions), type ? type : "tt:OSDConfigurationOptions"))
		return soap->error;
	if (!a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs)
	{	if (soap_element_empty(soap, "tt:MaximumNumberOfOSDs", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", -1, &a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__OSDType(soap, "tt:Type", -1, &a->tt__OSDConfigurationOptions::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:PositionOption", -1, &a->tt__OSDConfigurationOptions::PositionOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptions(soap, "tt:TextOption", -1, &a->tt__OSDConfigurationOptions::TextOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptions(soap, "tt:ImageOption", -1, &a->tt__OSDConfigurationOptions::ImageOption, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptions * SOAP_FMAC4 soap_in_tt__OSDConfigurationOptions(struct soap *soap, const char *tag, tt__OSDConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(tt__OSDConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_MaximumNumberOfOSDs1 = 1;
	size_t soap_flag_TextOption1 = 1;
	size_t soap_flag_ImageOption1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfOSDs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MaximumNumberOfOSDs(soap, "tt:MaximumNumberOfOSDs", &a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs, "tt:MaximumNumberOfOSDs"))
				{	soap_flag_MaximumNumberOfOSDs1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__OSDType(soap, "tt:Type", &a->tt__OSDConfigurationOptions::Type, "tt:OSDType"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:PositionOption", &a->tt__OSDConfigurationOptions::PositionOption, "xsd:string"))
					continue;
			}
			if (soap_flag_TextOption1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptions(soap, "tt:TextOption", &a->tt__OSDConfigurationOptions::TextOption, "tt:OSDTextOptions"))
				{	soap_flag_TextOption1--;
					continue;
				}
			}
			if (soap_flag_ImageOption1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptions(soap, "tt:ImageOption", &a->tt__OSDConfigurationOptions::ImageOption, "tt:OSDImgOptions"))
				{	soap_flag_ImageOption1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__OSDConfigurationOptions::Extension, "tt:OSDConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs || a->tt__OSDConfigurationOptions::Type.size() < 1 || a->tt__OSDConfigurationOptions::PositionOption.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfigurationOptions, SOAP_TYPE_tt__OSDConfigurationOptions, sizeof(tt__OSDConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_dup_tt__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions *d, tt__OSDConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__MaximumNumberOfOSDs(soap, &d->tt__OSDConfigurationOptions::MaximumNumberOfOSDs, &a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs);
	soap_dup_std__vectorTemplateOftt__OSDType(soap, &d->tt__OSDConfigurationOptions::Type, &a->tt__OSDConfigurationOptions::Type);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__OSDConfigurationOptions::PositionOption, &a->tt__OSDConfigurationOptions::PositionOption);
	soap_dup_PointerTott__OSDTextOptions(soap, &d->tt__OSDConfigurationOptions::TextOption, &a->tt__OSDConfigurationOptions::TextOption);
	soap_dup_PointerTott__OSDImgOptions(soap, &d->tt__OSDConfigurationOptions::ImageOption, &a->tt__OSDConfigurationOptions::ImageOption);
	soap_dup_PointerTott__OSDConfigurationOptionsExtension(soap, &d->tt__OSDConfigurationOptions::Extension, &a->tt__OSDConfigurationOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDConfigurationOptions(tt__OSDConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__MaximumNumberOfOSDs(&a->tt__OSDConfigurationOptions::MaximumNumberOfOSDs);
	soap_del_std__vectorTemplateOftt__OSDType(&a->tt__OSDConfigurationOptions::Type);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__OSDConfigurationOptions::PositionOption);
	soap_del_PointerTott__OSDTextOptions(&a->tt__OSDConfigurationOptions::TextOption);
	soap_del_PointerTott__OSDImgOptions(&a->tt__OSDConfigurationOptions::ImageOption);
	soap_del_PointerTott__OSDConfigurationOptionsExtension(&a->tt__OSDConfigurationOptions::Extension);
}

SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationOptions *p;
	size_t k = sizeof(tt__OSDConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationOptions(soap, tag ? tag : "tt:OSDConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationOptions * SOAP_FMAC4 soap_get_tt__OSDConfigurationOptions(struct soap *soap, tt__OSDConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MaximumNumberOfOSDs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__MaximumNumberOfOSDs::Total);
	this->tt__MaximumNumberOfOSDs::Image = NULL;
	this->tt__MaximumNumberOfOSDs::PlainText = NULL;
	this->tt__MaximumNumberOfOSDs::Date = NULL;
	this->tt__MaximumNumberOfOSDs::Time = NULL;
	this->tt__MaximumNumberOfOSDs::DateAndTime = NULL;
}

void tt__MaximumNumberOfOSDs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MaximumNumberOfOSDs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MaximumNumberOfOSDs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, int id, const tt__MaximumNumberOfOSDs *a, const char *type)
{
	soap_set_attr(soap, "Total", soap_int2s(soap, ((tt__MaximumNumberOfOSDs*)a)->Total), 1);
	if (((tt__MaximumNumberOfOSDs*)a)->Image)
	{	soap_set_attr(soap, "Image", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Image), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->PlainText)
	{	soap_set_attr(soap, "PlainText", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->PlainText), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->Date)
	{	soap_set_attr(soap, "Date", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Date), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->Time)
	{	soap_set_attr(soap, "Time", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->Time), 1);
	}
	if (((tt__MaximumNumberOfOSDs*)a)->DateAndTime)
	{	soap_set_attr(soap, "DateAndTime", soap_int2s(soap, *((tt__MaximumNumberOfOSDs*)a)->DateAndTime), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:MaximumNumberOfOSDs");
}

void *tt__MaximumNumberOfOSDs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MaximumNumberOfOSDs(soap, tag, this, type);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_in_tt__MaximumNumberOfOSDs(struct soap *soap, const char *tag, tt__MaximumNumberOfOSDs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MaximumNumberOfOSDs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MaximumNumberOfOSDs, sizeof(tt__MaximumNumberOfOSDs), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MaximumNumberOfOSDs)
		return (tt__MaximumNumberOfOSDs *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "Total", 5, 3), &((tt__MaximumNumberOfOSDs*)a)->Total))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Image", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Image = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Image))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PlainText", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->PlainText = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->PlainText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Date", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Date = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Date))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Time", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->Time = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->Time))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DateAndTime", 5, 0);
		if (t)
		{
			if (!(((tt__MaximumNumberOfOSDs*)a)->DateAndTime = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MaximumNumberOfOSDs*)a)->DateAndTime))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_dup_tt__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *d, tt__MaximumNumberOfOSDs const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MaximumNumberOfOSDs*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MaximumNumberOfOSDs, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MaximumNumberOfOSDs(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__MaximumNumberOfOSDs::Total = a->tt__MaximumNumberOfOSDs::Total;
	soap_dup_PointerToint(soap, &d->tt__MaximumNumberOfOSDs::Image, &a->tt__MaximumNumberOfOSDs::Image);
	soap_dup_PointerToint(soap, &d->tt__MaximumNumberOfOSDs::PlainText, &a->tt__MaximumNumberOfOSDs::PlainText);
	soap_dup_PointerToint(soap, &d->tt__MaximumNumberOfOSDs::Date, &a->tt__MaximumNumberOfOSDs::Date);
	soap_dup_PointerToint(soap, &d->tt__MaximumNumberOfOSDs::Time, &a->tt__MaximumNumberOfOSDs::Time);
	soap_dup_PointerToint(soap, &d->tt__MaximumNumberOfOSDs::DateAndTime, &a->tt__MaximumNumberOfOSDs::DateAndTime);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MaximumNumberOfOSDs(tt__MaximumNumberOfOSDs const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Total skipped */
	soap_del_PointerToint(&a->tt__MaximumNumberOfOSDs::Image);
	soap_del_PointerToint(&a->tt__MaximumNumberOfOSDs::PlainText);
	soap_del_PointerToint(&a->tt__MaximumNumberOfOSDs::Date);
	soap_del_PointerToint(&a->tt__MaximumNumberOfOSDs::Time);
	soap_del_PointerToint(&a->tt__MaximumNumberOfOSDs::DateAndTime);
}

SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MaximumNumberOfOSDs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MaximumNumberOfOSDs *p;
	size_t k = sizeof(tt__MaximumNumberOfOSDs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MaximumNumberOfOSDs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MaximumNumberOfOSDs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MaximumNumberOfOSDs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MaximumNumberOfOSDs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MaximumNumberOfOSDs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MaximumNumberOfOSDs(soap, tag ? tag : "tt:MaximumNumberOfOSDs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MaximumNumberOfOSDs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MaximumNumberOfOSDs(soap, this, tag, type);
}

SOAP_FMAC3 tt__MaximumNumberOfOSDs * SOAP_FMAC4 soap_get_tt__MaximumNumberOfOSDs(struct soap *soap, tt__MaximumNumberOfOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MaximumNumberOfOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDConfigurationExtension");
}

void *tt__OSDConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDConfigurationExtension(struct soap *soap, const char *tag, tt__OSDConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfigurationExtension, sizeof(tt__OSDConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfigurationExtension)
		return (tt__OSDConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_dup_tt__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *d, tt__OSDConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDConfigurationExtension(tt__OSDConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfigurationExtension *p;
	size_t k = sizeof(tt__OSDConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfigurationExtension(soap, tag ? tag : "tt:OSDConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDConfigurationExtension(struct soap *soap, tt__OSDConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__OSDConfiguration::VideoSourceConfigurationToken = NULL;
	soap_default_tt__OSDType(soap, &this->tt__OSDConfiguration::Type);
	this->tt__OSDConfiguration::Position = NULL;
	this->tt__OSDConfiguration::TextString = NULL;
	this->tt__OSDConfiguration::Image = NULL;
	this->tt__OSDConfiguration::Extension = NULL;
}

void tt__OSDConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__OSDReference(soap, &this->tt__OSDConfiguration::VideoSourceConfigurationToken);
	soap_serialize_PointerTott__OSDPosConfiguration(soap, &this->tt__OSDConfiguration::Position);
	soap_serialize_PointerTott__OSDTextConfiguration(soap, &this->tt__OSDConfiguration::TextString);
	soap_serialize_PointerTott__OSDImgConfiguration(soap, &this->tt__OSDConfiguration::Image);
	soap_serialize_PointerTott__OSDConfigurationExtension(soap, &this->tt__OSDConfiguration::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__OSDConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDConfiguration), type ? type : "tt:OSDConfiguration"))
		return soap->error;
	if (!a->tt__OSDConfiguration::VideoSourceConfigurationToken)
	{	if (soap_element_empty(soap, "tt:VideoSourceConfigurationToken", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", -1, &a->tt__OSDConfiguration::VideoSourceConfigurationToken, ""))
		return soap->error;
	if (soap_out_tt__OSDType(soap, "tt:Type", -1, &a->tt__OSDConfiguration::Type, ""))
		return soap->error;
	if (!a->tt__OSDConfiguration::Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OSDPosConfiguration(soap, "tt:Position", -1, &a->tt__OSDConfiguration::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfiguration(soap, "tt:TextString", -1, &a->tt__OSDConfiguration::TextString, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfiguration(soap, "tt:Image", -1, &a->tt__OSDConfiguration::Image, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDConfiguration * SOAP_FMAC4 soap_in_tt__OSDConfiguration(struct soap *soap, const char *tag, tt__OSDConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDConfiguration, sizeof(tt__OSDConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_VideoSourceConfigurationToken1 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_TextString1 = 1;
	size_t soap_flag_Image1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceConfigurationToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDReference(soap, "tt:VideoSourceConfigurationToken", &a->tt__OSDConfiguration::VideoSourceConfigurationToken, "tt:OSDReference"))
				{	soap_flag_VideoSourceConfigurationToken1--;
					continue;
				}
			}
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__OSDType(soap, "tt:Type", &a->tt__OSDConfiguration::Type, "tt:OSDType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfiguration(soap, "tt:Position", &a->tt__OSDConfiguration::Position, "tt:OSDPosConfiguration"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_TextString1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfiguration(soap, "tt:TextString", &a->tt__OSDConfiguration::TextString, "tt:OSDTextConfiguration"))
				{	soap_flag_TextString1--;
					continue;
				}
			}
			if (soap_flag_Image1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfiguration(soap, "tt:Image", &a->tt__OSDConfiguration::Image, "tt:OSDImgConfiguration"))
				{	soap_flag_Image1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDConfigurationExtension(soap, "tt:Extension", &a->tt__OSDConfiguration::Extension, "tt:OSDConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__OSDConfiguration::VideoSourceConfigurationToken || soap_flag_Type1 > 0 || !a->tt__OSDConfiguration::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_tt__OSDConfiguration, sizeof(tt__OSDConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_dup_tt__OSDConfiguration(struct soap *soap, tt__OSDConfiguration *d, tt__OSDConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	soap_dup_PointerTott__OSDReference(soap, &d->tt__OSDConfiguration::VideoSourceConfigurationToken, &a->tt__OSDConfiguration::VideoSourceConfigurationToken);
	d->tt__OSDConfiguration::Type = a->tt__OSDConfiguration::Type;
	soap_dup_PointerTott__OSDPosConfiguration(soap, &d->tt__OSDConfiguration::Position, &a->tt__OSDConfiguration::Position);
	soap_dup_PointerTott__OSDTextConfiguration(soap, &d->tt__OSDConfiguration::TextString, &a->tt__OSDConfiguration::TextString);
	soap_dup_PointerTott__OSDImgConfiguration(soap, &d->tt__OSDConfiguration::Image, &a->tt__OSDConfiguration::Image);
	soap_dup_PointerTott__OSDConfigurationExtension(soap, &d->tt__OSDConfiguration::Extension, &a->tt__OSDConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDConfiguration(tt__OSDConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	soap_del_PointerTott__OSDReference(&a->tt__OSDConfiguration::VideoSourceConfigurationToken);
	/* Type skipped */
	soap_del_PointerTott__OSDPosConfiguration(&a->tt__OSDConfiguration::Position);
	soap_del_PointerTott__OSDTextConfiguration(&a->tt__OSDConfiguration::TextString);
	soap_del_PointerTott__OSDImgConfiguration(&a->tt__OSDConfiguration::Image);
	soap_del_PointerTott__OSDConfigurationExtension(&a->tt__OSDConfiguration::Extension);
}

SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDConfiguration *p;
	size_t k = sizeof(tt__OSDConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDConfiguration(soap, tag ? tag : "tt:OSDConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDConfiguration * SOAP_FMAC4 soap_get_tt__OSDConfiguration(struct soap *soap, tt__OSDConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDImgOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDImgOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDImgOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDImgOptionsExtension");
}

void *tt__OSDImgOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDImgOptionsExtension(struct soap *soap, const char *tag, tt__OSDImgOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDImgOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptionsExtension, sizeof(tt__OSDImgOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgOptionsExtension)
		return (tt__OSDImgOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_dup_tt__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *d, tt__OSDImgOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDImgOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDImgOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDImgOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDImgOptionsExtension(tt__OSDImgOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgOptionsExtension *p;
	size_t k = sizeof(tt__OSDImgOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgOptionsExtension(soap, tag ? tag : "tt:OSDImgOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDImgOptionsExtension(struct soap *soap, tt__OSDImgOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__OSDImgOptions::ImagePath);
	this->tt__OSDImgOptions::Extension = NULL;
	this->tt__OSDImgOptions::FormatsSupported = NULL;
	this->tt__OSDImgOptions::MaxSize = NULL;
	this->tt__OSDImgOptions::MaxWidth = NULL;
	this->tt__OSDImgOptions::MaxHeight = NULL;
}

void tt__OSDImgOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__OSDImgOptions::ImagePath);
	soap_serialize_PointerTott__OSDImgOptionsExtension(soap, &this->tt__OSDImgOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDImgOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgOptions(struct soap *soap, const char *tag, int id, const tt__OSDImgOptions *a, const char *type)
{
	if (((tt__OSDImgOptions*)a)->FormatsSupported)
	{	soap_set_attr(soap, "FormatsSupported", soap_tt__StringAttrList2s(soap, *((tt__OSDImgOptions*)a)->FormatsSupported), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxSize)
	{	soap_set_attr(soap, "MaxSize", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxSize), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxWidth)
	{	soap_set_attr(soap, "MaxWidth", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxWidth), 1);
	}
	if (((tt__OSDImgOptions*)a)->MaxHeight)
	{	soap_set_attr(soap, "MaxHeight", soap_int2s(soap, *((tt__OSDImgOptions*)a)->MaxHeight), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgOptions), type ? type : "tt:OSDImgOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:ImagePath", -1, &a->tt__OSDImgOptions::ImagePath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDImgOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgOptions * SOAP_FMAC4 soap_in_tt__OSDImgOptions(struct soap *soap, const char *tag, tt__OSDImgOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FormatsSupported", 1, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->FormatsSupported = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tt__OSDImgOptions*)a)->FormatsSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxSize", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxSize = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxSize))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxWidth", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxWidth = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxWidth))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxHeight", 5, 0);
		if (t)
		{
			if (!(((tt__OSDImgOptions*)a)->MaxHeight = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__OSDImgOptions*)a)->MaxHeight))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:ImagePath", &a->tt__OSDImgOptions::ImagePath, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgOptionsExtension(soap, "tt:Extension", &a->tt__OSDImgOptions::Extension, "tt:OSDImgOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__OSDImgOptions::ImagePath.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDImgOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgOptions, SOAP_TYPE_tt__OSDImgOptions, sizeof(tt__OSDImgOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_dup_tt__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *d, tt__OSDImgOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDImgOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDImgOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDImgOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->tt__OSDImgOptions::ImagePath, &a->tt__OSDImgOptions::ImagePath);
	soap_dup_PointerTott__OSDImgOptionsExtension(soap, &d->tt__OSDImgOptions::Extension, &a->tt__OSDImgOptions::Extension);
	soap_dup_PointerTott__StringAttrList(soap, &d->tt__OSDImgOptions::FormatsSupported, &a->tt__OSDImgOptions::FormatsSupported);
	soap_dup_PointerToint(soap, &d->tt__OSDImgOptions::MaxSize, &a->tt__OSDImgOptions::MaxSize);
	soap_dup_PointerToint(soap, &d->tt__OSDImgOptions::MaxWidth, &a->tt__OSDImgOptions::MaxWidth);
	soap_dup_PointerToint(soap, &d->tt__OSDImgOptions::MaxHeight, &a->tt__OSDImgOptions::MaxHeight);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDImgOptions(tt__OSDImgOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->tt__OSDImgOptions::ImagePath);
	soap_del_PointerTott__OSDImgOptionsExtension(&a->tt__OSDImgOptions::Extension);
	soap_del_PointerTott__StringAttrList(&a->tt__OSDImgOptions::FormatsSupported);
	soap_del_PointerToint(&a->tt__OSDImgOptions::MaxSize);
	soap_del_PointerToint(&a->tt__OSDImgOptions::MaxWidth);
	soap_del_PointerToint(&a->tt__OSDImgOptions::MaxHeight);
}

SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgOptions *p;
	size_t k = sizeof(tt__OSDImgOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgOptions(soap, tag ? tag : "tt:OSDImgOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgOptions * SOAP_FMAC4 soap_get_tt__OSDImgOptions(struct soap *soap, tt__OSDImgOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDTextOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDTextOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDTextOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDTextOptionsExtension");
}

void *tt__OSDTextOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDTextOptionsExtension(struct soap *soap, const char *tag, tt__OSDTextOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDTextOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptionsExtension, sizeof(tt__OSDTextOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextOptionsExtension)
		return (tt__OSDTextOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_dup_tt__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *d, tt__OSDTextOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDTextOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDTextOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDTextOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDTextOptionsExtension(tt__OSDTextOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextOptionsExtension *p;
	size_t k = sizeof(tt__OSDTextOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextOptionsExtension(soap, tag ? tag : "tt:OSDTextOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDTextOptionsExtension(struct soap *soap, tt__OSDTextOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::Type);
	this->tt__OSDTextOptions::FontSizeRange = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::DateFormat);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::TimeFormat);
	this->tt__OSDTextOptions::FontColor = NULL;
	this->tt__OSDTextOptions::BackgroundColor = NULL;
	this->tt__OSDTextOptions::Extension = NULL;
}

void tt__OSDTextOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::Type);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__OSDTextOptions::FontSizeRange);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::DateFormat);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__OSDTextOptions::TimeFormat);
	soap_serialize_PointerTott__OSDColorOptions(soap, &this->tt__OSDTextOptions::FontColor);
	soap_serialize_PointerTott__OSDColorOptions(soap, &this->tt__OSDTextOptions::BackgroundColor);
	soap_serialize_PointerTott__OSDTextOptionsExtension(soap, &this->tt__OSDTextOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDTextOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextOptions(struct soap *soap, const char *tag, int id, const tt__OSDTextOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextOptions), type ? type : "tt:OSDTextOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Type", -1, &a->tt__OSDTextOptions::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:FontSizeRange", -1, &a->tt__OSDTextOptions::FontSizeRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:DateFormat", -1, &a->tt__OSDTextOptions::DateFormat, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:TimeFormat", -1, &a->tt__OSDTextOptions::TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:FontColor", -1, &a->tt__OSDTextOptions::FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", -1, &a->tt__OSDTextOptions::BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDTextOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextOptions * SOAP_FMAC4 soap_in_tt__OSDTextOptions(struct soap *soap, const char *tag, tt__OSDTextOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FontSizeRange1 = 1;
	size_t soap_flag_FontColor1 = 1;
	size_t soap_flag_BackgroundColor1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Type", &a->tt__OSDTextOptions::Type, "xsd:string"))
					continue;
			}
			if (soap_flag_FontSizeRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FontSizeRange", &a->tt__OSDTextOptions::FontSizeRange, "tt:IntRange"))
				{	soap_flag_FontSizeRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:DateFormat", &a->tt__OSDTextOptions::DateFormat, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:TimeFormat", &a->tt__OSDTextOptions::TimeFormat, "xsd:string"))
					continue;
			}
			if (soap_flag_FontColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:FontColor", &a->tt__OSDTextOptions::FontColor, "tt:OSDColorOptions"))
				{	soap_flag_FontColor1--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptions(soap, "tt:BackgroundColor", &a->tt__OSDTextOptions::BackgroundColor, "tt:OSDColorOptions"))
				{	soap_flag_BackgroundColor1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextOptionsExtension(soap, "tt:Extension", &a->tt__OSDTextOptions::Extension, "tt:OSDTextOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__OSDTextOptions::Type.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDTextOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextOptions, SOAP_TYPE_tt__OSDTextOptions, sizeof(tt__OSDTextOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_dup_tt__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *d, tt__OSDTextOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDTextOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDTextOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDTextOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__OSDTextOptions::Type, &a->tt__OSDTextOptions::Type);
	soap_dup_PointerTott__IntRange(soap, &d->tt__OSDTextOptions::FontSizeRange, &a->tt__OSDTextOptions::FontSizeRange);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__OSDTextOptions::DateFormat, &a->tt__OSDTextOptions::DateFormat);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__OSDTextOptions::TimeFormat, &a->tt__OSDTextOptions::TimeFormat);
	soap_dup_PointerTott__OSDColorOptions(soap, &d->tt__OSDTextOptions::FontColor, &a->tt__OSDTextOptions::FontColor);
	soap_dup_PointerTott__OSDColorOptions(soap, &d->tt__OSDTextOptions::BackgroundColor, &a->tt__OSDTextOptions::BackgroundColor);
	soap_dup_PointerTott__OSDTextOptionsExtension(soap, &d->tt__OSDTextOptions::Extension, &a->tt__OSDTextOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDTextOptions(tt__OSDTextOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__OSDTextOptions::Type);
	soap_del_PointerTott__IntRange(&a->tt__OSDTextOptions::FontSizeRange);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__OSDTextOptions::DateFormat);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__OSDTextOptions::TimeFormat);
	soap_del_PointerTott__OSDColorOptions(&a->tt__OSDTextOptions::FontColor);
	soap_del_PointerTott__OSDColorOptions(&a->tt__OSDTextOptions::BackgroundColor);
	soap_del_PointerTott__OSDTextOptionsExtension(&a->tt__OSDTextOptions::Extension);
}

SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextOptions *p;
	size_t k = sizeof(tt__OSDTextOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextOptions(soap, tag ? tag : "tt:OSDTextOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextOptions * SOAP_FMAC4 soap_get_tt__OSDTextOptions(struct soap *soap, tt__OSDTextOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColorOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDColorOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDColorOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColorOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, int id, const tt__OSDColorOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDColorOptionsExtension");
}

void *tt__OSDColorOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColorOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_in_tt__OSDColorOptionsExtension(struct soap *soap, const char *tag, tt__OSDColorOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDColorOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptionsExtension, sizeof(tt__OSDColorOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColorOptionsExtension)
		return (tt__OSDColorOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_dup_tt__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *d, tt__OSDColorOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDColorOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDColorOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDColorOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDColorOptionsExtension(tt__OSDColorOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColorOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColorOptionsExtension *p;
	size_t k = sizeof(tt__OSDColorOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColorOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColorOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColorOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColorOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColorOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColorOptionsExtension(soap, tag ? tag : "tt:OSDColorOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColorOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColorOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColorOptionsExtension * SOAP_FMAC4 soap_get_tt__OSDColorOptionsExtension(struct soap *soap, tt__OSDColorOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColorOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__OSDColorOptions::Color = NULL;
	this->tt__OSDColorOptions::Transparent = NULL;
	this->tt__OSDColorOptions::Extension = NULL;
}

void tt__OSDColorOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ColorOptions(soap, &this->tt__OSDColorOptions::Color);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__OSDColorOptions::Transparent);
	soap_serialize_PointerTott__OSDColorOptionsExtension(soap, &this->tt__OSDColorOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDColorOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColorOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColorOptions(struct soap *soap, const char *tag, int id, const tt__OSDColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColorOptions), type ? type : "tt:OSDColorOptions"))
		return soap->error;
	if (soap_out_PointerTott__ColorOptions(soap, "tt:Color", -1, &a->tt__OSDColorOptions::Color, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:Transparent", -1, &a->tt__OSDColorOptions::Transparent, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", -1, &a->tt__OSDColorOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDColorOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColorOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColorOptions * SOAP_FMAC4 soap_in_tt__OSDColorOptions(struct soap *soap, const char *tag, tt__OSDColorOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColorOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDColorOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Color1 = 1;
	size_t soap_flag_Transparent1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ColorOptions(soap, "tt:Color", &a->tt__OSDColorOptions::Color, "tt:ColorOptions"))
				{	soap_flag_Color1--;
					continue;
				}
			}
			if (soap_flag_Transparent1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:Transparent", &a->tt__OSDColorOptions::Transparent, "tt:IntRange"))
				{	soap_flag_Transparent1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColorOptionsExtension(soap, "tt:Extension", &a->tt__OSDColorOptions::Extension, "tt:OSDColorOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__OSDColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColorOptions, SOAP_TYPE_tt__OSDColorOptions, sizeof(tt__OSDColorOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_dup_tt__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *d, tt__OSDColorOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDColorOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDColorOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDColorOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ColorOptions(soap, &d->tt__OSDColorOptions::Color, &a->tt__OSDColorOptions::Color);
	soap_dup_PointerTott__IntRange(soap, &d->tt__OSDColorOptions::Transparent, &a->tt__OSDColorOptions::Transparent);
	soap_dup_PointerTott__OSDColorOptionsExtension(soap, &d->tt__OSDColorOptions::Extension, &a->tt__OSDColorOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDColorOptions(tt__OSDColorOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ColorOptions(&a->tt__OSDColorOptions::Color);
	soap_del_PointerTott__IntRange(&a->tt__OSDColorOptions::Transparent);
	soap_del_PointerTott__OSDColorOptionsExtension(&a->tt__OSDColorOptions::Extension);
}

SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColorOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColorOptions *p;
	size_t k = sizeof(tt__OSDColorOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColorOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColorOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColorOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColorOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColorOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColorOptions(soap, tag ? tag : "tt:OSDColorOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColorOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColorOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColorOptions * SOAP_FMAC4 soap_get_tt__OSDColorOptions(struct soap *soap, tt__OSDColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ColorOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ColorOptions::__union_ColorOptions = 0;
}

void tt__ColorOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_ColorOptions(soap, this->tt__ColorOptions::__union_ColorOptions, &this->tt__ColorOptions::union_ColorOptions);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ColorOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorOptions(struct soap *soap, const char *tag, int id, const tt__ColorOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorOptions), type ? type : "tt:ColorOptions"))
		return soap->error;
	if (soap_out__tt__union_ColorOptions(soap, a->tt__ColorOptions::__union_ColorOptions, &a->tt__ColorOptions::union_ColorOptions))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ColorOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ColorOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorOptions * SOAP_FMAC4 soap_in_tt__ColorOptions(struct soap *soap, const char *tag, tt__ColorOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ColorOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ColorOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_union_ColorOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_ColorOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__tt__union_ColorOptions(soap, &a->tt__ColorOptions::__union_ColorOptions, &a->tt__ColorOptions::union_ColorOptions))
				{	soap_flag_union_ColorOptions1 = 0;
					continue;
				}
		}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ColorOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorOptions, SOAP_TYPE_tt__ColorOptions, sizeof(tt__ColorOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_dup_tt__ColorOptions(struct soap *soap, tt__ColorOptions *d, tt__ColorOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ColorOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ColorOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ColorOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__ColorOptions::__union_ColorOptions = a->tt__ColorOptions::__union_ColorOptions;
	switch (a->tt__ColorOptions::__union_ColorOptions)
	{
		case SOAP_UNION__tt__union_ColorOptions_ColorList:
			soap_dup_PointerTostd__vectorTemplateOfPointerTott__Color(soap, &d->tt__ColorOptions::union_ColorOptions.ColorList, &a->tt__ColorOptions::union_ColorOptions.ColorList);
			break;
		case SOAP_UNION__tt__union_ColorOptions_ColorspaceRange:
			soap_dup_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, &d->tt__ColorOptions::union_ColorOptions.ColorspaceRange, &a->tt__ColorOptions::union_ColorOptions.ColorspaceRange);
			break;
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ColorOptions(tt__ColorOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	switch (a->tt__ColorOptions::__union_ColorOptions)
	{
		case SOAP_UNION__tt__union_ColorOptions_ColorList:
			soap_del_PointerTostd__vectorTemplateOfPointerTott__Color(&a->tt__ColorOptions::union_ColorOptions.ColorList);
			break;
		case SOAP_UNION__tt__union_ColorOptions_ColorspaceRange:
			soap_del_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(&a->tt__ColorOptions::union_ColorOptions.ColorspaceRange);
			break;
	}
}

SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ColorOptions *p;
	size_t k = sizeof(tt__ColorOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ColorOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ColorOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ColorOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ColorOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ColorOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ColorOptions(soap, tag ? tag : "tt:ColorOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorOptions * SOAP_FMAC4 soap_get_tt__ColorOptions(struct soap *soap, tt__ColorOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ColorspaceRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ColorspaceRange::X = NULL;
	this->tt__ColorspaceRange::Y = NULL;
	this->tt__ColorspaceRange::Z = NULL;
	soap_default_xsd__anyURI(soap, &this->tt__ColorspaceRange::Colorspace);
}

void tt__ColorspaceRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::X);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::Y);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ColorspaceRange::Z);
	soap_embedded(soap, &this->tt__ColorspaceRange::Colorspace, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ColorspaceRange::Colorspace);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ColorspaceRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ColorspaceRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ColorspaceRange(struct soap *soap, const char *tag, int id, const tt__ColorspaceRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ColorspaceRange), type ? type : "tt:ColorspaceRange"))
		return soap->error;
	if (!a->tt__ColorspaceRange::X)
	{	if (soap_element_empty(soap, "tt:X", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:X", -1, &a->tt__ColorspaceRange::X, ""))
		return soap->error;
	if (!a->tt__ColorspaceRange::Y)
	{	if (soap_element_empty(soap, "tt:Y", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Y", -1, &a->tt__ColorspaceRange::Y, ""))
		return soap->error;
	if (!a->tt__ColorspaceRange::Z)
	{	if (soap_element_empty(soap, "tt:Z", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Z", -1, &a->tt__ColorspaceRange::Z, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Colorspace", -1, &a->tt__ColorspaceRange::Colorspace, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ColorspaceRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ColorspaceRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__ColorspaceRange * SOAP_FMAC4 soap_in_tt__ColorspaceRange(struct soap *soap, const char *tag, tt__ColorspaceRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ColorspaceRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ColorspaceRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ColorspaceRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_X1 = 1;
	size_t soap_flag_Y1 = 1;
	size_t soap_flag_Z1 = 1;
	size_t soap_flag_Colorspace1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:X", &a->tt__ColorspaceRange::X, "tt:FloatRange"))
				{	soap_flag_X1--;
					continue;
				}
			}
			if (soap_flag_Y1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Y", &a->tt__ColorspaceRange::Y, "tt:FloatRange"))
				{	soap_flag_Y1--;
					continue;
				}
			}
			if (soap_flag_Z1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Z", &a->tt__ColorspaceRange::Z, "tt:FloatRange"))
				{	soap_flag_Z1--;
					continue;
				}
			}
			if (soap_flag_Colorspace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Colorspace", &a->tt__ColorspaceRange::Colorspace, "xsd:anyURI"))
				{	soap_flag_Colorspace1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__ColorspaceRange::X || !a->tt__ColorspaceRange::Y || !a->tt__ColorspaceRange::Z || soap_flag_Colorspace1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ColorspaceRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ColorspaceRange, SOAP_TYPE_tt__ColorspaceRange, sizeof(tt__ColorspaceRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_dup_tt__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *d, tt__ColorspaceRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ColorspaceRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ColorspaceRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ColorspaceRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ColorspaceRange::X, &a->tt__ColorspaceRange::X);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ColorspaceRange::Y, &a->tt__ColorspaceRange::Y);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ColorspaceRange::Z, &a->tt__ColorspaceRange::Z);
	soap_dup_xsd__anyURI(soap, &d->tt__ColorspaceRange::Colorspace, &a->tt__ColorspaceRange::Colorspace);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ColorspaceRange(tt__ColorspaceRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__FloatRange(&a->tt__ColorspaceRange::X);
	soap_del_PointerTott__FloatRange(&a->tt__ColorspaceRange::Y);
	soap_del_PointerTott__FloatRange(&a->tt__ColorspaceRange::Z);
	soap_del_xsd__anyURI(&a->tt__ColorspaceRange::Colorspace);
}

SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ColorspaceRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ColorspaceRange *p;
	size_t k = sizeof(tt__ColorspaceRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ColorspaceRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ColorspaceRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ColorspaceRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ColorspaceRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ColorspaceRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ColorspaceRange(soap, tag ? tag : "tt:ColorspaceRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ColorspaceRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ColorspaceRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__ColorspaceRange * SOAP_FMAC4 soap_get_tt__ColorspaceRange(struct soap *soap, tt__ColorspaceRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ColorspaceRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDImgConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDImgConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDImgConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDImgConfigurationExtension");
}

void *tt__OSDImgConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDImgConfigurationExtension(struct soap *soap, const char *tag, tt__OSDImgConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDImgConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfigurationExtension, sizeof(tt__OSDImgConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgConfigurationExtension)
		return (tt__OSDImgConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_dup_tt__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *d, tt__OSDImgConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDImgConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDImgConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDImgConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDImgConfigurationExtension(tt__OSDImgConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgConfigurationExtension *p;
	size_t k = sizeof(tt__OSDImgConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgConfigurationExtension(soap, tag ? tag : "tt:OSDImgConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDImgConfigurationExtension(struct soap *soap, tt__OSDImgConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDImgConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__OSDImgConfiguration::ImgPath);
	this->tt__OSDImgConfiguration::Extension = NULL;
}

void tt__OSDImgConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDImgConfiguration::ImgPath, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__OSDImgConfiguration::ImgPath);
	soap_serialize_PointerTott__OSDImgConfigurationExtension(soap, &this->tt__OSDImgConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDImgConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDImgConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDImgConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDImgConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDImgConfiguration), type ? type : "tt:OSDImgConfiguration"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ImgPath", -1, &a->tt__OSDImgConfiguration::ImgPath, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDImgConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDImgConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDImgConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDImgConfiguration * SOAP_FMAC4 soap_in_tt__OSDImgConfiguration(struct soap *soap, const char *tag, tt__OSDImgConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDImgConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDImgConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDImgConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImgPath1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImgPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ImgPath", &a->tt__OSDImgConfiguration::ImgPath, "xsd:anyURI"))
				{	soap_flag_ImgPath1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDImgConfigurationExtension(soap, "tt:Extension", &a->tt__OSDImgConfiguration::Extension, "tt:OSDImgConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_ImgPath1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDImgConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDImgConfiguration, SOAP_TYPE_tt__OSDImgConfiguration, sizeof(tt__OSDImgConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_dup_tt__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *d, tt__OSDImgConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDImgConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDImgConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDImgConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__OSDImgConfiguration::ImgPath, &a->tt__OSDImgConfiguration::ImgPath);
	soap_dup_PointerTott__OSDImgConfigurationExtension(soap, &d->tt__OSDImgConfiguration::Extension, &a->tt__OSDImgConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDImgConfiguration(tt__OSDImgConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__OSDImgConfiguration::ImgPath);
	soap_del_PointerTott__OSDImgConfigurationExtension(&a->tt__OSDImgConfiguration::Extension);
}

SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDImgConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDImgConfiguration *p;
	size_t k = sizeof(tt__OSDImgConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDImgConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDImgConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDImgConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDImgConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDImgConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDImgConfiguration(soap, tag ? tag : "tt:OSDImgConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDImgConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDImgConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDImgConfiguration * SOAP_FMAC4 soap_get_tt__OSDImgConfiguration(struct soap *soap, tt__OSDImgConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDImgConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDTextConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDTextConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDTextConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDTextConfigurationExtension");
}

void *tt__OSDTextConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDTextConfigurationExtension(struct soap *soap, const char *tag, tt__OSDTextConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDTextConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfigurationExtension, sizeof(tt__OSDTextConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextConfigurationExtension)
		return (tt__OSDTextConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_dup_tt__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *d, tt__OSDTextConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDTextConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDTextConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDTextConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDTextConfigurationExtension(tt__OSDTextConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextConfigurationExtension *p;
	size_t k = sizeof(tt__OSDTextConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextConfigurationExtension(soap, tag ? tag : "tt:OSDTextConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDTextConfigurationExtension(struct soap *soap, tt__OSDTextConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDTextConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__OSDTextConfiguration::Type);
	this->tt__OSDTextConfiguration::DateFormat = NULL;
	this->tt__OSDTextConfiguration::TimeFormat = NULL;
	this->tt__OSDTextConfiguration::FontSize = NULL;
	this->tt__OSDTextConfiguration::FontColor = NULL;
	this->tt__OSDTextConfiguration::BackgroundColor = NULL;
	this->tt__OSDTextConfiguration::PlainText = NULL;
	this->tt__OSDTextConfiguration::Extension = NULL;
	this->tt__OSDTextConfiguration::IsPersistentText = NULL;
}

void tt__OSDTextConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDTextConfiguration::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__OSDTextConfiguration::Type);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::DateFormat);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::TimeFormat);
	soap_serialize_PointerToint(soap, &this->tt__OSDTextConfiguration::FontSize);
	soap_serialize_PointerTott__OSDColor(soap, &this->tt__OSDTextConfiguration::FontColor);
	soap_serialize_PointerTott__OSDColor(soap, &this->tt__OSDTextConfiguration::BackgroundColor);
	soap_serialize_PointerTostd__string(soap, &this->tt__OSDTextConfiguration::PlainText);
	soap_serialize_PointerTott__OSDTextConfigurationExtension(soap, &this->tt__OSDTextConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDTextConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDTextConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDTextConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDTextConfiguration *a, const char *type)
{
	if (((tt__OSDTextConfiguration*)a)->IsPersistentText)
	{	soap_set_attr(soap, "IsPersistentText", soap_bool2s(soap, *((tt__OSDTextConfiguration*)a)->IsPersistentText), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDTextConfiguration), type ? type : "tt:OSDTextConfiguration"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Type", -1, &a->tt__OSDTextConfiguration::Type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:DateFormat", -1, &a->tt__OSDTextConfiguration::DateFormat, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:TimeFormat", -1, &a->tt__OSDTextConfiguration::TimeFormat, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:FontSize", -1, &a->tt__OSDTextConfiguration::FontSize, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:FontColor", -1, &a->tt__OSDTextConfiguration::FontColor, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDColor(soap, "tt:BackgroundColor", -1, &a->tt__OSDTextConfiguration::BackgroundColor, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:PlainText", -1, &a->tt__OSDTextConfiguration::PlainText, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDTextConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDTextConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDTextConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDTextConfiguration * SOAP_FMAC4 soap_in_tt__OSDTextConfiguration(struct soap *soap, const char *tag, tt__OSDTextConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDTextConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDTextConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDTextConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IsPersistentText", 5, 0);
		if (t)
		{
			if (!(((tt__OSDTextConfiguration*)a)->IsPersistentText = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__OSDTextConfiguration*)a)->IsPersistentText))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_DateFormat1 = 1;
	size_t soap_flag_TimeFormat1 = 1;
	size_t soap_flag_FontSize1 = 1;
	size_t soap_flag_FontColor1 = 1;
	size_t soap_flag_BackgroundColor1 = 1;
	size_t soap_flag_PlainText1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Type", &a->tt__OSDTextConfiguration::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_DateFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:DateFormat", &a->tt__OSDTextConfiguration::DateFormat, "xsd:string"))
				{	soap_flag_DateFormat1--;
					continue;
				}
			}
			if (soap_flag_TimeFormat1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:TimeFormat", &a->tt__OSDTextConfiguration::TimeFormat, "xsd:string"))
				{	soap_flag_TimeFormat1--;
					continue;
				}
			}
			if (soap_flag_FontSize1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:FontSize", &a->tt__OSDTextConfiguration::FontSize, "xsd:int"))
				{	soap_flag_FontSize1--;
					continue;
				}
			}
			if (soap_flag_FontColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:FontColor", &a->tt__OSDTextConfiguration::FontColor, "tt:OSDColor"))
				{	soap_flag_FontColor1--;
					continue;
				}
			}
			if (soap_flag_BackgroundColor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDColor(soap, "tt:BackgroundColor", &a->tt__OSDTextConfiguration::BackgroundColor, "tt:OSDColor"))
				{	soap_flag_BackgroundColor1--;
					continue;
				}
			}
			if (soap_flag_PlainText1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:PlainText", &a->tt__OSDTextConfiguration::PlainText, "xsd:string"))
				{	soap_flag_PlainText1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDTextConfigurationExtension(soap, "tt:Extension", &a->tt__OSDTextConfiguration::Extension, "tt:OSDTextConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDTextConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDTextConfiguration, SOAP_TYPE_tt__OSDTextConfiguration, sizeof(tt__OSDTextConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_dup_tt__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *d, tt__OSDTextConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDTextConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDTextConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDTextConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__OSDTextConfiguration::Type, &a->tt__OSDTextConfiguration::Type);
	soap_dup_PointerTostd__string(soap, &d->tt__OSDTextConfiguration::DateFormat, &a->tt__OSDTextConfiguration::DateFormat);
	soap_dup_PointerTostd__string(soap, &d->tt__OSDTextConfiguration::TimeFormat, &a->tt__OSDTextConfiguration::TimeFormat);
	soap_dup_PointerToint(soap, &d->tt__OSDTextConfiguration::FontSize, &a->tt__OSDTextConfiguration::FontSize);
	soap_dup_PointerTott__OSDColor(soap, &d->tt__OSDTextConfiguration::FontColor, &a->tt__OSDTextConfiguration::FontColor);
	soap_dup_PointerTott__OSDColor(soap, &d->tt__OSDTextConfiguration::BackgroundColor, &a->tt__OSDTextConfiguration::BackgroundColor);
	soap_dup_PointerTostd__string(soap, &d->tt__OSDTextConfiguration::PlainText, &a->tt__OSDTextConfiguration::PlainText);
	soap_dup_PointerTott__OSDTextConfigurationExtension(soap, &d->tt__OSDTextConfiguration::Extension, &a->tt__OSDTextConfiguration::Extension);
	soap_dup_PointerTobool(soap, &d->tt__OSDTextConfiguration::IsPersistentText, &a->tt__OSDTextConfiguration::IsPersistentText);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDTextConfiguration(tt__OSDTextConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__OSDTextConfiguration::Type);
	soap_del_PointerTostd__string(&a->tt__OSDTextConfiguration::DateFormat);
	soap_del_PointerTostd__string(&a->tt__OSDTextConfiguration::TimeFormat);
	soap_del_PointerToint(&a->tt__OSDTextConfiguration::FontSize);
	soap_del_PointerTott__OSDColor(&a->tt__OSDTextConfiguration::FontColor);
	soap_del_PointerTott__OSDColor(&a->tt__OSDTextConfiguration::BackgroundColor);
	soap_del_PointerTostd__string(&a->tt__OSDTextConfiguration::PlainText);
	soap_del_PointerTott__OSDTextConfigurationExtension(&a->tt__OSDTextConfiguration::Extension);
	soap_del_PointerTobool(&a->tt__OSDTextConfiguration::IsPersistentText);
}

SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDTextConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDTextConfiguration *p;
	size_t k = sizeof(tt__OSDTextConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDTextConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDTextConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDTextConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDTextConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDTextConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDTextConfiguration(soap, tag ? tag : "tt:OSDTextConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDTextConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDTextConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDTextConfiguration * SOAP_FMAC4 soap_get_tt__OSDTextConfiguration(struct soap *soap, tt__OSDTextConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDTextConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDColor::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__OSDColor::Color = NULL;
	this->tt__OSDColor::Transparent = NULL;
}

void tt__OSDColor::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Color(soap, &this->tt__OSDColor::Color);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDColor::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDColor(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDColor(struct soap *soap, const char *tag, int id, const tt__OSDColor *a, const char *type)
{
	if (((tt__OSDColor*)a)->Transparent)
	{	soap_set_attr(soap, "Transparent", soap_int2s(soap, *((tt__OSDColor*)a)->Transparent), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDColor), type ? type : "tt:OSDColor"))
		return soap->error;
	if (!a->tt__OSDColor::Color)
	{	if (soap_element_empty(soap, "tt:Color", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Color(soap, "tt:Color", -1, &a->tt__OSDColor::Color, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDColor::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDColor(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDColor * SOAP_FMAC4 soap_in_tt__OSDColor(struct soap *soap, const char *tag, tt__OSDColor *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDColor*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDColor)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDColor *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Transparent", 5, 0);
		if (t)
		{
			if (!(((tt__OSDColor*)a)->Transparent = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__OSDColor*)a)->Transparent))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Color1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Color1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Color(soap, "tt:Color", &a->tt__OSDColor::Color, "tt:Color"))
				{	soap_flag_Color1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__OSDColor::Color))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDColor *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDColor, SOAP_TYPE_tt__OSDColor, sizeof(tt__OSDColor), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_dup_tt__OSDColor(struct soap *soap, tt__OSDColor *d, tt__OSDColor const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDColor*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDColor, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDColor(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Color(soap, &d->tt__OSDColor::Color, &a->tt__OSDColor::Color);
	soap_dup_PointerToint(soap, &d->tt__OSDColor::Transparent, &a->tt__OSDColor::Transparent);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDColor(tt__OSDColor const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Color(&a->tt__OSDColor::Color);
	soap_del_PointerToint(&a->tt__OSDColor::Transparent);
}

SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDColor(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDColor *p;
	size_t k = sizeof(tt__OSDColor);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDColor, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDColor);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDColor, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDColor location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDColor::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDColor(soap, tag ? tag : "tt:OSDColor", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDColor::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDColor(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDColor * SOAP_FMAC4 soap_get_tt__OSDColor(struct soap *soap, tt__OSDColor *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDColor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDPosConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__OSDPosConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDPosConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDPosConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__OSDPosConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:OSDPosConfigurationExtension");
}

void *tt__OSDPosConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDPosConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_in_tt__OSDPosConfigurationExtension(struct soap *soap, const char *tag, tt__OSDPosConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDPosConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfigurationExtension, sizeof(tt__OSDPosConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDPosConfigurationExtension)
		return (tt__OSDPosConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_dup_tt__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *d, tt__OSDPosConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDPosConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDPosConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDPosConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDPosConfigurationExtension(tt__OSDPosConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDPosConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDPosConfigurationExtension *p;
	size_t k = sizeof(tt__OSDPosConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDPosConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDPosConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDPosConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDPosConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDPosConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDPosConfigurationExtension(soap, tag ? tag : "tt:OSDPosConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDPosConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDPosConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDPosConfigurationExtension * SOAP_FMAC4 soap_get_tt__OSDPosConfigurationExtension(struct soap *soap, tt__OSDPosConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDPosConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__OSDPosConfiguration::Type);
	this->tt__OSDPosConfiguration::Pos = NULL;
	this->tt__OSDPosConfiguration::Extension = NULL;
}

void tt__OSDPosConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDPosConfiguration::Type, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__OSDPosConfiguration::Type);
	soap_serialize_PointerTott__Vector(soap, &this->tt__OSDPosConfiguration::Pos);
	soap_serialize_PointerTott__OSDPosConfigurationExtension(soap, &this->tt__OSDPosConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDPosConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDPosConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDPosConfiguration(struct soap *soap, const char *tag, int id, const tt__OSDPosConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OSDPosConfiguration), type ? type : "tt:OSDPosConfiguration"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Type", -1, &a->tt__OSDPosConfiguration::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector(soap, "tt:Pos", -1, &a->tt__OSDPosConfiguration::Pos, ""))
		return soap->error;
	if (soap_out_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", -1, &a->tt__OSDPosConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OSDPosConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDPosConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDPosConfiguration * SOAP_FMAC4 soap_in_tt__OSDPosConfiguration(struct soap *soap, const char *tag, tt__OSDPosConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OSDPosConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDPosConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OSDPosConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Pos1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Type", &a->tt__OSDPosConfiguration::Type, "xsd:string"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Pos1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector(soap, "tt:Pos", &a->tt__OSDPosConfiguration::Pos, "tt:Vector"))
				{	soap_flag_Pos1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OSDPosConfigurationExtension(soap, "tt:Extension", &a->tt__OSDPosConfiguration::Extension, "tt:OSDPosConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OSDPosConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OSDPosConfiguration, SOAP_TYPE_tt__OSDPosConfiguration, sizeof(tt__OSDPosConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_dup_tt__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *d, tt__OSDPosConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDPosConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDPosConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDPosConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__OSDPosConfiguration::Type, &a->tt__OSDPosConfiguration::Type);
	soap_dup_PointerTott__Vector(soap, &d->tt__OSDPosConfiguration::Pos, &a->tt__OSDPosConfiguration::Pos);
	soap_dup_PointerTott__OSDPosConfigurationExtension(soap, &d->tt__OSDPosConfiguration::Extension, &a->tt__OSDPosConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDPosConfiguration(tt__OSDPosConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__OSDPosConfiguration::Type);
	soap_del_PointerTott__Vector(&a->tt__OSDPosConfiguration::Pos);
	soap_del_PointerTott__OSDPosConfigurationExtension(&a->tt__OSDPosConfiguration::Extension);
}

SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDPosConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDPosConfiguration *p;
	size_t k = sizeof(tt__OSDPosConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDPosConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDPosConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDPosConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDPosConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDPosConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDPosConfiguration(soap, tag ? tag : "tt:OSDPosConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDPosConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDPosConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDPosConfiguration * SOAP_FMAC4 soap_get_tt__OSDPosConfiguration(struct soap *soap, tt__OSDPosConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDPosConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OSDReference::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__OSDReference::__item);
}

void tt__OSDReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OSDReference::__item, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__OSDReference::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OSDReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OSDReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OSDReference(struct soap *soap, const char *tag, int id, const tt__OSDReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_tt__ReferenceToken(soap, tag, id, &a->tt__OSDReference::__item, "tt:OSDReference");
}

void *tt__OSDReference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OSDReference(soap, tag, this, type);
}

SOAP_FMAC3 tt__OSDReference * SOAP_FMAC4 soap_in_tt__OSDReference(struct soap *soap, const char *tag, tt__OSDReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__OSDReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OSDReference, sizeof(tt__OSDReference), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OSDReference)
		return (tt__OSDReference *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_tt__ReferenceToken(soap, tag, &a->tt__OSDReference::__item, "tt:OSDReference"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_dup_tt__OSDReference(struct soap *soap, tt__OSDReference *d, tt__OSDReference const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OSDReference*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OSDReference, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OSDReference(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__OSDReference::__item, &a->tt__OSDReference::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OSDReference(tt__OSDReference const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__ReferenceToken(&a->tt__OSDReference::__item);
}

SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OSDReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OSDReference *p;
	size_t k = sizeof(tt__OSDReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OSDReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OSDReference);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OSDReference, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OSDReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OSDReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OSDReference(soap, tag ? tag : "tt:OSDReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OSDReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OSDReference(soap, this, tag, type);
}

SOAP_FMAC3 tt__OSDReference * SOAP_FMAC4 soap_get_tt__OSDReference(struct soap *soap, tt__OSDReference *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OSDReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTimeRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_dateTime(soap, &this->tt__DateTimeRange::From);
	soap_default_dateTime(soap, &this->tt__DateTimeRange::Until);
}

void tt__DateTimeRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DateTimeRange::From, SOAP_TYPE_dateTime);
	soap_embedded(soap, &this->tt__DateTimeRange::Until, SOAP_TYPE_dateTime);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DateTimeRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTimeRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTimeRange(struct soap *soap, const char *tag, int id, const tt__DateTimeRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTimeRange), type ? type : "tt:DateTimeRange"))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:From", -1, &a->tt__DateTimeRange::From, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:Until", -1, &a->tt__DateTimeRange::Until, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTimeRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTimeRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_in_tt__DateTimeRange(struct soap *soap, const char *tag, tt__DateTimeRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTimeRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTimeRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTimeRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_From1 = 1;
	size_t soap_flag_Until1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_From1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:From", &a->tt__DateTimeRange::From, "xsd:dateTime"))
				{	soap_flag_From1--;
					continue;
				}
			}
			if (soap_flag_Until1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:Until", &a->tt__DateTimeRange::Until, "xsd:dateTime"))
				{	soap_flag_Until1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_From1 > 0 || soap_flag_Until1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTimeRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTimeRange, SOAP_TYPE_tt__DateTimeRange, sizeof(tt__DateTimeRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_dup_tt__DateTimeRange(struct soap *soap, tt__DateTimeRange *d, tt__DateTimeRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DateTimeRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DateTimeRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DateTimeRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__DateTimeRange::From = a->tt__DateTimeRange::From;
	d->tt__DateTimeRange::Until = a->tt__DateTimeRange::Until;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DateTimeRange(tt__DateTimeRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* From skipped */
	/* Until skipped */
}

SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTimeRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTimeRange *p;
	size_t k = sizeof(tt__DateTimeRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTimeRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTimeRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTimeRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTimeRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTimeRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTimeRange(soap, tag ? tag : "tt:DateTimeRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTimeRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTimeRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTimeRange * SOAP_FMAC4 soap_get_tt__DateTimeRange(struct soap *soap, tt__DateTimeRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Config::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Config::Parameters = NULL;
	soap_default_std__string(soap, &this->tt__Config::Name);
	soap_default_xsd__QName(soap, &this->tt__Config::Type);
}

void tt__Config::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ItemList(soap, &this->tt__Config::Parameters);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Config::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Config(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Config(struct soap *soap, const char *tag, int id, const tt__Config *a, const char *type)
{
	soap_set_attr(soap, "Name", soap_std__string2s(soap, ((tt__Config*)a)->Name), 1);
	soap_set_attr(soap, "Type", soap_xsd__QName2s(soap, ((tt__Config*)a)->Type), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Config), type ? type : "tt:Config"))
		return soap->error;
	if (!a->tt__Config::Parameters)
	{	if (soap_element_empty(soap, "tt:Parameters", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ItemList(soap, "tt:Parameters", -1, &a->tt__Config::Parameters, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Config::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Config(soap, tag, this, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_in_tt__Config(struct soap *soap, const char *tag, tt__Config *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Config*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Config, sizeof(tt__Config), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Config)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Config *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "Name", 1, 3), &((tt__Config*)a)->Name))
		return NULL;
	if (soap_s2xsd__QName(soap, soap_attr_value(soap, "Type", 2, 3), &((tt__Config*)a)->Type))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Parameters1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Parameters1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemList(soap, "tt:Parameters", &a->tt__Config::Parameters, "tt:ItemList"))
				{	soap_flag_Parameters1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__Config::Parameters))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Config *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Config, SOAP_TYPE_tt__Config, sizeof(tt__Config), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_dup_tt__Config(struct soap *soap, tt__Config *d, tt__Config const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Config*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Config, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Config(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ItemList(soap, &d->tt__Config::Parameters, &a->tt__Config::Parameters);
	soap_dup_std__string(soap, &d->tt__Config::Name, &a->tt__Config::Name);
	soap_dup_xsd__QName(soap, &d->tt__Config::Type, &a->tt__Config::Type);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Config(tt__Config const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ItemList(&a->tt__Config::Parameters);
	soap_del_std__string(&a->tt__Config::Name);
	soap_del_xsd__QName(&a->tt__Config::Type);
}

SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Config(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Config *p;
	size_t k = sizeof(tt__Config);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Config, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Config);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Config, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Config location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Config::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Config(soap, tag ? tag : "tt:Config", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Config::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Config(soap, this, tag, type);
}

SOAP_FMAC3 tt__Config * SOAP_FMAC4 soap_get_tt__Config(struct soap *soap, tt__Config *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__RuleEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RuleEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:RuleEngineConfigurationExtension");
}

void *tt__RuleEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, tt__RuleEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RuleEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(tt__RuleEngineConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfigurationExtension)
		return (tt__RuleEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_dup_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *d, tt__RuleEngineConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RuleEngineConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RuleEngineConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RuleEngineConfigurationExtension(tt__RuleEngineConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfigurationExtension *p;
	size_t k = sizeof(tt__RuleEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfigurationExtension(soap, tag ? tag : "tt:RuleEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__RuleEngineConfigurationExtension(struct soap *soap, tt__RuleEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RuleEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	this->tt__RuleEngineConfiguration::Extension = NULL;
}

void tt__RuleEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__RuleEngineConfiguration::Rule);
	soap_serialize_PointerTott__RuleEngineConfigurationExtension(soap, &this->tt__RuleEngineConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RuleEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__RuleEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RuleEngineConfiguration), type ? type : "tt:RuleEngineConfiguration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", -1, &a->tt__RuleEngineConfiguration::Rule, ""))
		return soap->error;
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__RuleEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RuleEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RuleEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_in_tt__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RuleEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RuleEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RuleEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:Rule", &a->tt__RuleEngineConfiguration::Rule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfigurationExtension(soap, "tt:Extension", &a->tt__RuleEngineConfiguration::Extension, "tt:RuleEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RuleEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RuleEngineConfiguration, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_dup_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *d, tt__RuleEngineConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RuleEngineConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RuleEngineConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RuleEngineConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__Config(soap, &d->tt__RuleEngineConfiguration::Rule, &a->tt__RuleEngineConfiguration::Rule);
	soap_dup_PointerTott__RuleEngineConfigurationExtension(soap, &d->tt__RuleEngineConfiguration::Extension, &a->tt__RuleEngineConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RuleEngineConfiguration(tt__RuleEngineConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__Config(&a->tt__RuleEngineConfiguration::Rule);
	soap_del_PointerTott__RuleEngineConfigurationExtension(&a->tt__RuleEngineConfiguration::Extension);
}

SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RuleEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RuleEngineConfiguration *p;
	size_t k = sizeof(tt__RuleEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RuleEngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RuleEngineConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RuleEngineConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RuleEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RuleEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RuleEngineConfiguration(soap, tag ? tag : "tt:RuleEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RuleEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RuleEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration * SOAP_FMAC4 soap_get_tt__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__AnalyticsEngineConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:AnalyticsEngineConfigurationExtension");
}

void *tt__AnalyticsEngineConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AnalyticsEngineConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(tt__AnalyticsEngineConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension)
		return (tt__AnalyticsEngineConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_dup_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *d, tt__AnalyticsEngineConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AnalyticsEngineConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AnalyticsEngineConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AnalyticsEngineConfigurationExtension(tt__AnalyticsEngineConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfigurationExtension *p;
	size_t k = sizeof(tt__AnalyticsEngineConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag ? tag : "tt:AnalyticsEngineConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfigurationExtension(struct soap *soap, tt__AnalyticsEngineConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsEngineConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	this->tt__AnalyticsEngineConfiguration::Extension = NULL;
}

void tt__AnalyticsEngineConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Config(soap, &this->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(soap, &this->tt__AnalyticsEngineConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsEngineConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, const tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration), type ? type : "tt:AnalyticsEngineConfiguration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", -1, &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsEngineConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsEngineConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsEngineConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_in_tt__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsEngineConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsEngineConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsEngineConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Config(soap, "tt:AnalyticsModule", &a->tt__AnalyticsEngineConfiguration::AnalyticsModule, "tt:Config"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, "tt:Extension", &a->tt__AnalyticsEngineConfiguration::Extension, "tt:AnalyticsEngineConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnalyticsEngineConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsEngineConfiguration, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_dup_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *d, tt__AnalyticsEngineConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AnalyticsEngineConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AnalyticsEngineConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__Config(soap, &d->tt__AnalyticsEngineConfiguration::AnalyticsModule, &a->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_dup_PointerTott__AnalyticsEngineConfigurationExtension(soap, &d->tt__AnalyticsEngineConfiguration::Extension, &a->tt__AnalyticsEngineConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AnalyticsEngineConfiguration(tt__AnalyticsEngineConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__Config(&a->tt__AnalyticsEngineConfiguration::AnalyticsModule);
	soap_del_PointerTott__AnalyticsEngineConfigurationExtension(&a->tt__AnalyticsEngineConfiguration::Extension);
}

SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsEngineConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsEngineConfiguration *p;
	size_t k = sizeof(tt__AnalyticsEngineConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsEngineConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsEngineConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsEngineConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsEngineConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsEngineConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsEngineConfiguration(soap, tag ? tag : "tt:AnalyticsEngineConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsEngineConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsEngineConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration * SOAP_FMAC4 soap_get_tt__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Polyline::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
}

void tt__Polyline::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Vector(soap, &this->tt__Polyline::Point);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Polyline::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Polyline(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Polyline(struct soap *soap, const char *tag, int id, const tt__Polyline *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Polyline), type ? type : "tt:Polyline"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", -1, &a->tt__Polyline::Point, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Polyline::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Polyline(soap, tag, this, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_in_tt__Polyline(struct soap *soap, const char *tag, tt__Polyline *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Polyline*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Polyline)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Polyline *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Vector(soap, "tt:Point", &a->tt__Polyline::Point, "tt:Vector"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__Polyline::Point.size() < 2))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Polyline *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Polyline, SOAP_TYPE_tt__Polyline, sizeof(tt__Polyline), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_dup_tt__Polyline(struct soap *soap, tt__Polyline *d, tt__Polyline const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Polyline*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Polyline, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Polyline(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__Vector(soap, &d->tt__Polyline::Point, &a->tt__Polyline::Point);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Polyline(tt__Polyline const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__Vector(&a->tt__Polyline::Point);
}

SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Polyline(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Polyline *p;
	size_t k = sizeof(tt__Polyline);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Polyline, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Polyline);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Polyline, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Polyline location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Polyline::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Polyline(soap, tag ? tag : "tt:Polyline", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Polyline::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Polyline(soap, this, tag, type);
}

SOAP_FMAC3 tt__Polyline * SOAP_FMAC4 soap_get_tt__Polyline(struct soap *soap, tt__Polyline *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemListExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ItemListExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ItemListExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemListExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemListExtension(struct soap *soap, const char *tag, int id, const tt__ItemListExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ItemListExtension");
}

void *tt__ItemListExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemListExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_in_tt__ItemListExtension(struct soap *soap, const char *tag, tt__ItemListExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ItemListExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemListExtension, sizeof(tt__ItemListExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemListExtension)
		return (tt__ItemListExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_dup_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *d, tt__ItemListExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ItemListExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ItemListExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ItemListExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ItemListExtension(tt__ItemListExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemListExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemListExtension *p;
	size_t k = sizeof(tt__ItemListExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemListExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemListExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemListExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemListExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemListExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemListExtension(soap, tag ? tag : "tt:ItemListExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemListExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemListExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemListExtension * SOAP_FMAC4 soap_get_tt__ItemListExtension(struct soap *soap, tt__ItemListExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_default_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	this->tt__ItemList::Extension = NULL;
}

void tt__ItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &this->tt__ItemList::SimpleItem);
	soap_serialize_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &this->tt__ItemList::ElementItem);
	soap_serialize_PointerTott__ItemListExtension(soap, &this->tt__ItemList::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ItemList(struct soap *soap, const char *tag, int id, const tt__ItemList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ItemList), type ? type : "tt:ItemList"))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", -1, &a->tt__ItemList::SimpleItem, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", -1, &a->tt__ItemList::ElementItem, ""))
		return soap->error;
	if (soap_out_PointerTott__ItemListExtension(soap, "tt:Extension", -1, &a->tt__ItemList::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ItemList(soap, tag, this, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_in_tt__ItemList(struct soap *soap, const char *tag, tt__ItemList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ItemList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ItemList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ItemList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, "tt:SimpleItem", &a->tt__ItemList::SimpleItem, ""))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, "tt:ElementItem", &a->tt__ItemList::ElementItem, ""))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ItemListExtension(soap, "tt:Extension", &a->tt__ItemList::Extension, "tt:ItemListExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ItemList, SOAP_TYPE_tt__ItemList, sizeof(tt__ItemList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_dup_tt__ItemList(struct soap *soap, tt__ItemList *d, tt__ItemList const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ItemList*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ItemList, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ItemList(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOf_tt__ItemList_SimpleItem(soap, &d->tt__ItemList::SimpleItem, &a->tt__ItemList::SimpleItem);
	soap_dup_std__vectorTemplateOf_tt__ItemList_ElementItem(soap, &d->tt__ItemList::ElementItem, &a->tt__ItemList::ElementItem);
	soap_dup_PointerTott__ItemListExtension(soap, &d->tt__ItemList::Extension, &a->tt__ItemList::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ItemList(tt__ItemList const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOf_tt__ItemList_SimpleItem(&a->tt__ItemList::SimpleItem);
	soap_del_std__vectorTemplateOf_tt__ItemList_ElementItem(&a->tt__ItemList::ElementItem);
	soap_del_PointerTott__ItemListExtension(&a->tt__ItemList::Extension);
}

SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ItemList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ItemList *p;
	size_t k = sizeof(tt__ItemList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ItemList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ItemList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ItemList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ItemList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ItemList(soap, tag ? tag : "tt:ItemList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ItemList(soap, this, tag, type);
}

SOAP_FMAC3 tt__ItemList * SOAP_FMAC4 soap_get_tt__ItemList(struct soap *soap, tt__ItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MessageExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__MessageExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MessageExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MessageExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MessageExtension(struct soap *soap, const char *tag, int id, const tt__MessageExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:MessageExtension");
}

void *tt__MessageExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MessageExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_in_tt__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MessageExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MessageExtension)
		return (tt__MessageExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_dup_tt__MessageExtension(struct soap *soap, tt__MessageExtension *d, tt__MessageExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MessageExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MessageExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MessageExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MessageExtension(tt__MessageExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MessageExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MessageExtension *p;
	size_t k = sizeof(tt__MessageExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MessageExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MessageExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MessageExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MessageExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MessageExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MessageExtension(soap, tag ? tag : "tt:MessageExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MessageExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MessageExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MessageExtension * SOAP_FMAC4 soap_get_tt__MessageExtension(struct soap *soap, tt__MessageExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReductionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__NoiseReductionOptions::Level);
}

void tt__NoiseReductionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReductionOptions::Level, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NoiseReductionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReductionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReductionOptions(struct soap *soap, const char *tag, int id, const tt__NoiseReductionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReductionOptions), type ? type : "tt:NoiseReductionOptions"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__NoiseReductionOptions::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReductionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReductionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_in_tt__NoiseReductionOptions(struct soap *soap, const char *tag, tt__NoiseReductionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReductionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReductionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReductionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__NoiseReductionOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReductionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReductionOptions, SOAP_TYPE_tt__NoiseReductionOptions, sizeof(tt__NoiseReductionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_dup_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *d, tt__NoiseReductionOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NoiseReductionOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NoiseReductionOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NoiseReductionOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NoiseReductionOptions::Level = a->tt__NoiseReductionOptions::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NoiseReductionOptions(tt__NoiseReductionOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Level skipped */
}

SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NoiseReductionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReductionOptions *p;
	size_t k = sizeof(tt__NoiseReductionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReductionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReductionOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReductionOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReductionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReductionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReductionOptions(soap, tag ? tag : "tt:NoiseReductionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReductionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReductionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReductionOptions * SOAP_FMAC4 soap_get_tt__NoiseReductionOptions(struct soap *soap, tt__NoiseReductionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReductionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_default_bool(soap, &this->tt__DefoggingOptions::Level);
}

void tt__DefoggingOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__DefoggingOptions::Mode);
	soap_embedded(soap, &this->tt__DefoggingOptions::Level, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DefoggingOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingOptions(struct soap *soap, const char *tag, int id, const tt__DefoggingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DefoggingOptions), type ? type : "tt:DefoggingOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__DefoggingOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__DefoggingOptions::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DefoggingOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_in_tt__DefoggingOptions(struct soap *soap, const char *tag, tt__DefoggingOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DefoggingOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DefoggingOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__DefoggingOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__DefoggingOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__DefoggingOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DefoggingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DefoggingOptions, SOAP_TYPE_tt__DefoggingOptions, sizeof(tt__DefoggingOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_dup_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *d, tt__DefoggingOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DefoggingOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DefoggingOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DefoggingOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__DefoggingOptions::Mode, &a->tt__DefoggingOptions::Mode);
	d->tt__DefoggingOptions::Level = a->tt__DefoggingOptions::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DefoggingOptions(tt__DefoggingOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__DefoggingOptions::Mode);
	/* Level skipped */
}

SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DefoggingOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingOptions *p;
	size_t k = sizeof(tt__DefoggingOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingOptions(soap, tag ? tag : "tt:DefoggingOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingOptions * SOAP_FMAC4 soap_get_tt__DefoggingOptions(struct soap *soap, tt__DefoggingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_default_bool(soap, &this->tt__ToneCompensationOptions::Level);
}

void tt__ToneCompensationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__ToneCompensationOptions::Mode);
	soap_embedded(soap, &this->tt__ToneCompensationOptions::Level, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationOptions(struct soap *soap, const char *tag, int id, const tt__ToneCompensationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensationOptions), type ? type : "tt:ToneCompensationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:Mode", -1, &a->tt__ToneCompensationOptions::Mode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Level", -1, &a->tt__ToneCompensationOptions::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_in_tt__ToneCompensationOptions(struct soap *soap, const char *tag, tt__ToneCompensationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:Mode", &a->tt__ToneCompensationOptions::Mode, "xsd:string"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Level", &a->tt__ToneCompensationOptions::Level, "xsd:boolean"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__ToneCompensationOptions::Mode.size() < 1 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensationOptions, SOAP_TYPE_tt__ToneCompensationOptions, sizeof(tt__ToneCompensationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_dup_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *d, tt__ToneCompensationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ToneCompensationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ToneCompensationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ToneCompensationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__ToneCompensationOptions::Mode, &a->tt__ToneCompensationOptions::Mode);
	d->tt__ToneCompensationOptions::Level = a->tt__ToneCompensationOptions::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ToneCompensationOptions(tt__ToneCompensationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__ToneCompensationOptions::Mode);
	/* Level skipped */
}

SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationOptions *p;
	size_t k = sizeof(tt__ToneCompensationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationOptions(soap, tag ? tag : "tt:ToneCompensationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationOptions * SOAP_FMAC4 soap_get_tt__ToneCompensationOptions(struct soap *soap, tt__ToneCompensationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__FocusOptions20Extension::AFModes = NULL;
}

void tt__FocusOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__StringAttrList(soap, &this->tt__FocusOptions20Extension::AFModes);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20Extension(struct soap *soap, const char *tag, int id, const tt__FocusOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20Extension), type ? type : "tt:FocusOptions20Extension"))
		return soap->error;
	if (soap_out_PointerTott__StringAttrList(soap, "tt:AFModes", -1, &a->tt__FocusOptions20Extension::AFModes, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_in_tt__FocusOptions20Extension(struct soap *soap, const char *tag, tt__FocusOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AFModes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AFModes1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__StringAttrList(soap, "tt:AFModes", &a->tt__FocusOptions20Extension::AFModes, "tt:StringAttrList"))
				{	soap_flag_AFModes1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20Extension, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(tt__FocusOptions20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_dup_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *d, tt__FocusOptions20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusOptions20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusOptions20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusOptions20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__StringAttrList(soap, &d->tt__FocusOptions20Extension::AFModes, &a->tt__FocusOptions20Extension::AFModes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusOptions20Extension(tt__FocusOptions20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__StringAttrList(&a->tt__FocusOptions20Extension::AFModes);
}

SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20Extension *p;
	size_t k = sizeof(tt__FocusOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20Extension(soap, tag ? tag : "tt:FocusOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20Extension * SOAP_FMAC4 soap_get_tt__FocusOptions20Extension(struct soap *soap, tt__FocusOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	this->tt__FocusOptions20::DefaultSpeed = NULL;
	this->tt__FocusOptions20::NearLimit = NULL;
	this->tt__FocusOptions20::FarLimit = NULL;
	this->tt__FocusOptions20::Extension = NULL;
}

void tt__FocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__AutoFocusMode(soap, &this->tt__FocusOptions20::AutoFocusModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::DefaultSpeed);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::NearLimit);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__FocusOptions20::FarLimit);
	soap_serialize_PointerTott__FocusOptions20Extension(soap, &this->tt__FocusOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusOptions20(struct soap *soap, const char *tag, int id, const tt__FocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusOptions20), type ? type : "tt:FocusOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", -1, &a->tt__FocusOptions20::AutoFocusModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:DefaultSpeed", -1, &a->tt__FocusOptions20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:NearLimit", -1, &a->tt__FocusOptions20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:FarLimit", -1, &a->tt__FocusOptions20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20Extension(soap, "tt:Extension", -1, &a->tt__FocusOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_in_tt__FocusOptions20(struct soap *soap, const char *tag, tt__FocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AutoFocusMode(soap, "tt:AutoFocusModes", &a->tt__FocusOptions20::AutoFocusModes, "tt:AutoFocusMode"))
					continue;
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:DefaultSpeed", &a->tt__FocusOptions20::DefaultSpeed, "tt:FloatRange"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:NearLimit", &a->tt__FocusOptions20::NearLimit, "tt:FloatRange"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:FarLimit", &a->tt__FocusOptions20::FarLimit, "tt:FloatRange"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20Extension(soap, "tt:Extension", &a->tt__FocusOptions20::Extension, "tt:FocusOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusOptions20, SOAP_TYPE_tt__FocusOptions20, sizeof(tt__FocusOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_dup_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *d, tt__FocusOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__AutoFocusMode(soap, &d->tt__FocusOptions20::AutoFocusModes, &a->tt__FocusOptions20::AutoFocusModes);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__FocusOptions20::DefaultSpeed, &a->tt__FocusOptions20::DefaultSpeed);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__FocusOptions20::NearLimit, &a->tt__FocusOptions20::NearLimit);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__FocusOptions20::FarLimit, &a->tt__FocusOptions20::FarLimit);
	soap_dup_PointerTott__FocusOptions20Extension(soap, &d->tt__FocusOptions20::Extension, &a->tt__FocusOptions20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusOptions20(tt__FocusOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__AutoFocusMode(&a->tt__FocusOptions20::AutoFocusModes);
	soap_del_PointerTott__FloatRange(&a->tt__FocusOptions20::DefaultSpeed);
	soap_del_PointerTott__FloatRange(&a->tt__FocusOptions20::NearLimit);
	soap_del_PointerTott__FloatRange(&a->tt__FocusOptions20::FarLimit);
	soap_del_PointerTott__FocusOptions20Extension(&a->tt__FocusOptions20::Extension);
}

SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusOptions20 *p;
	size_t k = sizeof(tt__FocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusOptions20(soap, tag ? tag : "tt:FocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusOptions20 * SOAP_FMAC4 soap_get_tt__FocusOptions20(struct soap *soap, tt__FocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__WhiteBalanceOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalanceOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:WhiteBalanceOptions20Extension");
}

void *tt__WhiteBalanceOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WhiteBalanceOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(tt__WhiteBalanceOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20Extension)
		return (tt__WhiteBalanceOptions20Extension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_dup_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *d, tt__WhiteBalanceOptions20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WhiteBalanceOptions20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WhiteBalanceOptions20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WhiteBalanceOptions20Extension(tt__WhiteBalanceOptions20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20Extension *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20Extension(soap, tag ? tag : "tt:WhiteBalanceOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20Extension(struct soap *soap, tt__WhiteBalanceOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalanceOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	this->tt__WhiteBalanceOptions20::YrGain = NULL;
	this->tt__WhiteBalanceOptions20::YbGain = NULL;
	this->tt__WhiteBalanceOptions20::Extension = NULL;
}

void tt__WhiteBalanceOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WhiteBalanceMode(soap, &this->tt__WhiteBalanceOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YrGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WhiteBalanceOptions20::YbGain);
	soap_serialize_PointerTott__WhiteBalanceOptions20Extension(soap, &this->tt__WhiteBalanceOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalanceOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, const tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalanceOptions20), type ? type : "tt:WhiteBalanceOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalanceOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YrGain", -1, &a->tt__WhiteBalanceOptions20::YrGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:YbGain", -1, &a->tt__WhiteBalanceOptions20::YbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalanceOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalanceOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalanceOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_in_tt__WhiteBalanceOptions20(struct soap *soap, const char *tag, tt__WhiteBalanceOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalanceOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalanceOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalanceOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_YrGain1 = 1;
	size_t soap_flag_YbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalanceOptions20::Mode, "tt:WhiteBalanceMode"))
					continue;
			}
			if (soap_flag_YrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YrGain", &a->tt__WhiteBalanceOptions20::YrGain, "tt:FloatRange"))
				{	soap_flag_YrGain1--;
					continue;
				}
			}
			if (soap_flag_YbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YbGain", &a->tt__WhiteBalanceOptions20::YbGain, "tt:FloatRange"))
				{	soap_flag_YbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, "tt:Extension", &a->tt__WhiteBalanceOptions20::Extension, "tt:WhiteBalanceOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__WhiteBalanceOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalanceOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalanceOptions20, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(tt__WhiteBalanceOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_dup_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *d, tt__WhiteBalanceOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WhiteBalanceOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WhiteBalanceOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WhiteBalanceOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__WhiteBalanceMode(soap, &d->tt__WhiteBalanceOptions20::Mode, &a->tt__WhiteBalanceOptions20::Mode);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__WhiteBalanceOptions20::YrGain, &a->tt__WhiteBalanceOptions20::YrGain);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__WhiteBalanceOptions20::YbGain, &a->tt__WhiteBalanceOptions20::YbGain);
	soap_dup_PointerTott__WhiteBalanceOptions20Extension(soap, &d->tt__WhiteBalanceOptions20::Extension, &a->tt__WhiteBalanceOptions20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WhiteBalanceOptions20(tt__WhiteBalanceOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__WhiteBalanceMode(&a->tt__WhiteBalanceOptions20::Mode);
	soap_del_PointerTott__FloatRange(&a->tt__WhiteBalanceOptions20::YrGain);
	soap_del_PointerTott__FloatRange(&a->tt__WhiteBalanceOptions20::YbGain);
	soap_del_PointerTott__WhiteBalanceOptions20Extension(&a->tt__WhiteBalanceOptions20::Extension);
}

SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalanceOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalanceOptions20 *p;
	size_t k = sizeof(tt__WhiteBalanceOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalanceOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalanceOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalanceOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalanceOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalanceOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalanceOptions20(soap, tag ? tag : "tt:WhiteBalanceOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalanceOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalanceOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalanceOptions20 * SOAP_FMAC4 soap_get_tt__WhiteBalanceOptions20(struct soap *soap, tt__WhiteBalanceOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__FocusConfiguration20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusConfiguration20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:FocusConfiguration20Extension");
}

void *tt__FocusConfiguration20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_in_tt__FocusConfiguration20Extension(struct soap *soap, const char *tag, tt__FocusConfiguration20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__FocusConfiguration20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(tt__FocusConfiguration20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20Extension)
		return (tt__FocusConfiguration20Extension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_dup_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *d, tt__FocusConfiguration20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusConfiguration20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusConfiguration20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusConfiguration20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusConfiguration20Extension(tt__FocusConfiguration20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20Extension *p;
	size_t k = sizeof(tt__FocusConfiguration20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20Extension(soap, tag ? tag : "tt:FocusConfiguration20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20Extension * SOAP_FMAC4 soap_get_tt__FocusConfiguration20Extension(struct soap *soap, tt__FocusConfiguration20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration20::AutoFocusMode);
	this->tt__FocusConfiguration20::DefaultSpeed = NULL;
	this->tt__FocusConfiguration20::NearLimit = NULL;
	this->tt__FocusConfiguration20::FarLimit = NULL;
	this->tt__FocusConfiguration20::Extension = NULL;
	this->tt__FocusConfiguration20::AFMode = NULL;
}

void tt__FocusConfiguration20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::DefaultSpeed);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::NearLimit);
	soap_serialize_PointerTofloat(soap, &this->tt__FocusConfiguration20::FarLimit);
	soap_serialize_PointerTott__FocusConfiguration20Extension(soap, &this->tt__FocusConfiguration20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusConfiguration20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration20(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration20 *a, const char *type)
{
	if (((tt__FocusConfiguration20*)a)->AFMode)
	{	soap_set_attr(soap, "AFMode", soap_tt__StringAttrList2s(soap, *((tt__FocusConfiguration20*)a)->AFMode), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration20), type ? type : "tt:FocusConfiguration20"))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->tt__FocusConfiguration20::AutoFocusMode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:DefaultSpeed", -1, &a->tt__FocusConfiguration20::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:NearLimit", -1, &a->tt__FocusConfiguration20::NearLimit, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:FarLimit", -1, &a->tt__FocusConfiguration20::FarLimit, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", -1, &a->tt__FocusConfiguration20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_in_tt__FocusConfiguration20(struct soap *soap, const char *tag, tt__FocusConfiguration20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "AFMode", 1, 0);
		if (t)
		{
			if (!(((tt__FocusConfiguration20*)a)->AFMode = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tt__FocusConfiguration20*)a)->AFMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->tt__FocusConfiguration20::AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:DefaultSpeed", &a->tt__FocusConfiguration20::DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:NearLimit", &a->tt__FocusConfiguration20::NearLimit, "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:FarLimit", &a->tt__FocusConfiguration20::FarLimit, "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20Extension(soap, "tt:Extension", &a->tt__FocusConfiguration20::Extension, "tt:FocusConfiguration20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_AutoFocusMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusConfiguration20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration20, SOAP_TYPE_tt__FocusConfiguration20, sizeof(tt__FocusConfiguration20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_dup_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *d, tt__FocusConfiguration20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusConfiguration20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusConfiguration20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusConfiguration20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__FocusConfiguration20::AutoFocusMode = a->tt__FocusConfiguration20::AutoFocusMode;
	soap_dup_PointerTofloat(soap, &d->tt__FocusConfiguration20::DefaultSpeed, &a->tt__FocusConfiguration20::DefaultSpeed);
	soap_dup_PointerTofloat(soap, &d->tt__FocusConfiguration20::NearLimit, &a->tt__FocusConfiguration20::NearLimit);
	soap_dup_PointerTofloat(soap, &d->tt__FocusConfiguration20::FarLimit, &a->tt__FocusConfiguration20::FarLimit);
	soap_dup_PointerTott__FocusConfiguration20Extension(soap, &d->tt__FocusConfiguration20::Extension, &a->tt__FocusConfiguration20::Extension);
	soap_dup_PointerTott__StringAttrList(soap, &d->tt__FocusConfiguration20::AFMode, &a->tt__FocusConfiguration20::AFMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusConfiguration20(tt__FocusConfiguration20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* AutoFocusMode skipped */
	soap_del_PointerTofloat(&a->tt__FocusConfiguration20::DefaultSpeed);
	soap_del_PointerTofloat(&a->tt__FocusConfiguration20::NearLimit);
	soap_del_PointerTofloat(&a->tt__FocusConfiguration20::FarLimit);
	soap_del_PointerTott__FocusConfiguration20Extension(&a->tt__FocusConfiguration20::Extension);
	soap_del_PointerTott__StringAttrList(&a->tt__FocusConfiguration20::AFMode);
}

SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration20 *p;
	size_t k = sizeof(tt__FocusConfiguration20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration20(soap, tag ? tag : "tt:FocusConfiguration20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration20 * SOAP_FMAC4 soap_get_tt__FocusConfiguration20(struct soap *soap, tt__FocusConfiguration20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__WhiteBalance20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalance20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:WhiteBalance20Extension");
}

void *tt__WhiteBalance20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_in_tt__WhiteBalance20Extension(struct soap *soap, const char *tag, tt__WhiteBalance20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__WhiteBalance20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(tt__WhiteBalance20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20Extension)
		return (tt__WhiteBalance20Extension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_dup_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *d, tt__WhiteBalance20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WhiteBalance20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WhiteBalance20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WhiteBalance20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WhiteBalance20Extension(tt__WhiteBalance20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20Extension *p;
	size_t k = sizeof(tt__WhiteBalance20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20Extension(soap, tag ? tag : "tt:WhiteBalance20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20Extension * SOAP_FMAC4 soap_get_tt__WhiteBalance20Extension(struct soap *soap, tt__WhiteBalance20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance20::Mode);
	this->tt__WhiteBalance20::CrGain = NULL;
	this->tt__WhiteBalance20::CbGain = NULL;
	this->tt__WhiteBalance20::Extension = NULL;
}

void tt__WhiteBalance20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CrGain);
	soap_serialize_PointerTofloat(soap, &this->tt__WhiteBalance20::CbGain);
	soap_serialize_PointerTott__WhiteBalance20Extension(soap, &this->tt__WhiteBalance20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalance20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance20(struct soap *soap, const char *tag, int id, const tt__WhiteBalance20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance20), type ? type : "tt:WhiteBalance20"))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalance20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CrGain", -1, &a->tt__WhiteBalance20::CrGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:CbGain", -1, &a->tt__WhiteBalance20::CbGain, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", -1, &a->tt__WhiteBalance20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_in_tt__WhiteBalance20(struct soap *soap, const char *tag, tt__WhiteBalance20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalance20::Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CrGain", &a->tt__WhiteBalance20::CrGain, "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:CbGain", &a->tt__WhiteBalance20::CbGain, "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20Extension(soap, "tt:Extension", &a->tt__WhiteBalance20::Extension, "tt:WhiteBalance20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalance20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance20, SOAP_TYPE_tt__WhiteBalance20, sizeof(tt__WhiteBalance20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_dup_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *d, tt__WhiteBalance20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WhiteBalance20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WhiteBalance20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WhiteBalance20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__WhiteBalance20::Mode = a->tt__WhiteBalance20::Mode;
	soap_dup_PointerTofloat(soap, &d->tt__WhiteBalance20::CrGain, &a->tt__WhiteBalance20::CrGain);
	soap_dup_PointerTofloat(soap, &d->tt__WhiteBalance20::CbGain, &a->tt__WhiteBalance20::CbGain);
	soap_dup_PointerTott__WhiteBalance20Extension(soap, &d->tt__WhiteBalance20::Extension, &a->tt__WhiteBalance20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WhiteBalance20(tt__WhiteBalance20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTofloat(&a->tt__WhiteBalance20::CrGain);
	soap_del_PointerTofloat(&a->tt__WhiteBalance20::CbGain);
	soap_del_PointerTott__WhiteBalance20Extension(&a->tt__WhiteBalance20::Extension);
}

SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance20 *p;
	size_t k = sizeof(tt__WhiteBalance20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance20(soap, tag ? tag : "tt:WhiteBalance20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance20 * SOAP_FMAC4 soap_get_tt__WhiteBalance20(struct soap *soap, tt__WhiteBalance20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocusOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RelativeFocusOptions20::Distance = NULL;
	this->tt__RelativeFocusOptions20::Speed = NULL;
}

void tt__RelativeFocusOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Distance);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__RelativeFocusOptions20::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RelativeFocusOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, const tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocusOptions20), type ? type : "tt:RelativeFocusOptions20"))
		return soap->error;
	if (!a->tt__RelativeFocusOptions20::Distance)
	{	if (soap_element_empty(soap, "tt:Distance", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Distance", -1, &a->tt__RelativeFocusOptions20::Distance, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__RelativeFocusOptions20::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocusOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocusOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_in_tt__RelativeFocusOptions20(struct soap *soap, const char *tag, tt__RelativeFocusOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocusOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocusOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocusOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Distance", &a->tt__RelativeFocusOptions20::Distance, "tt:FloatRange"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__RelativeFocusOptions20::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__RelativeFocusOptions20::Distance))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocusOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocusOptions20, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(tt__RelativeFocusOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_dup_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *d, tt__RelativeFocusOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RelativeFocusOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RelativeFocusOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RelativeFocusOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__RelativeFocusOptions20::Distance, &a->tt__RelativeFocusOptions20::Distance);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__RelativeFocusOptions20::Speed, &a->tt__RelativeFocusOptions20::Speed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RelativeFocusOptions20(tt__RelativeFocusOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__FloatRange(&a->tt__RelativeFocusOptions20::Distance);
	soap_del_PointerTott__FloatRange(&a->tt__RelativeFocusOptions20::Speed);
}

SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocusOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocusOptions20 *p;
	size_t k = sizeof(tt__RelativeFocusOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocusOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocusOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocusOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocusOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocusOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocusOptions20(soap, tag ? tag : "tt:RelativeFocusOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocusOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocusOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocusOptions20 * SOAP_FMAC4 soap_get_tt__RelativeFocusOptions20(struct soap *soap, tt__RelativeFocusOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MoveOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MoveOptions20::Absolute = NULL;
	this->tt__MoveOptions20::Relative = NULL;
	this->tt__MoveOptions20::Continuous = NULL;
}

void tt__MoveOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocusOptions(soap, &this->tt__MoveOptions20::Absolute);
	soap_serialize_PointerTott__RelativeFocusOptions20(soap, &this->tt__MoveOptions20::Relative);
	soap_serialize_PointerTott__ContinuousFocusOptions(soap, &this->tt__MoveOptions20::Continuous);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MoveOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MoveOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveOptions20(struct soap *soap, const char *tag, int id, const tt__MoveOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveOptions20), type ? type : "tt:MoveOptions20"))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", -1, &a->tt__MoveOptions20::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", -1, &a->tt__MoveOptions20::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", -1, &a->tt__MoveOptions20::Continuous, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MoveOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MoveOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_in_tt__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MoveOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MoveOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MoveOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocusOptions(soap, "tt:Absolute", &a->tt__MoveOptions20::Absolute, "tt:AbsoluteFocusOptions"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocusOptions20(soap, "tt:Relative", &a->tt__MoveOptions20::Relative, "tt:RelativeFocusOptions20"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocusOptions(soap, "tt:Continuous", &a->tt__MoveOptions20::Continuous, "tt:ContinuousFocusOptions"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MoveOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveOptions20, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_dup_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *d, tt__MoveOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MoveOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MoveOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MoveOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AbsoluteFocusOptions(soap, &d->tt__MoveOptions20::Absolute, &a->tt__MoveOptions20::Absolute);
	soap_dup_PointerTott__RelativeFocusOptions20(soap, &d->tt__MoveOptions20::Relative, &a->tt__MoveOptions20::Relative);
	soap_dup_PointerTott__ContinuousFocusOptions(soap, &d->tt__MoveOptions20::Continuous, &a->tt__MoveOptions20::Continuous);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MoveOptions20(tt__MoveOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AbsoluteFocusOptions(&a->tt__MoveOptions20::Absolute);
	soap_del_PointerTott__RelativeFocusOptions20(&a->tt__MoveOptions20::Relative);
	soap_del_PointerTott__ContinuousFocusOptions(&a->tt__MoveOptions20::Continuous);
}

SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MoveOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MoveOptions20 *p;
	size_t k = sizeof(tt__MoveOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MoveOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MoveOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MoveOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MoveOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MoveOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MoveOptions20(soap, tag ? tag : "tt:MoveOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MoveOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MoveOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__MoveOptions20 * SOAP_FMAC4 soap_get_tt__MoveOptions20(struct soap *soap, tt__MoveOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ExposureOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_default_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	this->tt__ExposureOptions20::MinExposureTime = NULL;
	this->tt__ExposureOptions20::MaxExposureTime = NULL;
	this->tt__ExposureOptions20::MinGain = NULL;
	this->tt__ExposureOptions20::MaxGain = NULL;
	this->tt__ExposureOptions20::MinIris = NULL;
	this->tt__ExposureOptions20::MaxIris = NULL;
	this->tt__ExposureOptions20::ExposureTime = NULL;
	this->tt__ExposureOptions20::Gain = NULL;
	this->tt__ExposureOptions20::Iris = NULL;
}

void tt__ExposureOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ExposureMode(soap, &this->tt__ExposureOptions20::Mode);
	soap_serialize_std__vectorTemplateOftt__ExposurePriority(soap, &this->tt__ExposureOptions20::Priority);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxGain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MinIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::MaxIris);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::ExposureTime);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Gain);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ExposureOptions20::Iris);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ExposureOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ExposureOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ExposureOptions20(struct soap *soap, const char *tag, int id, const tt__ExposureOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ExposureOptions20), type ? type : "tt:ExposureOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", -1, &a->tt__ExposureOptions20::Mode, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__ExposureOptions20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinExposureTime", -1, &a->tt__ExposureOptions20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxExposureTime", -1, &a->tt__ExposureOptions20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinGain", -1, &a->tt__ExposureOptions20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxGain", -1, &a->tt__ExposureOptions20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MinIris", -1, &a->tt__ExposureOptions20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:MaxIris", -1, &a->tt__ExposureOptions20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ExposureTime", -1, &a->tt__ExposureOptions20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Gain", -1, &a->tt__ExposureOptions20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Iris", -1, &a->tt__ExposureOptions20::Iris, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ExposureOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ExposureOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_in_tt__ExposureOptions20(struct soap *soap, const char *tag, tt__ExposureOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ExposureOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ExposureOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ExposureOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposureMode(soap, "tt:Mode", &a->tt__ExposureOptions20::Mode, "tt:ExposureMode"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ExposurePriority(soap, "tt:Priority", &a->tt__ExposureOptions20::Priority, "tt:ExposurePriority"))
					continue;
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinExposureTime", &a->tt__ExposureOptions20::MinExposureTime, "tt:FloatRange"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxExposureTime", &a->tt__ExposureOptions20::MaxExposureTime, "tt:FloatRange"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinGain", &a->tt__ExposureOptions20::MinGain, "tt:FloatRange"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxGain", &a->tt__ExposureOptions20::MaxGain, "tt:FloatRange"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MinIris", &a->tt__ExposureOptions20::MinIris, "tt:FloatRange"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:MaxIris", &a->tt__ExposureOptions20::MaxIris, "tt:FloatRange"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ExposureTime", &a->tt__ExposureOptions20::ExposureTime, "tt:FloatRange"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Gain", &a->tt__ExposureOptions20::Gain, "tt:FloatRange"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Iris", &a->tt__ExposureOptions20::Iris, "tt:FloatRange"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__ExposureOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ExposureOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ExposureOptions20, SOAP_TYPE_tt__ExposureOptions20, sizeof(tt__ExposureOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_dup_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *d, tt__ExposureOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ExposureOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ExposureOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ExposureOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__ExposureMode(soap, &d->tt__ExposureOptions20::Mode, &a->tt__ExposureOptions20::Mode);
	soap_dup_std__vectorTemplateOftt__ExposurePriority(soap, &d->tt__ExposureOptions20::Priority, &a->tt__ExposureOptions20::Priority);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MinExposureTime, &a->tt__ExposureOptions20::MinExposureTime);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MaxExposureTime, &a->tt__ExposureOptions20::MaxExposureTime);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MinGain, &a->tt__ExposureOptions20::MinGain);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MaxGain, &a->tt__ExposureOptions20::MaxGain);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MinIris, &a->tt__ExposureOptions20::MinIris);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::MaxIris, &a->tt__ExposureOptions20::MaxIris);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::ExposureTime, &a->tt__ExposureOptions20::ExposureTime);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::Gain, &a->tt__ExposureOptions20::Gain);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ExposureOptions20::Iris, &a->tt__ExposureOptions20::Iris);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ExposureOptions20(tt__ExposureOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__ExposureMode(&a->tt__ExposureOptions20::Mode);
	soap_del_std__vectorTemplateOftt__ExposurePriority(&a->tt__ExposureOptions20::Priority);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MinExposureTime);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MaxExposureTime);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MinGain);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MaxGain);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MinIris);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::MaxIris);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::ExposureTime);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::Gain);
	soap_del_PointerTott__FloatRange(&a->tt__ExposureOptions20::Iris);
}

SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ExposureOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ExposureOptions20 *p;
	size_t k = sizeof(tt__ExposureOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ExposureOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ExposureOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ExposureOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ExposureOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ExposureOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ExposureOptions20(soap, tag ? tag : "tt:ExposureOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ExposureOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ExposureOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ExposureOptions20 * SOAP_FMAC4 soap_get_tt__ExposureOptions20(struct soap *soap, tt__ExposureOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensationOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	this->tt__BacklightCompensationOptions20::Level = NULL;
}

void tt__BacklightCompensationOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__BacklightCompensationMode(soap, &this->tt__BacklightCompensationOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__BacklightCompensationOptions20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensationOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensationOptions20), type ? type : "tt:BacklightCompensationOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensationOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__BacklightCompensationOptions20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensationOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensationOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_in_tt__BacklightCompensationOptions20(struct soap *soap, const char *tag, tt__BacklightCompensationOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensationOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensationOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensationOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensationOptions20::Mode, "tt:BacklightCompensationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__BacklightCompensationOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__BacklightCompensationOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensationOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensationOptions20, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(tt__BacklightCompensationOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_dup_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *d, tt__BacklightCompensationOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__BacklightCompensationOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__BacklightCompensationOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__BacklightCompensationOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__BacklightCompensationMode(soap, &d->tt__BacklightCompensationOptions20::Mode, &a->tt__BacklightCompensationOptions20::Mode);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__BacklightCompensationOptions20::Level, &a->tt__BacklightCompensationOptions20::Level);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__BacklightCompensationOptions20(tt__BacklightCompensationOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__BacklightCompensationMode(&a->tt__BacklightCompensationOptions20::Mode);
	soap_del_PointerTott__FloatRange(&a->tt__BacklightCompensationOptions20::Level);
}

SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensationOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensationOptions20 *p;
	size_t k = sizeof(tt__BacklightCompensationOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensationOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensationOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensationOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensationOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensationOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensationOptions20(soap, tag ? tag : "tt:BacklightCompensationOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensationOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensationOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensationOptions20 * SOAP_FMAC4 soap_get_tt__BacklightCompensationOptions20(struct soap *soap, tt__BacklightCompensationOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRangeOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	this->tt__WideDynamicRangeOptions20::Level = NULL;
}

void tt__WideDynamicRangeOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__WideDynamicMode(soap, &this->tt__WideDynamicRangeOptions20::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__WideDynamicRangeOptions20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicRangeOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20), type ? type : "tt:WideDynamicRangeOptions20"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRangeOptions20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__WideDynamicRangeOptions20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRangeOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRangeOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_in_tt__WideDynamicRangeOptions20(struct soap *soap, const char *tag, tt__WideDynamicRangeOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRangeOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRangeOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRangeOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRangeOptions20::Mode, "tt:WideDynamicMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__WideDynamicRangeOptions20::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__WideDynamicRangeOptions20::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRangeOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRangeOptions20, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(tt__WideDynamicRangeOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_dup_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *d, tt__WideDynamicRangeOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WideDynamicRangeOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WideDynamicRangeOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__WideDynamicMode(soap, &d->tt__WideDynamicRangeOptions20::Mode, &a->tt__WideDynamicRangeOptions20::Mode);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__WideDynamicRangeOptions20::Level, &a->tt__WideDynamicRangeOptions20::Level);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WideDynamicRangeOptions20(tt__WideDynamicRangeOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__WideDynamicMode(&a->tt__WideDynamicRangeOptions20::Mode);
	soap_del_PointerTott__FloatRange(&a->tt__WideDynamicRangeOptions20::Level);
}

SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRangeOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRangeOptions20 *p;
	size_t k = sizeof(tt__WideDynamicRangeOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRangeOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRangeOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRangeOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRangeOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRangeOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRangeOptions20(soap, tag ? tag : "tt:WideDynamicRangeOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRangeOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRangeOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRangeOptions20 * SOAP_FMAC4 soap_get_tt__WideDynamicRangeOptions20(struct soap *soap, tt__WideDynamicRangeOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IrCutFilterAutoAdjustmentOptionsExtension");
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension)
		return (tt__IrCutFilterAutoAdjustmentOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_dup_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *d, tt__IrCutFilterAutoAdjustmentOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IrCutFilterAutoAdjustmentOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IrCutFilterAutoAdjustmentOptionsExtension(tt__IrCutFilterAutoAdjustmentOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptionsExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange = NULL;
	this->tt__IrCutFilterAutoAdjustmentOptions::Extension = NULL;
}

void tt__IrCutFilterAutoAdjustmentOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	soap_serialize_PointerTobool(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &this->tt__IrCutFilterAutoAdjustmentOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions), type ? type : "tt:IrCutFilterAutoAdjustmentOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustmentOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustmentOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTimeRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, "xsd:string"))
					continue;
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, "xsd:boolean"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTimeRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:ResponseTimeRange", &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, "tt:DurationRange"))
				{	soap_flag_ResponseTimeRange1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustmentOptions::Extension, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustmentOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, sizeof(tt__IrCutFilterAutoAdjustmentOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_dup_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *d, tt__IrCutFilterAutoAdjustmentOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IrCutFilterAutoAdjustmentOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IrCutFilterAutoAdjustmentOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	soap_dup_PointerTobool(soap, &d->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset, &a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset);
	soap_dup_PointerTott__DurationRange(soap, &d->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange, &a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange);
	soap_dup_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(soap, &d->tt__IrCutFilterAutoAdjustmentOptions::Extension, &a->tt__IrCutFilterAutoAdjustmentOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IrCutFilterAutoAdjustmentOptions(tt__IrCutFilterAutoAdjustmentOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryType);
	soap_del_PointerTobool(&a->tt__IrCutFilterAutoAdjustmentOptions::BoundaryOffset);
	soap_del_PointerTott__DurationRange(&a->tt__IrCutFilterAutoAdjustmentOptions::ResponseTimeRange);
	soap_del_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension(&a->tt__IrCutFilterAutoAdjustmentOptions::Extension);
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentOptions *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentOptions(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentOptions(struct soap *soap, tt__IrCutFilterAutoAdjustmentOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImageStabilizationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImageStabilizationOptionsExtension");
}

void *tt__ImageStabilizationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, tt__ImageStabilizationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImageStabilizationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(tt__ImageStabilizationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptionsExtension)
		return (tt__ImageStabilizationOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_dup_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *d, tt__ImageStabilizationOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImageStabilizationOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImageStabilizationOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImageStabilizationOptionsExtension(tt__ImageStabilizationOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptionsExtension *p;
	size_t k = sizeof(tt__ImageStabilizationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptionsExtension(soap, tag ? tag : "tt:ImageStabilizationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptionsExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptionsExtension(struct soap *soap, tt__ImageStabilizationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	this->tt__ImageStabilizationOptions::Level = NULL;
	this->tt__ImageStabilizationOptions::Extension = NULL;
}

void tt__ImageStabilizationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ImageStabilizationMode(soap, &this->tt__ImageStabilizationOptions::Mode);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImageStabilizationOptions::Level);
	soap_serialize_PointerTott__ImageStabilizationOptionsExtension(soap, &this->tt__ImageStabilizationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilizationOptions), type ? type : "tt:ImageStabilizationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilizationOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Level", -1, &a->tt__ImageStabilizationOptions::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilizationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilizationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_in_tt__ImageStabilizationOptions(struct soap *soap, const char *tag, tt__ImageStabilizationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilizationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilizationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilizationOptions::Mode, "tt:ImageStabilizationMode"))
					continue;
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Level", &a->tt__ImageStabilizationOptions::Level, "tt:FloatRange"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, "tt:Extension", &a->tt__ImageStabilizationOptions::Extension, "tt:ImageStabilizationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__ImageStabilizationOptions::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilizationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilizationOptions, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(tt__ImageStabilizationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_dup_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *d, tt__ImageStabilizationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImageStabilizationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImageStabilizationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImageStabilizationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__ImageStabilizationMode(soap, &d->tt__ImageStabilizationOptions::Mode, &a->tt__ImageStabilizationOptions::Mode);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ImageStabilizationOptions::Level, &a->tt__ImageStabilizationOptions::Level);
	soap_dup_PointerTott__ImageStabilizationOptionsExtension(soap, &d->tt__ImageStabilizationOptions::Extension, &a->tt__ImageStabilizationOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImageStabilizationOptions(tt__ImageStabilizationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__ImageStabilizationMode(&a->tt__ImageStabilizationOptions::Mode);
	soap_del_PointerTott__FloatRange(&a->tt__ImageStabilizationOptions::Level);
	soap_del_PointerTott__ImageStabilizationOptionsExtension(&a->tt__ImageStabilizationOptions::Extension);
}

SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationOptions *p;
	size_t k = sizeof(tt__ImageStabilizationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationOptions(soap, tag ? tag : "tt:ImageStabilizationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationOptions * SOAP_FMAC4 soap_get_tt__ImageStabilizationOptions(struct soap *soap, tt__ImageStabilizationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension4::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImagingOptions20Extension4::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension4::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension4(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImagingOptions20Extension4");
}

void *tt__ImagingOptions20Extension4::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension4(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension4(struct soap *soap, const char *tag, tt__ImagingOptions20Extension4 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImagingOptions20Extension4*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension4, sizeof(tt__ImagingOptions20Extension4), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension4)
		return (tt__ImagingOptions20Extension4 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_dup_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *d, tt__ImagingOptions20Extension4 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingOptions20Extension4*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingOptions20Extension4, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingOptions20Extension4(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingOptions20Extension4(tt__ImagingOptions20Extension4 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension4(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension4 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension4);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension4, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension4);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension4, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension4 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension4::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension4(soap, tag ? tag : "tt:ImagingOptions20Extension4", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension4::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension4(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension4 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension4(struct soap *soap, tt__ImagingOptions20Extension4 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension3::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20Extension3::ToneCompensationOptions = NULL;
	this->tt__ImagingOptions20Extension3::DefoggingOptions = NULL;
	this->tt__ImagingOptions20Extension3::NoiseReductionOptions = NULL;
	this->tt__ImagingOptions20Extension3::Extension = NULL;
}

void tt__ImagingOptions20Extension3::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensationOptions(soap, &this->tt__ImagingOptions20Extension3::ToneCompensationOptions);
	soap_serialize_PointerTott__DefoggingOptions(soap, &this->tt__ImagingOptions20Extension3::DefoggingOptions);
	soap_serialize_PointerTott__NoiseReductionOptions(soap, &this->tt__ImagingOptions20Extension3::NoiseReductionOptions);
	soap_serialize_PointerTott__ImagingOptions20Extension4(soap, &this->tt__ImagingOptions20Extension3::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension3::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension3(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension3), type ? type : "tt:ImagingOptions20Extension3"))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", -1, &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", -1, &a->tt__ImagingOptions20Extension3::DefoggingOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", -1, &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension3::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension3::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension3(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension3(struct soap *soap, const char *tag, tt__ImagingOptions20Extension3 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension3*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension3)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension3 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ToneCompensationOptions1 = 1;
	size_t soap_flag_DefoggingOptions1 = 1;
	size_t soap_flag_NoiseReductionOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationOptions(soap, "tt:ToneCompensationOptions", &a->tt__ImagingOptions20Extension3::ToneCompensationOptions, "tt:ToneCompensationOptions"))
				{	soap_flag_ToneCompensationOptions1--;
					continue;
				}
			}
			if (soap_flag_DefoggingOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingOptions(soap, "tt:DefoggingOptions", &a->tt__ImagingOptions20Extension3::DefoggingOptions, "tt:DefoggingOptions"))
				{	soap_flag_DefoggingOptions1--;
					continue;
				}
			}
			if (soap_flag_NoiseReductionOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReductionOptions(soap, "tt:NoiseReductionOptions", &a->tt__ImagingOptions20Extension3::NoiseReductionOptions, "tt:NoiseReductionOptions"))
				{	soap_flag_NoiseReductionOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension4(soap, "tt:Extension", &a->tt__ImagingOptions20Extension3::Extension, "tt:ImagingOptions20Extension4"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension3, SOAP_TYPE_tt__ImagingOptions20Extension3, sizeof(tt__ImagingOptions20Extension3), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_dup_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *d, tt__ImagingOptions20Extension3 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingOptions20Extension3*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingOptions20Extension3, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingOptions20Extension3(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ToneCompensationOptions(soap, &d->tt__ImagingOptions20Extension3::ToneCompensationOptions, &a->tt__ImagingOptions20Extension3::ToneCompensationOptions);
	soap_dup_PointerTott__DefoggingOptions(soap, &d->tt__ImagingOptions20Extension3::DefoggingOptions, &a->tt__ImagingOptions20Extension3::DefoggingOptions);
	soap_dup_PointerTott__NoiseReductionOptions(soap, &d->tt__ImagingOptions20Extension3::NoiseReductionOptions, &a->tt__ImagingOptions20Extension3::NoiseReductionOptions);
	soap_dup_PointerTott__ImagingOptions20Extension4(soap, &d->tt__ImagingOptions20Extension3::Extension, &a->tt__ImagingOptions20Extension3::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingOptions20Extension3(tt__ImagingOptions20Extension3 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ToneCompensationOptions(&a->tt__ImagingOptions20Extension3::ToneCompensationOptions);
	soap_del_PointerTott__DefoggingOptions(&a->tt__ImagingOptions20Extension3::DefoggingOptions);
	soap_del_PointerTott__NoiseReductionOptions(&a->tt__ImagingOptions20Extension3::NoiseReductionOptions);
	soap_del_PointerTott__ImagingOptions20Extension4(&a->tt__ImagingOptions20Extension3::Extension);
}

SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension3(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension3 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension3);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension3, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension3);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension3, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension3 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension3::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension3(soap, tag ? tag : "tt:ImagingOptions20Extension3", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension3::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension3(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension3 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension3(struct soap *soap, tt__ImagingOptions20Extension3 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment = NULL;
	this->tt__ImagingOptions20Extension2::Extension = NULL;
}

void tt__ImagingOptions20Extension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &this->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingOptions20Extension3(soap, &this->tt__ImagingOptions20Extension2::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension2), type ? type : "tt:ImagingOptions20Extension2"))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension2::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension2(struct soap *soap, const char *tag, tt__ImagingOptions20Extension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_IrCutFilterAutoAdjustment1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IrCutFilterAutoAdjustment1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustmentOptions"))
				{	soap_flag_IrCutFilterAutoAdjustment1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension3(soap, "tt:Extension", &a->tt__ImagingOptions20Extension2::Extension, "tt:ImagingOptions20Extension3"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension2, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(tt__ImagingOptions20Extension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_dup_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *d, tt__ImagingOptions20Extension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingOptions20Extension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingOptions20Extension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingOptions20Extension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IrCutFilterAutoAdjustmentOptions(soap, &d->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment, &a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment);
	soap_dup_PointerTott__ImagingOptions20Extension3(soap, &d->tt__ImagingOptions20Extension2::Extension, &a->tt__ImagingOptions20Extension2::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingOptions20Extension2(tt__ImagingOptions20Extension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IrCutFilterAutoAdjustmentOptions(&a->tt__ImagingOptions20Extension2::IrCutFilterAutoAdjustment);
	soap_del_PointerTott__ImagingOptions20Extension3(&a->tt__ImagingOptions20Extension2::Extension);
}

SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension2 *p;
	size_t k = sizeof(tt__ImagingOptions20Extension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension2(soap, tag ? tag : "tt:ImagingOptions20Extension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension2 * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension2(struct soap *soap, tt__ImagingOptions20Extension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20Extension::ImageStabilization = NULL;
	this->tt__ImagingOptions20Extension::Extension = NULL;
}

void tt__ImagingOptions20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImageStabilizationOptions(soap, &this->tt__ImagingOptions20Extension::ImageStabilization);
	soap_serialize_PointerTott__ImagingOptions20Extension2(soap, &this->tt__ImagingOptions20Extension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20Extension), type ? type : "tt:ImagingOptions20Extension"))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", -1, &a->tt__ImagingOptions20Extension::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", -1, &a->tt__ImagingOptions20Extension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_in_tt__ImagingOptions20Extension(struct soap *soap, const char *tag, tt__ImagingOptions20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20Extension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20Extension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationOptions(soap, "tt:ImageStabilization", &a->tt__ImagingOptions20Extension::ImageStabilization, "tt:ImageStabilizationOptions"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension2(soap, "tt:Extension", &a->tt__ImagingOptions20Extension::Extension, "tt:ImagingOptions20Extension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20Extension, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(tt__ImagingOptions20Extension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_dup_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *d, tt__ImagingOptions20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingOptions20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingOptions20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingOptions20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ImageStabilizationOptions(soap, &d->tt__ImagingOptions20Extension::ImageStabilization, &a->tt__ImagingOptions20Extension::ImageStabilization);
	soap_dup_PointerTott__ImagingOptions20Extension2(soap, &d->tt__ImagingOptions20Extension::Extension, &a->tt__ImagingOptions20Extension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingOptions20Extension(tt__ImagingOptions20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ImageStabilizationOptions(&a->tt__ImagingOptions20Extension::ImageStabilization);
	soap_del_PointerTott__ImagingOptions20Extension2(&a->tt__ImagingOptions20Extension::Extension);
}

SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20Extension *p;
	size_t k = sizeof(tt__ImagingOptions20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20Extension(soap, tag ? tag : "tt:ImagingOptions20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20Extension * SOAP_FMAC4 soap_get_tt__ImagingOptions20Extension(struct soap *soap, tt__ImagingOptions20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingOptions20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingOptions20::BacklightCompensation = NULL;
	this->tt__ImagingOptions20::Brightness = NULL;
	this->tt__ImagingOptions20::ColorSaturation = NULL;
	this->tt__ImagingOptions20::Contrast = NULL;
	this->tt__ImagingOptions20::Exposure = NULL;
	this->tt__ImagingOptions20::Focus = NULL;
	soap_default_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	this->tt__ImagingOptions20::Sharpness = NULL;
	this->tt__ImagingOptions20::WideDynamicRange = NULL;
	this->tt__ImagingOptions20::WhiteBalance = NULL;
	this->tt__ImagingOptions20::Extension = NULL;
}

void tt__ImagingOptions20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensationOptions20(soap, &this->tt__ImagingOptions20::BacklightCompensation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Brightness);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::ColorSaturation);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Contrast);
	soap_serialize_PointerTott__ExposureOptions20(soap, &this->tt__ImagingOptions20::Exposure);
	soap_serialize_PointerTott__FocusOptions20(soap, &this->tt__ImagingOptions20::Focus);
	soap_serialize_std__vectorTemplateOftt__IrCutFilterMode(soap, &this->tt__ImagingOptions20::IrCutFilterModes);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ImagingOptions20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRangeOptions20(soap, &this->tt__ImagingOptions20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalanceOptions20(soap, &this->tt__ImagingOptions20::WhiteBalance);
	soap_serialize_PointerTott__ImagingOptions20Extension(soap, &this->tt__ImagingOptions20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingOptions20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingOptions20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingOptions20(struct soap *soap, const char *tag, int id, const tt__ImagingOptions20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingOptions20), type ? type : "tt:ImagingOptions20"))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingOptions20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Brightness", -1, &a->tt__ImagingOptions20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:ColorSaturation", -1, &a->tt__ImagingOptions20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Contrast", -1, &a->tt__ImagingOptions20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposureOptions20(soap, "tt:Exposure", -1, &a->tt__ImagingOptions20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusOptions20(soap, "tt:Focus", -1, &a->tt__ImagingOptions20::Focus, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", -1, &a->tt__ImagingOptions20::IrCutFilterModes, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Sharpness", -1, &a->tt__ImagingOptions20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingOptions20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingOptions20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", -1, &a->tt__ImagingOptions20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingOptions20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingOptions20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_in_tt__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingOptions20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingOptions20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingOptions20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensationOptions20(soap, "tt:BacklightCompensation", &a->tt__ImagingOptions20::BacklightCompensation, "tt:BacklightCompensationOptions20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Brightness", &a->tt__ImagingOptions20::Brightness, "tt:FloatRange"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:ColorSaturation", &a->tt__ImagingOptions20::ColorSaturation, "tt:FloatRange"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Contrast", &a->tt__ImagingOptions20::Contrast, "tt:FloatRange"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposureOptions20(soap, "tt:Exposure", &a->tt__ImagingOptions20::Exposure, "tt:ExposureOptions20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusOptions20(soap, "tt:Focus", &a->tt__ImagingOptions20::Focus, "tt:FocusOptions20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IrCutFilterMode(soap, "tt:IrCutFilterModes", &a->tt__ImagingOptions20::IrCutFilterModes, "tt:IrCutFilterMode"))
					continue;
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Sharpness", &a->tt__ImagingOptions20::Sharpness, "tt:FloatRange"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRangeOptions20(soap, "tt:WideDynamicRange", &a->tt__ImagingOptions20::WideDynamicRange, "tt:WideDynamicRangeOptions20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalanceOptions20(soap, "tt:WhiteBalance", &a->tt__ImagingOptions20::WhiteBalance, "tt:WhiteBalanceOptions20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingOptions20Extension(soap, "tt:Extension", &a->tt__ImagingOptions20::Extension, "tt:ImagingOptions20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingOptions20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingOptions20, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_dup_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *d, tt__ImagingOptions20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingOptions20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingOptions20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingOptions20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__BacklightCompensationOptions20(soap, &d->tt__ImagingOptions20::BacklightCompensation, &a->tt__ImagingOptions20::BacklightCompensation);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ImagingOptions20::Brightness, &a->tt__ImagingOptions20::Brightness);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ImagingOptions20::ColorSaturation, &a->tt__ImagingOptions20::ColorSaturation);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ImagingOptions20::Contrast, &a->tt__ImagingOptions20::Contrast);
	soap_dup_PointerTott__ExposureOptions20(soap, &d->tt__ImagingOptions20::Exposure, &a->tt__ImagingOptions20::Exposure);
	soap_dup_PointerTott__FocusOptions20(soap, &d->tt__ImagingOptions20::Focus, &a->tt__ImagingOptions20::Focus);
	soap_dup_std__vectorTemplateOftt__IrCutFilterMode(soap, &d->tt__ImagingOptions20::IrCutFilterModes, &a->tt__ImagingOptions20::IrCutFilterModes);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ImagingOptions20::Sharpness, &a->tt__ImagingOptions20::Sharpness);
	soap_dup_PointerTott__WideDynamicRangeOptions20(soap, &d->tt__ImagingOptions20::WideDynamicRange, &a->tt__ImagingOptions20::WideDynamicRange);
	soap_dup_PointerTott__WhiteBalanceOptions20(soap, &d->tt__ImagingOptions20::WhiteBalance, &a->tt__ImagingOptions20::WhiteBalance);
	soap_dup_PointerTott__ImagingOptions20Extension(soap, &d->tt__ImagingOptions20::Extension, &a->tt__ImagingOptions20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingOptions20(tt__ImagingOptions20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__BacklightCompensationOptions20(&a->tt__ImagingOptions20::BacklightCompensation);
	soap_del_PointerTott__FloatRange(&a->tt__ImagingOptions20::Brightness);
	soap_del_PointerTott__FloatRange(&a->tt__ImagingOptions20::ColorSaturation);
	soap_del_PointerTott__FloatRange(&a->tt__ImagingOptions20::Contrast);
	soap_del_PointerTott__ExposureOptions20(&a->tt__ImagingOptions20::Exposure);
	soap_del_PointerTott__FocusOptions20(&a->tt__ImagingOptions20::Focus);
	soap_del_std__vectorTemplateOftt__IrCutFilterMode(&a->tt__ImagingOptions20::IrCutFilterModes);
	soap_del_PointerTott__FloatRange(&a->tt__ImagingOptions20::Sharpness);
	soap_del_PointerTott__WideDynamicRangeOptions20(&a->tt__ImagingOptions20::WideDynamicRange);
	soap_del_PointerTott__WhiteBalanceOptions20(&a->tt__ImagingOptions20::WhiteBalance);
	soap_del_PointerTott__ImagingOptions20Extension(&a->tt__ImagingOptions20::Extension);
}

SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingOptions20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingOptions20 *p;
	size_t k = sizeof(tt__ImagingOptions20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingOptions20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingOptions20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingOptions20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingOptions20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingOptions20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingOptions20(soap, tag ? tag : "tt:ImagingOptions20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingOptions20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingOptions20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingOptions20 * SOAP_FMAC4 soap_get_tt__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NoiseReduction::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__NoiseReduction::Level);
}

void tt__NoiseReduction::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NoiseReduction::Level, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NoiseReduction::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NoiseReduction(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NoiseReduction(struct soap *soap, const char *tag, int id, const tt__NoiseReduction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NoiseReduction), type ? type : "tt:NoiseReduction"))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__NoiseReduction::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NoiseReduction::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NoiseReduction(soap, tag, this, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_in_tt__NoiseReduction(struct soap *soap, const char *tag, tt__NoiseReduction *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NoiseReduction*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NoiseReduction)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NoiseReduction *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__NoiseReduction::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NoiseReduction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NoiseReduction, SOAP_TYPE_tt__NoiseReduction, sizeof(tt__NoiseReduction), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_dup_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *d, tt__NoiseReduction const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NoiseReduction*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NoiseReduction, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NoiseReduction(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NoiseReduction::Level = a->tt__NoiseReduction::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NoiseReduction(tt__NoiseReduction const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Level skipped */
}

SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NoiseReduction(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NoiseReduction *p;
	size_t k = sizeof(tt__NoiseReduction);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NoiseReduction, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NoiseReduction);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NoiseReduction, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NoiseReduction location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NoiseReduction::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NoiseReduction(soap, tag ? tag : "tt:NoiseReduction", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NoiseReduction::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NoiseReduction(soap, this, tag, type);
}

SOAP_FMAC3 tt__NoiseReduction * SOAP_FMAC4 soap_get_tt__NoiseReduction(struct soap *soap, tt__NoiseReduction *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NoiseReduction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DefoggingExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__DefoggingExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DefoggingExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DefoggingExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DefoggingExtension(struct soap *soap, const char *tag, int id, const tt__DefoggingExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:DefoggingExtension");
}

void *tt__DefoggingExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DefoggingExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_in_tt__DefoggingExtension(struct soap *soap, const char *tag, tt__DefoggingExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DefoggingExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DefoggingExtension, sizeof(tt__DefoggingExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DefoggingExtension)
		return (tt__DefoggingExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_dup_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *d, tt__DefoggingExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DefoggingExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DefoggingExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DefoggingExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DefoggingExtension(tt__DefoggingExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DefoggingExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DefoggingExtension *p;
	size_t k = sizeof(tt__DefoggingExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DefoggingExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DefoggingExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DefoggingExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DefoggingExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DefoggingExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DefoggingExtension(soap, tag ? tag : "tt:DefoggingExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DefoggingExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DefoggingExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DefoggingExtension * SOAP_FMAC4 soap_get_tt__DefoggingExtension(struct soap *soap, tt__DefoggingExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DefoggingExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Defogging::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__Defogging::Mode);
	this->tt__Defogging::Level = NULL;
	this->tt__Defogging::Extension = NULL;
}

void tt__Defogging::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Defogging::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Defogging::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__Defogging::Level);
	soap_serialize_PointerTott__DefoggingExtension(soap, &this->tt__Defogging::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Defogging::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Defogging(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Defogging(struct soap *soap, const char *tag, int id, const tt__Defogging *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Defogging), type ? type : "tt:Defogging"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__Defogging::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__Defogging::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__DefoggingExtension(soap, "tt:Extension", -1, &a->tt__Defogging::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Defogging::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Defogging(soap, tag, this, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_in_tt__Defogging(struct soap *soap, const char *tag, tt__Defogging *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Defogging*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Defogging)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Defogging *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__Defogging::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__Defogging::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DefoggingExtension(soap, "tt:Extension", &a->tt__Defogging::Extension, "tt:DefoggingExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Defogging *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Defogging, SOAP_TYPE_tt__Defogging, sizeof(tt__Defogging), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_dup_tt__Defogging(struct soap *soap, tt__Defogging *d, tt__Defogging const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Defogging*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Defogging, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Defogging(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__Defogging::Mode, &a->tt__Defogging::Mode);
	soap_dup_PointerTofloat(soap, &d->tt__Defogging::Level, &a->tt__Defogging::Level);
	soap_dup_PointerTott__DefoggingExtension(soap, &d->tt__Defogging::Extension, &a->tt__Defogging::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Defogging(tt__Defogging const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__Defogging::Mode);
	soap_del_PointerTofloat(&a->tt__Defogging::Level);
	soap_del_PointerTott__DefoggingExtension(&a->tt__Defogging::Extension);
}

SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Defogging(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Defogging *p;
	size_t k = sizeof(tt__Defogging);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Defogging, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Defogging);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Defogging, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Defogging location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Defogging::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Defogging(soap, tag ? tag : "tt:Defogging", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Defogging::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Defogging(soap, this, tag, type);
}

SOAP_FMAC3 tt__Defogging * SOAP_FMAC4 soap_get_tt__Defogging(struct soap *soap, tt__Defogging *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Defogging(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ToneCompensationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensationExtension(struct soap *soap, const char *tag, int id, const tt__ToneCompensationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ToneCompensationExtension");
}

void *tt__ToneCompensationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_in_tt__ToneCompensationExtension(struct soap *soap, const char *tag, tt__ToneCompensationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ToneCompensationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensationExtension, sizeof(tt__ToneCompensationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensationExtension)
		return (tt__ToneCompensationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_dup_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *d, tt__ToneCompensationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ToneCompensationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ToneCompensationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ToneCompensationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ToneCompensationExtension(tt__ToneCompensationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensationExtension *p;
	size_t k = sizeof(tt__ToneCompensationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensationExtension(soap, tag ? tag : "tt:ToneCompensationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensationExtension * SOAP_FMAC4 soap_get_tt__ToneCompensationExtension(struct soap *soap, tt__ToneCompensationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ToneCompensation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__ToneCompensation::Mode);
	this->tt__ToneCompensation::Level = NULL;
	this->tt__ToneCompensation::Extension = NULL;
}

void tt__ToneCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ToneCompensation::Mode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__ToneCompensation::Mode);
	soap_serialize_PointerTofloat(soap, &this->tt__ToneCompensation::Level);
	soap_serialize_PointerTott__ToneCompensationExtension(soap, &this->tt__ToneCompensation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ToneCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ToneCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ToneCompensation(struct soap *soap, const char *tag, int id, const tt__ToneCompensation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ToneCompensation), type ? type : "tt:ToneCompensation"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Mode", -1, &a->tt__ToneCompensation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ToneCompensation::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensationExtension(soap, "tt:Extension", -1, &a->tt__ToneCompensation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ToneCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ToneCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_in_tt__ToneCompensation(struct soap *soap, const char *tag, tt__ToneCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ToneCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ToneCompensation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ToneCompensation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Mode", &a->tt__ToneCompensation::Mode, "xsd:string"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ToneCompensation::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensationExtension(soap, "tt:Extension", &a->tt__ToneCompensation::Extension, "tt:ToneCompensationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ToneCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ToneCompensation, SOAP_TYPE_tt__ToneCompensation, sizeof(tt__ToneCompensation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_dup_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *d, tt__ToneCompensation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ToneCompensation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ToneCompensation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ToneCompensation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__ToneCompensation::Mode, &a->tt__ToneCompensation::Mode);
	soap_dup_PointerTofloat(soap, &d->tt__ToneCompensation::Level, &a->tt__ToneCompensation::Level);
	soap_dup_PointerTott__ToneCompensationExtension(soap, &d->tt__ToneCompensation::Extension, &a->tt__ToneCompensation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ToneCompensation(tt__ToneCompensation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__ToneCompensation::Mode);
	soap_del_PointerTofloat(&a->tt__ToneCompensation::Level);
	soap_del_PointerTott__ToneCompensationExtension(&a->tt__ToneCompensation::Extension);
}

SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ToneCompensation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ToneCompensation *p;
	size_t k = sizeof(tt__ToneCompensation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ToneCompensation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ToneCompensation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ToneCompensation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ToneCompensation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ToneCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ToneCompensation(soap, tag ? tag : "tt:ToneCompensation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ToneCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ToneCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__ToneCompensation * SOAP_FMAC4 soap_get_tt__ToneCompensation(struct soap *soap, tt__ToneCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ToneCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Exposure20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure20::Mode);
	this->tt__Exposure20::Priority = NULL;
	this->tt__Exposure20::Window = NULL;
	this->tt__Exposure20::MinExposureTime = NULL;
	this->tt__Exposure20::MaxExposureTime = NULL;
	this->tt__Exposure20::MinGain = NULL;
	this->tt__Exposure20::MaxGain = NULL;
	this->tt__Exposure20::MinIris = NULL;
	this->tt__Exposure20::MaxIris = NULL;
	this->tt__Exposure20::ExposureTime = NULL;
	this->tt__Exposure20::Gain = NULL;
	this->tt__Exposure20::Iris = NULL;
}

void tt__Exposure20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ExposurePriority(soap, &this->tt__Exposure20::Priority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure20::Window);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxGain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MinIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::MaxIris);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::ExposureTime);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Gain);
	soap_serialize_PointerTofloat(soap, &this->tt__Exposure20::Iris);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Exposure20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure20(struct soap *soap, const char *tag, int id, const tt__Exposure20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure20), type ? type : "tt:Exposure20"))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->tt__Exposure20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ExposurePriority(soap, "tt:Priority", -1, &a->tt__Exposure20::Priority, ""))
		return soap->error;
	if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure20::Window, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinExposureTime", -1, &a->tt__Exposure20::MinExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxExposureTime", -1, &a->tt__Exposure20::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinGain", -1, &a->tt__Exposure20::MinGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxGain", -1, &a->tt__Exposure20::MaxGain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MinIris", -1, &a->tt__Exposure20::MinIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:MaxIris", -1, &a->tt__Exposure20::MaxIris, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ExposureTime", -1, &a->tt__Exposure20::ExposureTime, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Gain", -1, &a->tt__Exposure20::Gain, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Iris", -1, &a->tt__Exposure20::Iris, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Exposure20(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_in_tt__Exposure20(struct soap *soap, const char *tag, tt__Exposure20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Exposure20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Exposure20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->tt__Exposure20::Mode, "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ExposurePriority(soap, "tt:Priority", &a->tt__Exposure20::Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->tt__Exposure20::Window, "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinExposureTime", &a->tt__Exposure20::MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxExposureTime", &a->tt__Exposure20::MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinGain", &a->tt__Exposure20::MinGain, "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxGain", &a->tt__Exposure20::MaxGain, "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MinIris", &a->tt__Exposure20::MinIris, "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:MaxIris", &a->tt__Exposure20::MaxIris, "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ExposureTime", &a->tt__Exposure20::ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Gain", &a->tt__Exposure20::Gain, "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Iris", &a->tt__Exposure20::Iris, "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Exposure20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure20, SOAP_TYPE_tt__Exposure20, sizeof(tt__Exposure20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_dup_tt__Exposure20(struct soap *soap, tt__Exposure20 *d, tt__Exposure20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Exposure20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Exposure20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Exposure20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Exposure20::Mode = a->tt__Exposure20::Mode;
	soap_dup_PointerTott__ExposurePriority(soap, &d->tt__Exposure20::Priority, &a->tt__Exposure20::Priority);
	soap_dup_PointerTott__Rectangle(soap, &d->tt__Exposure20::Window, &a->tt__Exposure20::Window);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MinExposureTime, &a->tt__Exposure20::MinExposureTime);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MaxExposureTime, &a->tt__Exposure20::MaxExposureTime);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MinGain, &a->tt__Exposure20::MinGain);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MaxGain, &a->tt__Exposure20::MaxGain);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MinIris, &a->tt__Exposure20::MinIris);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::MaxIris, &a->tt__Exposure20::MaxIris);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::ExposureTime, &a->tt__Exposure20::ExposureTime);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::Gain, &a->tt__Exposure20::Gain);
	soap_dup_PointerTofloat(soap, &d->tt__Exposure20::Iris, &a->tt__Exposure20::Iris);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Exposure20(tt__Exposure20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTott__ExposurePriority(&a->tt__Exposure20::Priority);
	soap_del_PointerTott__Rectangle(&a->tt__Exposure20::Window);
	soap_del_PointerTofloat(&a->tt__Exposure20::MinExposureTime);
	soap_del_PointerTofloat(&a->tt__Exposure20::MaxExposureTime);
	soap_del_PointerTofloat(&a->tt__Exposure20::MinGain);
	soap_del_PointerTofloat(&a->tt__Exposure20::MaxGain);
	soap_del_PointerTofloat(&a->tt__Exposure20::MinIris);
	soap_del_PointerTofloat(&a->tt__Exposure20::MaxIris);
	soap_del_PointerTofloat(&a->tt__Exposure20::ExposureTime);
	soap_del_PointerTofloat(&a->tt__Exposure20::Gain);
	soap_del_PointerTofloat(&a->tt__Exposure20::Iris);
}

SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Exposure20 *p;
	size_t k = sizeof(tt__Exposure20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Exposure20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Exposure20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Exposure20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Exposure20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Exposure20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Exposure20(soap, tag ? tag : "tt:Exposure20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure20(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure20 * SOAP_FMAC4 soap_get_tt__Exposure20(struct soap *soap, tt__Exposure20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensation20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation20::Mode);
	this->tt__BacklightCompensation20::Level = NULL;
}

void tt__BacklightCompensation20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__BacklightCompensation20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensation20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation20(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation20), type ? type : "tt:BacklightCompensation20"))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensation20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__BacklightCompensation20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensation20(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_in_tt__BacklightCompensation20(struct soap *soap, const char *tag, tt__BacklightCompensation20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensation20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensation20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensation20::Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__BacklightCompensation20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensation20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation20, SOAP_TYPE_tt__BacklightCompensation20, sizeof(tt__BacklightCompensation20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_dup_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *d, tt__BacklightCompensation20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__BacklightCompensation20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__BacklightCompensation20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__BacklightCompensation20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__BacklightCompensation20::Mode = a->tt__BacklightCompensation20::Mode;
	soap_dup_PointerTofloat(soap, &d->tt__BacklightCompensation20::Level, &a->tt__BacklightCompensation20::Level);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__BacklightCompensation20(tt__BacklightCompensation20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTofloat(&a->tt__BacklightCompensation20::Level);
}

SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensation20 *p;
	size_t k = sizeof(tt__BacklightCompensation20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensation20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensation20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensation20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensation20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensation20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensation20(soap, tag ? tag : "tt:BacklightCompensation20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation20(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation20 * SOAP_FMAC4 soap_get_tt__BacklightCompensation20(struct soap *soap, tt__BacklightCompensation20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRange20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange20::Mode);
	this->tt__WideDynamicRange20::Level = NULL;
}

void tt__WideDynamicRange20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__WideDynamicRange20::Level);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicRange20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange20(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange20), type ? type : "tt:WideDynamicRange20"))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRange20::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__WideDynamicRange20::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRange20(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_in_tt__WideDynamicRange20(struct soap *soap, const char *tag, tt__WideDynamicRange20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRange20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRange20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRange20::Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__WideDynamicRange20::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRange20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange20, SOAP_TYPE_tt__WideDynamicRange20, sizeof(tt__WideDynamicRange20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_dup_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *d, tt__WideDynamicRange20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WideDynamicRange20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WideDynamicRange20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WideDynamicRange20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__WideDynamicRange20::Mode = a->tt__WideDynamicRange20::Mode;
	soap_dup_PointerTofloat(soap, &d->tt__WideDynamicRange20::Level, &a->tt__WideDynamicRange20::Level);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WideDynamicRange20(tt__WideDynamicRange20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTofloat(&a->tt__WideDynamicRange20::Level);
}

SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRange20 *p;
	size_t k = sizeof(tt__WideDynamicRange20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRange20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRange20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRange20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRange20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRange20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRange20(soap, tag ? tag : "tt:WideDynamicRange20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange20(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange20 * SOAP_FMAC4 soap_get_tt__WideDynamicRange20(struct soap *soap, tt__WideDynamicRange20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__IrCutFilterAutoAdjustmentExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IrCutFilterAutoAdjustmentExtension");
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustmentExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IrCutFilterAutoAdjustmentExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, sizeof(tt__IrCutFilterAutoAdjustmentExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension)
		return (tt__IrCutFilterAutoAdjustmentExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_dup_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *d, tt__IrCutFilterAutoAdjustmentExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IrCutFilterAutoAdjustmentExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IrCutFilterAutoAdjustmentExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IrCutFilterAutoAdjustmentExtension(tt__IrCutFilterAutoAdjustmentExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustmentExtension *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustmentExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustmentExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustmentExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustmentExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustmentExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustmentExtension(soap, tag ? tag : "tt:IrCutFilterAutoAdjustmentExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustmentExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustmentExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustmentExtension(struct soap *soap, tt__IrCutFilterAutoAdjustmentExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustmentExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IrCutFilterAutoAdjustment::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	this->tt__IrCutFilterAutoAdjustment::BoundaryOffset = NULL;
	this->tt__IrCutFilterAutoAdjustment::ResponseTime = NULL;
	this->tt__IrCutFilterAutoAdjustment::Extension = NULL;
}

void tt__IrCutFilterAutoAdjustment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryType);
	soap_serialize_PointerTofloat(soap, &this->tt__IrCutFilterAutoAdjustment::BoundaryOffset);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__IrCutFilterAutoAdjustment::ResponseTime);
	soap_serialize_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, &this->tt__IrCutFilterAutoAdjustment::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IrCutFilterAutoAdjustment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IrCutFilterAutoAdjustment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, int id, const tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment), type ? type : "tt:IrCutFilterAutoAdjustment"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:BoundaryType", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryType, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:BoundaryOffset", -1, &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:ResponseTime", -1, &a->tt__IrCutFilterAutoAdjustment::ResponseTime, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", -1, &a->tt__IrCutFilterAutoAdjustment::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IrCutFilterAutoAdjustment::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, this, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_in_tt__IrCutFilterAutoAdjustment(struct soap *soap, const char *tag, tt__IrCutFilterAutoAdjustment *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IrCutFilterAutoAdjustment*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IrCutFilterAutoAdjustment)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IrCutFilterAutoAdjustment *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundaryType1 = 1;
	size_t soap_flag_BoundaryOffset1 = 1;
	size_t soap_flag_ResponseTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundaryType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:BoundaryType", &a->tt__IrCutFilterAutoAdjustment::BoundaryType, "xsd:string"))
				{	soap_flag_BoundaryType1--;
					continue;
				}
			}
			if (soap_flag_BoundaryOffset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:BoundaryOffset", &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset, "xsd:float"))
				{	soap_flag_BoundaryOffset1--;
					continue;
				}
			}
			if (soap_flag_ResponseTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:ResponseTime", &a->tt__IrCutFilterAutoAdjustment::ResponseTime, "xsd:duration"))
				{	soap_flag_ResponseTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, "tt:Extension", &a->tt__IrCutFilterAutoAdjustment::Extension, "tt:IrCutFilterAutoAdjustmentExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_BoundaryType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IrCutFilterAutoAdjustment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, sizeof(tt__IrCutFilterAutoAdjustment), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_dup_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *d, tt__IrCutFilterAutoAdjustment const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IrCutFilterAutoAdjustment*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IrCutFilterAutoAdjustment(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__IrCutFilterAutoAdjustment::BoundaryType, &a->tt__IrCutFilterAutoAdjustment::BoundaryType);
	soap_dup_PointerTofloat(soap, &d->tt__IrCutFilterAutoAdjustment::BoundaryOffset, &a->tt__IrCutFilterAutoAdjustment::BoundaryOffset);
	soap_dup_PointerToxsd__duration(soap, &d->tt__IrCutFilterAutoAdjustment::ResponseTime, &a->tt__IrCutFilterAutoAdjustment::ResponseTime);
	soap_dup_PointerTott__IrCutFilterAutoAdjustmentExtension(soap, &d->tt__IrCutFilterAutoAdjustment::Extension, &a->tt__IrCutFilterAutoAdjustment::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IrCutFilterAutoAdjustment(tt__IrCutFilterAutoAdjustment const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__IrCutFilterAutoAdjustment::BoundaryType);
	soap_del_PointerTofloat(&a->tt__IrCutFilterAutoAdjustment::BoundaryOffset);
	soap_del_PointerToxsd__duration(&a->tt__IrCutFilterAutoAdjustment::ResponseTime);
	soap_del_PointerTott__IrCutFilterAutoAdjustmentExtension(&a->tt__IrCutFilterAutoAdjustment::Extension);
}

SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IrCutFilterAutoAdjustment(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IrCutFilterAutoAdjustment *p;
	size_t k = sizeof(tt__IrCutFilterAutoAdjustment);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IrCutFilterAutoAdjustment, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IrCutFilterAutoAdjustment);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IrCutFilterAutoAdjustment, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IrCutFilterAutoAdjustment location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IrCutFilterAutoAdjustment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IrCutFilterAutoAdjustment(soap, tag ? tag : "tt:IrCutFilterAutoAdjustment", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IrCutFilterAutoAdjustment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IrCutFilterAutoAdjustment(soap, this, tag, type);
}

SOAP_FMAC3 tt__IrCutFilterAutoAdjustment * SOAP_FMAC4 soap_get_tt__IrCutFilterAutoAdjustment(struct soap *soap, tt__IrCutFilterAutoAdjustment *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IrCutFilterAutoAdjustment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilizationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImageStabilizationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilizationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilizationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, const tt__ImageStabilizationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImageStabilizationExtension");
}

void *tt__ImageStabilizationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilizationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_in_tt__ImageStabilizationExtension(struct soap *soap, const char *tag, tt__ImageStabilizationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImageStabilizationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(tt__ImageStabilizationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilizationExtension)
		return (tt__ImageStabilizationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_dup_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *d, tt__ImageStabilizationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImageStabilizationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImageStabilizationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImageStabilizationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImageStabilizationExtension(tt__ImageStabilizationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilizationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilizationExtension *p;
	size_t k = sizeof(tt__ImageStabilizationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilizationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilizationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilizationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilizationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilizationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilizationExtension(soap, tag ? tag : "tt:ImageStabilizationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilizationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilizationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilizationExtension * SOAP_FMAC4 soap_get_tt__ImageStabilizationExtension(struct soap *soap, tt__ImageStabilizationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImageStabilization::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ImageStabilizationMode(soap, &this->tt__ImageStabilization::Mode);
	this->tt__ImageStabilization::Level = NULL;
	this->tt__ImageStabilization::Extension = NULL;
}

void tt__ImageStabilization::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTofloat(soap, &this->tt__ImageStabilization::Level);
	soap_serialize_PointerTott__ImageStabilizationExtension(soap, &this->tt__ImageStabilization::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImageStabilization::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImageStabilization(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImageStabilization(struct soap *soap, const char *tag, int id, const tt__ImageStabilization *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImageStabilization), type ? type : "tt:ImageStabilization"))
		return soap->error;
	if (soap_out_tt__ImageStabilizationMode(soap, "tt:Mode", -1, &a->tt__ImageStabilization::Mode, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Level", -1, &a->tt__ImageStabilization::Level, ""))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", -1, &a->tt__ImageStabilization::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImageStabilization::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImageStabilization(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_in_tt__ImageStabilization(struct soap *soap, const char *tag, tt__ImageStabilization *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImageStabilization*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImageStabilization)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImageStabilization *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ImageStabilizationMode(soap, "tt:Mode", &a->tt__ImageStabilization::Mode, "tt:ImageStabilizationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Level", &a->tt__ImageStabilization::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilizationExtension(soap, "tt:Extension", &a->tt__ImageStabilization::Extension, "tt:ImageStabilizationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImageStabilization *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImageStabilization, SOAP_TYPE_tt__ImageStabilization, sizeof(tt__ImageStabilization), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_dup_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *d, tt__ImageStabilization const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImageStabilization*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImageStabilization, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImageStabilization(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__ImageStabilization::Mode = a->tt__ImageStabilization::Mode;
	soap_dup_PointerTofloat(soap, &d->tt__ImageStabilization::Level, &a->tt__ImageStabilization::Level);
	soap_dup_PointerTott__ImageStabilizationExtension(soap, &d->tt__ImageStabilization::Extension, &a->tt__ImageStabilization::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImageStabilization(tt__ImageStabilization const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTofloat(&a->tt__ImageStabilization::Level);
	soap_del_PointerTott__ImageStabilizationExtension(&a->tt__ImageStabilization::Extension);
}

SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImageStabilization(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImageStabilization *p;
	size_t k = sizeof(tt__ImageStabilization);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImageStabilization, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImageStabilization);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImageStabilization, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImageStabilization location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImageStabilization::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImageStabilization(soap, tag ? tag : "tt:ImageStabilization", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImageStabilization::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImageStabilization(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImageStabilization * SOAP_FMAC4 soap_get_tt__ImageStabilization(struct soap *soap, tt__ImageStabilization *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension204::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImagingSettingsExtension204::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension204::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension204(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImagingSettingsExtension204");
}

void *tt__ImagingSettingsExtension204::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension204(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension204(struct soap *soap, const char *tag, tt__ImagingSettingsExtension204 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImagingSettingsExtension204*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension204, sizeof(tt__ImagingSettingsExtension204), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension204)
		return (tt__ImagingSettingsExtension204 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_dup_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *d, tt__ImagingSettingsExtension204 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettingsExtension204*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettingsExtension204, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettingsExtension204(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettingsExtension204(tt__ImagingSettingsExtension204 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension204(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension204 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension204);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension204, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension204);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension204, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension204 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension204::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension204(soap, tag ? tag : "tt:ImagingSettingsExtension204", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension204::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension204(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension204 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension204(struct soap *soap, tt__ImagingSettingsExtension204 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension204(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension203::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettingsExtension203::ToneCompensation = NULL;
	this->tt__ImagingSettingsExtension203::Defogging = NULL;
	this->tt__ImagingSettingsExtension203::NoiseReduction = NULL;
	this->tt__ImagingSettingsExtension203::Extension = NULL;
}

void tt__ImagingSettingsExtension203::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ToneCompensation(soap, &this->tt__ImagingSettingsExtension203::ToneCompensation);
	soap_serialize_PointerTott__Defogging(soap, &this->tt__ImagingSettingsExtension203::Defogging);
	soap_serialize_PointerTott__NoiseReduction(soap, &this->tt__ImagingSettingsExtension203::NoiseReduction);
	soap_serialize_PointerTott__ImagingSettingsExtension204(soap, &this->tt__ImagingSettingsExtension203::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension203::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension203(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension203), type ? type : "tt:ImagingSettingsExtension203"))
		return soap->error;
	if (soap_out_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", -1, &a->tt__ImagingSettingsExtension203::ToneCompensation, ""))
		return soap->error;
	if (soap_out_PointerTott__Defogging(soap, "tt:Defogging", -1, &a->tt__ImagingSettingsExtension203::Defogging, ""))
		return soap->error;
	if (soap_out_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", -1, &a->tt__ImagingSettingsExtension203::NoiseReduction, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension203::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension203::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension203(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension203(struct soap *soap, const char *tag, tt__ImagingSettingsExtension203 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension203*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension203)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension203 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ToneCompensation1 = 1;
	size_t soap_flag_Defogging1 = 1;
	size_t soap_flag_NoiseReduction1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ToneCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ToneCompensation(soap, "tt:ToneCompensation", &a->tt__ImagingSettingsExtension203::ToneCompensation, "tt:ToneCompensation"))
				{	soap_flag_ToneCompensation1--;
					continue;
				}
			}
			if (soap_flag_Defogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Defogging(soap, "tt:Defogging", &a->tt__ImagingSettingsExtension203::Defogging, "tt:Defogging"))
				{	soap_flag_Defogging1--;
					continue;
				}
			}
			if (soap_flag_NoiseReduction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NoiseReduction(soap, "tt:NoiseReduction", &a->tt__ImagingSettingsExtension203::NoiseReduction, "tt:NoiseReduction"))
				{	soap_flag_NoiseReduction1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension204(soap, "tt:Extension", &a->tt__ImagingSettingsExtension203::Extension, "tt:ImagingSettingsExtension204"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension203 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension203, SOAP_TYPE_tt__ImagingSettingsExtension203, sizeof(tt__ImagingSettingsExtension203), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_dup_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *d, tt__ImagingSettingsExtension203 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettingsExtension203*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettingsExtension203, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettingsExtension203(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ToneCompensation(soap, &d->tt__ImagingSettingsExtension203::ToneCompensation, &a->tt__ImagingSettingsExtension203::ToneCompensation);
	soap_dup_PointerTott__Defogging(soap, &d->tt__ImagingSettingsExtension203::Defogging, &a->tt__ImagingSettingsExtension203::Defogging);
	soap_dup_PointerTott__NoiseReduction(soap, &d->tt__ImagingSettingsExtension203::NoiseReduction, &a->tt__ImagingSettingsExtension203::NoiseReduction);
	soap_dup_PointerTott__ImagingSettingsExtension204(soap, &d->tt__ImagingSettingsExtension203::Extension, &a->tt__ImagingSettingsExtension203::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettingsExtension203(tt__ImagingSettingsExtension203 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ToneCompensation(&a->tt__ImagingSettingsExtension203::ToneCompensation);
	soap_del_PointerTott__Defogging(&a->tt__ImagingSettingsExtension203::Defogging);
	soap_del_PointerTott__NoiseReduction(&a->tt__ImagingSettingsExtension203::NoiseReduction);
	soap_del_PointerTott__ImagingSettingsExtension204(&a->tt__ImagingSettingsExtension203::Extension);
}

SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension203(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension203 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension203);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension203, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension203);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension203, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension203 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension203::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension203(soap, tag ? tag : "tt:ImagingSettingsExtension203", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension203::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension203(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension203 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension203(struct soap *soap, tt__ImagingSettingsExtension203 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension203(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension202::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	this->tt__ImagingSettingsExtension202::Extension = NULL;
}

void tt__ImagingSettingsExtension202::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &this->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	soap_serialize_PointerTott__ImagingSettingsExtension203(soap, &this->tt__ImagingSettingsExtension202::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension202::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension202(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension202), type ? type : "tt:ImagingSettingsExtension202"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", -1, &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension202::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension202::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension202(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension202(struct soap *soap, const char *tag, tt__ImagingSettingsExtension202 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension202*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension202)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension202 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, "tt:IrCutFilterAutoAdjustment", &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, "tt:IrCutFilterAutoAdjustment"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension203(soap, "tt:Extension", &a->tt__ImagingSettingsExtension202::Extension, "tt:ImagingSettingsExtension203"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension202 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension202, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(tt__ImagingSettingsExtension202), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_dup_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *d, tt__ImagingSettingsExtension202 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettingsExtension202*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettingsExtension202, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettingsExtension202(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(soap, &d->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment, &a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	soap_dup_PointerTott__ImagingSettingsExtension203(soap, &d->tt__ImagingSettingsExtension202::Extension, &a->tt__ImagingSettingsExtension202::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettingsExtension202(tt__ImagingSettingsExtension202 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment(&a->tt__ImagingSettingsExtension202::IrCutFilterAutoAdjustment);
	soap_del_PointerTott__ImagingSettingsExtension203(&a->tt__ImagingSettingsExtension202::Extension);
}

SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension202(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension202 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension202);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension202, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension202);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension202, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension202 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension202::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension202(soap, tag ? tag : "tt:ImagingSettingsExtension202", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension202::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension202(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension202 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension202(struct soap *soap, tt__ImagingSettingsExtension202 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettingsExtension20::ImageStabilization = NULL;
	this->tt__ImagingSettingsExtension20::Extension = NULL;
}

void tt__ImagingSettingsExtension20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImageStabilization(soap, &this->tt__ImagingSettingsExtension20::ImageStabilization);
	soap_serialize_PointerTott__ImagingSettingsExtension202(soap, &this->tt__ImagingSettingsExtension20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettingsExtension20), type ? type : "tt:ImagingSettingsExtension20"))
		return soap->error;
	if (soap_out_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", -1, &a->tt__ImagingSettingsExtension20::ImageStabilization, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", -1, &a->tt__ImagingSettingsExtension20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettingsExtension20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension20(struct soap *soap, const char *tag, tt__ImagingSettingsExtension20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettingsExtension20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettingsExtension20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ImageStabilization1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImageStabilization1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImageStabilization(soap, "tt:ImageStabilization", &a->tt__ImagingSettingsExtension20::ImageStabilization, "tt:ImageStabilization"))
				{	soap_flag_ImageStabilization1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension202(soap, "tt:Extension", &a->tt__ImagingSettingsExtension20::Extension, "tt:ImagingSettingsExtension202"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettingsExtension20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettingsExtension20, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(tt__ImagingSettingsExtension20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_dup_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *d, tt__ImagingSettingsExtension20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettingsExtension20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettingsExtension20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettingsExtension20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ImageStabilization(soap, &d->tt__ImagingSettingsExtension20::ImageStabilization, &a->tt__ImagingSettingsExtension20::ImageStabilization);
	soap_dup_PointerTott__ImagingSettingsExtension202(soap, &d->tt__ImagingSettingsExtension20::Extension, &a->tt__ImagingSettingsExtension20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettingsExtension20(tt__ImagingSettingsExtension20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ImageStabilization(&a->tt__ImagingSettingsExtension20::ImageStabilization);
	soap_del_PointerTott__ImagingSettingsExtension202(&a->tt__ImagingSettingsExtension20::Extension);
}

SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension20 *p;
	size_t k = sizeof(tt__ImagingSettingsExtension20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension20(soap, tag ? tag : "tt:ImagingSettingsExtension20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension20 * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension20(struct soap *soap, tt__ImagingSettingsExtension20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettings20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettings20::BacklightCompensation = NULL;
	this->tt__ImagingSettings20::Brightness = NULL;
	this->tt__ImagingSettings20::ColorSaturation = NULL;
	this->tt__ImagingSettings20::Contrast = NULL;
	this->tt__ImagingSettings20::Exposure = NULL;
	this->tt__ImagingSettings20::Focus = NULL;
	this->tt__ImagingSettings20::IrCutFilter = NULL;
	this->tt__ImagingSettings20::Sharpness = NULL;
	this->tt__ImagingSettings20::WideDynamicRange = NULL;
	this->tt__ImagingSettings20::WhiteBalance = NULL;
	this->tt__ImagingSettings20::Extension = NULL;
}

void tt__ImagingSettings20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation20(soap, &this->tt__ImagingSettings20::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Contrast);
	soap_serialize_PointerTott__Exposure20(soap, &this->tt__ImagingSettings20::Exposure);
	soap_serialize_PointerTott__FocusConfiguration20(soap, &this->tt__ImagingSettings20::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings20::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings20::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange20(soap, &this->tt__ImagingSettings20::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance20(soap, &this->tt__ImagingSettings20::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension20(soap, &this->tt__ImagingSettings20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettings20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings20(struct soap *soap, const char *tag, int id, const tt__ImagingSettings20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings20), type ? type : "tt:ImagingSettings20"))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingSettings20::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->tt__ImagingSettings20::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->tt__ImagingSettings20::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->tt__ImagingSettings20::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure20(soap, "tt:Exposure", -1, &a->tt__ImagingSettings20::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration20(soap, "tt:Focus", -1, &a->tt__ImagingSettings20::Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->tt__ImagingSettings20::IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->tt__ImagingSettings20::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingSettings20::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", -1, &a->tt__ImagingSettings20::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", -1, &a->tt__ImagingSettings20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettings20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_in_tt__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettings20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettings20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation20(soap, "tt:BacklightCompensation", &a->tt__ImagingSettings20::BacklightCompensation, "tt:BacklightCompensation20"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->tt__ImagingSettings20::Brightness, "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->tt__ImagingSettings20::ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->tt__ImagingSettings20::Contrast, "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure20(soap, "tt:Exposure", &a->tt__ImagingSettings20::Exposure, "tt:Exposure20"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration20(soap, "tt:Focus", &a->tt__ImagingSettings20::Focus, "tt:FocusConfiguration20"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->tt__ImagingSettings20::IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->tt__ImagingSettings20::Sharpness, "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange20(soap, "tt:WideDynamicRange", &a->tt__ImagingSettings20::WideDynamicRange, "tt:WideDynamicRange20"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance20(soap, "tt:WhiteBalance", &a->tt__ImagingSettings20::WhiteBalance, "tt:WhiteBalance20"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension20(soap, "tt:Extension", &a->tt__ImagingSettings20::Extension, "tt:ImagingSettingsExtension20"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings20, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_dup_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *d, tt__ImagingSettings20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettings20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettings20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettings20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__BacklightCompensation20(soap, &d->tt__ImagingSettings20::BacklightCompensation, &a->tt__ImagingSettings20::BacklightCompensation);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings20::Brightness, &a->tt__ImagingSettings20::Brightness);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings20::ColorSaturation, &a->tt__ImagingSettings20::ColorSaturation);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings20::Contrast, &a->tt__ImagingSettings20::Contrast);
	soap_dup_PointerTott__Exposure20(soap, &d->tt__ImagingSettings20::Exposure, &a->tt__ImagingSettings20::Exposure);
	soap_dup_PointerTott__FocusConfiguration20(soap, &d->tt__ImagingSettings20::Focus, &a->tt__ImagingSettings20::Focus);
	soap_dup_PointerTott__IrCutFilterMode(soap, &d->tt__ImagingSettings20::IrCutFilter, &a->tt__ImagingSettings20::IrCutFilter);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings20::Sharpness, &a->tt__ImagingSettings20::Sharpness);
	soap_dup_PointerTott__WideDynamicRange20(soap, &d->tt__ImagingSettings20::WideDynamicRange, &a->tt__ImagingSettings20::WideDynamicRange);
	soap_dup_PointerTott__WhiteBalance20(soap, &d->tt__ImagingSettings20::WhiteBalance, &a->tt__ImagingSettings20::WhiteBalance);
	soap_dup_PointerTott__ImagingSettingsExtension20(soap, &d->tt__ImagingSettings20::Extension, &a->tt__ImagingSettings20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettings20(tt__ImagingSettings20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__BacklightCompensation20(&a->tt__ImagingSettings20::BacklightCompensation);
	soap_del_PointerTofloat(&a->tt__ImagingSettings20::Brightness);
	soap_del_PointerTofloat(&a->tt__ImagingSettings20::ColorSaturation);
	soap_del_PointerTofloat(&a->tt__ImagingSettings20::Contrast);
	soap_del_PointerTott__Exposure20(&a->tt__ImagingSettings20::Exposure);
	soap_del_PointerTott__FocusConfiguration20(&a->tt__ImagingSettings20::Focus);
	soap_del_PointerTott__IrCutFilterMode(&a->tt__ImagingSettings20::IrCutFilter);
	soap_del_PointerTofloat(&a->tt__ImagingSettings20::Sharpness);
	soap_del_PointerTott__WideDynamicRange20(&a->tt__ImagingSettings20::WideDynamicRange);
	soap_del_PointerTott__WhiteBalance20(&a->tt__ImagingSettings20::WhiteBalance);
	soap_del_PointerTott__ImagingSettingsExtension20(&a->tt__ImagingSettings20::Extension);
}

SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettings20 *p;
	size_t k = sizeof(tt__ImagingSettings20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettings20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettings20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettings20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettings20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettings20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings20 * SOAP_FMAC4 soap_get_tt__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__FocusStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20Extension(struct soap *soap, const char *tag, int id, const tt__FocusStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:FocusStatus20Extension");
}

void *tt__FocusStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_in_tt__FocusStatus20Extension(struct soap *soap, const char *tag, tt__FocusStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__FocusStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(tt__FocusStatus20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20Extension)
		return (tt__FocusStatus20Extension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_dup_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *d, tt__FocusStatus20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusStatus20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusStatus20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusStatus20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusStatus20Extension(tt__FocusStatus20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20Extension *p;
	size_t k = sizeof(tt__FocusStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20Extension(soap, tag ? tag : "tt:FocusStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20Extension * SOAP_FMAC4 soap_get_tt__FocusStatus20Extension(struct soap *soap, tt__FocusStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__FocusStatus20::Position);
	soap_default_tt__MoveStatus(soap, &this->tt__FocusStatus20::MoveStatus);
	this->tt__FocusStatus20::Error = NULL;
	this->tt__FocusStatus20::Extension = NULL;
}

void tt__FocusStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusStatus20::Position, SOAP_TYPE_float);
	soap_serialize_PointerTostd__string(soap, &this->tt__FocusStatus20::Error);
	soap_serialize_PointerTott__FocusStatus20Extension(soap, &this->tt__FocusStatus20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusStatus20(struct soap *soap, const char *tag, int id, const tt__FocusStatus20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusStatus20), type ? type : "tt:FocusStatus20"))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__FocusStatus20::Position, ""))
		return soap->error;
	if (soap_out_tt__MoveStatus(soap, "tt:MoveStatus", -1, &a->tt__FocusStatus20::MoveStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__FocusStatus20::Error, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20Extension(soap, "tt:Extension", -1, &a->tt__FocusStatus20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_in_tt__FocusStatus20(struct soap *soap, const char *tag, tt__FocusStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__FocusStatus20::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__MoveStatus(soap, "tt:MoveStatus", &a->tt__FocusStatus20::MoveStatus, "tt:MoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__FocusStatus20::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20Extension(soap, "tt:Extension", &a->tt__FocusStatus20::Extension, "tt:FocusStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Position1 > 0 || soap_flag_MoveStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusStatus20, SOAP_TYPE_tt__FocusStatus20, sizeof(tt__FocusStatus20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_dup_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *d, tt__FocusStatus20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusStatus20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusStatus20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusStatus20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__FocusStatus20::Position = a->tt__FocusStatus20::Position;
	d->tt__FocusStatus20::MoveStatus = a->tt__FocusStatus20::MoveStatus;
	soap_dup_PointerTostd__string(soap, &d->tt__FocusStatus20::Error, &a->tt__FocusStatus20::Error);
	soap_dup_PointerTott__FocusStatus20Extension(soap, &d->tt__FocusStatus20::Extension, &a->tt__FocusStatus20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusStatus20(tt__FocusStatus20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Position skipped */
	/* MoveStatus skipped */
	soap_del_PointerTostd__string(&a->tt__FocusStatus20::Error);
	soap_del_PointerTott__FocusStatus20Extension(&a->tt__FocusStatus20::Extension);
}

SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusStatus20 *p;
	size_t k = sizeof(tt__FocusStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusStatus20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusStatus20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusStatus20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusStatus20(soap, tag ? tag : "tt:FocusStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusStatus20 * SOAP_FMAC4 soap_get_tt__FocusStatus20(struct soap *soap, tt__FocusStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20Extension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImagingStatus20Extension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingStatus20Extension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImagingStatus20Extension");
}

void *tt__ImagingStatus20Extension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20Extension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_in_tt__ImagingStatus20Extension(struct soap *soap, const char *tag, tt__ImagingStatus20Extension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImagingStatus20Extension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(tt__ImagingStatus20Extension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20Extension)
		return (tt__ImagingStatus20Extension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_dup_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *d, tt__ImagingStatus20Extension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingStatus20Extension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingStatus20Extension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingStatus20Extension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingStatus20Extension(tt__ImagingStatus20Extension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20Extension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20Extension *p;
	size_t k = sizeof(tt__ImagingStatus20Extension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20Extension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20Extension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20Extension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20Extension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20Extension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20Extension(soap, tag ? tag : "tt:ImagingStatus20Extension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20Extension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20Extension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20Extension * SOAP_FMAC4 soap_get_tt__ImagingStatus20Extension(struct soap *soap, tt__ImagingStatus20Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingStatus20::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingStatus20::FocusStatus20 = NULL;
	this->tt__ImagingStatus20::Extension = NULL;
}

void tt__ImagingStatus20::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FocusStatus20(soap, &this->tt__ImagingStatus20::FocusStatus20);
	soap_serialize_PointerTott__ImagingStatus20Extension(soap, &this->tt__ImagingStatus20::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingStatus20::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingStatus20(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingStatus20(struct soap *soap, const char *tag, int id, const tt__ImagingStatus20 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingStatus20), type ? type : "tt:ImagingStatus20"))
		return soap->error;
	if (soap_out_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", -1, &a->tt__ImagingStatus20::FocusStatus20, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", -1, &a->tt__ImagingStatus20::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingStatus20::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingStatus20(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_in_tt__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingStatus20*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingStatus20)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingStatus20 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FocusStatus201 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FocusStatus201 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusStatus20(soap, "tt:FocusStatus20", &a->tt__ImagingStatus20::FocusStatus20, "tt:FocusStatus20"))
				{	soap_flag_FocusStatus201--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingStatus20Extension(soap, "tt:Extension", &a->tt__ImagingStatus20::Extension, "tt:ImagingStatus20Extension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingStatus20 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingStatus20, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_dup_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *d, tt__ImagingStatus20 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingStatus20*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingStatus20, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingStatus20(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__FocusStatus20(soap, &d->tt__ImagingStatus20::FocusStatus20, &a->tt__ImagingStatus20::FocusStatus20);
	soap_dup_PointerTott__ImagingStatus20Extension(soap, &d->tt__ImagingStatus20::Extension, &a->tt__ImagingStatus20::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingStatus20(tt__ImagingStatus20 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__FocusStatus20(&a->tt__ImagingStatus20::FocusStatus20);
	soap_del_PointerTott__ImagingStatus20Extension(&a->tt__ImagingStatus20::Extension);
}

SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingStatus20(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingStatus20 *p;
	size_t k = sizeof(tt__ImagingStatus20);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingStatus20, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingStatus20);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingStatus20, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingStatus20 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingStatus20::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingStatus20(soap, tag ? tag : "tt:ImagingStatus20", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingStatus20::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingStatus20(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingStatus20 * SOAP_FMAC4 soap_get_tt__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WhiteBalance::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WhiteBalanceMode(soap, &this->tt__WhiteBalance::Mode);
	soap_default_float(soap, &this->tt__WhiteBalance::CrGain);
	soap_default_float(soap, &this->tt__WhiteBalance::CbGain);
}

void tt__WhiteBalance::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__WhiteBalance::CrGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__WhiteBalance::CbGain, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WhiteBalance::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WhiteBalance(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WhiteBalance(struct soap *soap, const char *tag, int id, const tt__WhiteBalance *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WhiteBalance), type ? type : "tt:WhiteBalance"))
		return soap->error;
	if (soap_out_tt__WhiteBalanceMode(soap, "tt:Mode", -1, &a->tt__WhiteBalance::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CrGain", -1, &a->tt__WhiteBalance::CrGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:CbGain", -1, &a->tt__WhiteBalance::CbGain, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WhiteBalance::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WhiteBalance(soap, tag, this, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_in_tt__WhiteBalance(struct soap *soap, const char *tag, tt__WhiteBalance *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WhiteBalance*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WhiteBalance)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WhiteBalance *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_CrGain1 = 1;
	size_t soap_flag_CbGain1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WhiteBalanceMode(soap, "tt:Mode", &a->tt__WhiteBalance::Mode, "tt:WhiteBalanceMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_CrGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CrGain", &a->tt__WhiteBalance::CrGain, "xsd:float"))
				{	soap_flag_CrGain1--;
					continue;
				}
			}
			if (soap_flag_CbGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:CbGain", &a->tt__WhiteBalance::CbGain, "xsd:float"))
				{	soap_flag_CbGain1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0 || soap_flag_CrGain1 > 0 || soap_flag_CbGain1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WhiteBalance *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WhiteBalance, SOAP_TYPE_tt__WhiteBalance, sizeof(tt__WhiteBalance), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_dup_tt__WhiteBalance(struct soap *soap, tt__WhiteBalance *d, tt__WhiteBalance const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WhiteBalance*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WhiteBalance, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WhiteBalance(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__WhiteBalance::Mode = a->tt__WhiteBalance::Mode;
	d->tt__WhiteBalance::CrGain = a->tt__WhiteBalance::CrGain;
	d->tt__WhiteBalance::CbGain = a->tt__WhiteBalance::CbGain;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WhiteBalance(tt__WhiteBalance const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	/* CrGain skipped */
	/* CbGain skipped */
}

SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WhiteBalance(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WhiteBalance *p;
	size_t k = sizeof(tt__WhiteBalance);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WhiteBalance, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WhiteBalance);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WhiteBalance, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WhiteBalance location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WhiteBalance::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WhiteBalance(soap, tag ? tag : "tt:WhiteBalance", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WhiteBalance::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WhiteBalance(soap, this, tag, type);
}

SOAP_FMAC3 tt__WhiteBalance * SOAP_FMAC4 soap_get_tt__WhiteBalance(struct soap *soap, tt__WhiteBalance *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ContinuousFocusOptions::Speed = NULL;
}

void tt__ContinuousFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__ContinuousFocusOptions::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ContinuousFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, const tt__ContinuousFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocusOptions), type ? type : "tt:ContinuousFocusOptions"))
		return soap->error;
	if (!a->tt__ContinuousFocusOptions::Speed)
	{	if (soap_element_empty(soap, "tt:Speed", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__ContinuousFocusOptions::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_in_tt__ContinuousFocusOptions(struct soap *soap, const char *tag, tt__ContinuousFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__ContinuousFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__ContinuousFocusOptions::Speed))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocusOptions, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(tt__ContinuousFocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_dup_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *d, tt__ContinuousFocusOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ContinuousFocusOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ContinuousFocusOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ContinuousFocusOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__ContinuousFocusOptions::Speed, &a->tt__ContinuousFocusOptions::Speed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ContinuousFocusOptions(tt__ContinuousFocusOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__FloatRange(&a->tt__ContinuousFocusOptions::Speed);
}

SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocusOptions *p;
	size_t k = sizeof(tt__ContinuousFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocusOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocusOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocusOptions(soap, tag ? tag : "tt:ContinuousFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocusOptions * SOAP_FMAC4 soap_get_tt__ContinuousFocusOptions(struct soap *soap, tt__ContinuousFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocusOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AbsoluteFocusOptions::Position = NULL;
	this->tt__AbsoluteFocusOptions::Speed = NULL;
}

void tt__AbsoluteFocusOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Position);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__AbsoluteFocusOptions::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AbsoluteFocusOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocusOptions), type ? type : "tt:AbsoluteFocusOptions"))
		return soap->error;
	if (!a->tt__AbsoluteFocusOptions::Position)
	{	if (soap_element_empty(soap, "tt:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:Position", -1, &a->tt__AbsoluteFocusOptions::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__FloatRange(soap, "tt:Speed", -1, &a->tt__AbsoluteFocusOptions::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocusOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocusOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_in_tt__AbsoluteFocusOptions(struct soap *soap, const char *tag, tt__AbsoluteFocusOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocusOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocusOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocusOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Position", &a->tt__AbsoluteFocusOptions::Position, "tt:FloatRange"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:Speed", &a->tt__AbsoluteFocusOptions::Speed, "tt:FloatRange"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__AbsoluteFocusOptions::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocusOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocusOptions, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(tt__AbsoluteFocusOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_dup_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *d, tt__AbsoluteFocusOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AbsoluteFocusOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AbsoluteFocusOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AbsoluteFocusOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__AbsoluteFocusOptions::Position, &a->tt__AbsoluteFocusOptions::Position);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__AbsoluteFocusOptions::Speed, &a->tt__AbsoluteFocusOptions::Speed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AbsoluteFocusOptions(tt__AbsoluteFocusOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__FloatRange(&a->tt__AbsoluteFocusOptions::Position);
	soap_del_PointerTott__FloatRange(&a->tt__AbsoluteFocusOptions::Speed);
}

SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocusOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocusOptions *p;
	size_t k = sizeof(tt__AbsoluteFocusOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocusOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocusOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocusOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocusOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocusOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocusOptions(soap, tag ? tag : "tt:AbsoluteFocusOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocusOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocusOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocusOptions * SOAP_FMAC4 soap_get_tt__AbsoluteFocusOptions(struct soap *soap, tt__AbsoluteFocusOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ContinuousFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__ContinuousFocus::Speed);
}

void tt__ContinuousFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ContinuousFocus::Speed, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ContinuousFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ContinuousFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ContinuousFocus(struct soap *soap, const char *tag, int id, const tt__ContinuousFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ContinuousFocus), type ? type : "tt:ContinuousFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Speed", -1, &a->tt__ContinuousFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ContinuousFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ContinuousFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_in_tt__ContinuousFocus(struct soap *soap, const char *tag, tt__ContinuousFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ContinuousFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ContinuousFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ContinuousFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Speed", &a->tt__ContinuousFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Speed1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ContinuousFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ContinuousFocus, SOAP_TYPE_tt__ContinuousFocus, sizeof(tt__ContinuousFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_dup_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *d, tt__ContinuousFocus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ContinuousFocus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ContinuousFocus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ContinuousFocus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__ContinuousFocus::Speed = a->tt__ContinuousFocus::Speed;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ContinuousFocus(tt__ContinuousFocus const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Speed skipped */
}

SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ContinuousFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ContinuousFocus *p;
	size_t k = sizeof(tt__ContinuousFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ContinuousFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ContinuousFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ContinuousFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ContinuousFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ContinuousFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ContinuousFocus(soap, tag ? tag : "tt:ContinuousFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ContinuousFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ContinuousFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__ContinuousFocus * SOAP_FMAC4 soap_get_tt__ContinuousFocus(struct soap *soap, tt__ContinuousFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelativeFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__RelativeFocus::Distance);
	this->tt__RelativeFocus::Speed = NULL;
}

void tt__RelativeFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelativeFocus::Distance, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__RelativeFocus::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RelativeFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelativeFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelativeFocus(struct soap *soap, const char *tag, int id, const tt__RelativeFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelativeFocus), type ? type : "tt:RelativeFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Distance", -1, &a->tt__RelativeFocus::Distance, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__RelativeFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelativeFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelativeFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_in_tt__RelativeFocus(struct soap *soap, const char *tag, tt__RelativeFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelativeFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelativeFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelativeFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Distance1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Distance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Distance", &a->tt__RelativeFocus::Distance, "xsd:float"))
				{	soap_flag_Distance1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__RelativeFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Distance1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelativeFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelativeFocus, SOAP_TYPE_tt__RelativeFocus, sizeof(tt__RelativeFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_dup_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *d, tt__RelativeFocus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RelativeFocus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RelativeFocus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RelativeFocus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__RelativeFocus::Distance = a->tt__RelativeFocus::Distance;
	soap_dup_PointerTofloat(soap, &d->tt__RelativeFocus::Speed, &a->tt__RelativeFocus::Speed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RelativeFocus(tt__RelativeFocus const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Distance skipped */
	soap_del_PointerTofloat(&a->tt__RelativeFocus::Speed);
}

SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelativeFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelativeFocus *p;
	size_t k = sizeof(tt__RelativeFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelativeFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelativeFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelativeFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelativeFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelativeFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelativeFocus(soap, tag ? tag : "tt:RelativeFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelativeFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelativeFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelativeFocus * SOAP_FMAC4 soap_get_tt__RelativeFocus(struct soap *soap, tt__RelativeFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AbsoluteFocus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__AbsoluteFocus::Position);
	this->tt__AbsoluteFocus::Speed = NULL;
}

void tt__AbsoluteFocus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AbsoluteFocus::Position, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__AbsoluteFocus::Speed);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AbsoluteFocus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AbsoluteFocus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AbsoluteFocus(struct soap *soap, const char *tag, int id, const tt__AbsoluteFocus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AbsoluteFocus), type ? type : "tt:AbsoluteFocus"))
		return soap->error;
	if (soap_out_float(soap, "tt:Position", -1, &a->tt__AbsoluteFocus::Position, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Speed", -1, &a->tt__AbsoluteFocus::Speed, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AbsoluteFocus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AbsoluteFocus(soap, tag, this, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_in_tt__AbsoluteFocus(struct soap *soap, const char *tag, tt__AbsoluteFocus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AbsoluteFocus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AbsoluteFocus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AbsoluteFocus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Position", &a->tt__AbsoluteFocus::Position, "xsd:float"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Speed", &a->tt__AbsoluteFocus::Speed, "xsd:float"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AbsoluteFocus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AbsoluteFocus, SOAP_TYPE_tt__AbsoluteFocus, sizeof(tt__AbsoluteFocus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_dup_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *d, tt__AbsoluteFocus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AbsoluteFocus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AbsoluteFocus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AbsoluteFocus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__AbsoluteFocus::Position = a->tt__AbsoluteFocus::Position;
	soap_dup_PointerTofloat(soap, &d->tt__AbsoluteFocus::Speed, &a->tt__AbsoluteFocus::Speed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AbsoluteFocus(tt__AbsoluteFocus const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Position skipped */
	soap_del_PointerTofloat(&a->tt__AbsoluteFocus::Speed);
}

SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AbsoluteFocus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AbsoluteFocus *p;
	size_t k = sizeof(tt__AbsoluteFocus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AbsoluteFocus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AbsoluteFocus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AbsoluteFocus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AbsoluteFocus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AbsoluteFocus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AbsoluteFocus(soap, tag ? tag : "tt:AbsoluteFocus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AbsoluteFocus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AbsoluteFocus(soap, this, tag, type);
}

SOAP_FMAC3 tt__AbsoluteFocus * SOAP_FMAC4 soap_get_tt__AbsoluteFocus(struct soap *soap, tt__AbsoluteFocus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__FocusMove::Absolute = NULL;
	this->tt__FocusMove::Relative = NULL;
	this->tt__FocusMove::Continuous = NULL;
}

void tt__FocusMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AbsoluteFocus(soap, &this->tt__FocusMove::Absolute);
	soap_serialize_PointerTott__RelativeFocus(soap, &this->tt__FocusMove::Relative);
	soap_serialize_PointerTott__ContinuousFocus(soap, &this->tt__FocusMove::Continuous);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusMove(struct soap *soap, const char *tag, int id, const tt__FocusMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusMove), type ? type : "tt:FocusMove"))
		return soap->error;
	if (soap_out_PointerTott__AbsoluteFocus(soap, "tt:Absolute", -1, &a->tt__FocusMove::Absolute, ""))
		return soap->error;
	if (soap_out_PointerTott__RelativeFocus(soap, "tt:Relative", -1, &a->tt__FocusMove::Relative, ""))
		return soap->error;
	if (soap_out_PointerTott__ContinuousFocus(soap, "tt:Continuous", -1, &a->tt__FocusMove::Continuous, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusMove(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_in_tt__FocusMove(struct soap *soap, const char *tag, tt__FocusMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Absolute1 = 1;
	size_t soap_flag_Relative1 = 1;
	size_t soap_flag_Continuous1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Absolute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AbsoluteFocus(soap, "tt:Absolute", &a->tt__FocusMove::Absolute, "tt:AbsoluteFocus"))
				{	soap_flag_Absolute1--;
					continue;
				}
			}
			if (soap_flag_Relative1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelativeFocus(soap, "tt:Relative", &a->tt__FocusMove::Relative, "tt:RelativeFocus"))
				{	soap_flag_Relative1--;
					continue;
				}
			}
			if (soap_flag_Continuous1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ContinuousFocus(soap, "tt:Continuous", &a->tt__FocusMove::Continuous, "tt:ContinuousFocus"))
				{	soap_flag_Continuous1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FocusMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusMove, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_dup_tt__FocusMove(struct soap *soap, tt__FocusMove *d, tt__FocusMove const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusMove*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusMove, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusMove(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AbsoluteFocus(soap, &d->tt__FocusMove::Absolute, &a->tt__FocusMove::Absolute);
	soap_dup_PointerTott__RelativeFocus(soap, &d->tt__FocusMove::Relative, &a->tt__FocusMove::Relative);
	soap_dup_PointerTott__ContinuousFocus(soap, &d->tt__FocusMove::Continuous, &a->tt__FocusMove::Continuous);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusMove(tt__FocusMove const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AbsoluteFocus(&a->tt__FocusMove::Absolute);
	soap_del_PointerTott__RelativeFocus(&a->tt__FocusMove::Relative);
	soap_del_PointerTott__ContinuousFocus(&a->tt__FocusMove::Continuous);
}

SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusMove *p;
	size_t k = sizeof(tt__FocusMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusMove(soap, tag ? tag : "tt:FocusMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusMove(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusMove * SOAP_FMAC4 soap_get_tt__FocusMove(struct soap *soap, tt__FocusMove *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BacklightCompensation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__BacklightCompensationMode(soap, &this->tt__BacklightCompensation::Mode);
	soap_default_float(soap, &this->tt__BacklightCompensation::Level);
}

void tt__BacklightCompensation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BacklightCompensation::Level, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BacklightCompensation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BacklightCompensation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BacklightCompensation(struct soap *soap, const char *tag, int id, const tt__BacklightCompensation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BacklightCompensation), type ? type : "tt:BacklightCompensation"))
		return soap->error;
	if (soap_out_tt__BacklightCompensationMode(soap, "tt:Mode", -1, &a->tt__BacklightCompensation::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__BacklightCompensation::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BacklightCompensation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BacklightCompensation(soap, tag, this, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_in_tt__BacklightCompensation(struct soap *soap, const char *tag, tt__BacklightCompensation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BacklightCompensation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BacklightCompensation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BacklightCompensation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__BacklightCompensationMode(soap, "tt:Mode", &a->tt__BacklightCompensation::Mode, "tt:BacklightCompensationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__BacklightCompensation::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BacklightCompensation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BacklightCompensation, SOAP_TYPE_tt__BacklightCompensation, sizeof(tt__BacklightCompensation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_dup_tt__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *d, tt__BacklightCompensation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__BacklightCompensation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__BacklightCompensation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__BacklightCompensation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__BacklightCompensation::Mode = a->tt__BacklightCompensation::Mode;
	d->tt__BacklightCompensation::Level = a->tt__BacklightCompensation::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__BacklightCompensation(tt__BacklightCompensation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	/* Level skipped */
}

SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BacklightCompensation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BacklightCompensation *p;
	size_t k = sizeof(tt__BacklightCompensation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BacklightCompensation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BacklightCompensation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BacklightCompensation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BacklightCompensation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BacklightCompensation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BacklightCompensation(soap, tag ? tag : "tt:BacklightCompensation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BacklightCompensation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BacklightCompensation(soap, this, tag, type);
}

SOAP_FMAC3 tt__BacklightCompensation * SOAP_FMAC4 soap_get_tt__BacklightCompensation(struct soap *soap, tt__BacklightCompensation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__WideDynamicRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__WideDynamicMode(soap, &this->tt__WideDynamicRange::Mode);
	soap_default_float(soap, &this->tt__WideDynamicRange::Level);
}

void tt__WideDynamicRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__WideDynamicRange::Level, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__WideDynamicRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__WideDynamicRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__WideDynamicRange(struct soap *soap, const char *tag, int id, const tt__WideDynamicRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__WideDynamicRange), type ? type : "tt:WideDynamicRange"))
		return soap->error;
	if (soap_out_tt__WideDynamicMode(soap, "tt:Mode", -1, &a->tt__WideDynamicRange::Mode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Level", -1, &a->tt__WideDynamicRange::Level, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__WideDynamicRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__WideDynamicRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_in_tt__WideDynamicRange(struct soap *soap, const char *tag, tt__WideDynamicRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__WideDynamicRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__WideDynamicRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__WideDynamicRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Level1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__WideDynamicMode(soap, "tt:Mode", &a->tt__WideDynamicRange::Mode, "tt:WideDynamicMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Level1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Level", &a->tt__WideDynamicRange::Level, "xsd:float"))
				{	soap_flag_Level1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0 || soap_flag_Level1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__WideDynamicRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__WideDynamicRange, SOAP_TYPE_tt__WideDynamicRange, sizeof(tt__WideDynamicRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_dup_tt__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *d, tt__WideDynamicRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__WideDynamicRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__WideDynamicRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__WideDynamicRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__WideDynamicRange::Mode = a->tt__WideDynamicRange::Mode;
	d->tt__WideDynamicRange::Level = a->tt__WideDynamicRange::Level;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__WideDynamicRange(tt__WideDynamicRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	/* Level skipped */
}

SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__WideDynamicRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__WideDynamicRange *p;
	size_t k = sizeof(tt__WideDynamicRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__WideDynamicRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__WideDynamicRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__WideDynamicRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__WideDynamicRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__WideDynamicRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__WideDynamicRange(soap, tag ? tag : "tt:WideDynamicRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__WideDynamicRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__WideDynamicRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__WideDynamicRange * SOAP_FMAC4 soap_get_tt__WideDynamicRange(struct soap *soap, tt__WideDynamicRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Exposure::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ExposureMode(soap, &this->tt__Exposure::Mode);
	soap_default_tt__ExposurePriority(soap, &this->tt__Exposure::Priority);
	this->tt__Exposure::Window = NULL;
	soap_default_float(soap, &this->tt__Exposure::MinExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MaxExposureTime);
	soap_default_float(soap, &this->tt__Exposure::MinGain);
	soap_default_float(soap, &this->tt__Exposure::MaxGain);
	soap_default_float(soap, &this->tt__Exposure::MinIris);
	soap_default_float(soap, &this->tt__Exposure::MaxIris);
	soap_default_float(soap, &this->tt__Exposure::ExposureTime);
	soap_default_float(soap, &this->tt__Exposure::Gain);
	soap_default_float(soap, &this->tt__Exposure::Iris);
}

void tt__Exposure::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Exposure::Priority, SOAP_TYPE_tt__ExposurePriority);
	soap_serialize_PointerTott__Rectangle(soap, &this->tt__Exposure::Window);
	soap_embedded(soap, &this->tt__Exposure::MinExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxGain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MinIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::MaxIris, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::ExposureTime, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Gain, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__Exposure::Iris, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Exposure::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Exposure(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Exposure(struct soap *soap, const char *tag, int id, const tt__Exposure *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Exposure), type ? type : "tt:Exposure"))
		return soap->error;
	if (soap_out_tt__ExposureMode(soap, "tt:Mode", -1, &a->tt__Exposure::Mode, ""))
		return soap->error;
	if (soap_out_tt__ExposurePriority(soap, "tt:Priority", -1, &a->tt__Exposure::Priority, ""))
		return soap->error;
	if (!a->tt__Exposure::Window)
	{	if (soap_element_empty(soap, "tt:Window", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Rectangle(soap, "tt:Window", -1, &a->tt__Exposure::Window, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinExposureTime", -1, &a->tt__Exposure::MinExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxExposureTime", -1, &a->tt__Exposure::MaxExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinGain", -1, &a->tt__Exposure::MinGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxGain", -1, &a->tt__Exposure::MaxGain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MinIris", -1, &a->tt__Exposure::MinIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:MaxIris", -1, &a->tt__Exposure::MaxIris, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:ExposureTime", -1, &a->tt__Exposure::ExposureTime, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Gain", -1, &a->tt__Exposure::Gain, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Iris", -1, &a->tt__Exposure::Iris, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Exposure::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Exposure(soap, tag, this, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_in_tt__Exposure(struct soap *soap, const char *tag, tt__Exposure *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Exposure*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Exposure)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Exposure *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Window1 = 1;
	size_t soap_flag_MinExposureTime1 = 1;
	size_t soap_flag_MaxExposureTime1 = 1;
	size_t soap_flag_MinGain1 = 1;
	size_t soap_flag_MaxGain1 = 1;
	size_t soap_flag_MinIris1 = 1;
	size_t soap_flag_MaxIris1 = 1;
	size_t soap_flag_ExposureTime1 = 1;
	size_t soap_flag_Gain1 = 1;
	size_t soap_flag_Iris1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposureMode(soap, "tt:Mode", &a->tt__Exposure::Mode, "tt:ExposureMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ExposurePriority(soap, "tt:Priority", &a->tt__Exposure::Priority, "tt:ExposurePriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Window1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rectangle(soap, "tt:Window", &a->tt__Exposure::Window, "tt:Rectangle"))
				{	soap_flag_Window1--;
					continue;
				}
			}
			if (soap_flag_MinExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinExposureTime", &a->tt__Exposure::MinExposureTime, "xsd:float"))
				{	soap_flag_MinExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MaxExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxExposureTime", &a->tt__Exposure::MaxExposureTime, "xsd:float"))
				{	soap_flag_MaxExposureTime1--;
					continue;
				}
			}
			if (soap_flag_MinGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinGain", &a->tt__Exposure::MinGain, "xsd:float"))
				{	soap_flag_MinGain1--;
					continue;
				}
			}
			if (soap_flag_MaxGain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxGain", &a->tt__Exposure::MaxGain, "xsd:float"))
				{	soap_flag_MaxGain1--;
					continue;
				}
			}
			if (soap_flag_MinIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MinIris", &a->tt__Exposure::MinIris, "xsd:float"))
				{	soap_flag_MinIris1--;
					continue;
				}
			}
			if (soap_flag_MaxIris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:MaxIris", &a->tt__Exposure::MaxIris, "xsd:float"))
				{	soap_flag_MaxIris1--;
					continue;
				}
			}
			if (soap_flag_ExposureTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:ExposureTime", &a->tt__Exposure::ExposureTime, "xsd:float"))
				{	soap_flag_ExposureTime1--;
					continue;
				}
			}
			if (soap_flag_Gain1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Gain", &a->tt__Exposure::Gain, "xsd:float"))
				{	soap_flag_Gain1--;
					continue;
				}
			}
			if (soap_flag_Iris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Iris", &a->tt__Exposure::Iris, "xsd:float"))
				{	soap_flag_Iris1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0 || soap_flag_Priority1 > 0 || !a->tt__Exposure::Window || soap_flag_MinExposureTime1 > 0 || soap_flag_MaxExposureTime1 > 0 || soap_flag_MinGain1 > 0 || soap_flag_MaxGain1 > 0 || soap_flag_MinIris1 > 0 || soap_flag_MaxIris1 > 0 || soap_flag_ExposureTime1 > 0 || soap_flag_Gain1 > 0 || soap_flag_Iris1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Exposure *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Exposure, SOAP_TYPE_tt__Exposure, sizeof(tt__Exposure), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_dup_tt__Exposure(struct soap *soap, tt__Exposure *d, tt__Exposure const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Exposure*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Exposure, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Exposure(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Exposure::Mode = a->tt__Exposure::Mode;
	d->tt__Exposure::Priority = a->tt__Exposure::Priority;
	soap_dup_PointerTott__Rectangle(soap, &d->tt__Exposure::Window, &a->tt__Exposure::Window);
	d->tt__Exposure::MinExposureTime = a->tt__Exposure::MinExposureTime;
	d->tt__Exposure::MaxExposureTime = a->tt__Exposure::MaxExposureTime;
	d->tt__Exposure::MinGain = a->tt__Exposure::MinGain;
	d->tt__Exposure::MaxGain = a->tt__Exposure::MaxGain;
	d->tt__Exposure::MinIris = a->tt__Exposure::MinIris;
	d->tt__Exposure::MaxIris = a->tt__Exposure::MaxIris;
	d->tt__Exposure::ExposureTime = a->tt__Exposure::ExposureTime;
	d->tt__Exposure::Gain = a->tt__Exposure::Gain;
	d->tt__Exposure::Iris = a->tt__Exposure::Iris;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Exposure(tt__Exposure const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	/* Priority skipped */
	soap_del_PointerTott__Rectangle(&a->tt__Exposure::Window);
	/* MinExposureTime skipped */
	/* MaxExposureTime skipped */
	/* MinGain skipped */
	/* MaxGain skipped */
	/* MinIris skipped */
	/* MaxIris skipped */
	/* ExposureTime skipped */
	/* Gain skipped */
	/* Iris skipped */
}

SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Exposure(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Exposure *p;
	size_t k = sizeof(tt__Exposure);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Exposure, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Exposure);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Exposure, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Exposure location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Exposure::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Exposure(soap, tag ? tag : "tt:Exposure", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Exposure::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Exposure(soap, this, tag, type);
}

SOAP_FMAC3 tt__Exposure * SOAP_FMAC4 soap_get_tt__Exposure(struct soap *soap, tt__Exposure *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettingsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ImagingSettingsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettingsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettingsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, const tt__ImagingSettingsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ImagingSettingsExtension");
}

void *tt__ImagingSettingsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettingsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_in_tt__ImagingSettingsExtension(struct soap *soap, const char *tag, tt__ImagingSettingsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ImagingSettingsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(tt__ImagingSettingsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettingsExtension)
		return (tt__ImagingSettingsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_dup_tt__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *d, tt__ImagingSettingsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettingsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettingsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettingsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettingsExtension(tt__ImagingSettingsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettingsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettingsExtension *p;
	size_t k = sizeof(tt__ImagingSettingsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettingsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettingsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettingsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettingsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettingsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettingsExtension(soap, tag ? tag : "tt:ImagingSettingsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettingsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettingsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettingsExtension * SOAP_FMAC4 soap_get_tt__ImagingSettingsExtension(struct soap *soap, tt__ImagingSettingsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ImagingSettings::BacklightCompensation = NULL;
	this->tt__ImagingSettings::Brightness = NULL;
	this->tt__ImagingSettings::ColorSaturation = NULL;
	this->tt__ImagingSettings::Contrast = NULL;
	this->tt__ImagingSettings::Exposure = NULL;
	this->tt__ImagingSettings::Focus = NULL;
	this->tt__ImagingSettings::IrCutFilter = NULL;
	this->tt__ImagingSettings::Sharpness = NULL;
	this->tt__ImagingSettings::WideDynamicRange = NULL;
	this->tt__ImagingSettings::WhiteBalance = NULL;
	this->tt__ImagingSettings::Extension = NULL;
}

void tt__ImagingSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BacklightCompensation(soap, &this->tt__ImagingSettings::BacklightCompensation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Brightness);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::ColorSaturation);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Contrast);
	soap_serialize_PointerTott__Exposure(soap, &this->tt__ImagingSettings::Exposure);
	soap_serialize_PointerTott__FocusConfiguration(soap, &this->tt__ImagingSettings::Focus);
	soap_serialize_PointerTott__IrCutFilterMode(soap, &this->tt__ImagingSettings::IrCutFilter);
	soap_serialize_PointerTofloat(soap, &this->tt__ImagingSettings::Sharpness);
	soap_serialize_PointerTott__WideDynamicRange(soap, &this->tt__ImagingSettings::WideDynamicRange);
	soap_serialize_PointerTott__WhiteBalance(soap, &this->tt__ImagingSettings::WhiteBalance);
	soap_serialize_PointerTott__ImagingSettingsExtension(soap, &this->tt__ImagingSettings::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingSettings(struct soap *soap, const char *tag, int id, const tt__ImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingSettings), type ? type : "tt:ImagingSettings"))
		return soap->error;
	if (soap_out_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", -1, &a->tt__ImagingSettings::BacklightCompensation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Brightness", -1, &a->tt__ImagingSettings::Brightness, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:ColorSaturation", -1, &a->tt__ImagingSettings::ColorSaturation, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Contrast", -1, &a->tt__ImagingSettings::Contrast, ""))
		return soap->error;
	if (soap_out_PointerTott__Exposure(soap, "tt:Exposure", -1, &a->tt__ImagingSettings::Exposure, ""))
		return soap->error;
	if (soap_out_PointerTott__FocusConfiguration(soap, "tt:Focus", -1, &a->tt__ImagingSettings::Focus, ""))
		return soap->error;
	if (soap_out_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", -1, &a->tt__ImagingSettings::IrCutFilter, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Sharpness", -1, &a->tt__ImagingSettings::Sharpness, ""))
		return soap->error;
	if (soap_out_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", -1, &a->tt__ImagingSettings::WideDynamicRange, ""))
		return soap->error;
	if (soap_out_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", -1, &a->tt__ImagingSettings::WhiteBalance, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", -1, &a->tt__ImagingSettings::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_in_tt__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BacklightCompensation1 = 1;
	size_t soap_flag_Brightness1 = 1;
	size_t soap_flag_ColorSaturation1 = 1;
	size_t soap_flag_Contrast1 = 1;
	size_t soap_flag_Exposure1 = 1;
	size_t soap_flag_Focus1 = 1;
	size_t soap_flag_IrCutFilter1 = 1;
	size_t soap_flag_Sharpness1 = 1;
	size_t soap_flag_WideDynamicRange1 = 1;
	size_t soap_flag_WhiteBalance1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BacklightCompensation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BacklightCompensation(soap, "tt:BacklightCompensation", &a->tt__ImagingSettings::BacklightCompensation, "tt:BacklightCompensation"))
				{	soap_flag_BacklightCompensation1--;
					continue;
				}
			}
			if (soap_flag_Brightness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Brightness", &a->tt__ImagingSettings::Brightness, "xsd:float"))
				{	soap_flag_Brightness1--;
					continue;
				}
			}
			if (soap_flag_ColorSaturation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:ColorSaturation", &a->tt__ImagingSettings::ColorSaturation, "xsd:float"))
				{	soap_flag_ColorSaturation1--;
					continue;
				}
			}
			if (soap_flag_Contrast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Contrast", &a->tt__ImagingSettings::Contrast, "xsd:float"))
				{	soap_flag_Contrast1--;
					continue;
				}
			}
			if (soap_flag_Exposure1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Exposure(soap, "tt:Exposure", &a->tt__ImagingSettings::Exposure, "tt:Exposure"))
				{	soap_flag_Exposure1--;
					continue;
				}
			}
			if (soap_flag_Focus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FocusConfiguration(soap, "tt:Focus", &a->tt__ImagingSettings::Focus, "tt:FocusConfiguration"))
				{	soap_flag_Focus1--;
					continue;
				}
			}
			if (soap_flag_IrCutFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IrCutFilterMode(soap, "tt:IrCutFilter", &a->tt__ImagingSettings::IrCutFilter, "tt:IrCutFilterMode"))
				{	soap_flag_IrCutFilter1--;
					continue;
				}
			}
			if (soap_flag_Sharpness1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Sharpness", &a->tt__ImagingSettings::Sharpness, "xsd:float"))
				{	soap_flag_Sharpness1--;
					continue;
				}
			}
			if (soap_flag_WideDynamicRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WideDynamicRange(soap, "tt:WideDynamicRange", &a->tt__ImagingSettings::WideDynamicRange, "tt:WideDynamicRange"))
				{	soap_flag_WideDynamicRange1--;
					continue;
				}
			}
			if (soap_flag_WhiteBalance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__WhiteBalance(soap, "tt:WhiteBalance", &a->tt__ImagingSettings::WhiteBalance, "tt:WhiteBalance"))
				{	soap_flag_WhiteBalance1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettingsExtension(soap, "tt:Extension", &a->tt__ImagingSettings::Extension, "tt:ImagingSettingsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingSettings, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_dup_tt__ImagingSettings(struct soap *soap, tt__ImagingSettings *d, tt__ImagingSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__BacklightCompensation(soap, &d->tt__ImagingSettings::BacklightCompensation, &a->tt__ImagingSettings::BacklightCompensation);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings::Brightness, &a->tt__ImagingSettings::Brightness);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings::ColorSaturation, &a->tt__ImagingSettings::ColorSaturation);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings::Contrast, &a->tt__ImagingSettings::Contrast);
	soap_dup_PointerTott__Exposure(soap, &d->tt__ImagingSettings::Exposure, &a->tt__ImagingSettings::Exposure);
	soap_dup_PointerTott__FocusConfiguration(soap, &d->tt__ImagingSettings::Focus, &a->tt__ImagingSettings::Focus);
	soap_dup_PointerTott__IrCutFilterMode(soap, &d->tt__ImagingSettings::IrCutFilter, &a->tt__ImagingSettings::IrCutFilter);
	soap_dup_PointerTofloat(soap, &d->tt__ImagingSettings::Sharpness, &a->tt__ImagingSettings::Sharpness);
	soap_dup_PointerTott__WideDynamicRange(soap, &d->tt__ImagingSettings::WideDynamicRange, &a->tt__ImagingSettings::WideDynamicRange);
	soap_dup_PointerTott__WhiteBalance(soap, &d->tt__ImagingSettings::WhiteBalance, &a->tt__ImagingSettings::WhiteBalance);
	soap_dup_PointerTott__ImagingSettingsExtension(soap, &d->tt__ImagingSettings::Extension, &a->tt__ImagingSettings::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingSettings(tt__ImagingSettings const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__BacklightCompensation(&a->tt__ImagingSettings::BacklightCompensation);
	soap_del_PointerTofloat(&a->tt__ImagingSettings::Brightness);
	soap_del_PointerTofloat(&a->tt__ImagingSettings::ColorSaturation);
	soap_del_PointerTofloat(&a->tt__ImagingSettings::Contrast);
	soap_del_PointerTott__Exposure(&a->tt__ImagingSettings::Exposure);
	soap_del_PointerTott__FocusConfiguration(&a->tt__ImagingSettings::Focus);
	soap_del_PointerTott__IrCutFilterMode(&a->tt__ImagingSettings::IrCutFilter);
	soap_del_PointerTofloat(&a->tt__ImagingSettings::Sharpness);
	soap_del_PointerTott__WideDynamicRange(&a->tt__ImagingSettings::WideDynamicRange);
	soap_del_PointerTott__WhiteBalance(&a->tt__ImagingSettings::WhiteBalance);
	soap_del_PointerTott__ImagingSettingsExtension(&a->tt__ImagingSettings::Extension);
}

SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingSettings *p;
	size_t k = sizeof(tt__ImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingSettings(soap, tag ? tag : "tt:ImagingSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingSettings * SOAP_FMAC4 soap_get_tt__ImagingSettings(struct soap *soap, tt__ImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FocusConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AutoFocusMode(soap, &this->tt__FocusConfiguration::AutoFocusMode);
	soap_default_float(soap, &this->tt__FocusConfiguration::DefaultSpeed);
	soap_default_float(soap, &this->tt__FocusConfiguration::NearLimit);
	soap_default_float(soap, &this->tt__FocusConfiguration::FarLimit);
}

void tt__FocusConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FocusConfiguration::DefaultSpeed, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::NearLimit, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FocusConfiguration::FarLimit, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FocusConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FocusConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FocusConfiguration(struct soap *soap, const char *tag, int id, const tt__FocusConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FocusConfiguration), type ? type : "tt:FocusConfiguration"))
		return soap->error;
	if (soap_out_tt__AutoFocusMode(soap, "tt:AutoFocusMode", -1, &a->tt__FocusConfiguration::AutoFocusMode, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:DefaultSpeed", -1, &a->tt__FocusConfiguration::DefaultSpeed, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:NearLimit", -1, &a->tt__FocusConfiguration::NearLimit, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:FarLimit", -1, &a->tt__FocusConfiguration::FarLimit, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FocusConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FocusConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_in_tt__FocusConfiguration(struct soap *soap, const char *tag, tt__FocusConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FocusConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FocusConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FocusConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AutoFocusMode1 = 1;
	size_t soap_flag_DefaultSpeed1 = 1;
	size_t soap_flag_NearLimit1 = 1;
	size_t soap_flag_FarLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoFocusMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AutoFocusMode(soap, "tt:AutoFocusMode", &a->tt__FocusConfiguration::AutoFocusMode, "tt:AutoFocusMode"))
				{	soap_flag_AutoFocusMode1--;
					continue;
				}
			}
			if (soap_flag_DefaultSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:DefaultSpeed", &a->tt__FocusConfiguration::DefaultSpeed, "xsd:float"))
				{	soap_flag_DefaultSpeed1--;
					continue;
				}
			}
			if (soap_flag_NearLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:NearLimit", &a->tt__FocusConfiguration::NearLimit, "xsd:float"))
				{	soap_flag_NearLimit1--;
					continue;
				}
			}
			if (soap_flag_FarLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:FarLimit", &a->tt__FocusConfiguration::FarLimit, "xsd:float"))
				{	soap_flag_FarLimit1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_AutoFocusMode1 > 0 || soap_flag_DefaultSpeed1 > 0 || soap_flag_NearLimit1 > 0 || soap_flag_FarLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FocusConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FocusConfiguration, SOAP_TYPE_tt__FocusConfiguration, sizeof(tt__FocusConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_dup_tt__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *d, tt__FocusConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FocusConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FocusConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FocusConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__FocusConfiguration::AutoFocusMode = a->tt__FocusConfiguration::AutoFocusMode;
	d->tt__FocusConfiguration::DefaultSpeed = a->tt__FocusConfiguration::DefaultSpeed;
	d->tt__FocusConfiguration::NearLimit = a->tt__FocusConfiguration::NearLimit;
	d->tt__FocusConfiguration::FarLimit = a->tt__FocusConfiguration::FarLimit;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FocusConfiguration(tt__FocusConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* AutoFocusMode skipped */
	/* DefaultSpeed skipped */
	/* NearLimit skipped */
	/* FarLimit skipped */
}

SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FocusConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FocusConfiguration *p;
	size_t k = sizeof(tt__FocusConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FocusConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FocusConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FocusConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FocusConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FocusConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FocusConfiguration(soap, tag ? tag : "tt:FocusConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FocusConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FocusConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__FocusConfiguration * SOAP_FMAC4 soap_get_tt__FocusConfiguration(struct soap *soap, tt__FocusConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PTZSpeed::PanTilt = NULL;
	this->tt__PTZSpeed::Zoom = NULL;
}

void tt__PTZSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZSpeed::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZSpeed::Zoom);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type ? type : "tt:PTZSpeed"))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZSpeed::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZSpeed::Zoom, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpeed(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZSpeed::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZSpeed::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_dup_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *d, tt__PTZSpeed const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZSpeed*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZSpeed, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZSpeed(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Vector2D(soap, &d->tt__PTZSpeed::PanTilt, &a->tt__PTZSpeed::PanTilt);
	soap_dup_PointerTott__Vector1D(soap, &d->tt__PTZSpeed::Zoom, &a->tt__PTZSpeed::Zoom);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZSpeed(tt__PTZSpeed const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Vector2D(&a->tt__PTZSpeed::PanTilt);
	soap_del_PointerTott__Vector1D(&a->tt__PTZSpeed::Zoom);
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpeed *p;
	size_t k = sizeof(tt__PTZSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpeed(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space1DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	this->tt__Space1DDescription::XRange = NULL;
}

void tt__Space1DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space1DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space1DDescription::XRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Space1DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space1DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type ? type : "tt:Space1DDescription"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space1DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space1DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space1DDescription::XRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space1DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space1DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space1DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space1DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space1DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space1DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_URI1 > 0 || !a->tt__Space1DDescription::XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_dup_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *d, tt__Space1DDescription const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Space1DDescription*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Space1DDescription, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Space1DDescription(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__Space1DDescription::URI, &a->tt__Space1DDescription::URI);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__Space1DDescription::XRange, &a->tt__Space1DDescription::XRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Space1DDescription(tt__Space1DDescription const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__Space1DDescription::URI);
	soap_del_PointerTott__FloatRange(&a->tt__Space1DDescription::XRange);
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space1DDescription *p;
	size_t k = sizeof(tt__Space1DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space1DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space1DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space1DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space1DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space1DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space1DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space2DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	this->tt__Space2DDescription::XRange = NULL;
	this->tt__Space2DDescription::YRange = NULL;
}

void tt__Space2DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space2DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::XRange);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::YRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Space2DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space2DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type ? type : "tt:Space2DDescription"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space2DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space2DDescription::XRange, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->tt__Space2DDescription::YRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space2DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space2DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space2DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space2DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space2DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space2DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->tt__Space2DDescription::YRange, "tt:FloatRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_URI1 > 0 || !a->tt__Space2DDescription::XRange || !a->tt__Space2DDescription::YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_dup_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *d, tt__Space2DDescription const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Space2DDescription*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Space2DDescription, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Space2DDescription(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__Space2DDescription::URI, &a->tt__Space2DDescription::URI);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__Space2DDescription::XRange, &a->tt__Space2DDescription::XRange);
	soap_dup_PointerTott__FloatRange(soap, &d->tt__Space2DDescription::YRange, &a->tt__Space2DDescription::YRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Space2DDescription(tt__Space2DDescription const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__Space2DDescription::URI);
	soap_del_PointerTott__FloatRange(&a->tt__Space2DDescription::XRange);
	soap_del_PointerTott__FloatRange(&a->tt__Space2DDescription::YRange);
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space2DDescription *p;
	size_t k = sizeof(tt__Space2DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space2DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space2DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space2DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space2DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space2DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space2DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ZoomLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ZoomLimits::Range = NULL;
}

void tt__ZoomLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__ZoomLimits::Range);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ZoomLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ZoomLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type ? type : "tt:ZoomLimits"))
		return soap->error;
	if (!a->tt__ZoomLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->tt__ZoomLimits::Range, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ZoomLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ZoomLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ZoomLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ZoomLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->tt__ZoomLimits::Range, "tt:Space1DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__ZoomLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_dup_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *d, tt__ZoomLimits const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ZoomLimits*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ZoomLimits, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ZoomLimits(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Space1DDescription(soap, &d->tt__ZoomLimits::Range, &a->tt__ZoomLimits::Range);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ZoomLimits(tt__ZoomLimits const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Space1DDescription(&a->tt__ZoomLimits::Range);
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ZoomLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ZoomLimits *p;
	size_t k = sizeof(tt__ZoomLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ZoomLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ZoomLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ZoomLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ZoomLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ZoomLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ZoomLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ZoomLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PanTiltLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PanTiltLimits::Range = NULL;
}

void tt__PanTiltLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PanTiltLimits::Range);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PanTiltLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PanTiltLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type ? type : "tt:PanTiltLimits"))
		return soap->error;
	if (!a->tt__PanTiltLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->tt__PanTiltLimits::Range, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PanTiltLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PanTiltLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PanTiltLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PanTiltLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->tt__PanTiltLimits::Range, "tt:Space2DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__PanTiltLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_dup_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *d, tt__PanTiltLimits const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PanTiltLimits*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PanTiltLimits, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PanTiltLimits(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Space2DDescription(soap, &d->tt__PanTiltLimits::Range, &a->tt__PanTiltLimits::Range);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PanTiltLimits(tt__PanTiltLimits const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Space2DDescription(&a->tt__PanTiltLimits::Range);
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PanTiltLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PanTiltLimits *p;
	size_t k = sizeof(tt__PanTiltLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PanTiltLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PanTiltLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PanTiltLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PanTiltLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PanTiltLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PanTiltLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PanTiltLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Reverse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReverseMode(soap, &this->tt__Reverse::Mode);
}

void tt__Reverse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Reverse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Reverse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const tt__Reverse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type ? type : "tt:Reverse"))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->tt__Reverse::Mode, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Reverse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Reverse(soap, tag, this, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, tt__Reverse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Reverse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Reverse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Reverse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->tt__Reverse::Mode, "tt:ReverseMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_dup_tt__Reverse(struct soap *soap, tt__Reverse *d, tt__Reverse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Reverse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Reverse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Reverse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Reverse::Mode = a->tt__Reverse::Mode;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Reverse(tt__Reverse const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
}

SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Reverse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Reverse *p;
	size_t k = sizeof(tt__Reverse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Reverse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Reverse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Reverse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Reverse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Reverse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Reverse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Reverse(soap, this, tag, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlip::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__EFlipMode(soap, &this->tt__EFlip::Mode);
}

void tt__EFlip::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EFlip::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlip(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const tt__EFlip *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type ? type : "tt:EFlip"))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlip::Mode, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlip::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlip(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, tt__EFlip *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlip*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlip)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlip *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->tt__EFlip::Mode, "tt:EFlipMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_dup_tt__EFlip(struct soap *soap, tt__EFlip *d, tt__EFlip const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__EFlip*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__EFlip, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__EFlip(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__EFlip::Mode = a->tt__EFlip::Mode;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__EFlip(tt__EFlip const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
}

SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlip(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlip *p;
	size_t k = sizeof(tt__EFlip);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlip, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlip);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlip, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlip location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlip::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlip::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlip(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__PTControlDirectionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTControlDirectionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:PTControlDirectionExtension");
}

void *tt__PTControlDirectionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTControlDirectionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionExtension)
		return (tt__PTControlDirectionExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_dup_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *d, tt__PTControlDirectionExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTControlDirectionExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTControlDirectionExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTControlDirectionExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTControlDirectionExtension(tt__PTControlDirectionExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionExtension *p;
	size_t k = sizeof(tt__PTControlDirectionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PTControlDirection::EFlip = NULL;
	this->tt__PTControlDirection::Reverse = NULL;
	this->tt__PTControlDirection::Extension = NULL;
}

void tt__PTControlDirection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &this->tt__PTControlDirection::EFlip);
	soap_serialize_PointerTott__Reverse(soap, &this->tt__PTControlDirection::Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &this->tt__PTControlDirection::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTControlDirection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const tt__PTControlDirection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type ? type : "tt:PTControlDirection"))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->tt__PTControlDirection::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->tt__PTControlDirection::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirection::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirection(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->tt__PTControlDirection::EFlip, "tt:EFlip"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->tt__PTControlDirection::Reverse, "tt:Reverse"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->tt__PTControlDirection::Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_dup_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *d, tt__PTControlDirection const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTControlDirection*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTControlDirection, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTControlDirection(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__EFlip(soap, &d->tt__PTControlDirection::EFlip, &a->tt__PTControlDirection::EFlip);
	soap_dup_PointerTott__Reverse(soap, &d->tt__PTControlDirection::Reverse, &a->tt__PTControlDirection::Reverse);
	soap_dup_PointerTott__PTControlDirectionExtension(soap, &d->tt__PTControlDirection::Extension, &a->tt__PTControlDirection::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTControlDirection(tt__PTControlDirection const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__EFlip(&a->tt__PTControlDirection::EFlip);
	soap_del_PointerTott__Reverse(&a->tt__PTControlDirection::Reverse);
	soap_del_PointerTott__PTControlDirectionExtension(&a->tt__PTControlDirection::Extension);
}

SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirection *p;
	size_t k = sizeof(tt__PTControlDirection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirection(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__PTZConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:PTZConfigurationExtension2");
}

void *tt__PTZConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTZConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension2)
		return (tt__PTZConfigurationExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_dup_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *d, tt__PTZConfigurationExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZConfigurationExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZConfigurationExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZConfigurationExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZConfigurationExtension2(tt__PTZConfigurationExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension2 *p;
	size_t k = sizeof(tt__PTZConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__PTZConfigurationExtension::PTControlDirection = NULL;
	this->tt__PTZConfigurationExtension::Extension = NULL;
}

void tt__PTZConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTControlDirection(soap, &this->tt__PTZConfigurationExtension::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &this->tt__PTZConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type ? type : "tt:PTZConfigurationExtension"))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationExtension::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationExtension::PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->tt__PTZConfigurationExtension::Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_dup_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *d, tt__PTZConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__PTControlDirection(soap, &d->tt__PTZConfigurationExtension::PTControlDirection, &a->tt__PTZConfigurationExtension::PTControlDirection);
	soap_dup_PointerTott__PTZConfigurationExtension2(soap, &d->tt__PTZConfigurationExtension::Extension, &a->tt__PTZConfigurationExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZConfigurationExtension(tt__PTZConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__PTControlDirection(&a->tt__PTZConfigurationExtension::PTControlDirection);
	soap_del_PointerTott__PTZConfigurationExtension2(&a->tt__PTZConfigurationExtension::Extension);
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension *p;
	size_t k = sizeof(tt__PTZConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultPTZSpeed = NULL;
	this->tt__PTZConfiguration::DefaultPTZTimeout = NULL;
	this->tt__PTZConfiguration::PanTiltLimits = NULL;
	this->tt__PTZConfiguration::ZoomLimits = NULL;
	this->tt__PTZConfiguration::Extension = NULL;
	this->tt__PTZConfiguration::MoveRamp = NULL;
	this->tt__PTZConfiguration::PresetRamp = NULL;
	this->tt__PTZConfiguration::PresetTourRamp = NULL;
}

void tt__PTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZConfiguration::NodeToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &this->tt__PTZConfiguration::PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &this->tt__PTZConfiguration::ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &this->tt__PTZConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__PTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const tt__PTZConfiguration *a, const char *type)
{
	if (((tt__PTZConfiguration*)a)->MoveRamp)
	{	soap_set_attr(soap, "MoveRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->MoveRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetRamp)
	{	soap_set_attr(soap, "PresetRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetTourRamp)
	{	soap_set_attr(soap, "PresetTourRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetTourRamp), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type ? type : "tt:PTZConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->tt__PTZConfiguration::NodeToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->tt__PTZConfiguration::DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &a->tt__PTZConfiguration::DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->tt__PTZConfiguration::PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->tt__PTZConfiguration::ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->tt__PTZConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MoveRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->MoveRamp = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->MoveRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetRamp = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetTourRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetTourRamp = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetTourRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_NodeToken1 = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace1 = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace1 = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace1 = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace1 = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace1 = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace1 = 1;
	size_t soap_flag_DefaultPTZSpeed1 = 1;
	size_t soap_flag_DefaultPTZTimeout1 = 1;
	size_t soap_flag_PanTiltLimits1 = 1;
	size_t soap_flag_ZoomLimits1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->tt__PTZConfiguration::NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativeZoomTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousZoomVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->tt__PTZConfiguration::DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &a->tt__PTZConfiguration::DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PanTiltLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->tt__PTZConfiguration::PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits1--;
					continue;
				}
			}
			if (soap_flag_ZoomLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->tt__PTZConfiguration::ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->tt__PTZConfiguration::Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_NodeToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_dup_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *d, tt__PTZConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__PTZConfiguration::NodeToken, &a->tt__PTZConfiguration::NodeToken);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_dup_PointerTott__PTZSpeed(soap, &d->tt__PTZConfiguration::DefaultPTZSpeed, &a->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_dup_PointerToxsd__duration(soap, &d->tt__PTZConfiguration::DefaultPTZTimeout, &a->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_dup_PointerTott__PanTiltLimits(soap, &d->tt__PTZConfiguration::PanTiltLimits, &a->tt__PTZConfiguration::PanTiltLimits);
	soap_dup_PointerTott__ZoomLimits(soap, &d->tt__PTZConfiguration::ZoomLimits, &a->tt__PTZConfiguration::ZoomLimits);
	soap_dup_PointerTott__PTZConfigurationExtension(soap, &d->tt__PTZConfiguration::Extension, &a->tt__PTZConfiguration::Extension);
	soap_dup_PointerToint(soap, &d->tt__PTZConfiguration::MoveRamp, &a->tt__PTZConfiguration::MoveRamp);
	soap_dup_PointerToint(soap, &d->tt__PTZConfiguration::PresetRamp, &a->tt__PTZConfiguration::PresetRamp);
	soap_dup_PointerToint(soap, &d->tt__PTZConfiguration::PresetTourRamp, &a->tt__PTZConfiguration::PresetTourRamp);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZConfiguration(tt__PTZConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_tt__ReferenceToken(&a->tt__PTZConfiguration::NodeToken);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_del_PointerToxsd__anyURI(&a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_del_PointerTott__PTZSpeed(&a->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_del_PointerToxsd__duration(&a->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_del_PointerTott__PanTiltLimits(&a->tt__PTZConfiguration::PanTiltLimits);
	soap_del_PointerTott__ZoomLimits(&a->tt__PTZConfiguration::ZoomLimits);
	soap_del_PointerTott__PTZConfigurationExtension(&a->tt__PTZConfiguration::Extension);
	soap_del_PointerToint(&a->tt__PTZConfiguration::MoveRamp);
	soap_del_PointerToint(&a->tt__PTZConfiguration::PresetRamp);
	soap_del_PointerToint(&a->tt__PTZConfiguration::PresetTourRamp);
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfiguration *p;
	size_t k = sizeof(tt__PTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__RelayOutput::Properties = NULL;
}

void tt__RelayOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->tt__RelayOutput::Properties);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__RelayOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutput(struct soap *soap, const char *tag, int id, const tt__RelayOutput *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutput), type ? type : "tt:RelayOutput"))
		return soap->error;
	if (!a->tt__RelayOutput::Properties)
	{	if (soap_element_empty(soap, "tt:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tt:Properties", -1, &a->tt__RelayOutput::Properties, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_in_tt__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutput)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutput *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tt:Properties", &a->tt__RelayOutput::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__RelayOutput::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutput *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutput, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_dup_tt__RelayOutput(struct soap *soap, tt__RelayOutput *d, tt__RelayOutput const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RelayOutput*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RelayOutput, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RelayOutput(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	soap_dup_PointerTott__RelayOutputSettings(soap, &d->tt__RelayOutput::Properties, &a->tt__RelayOutput::Properties);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RelayOutput(tt__RelayOutput const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	soap_del_PointerTott__RelayOutputSettings(&a->tt__RelayOutput::Properties);
}

SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutput *p;
	size_t k = sizeof(tt__RelayOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutput);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutput, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutput * SOAP_FMAC4 soap_get_tt__RelayOutput(struct soap *soap, tt__RelayOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RelayMode(soap, &this->tt__RelayOutputSettings::Mode);
	soap_default_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
	soap_default_tt__RelayIdleState(soap, &this->tt__RelayOutputSettings::IdleState);
}

void tt__RelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RelayOutputSettings::DelayTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__RelayOutputSettings::DelayTime);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RelayOutputSettings(struct soap *soap, const char *tag, int id, const tt__RelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RelayOutputSettings), type ? type : "tt:RelayOutputSettings"))
		return soap->error;
	if (soap_out_tt__RelayMode(soap, "tt:Mode", -1, &a->tt__RelayOutputSettings::Mode, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:DelayTime", -1, &a->tt__RelayOutputSettings::DelayTime, ""))
		return soap->error;
	if (soap_out_tt__RelayIdleState(soap, "tt:IdleState", -1, &a->tt__RelayOutputSettings::IdleState, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_in_tt__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_DelayTime1 = 1;
	size_t soap_flag_IdleState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayMode(soap, "tt:Mode", &a->tt__RelayOutputSettings::Mode, "tt:RelayMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_DelayTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:DelayTime", &a->tt__RelayOutputSettings::DelayTime, "xsd:duration"))
				{	soap_flag_DelayTime1--;
					continue;
				}
			}
			if (soap_flag_IdleState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayIdleState(soap, "tt:IdleState", &a->tt__RelayOutputSettings::IdleState, "tt:RelayIdleState"))
				{	soap_flag_IdleState1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0 || soap_flag_DelayTime1 > 0 || soap_flag_IdleState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RelayOutputSettings, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_dup_tt__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *d, tt__RelayOutputSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RelayOutputSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RelayOutputSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RelayOutputSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__RelayOutputSettings::Mode = a->tt__RelayOutputSettings::Mode;
	soap_dup_xsd__duration(soap, &d->tt__RelayOutputSettings::DelayTime, &a->tt__RelayOutputSettings::DelayTime);
	d->tt__RelayOutputSettings::IdleState = a->tt__RelayOutputSettings::IdleState;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RelayOutputSettings(tt__RelayOutputSettings const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_xsd__duration(&a->tt__RelayOutputSettings::DelayTime);
	/* IdleState skipped */
}

SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RelayOutputSettings *p;
	size_t k = sizeof(tt__RelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RelayOutputSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RelayOutputSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 tt__RelayOutputSettings * SOAP_FMAC4 soap_get_tt__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TLSConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
}

void tt__TLSConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TLSConfiguration::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TLSConfiguration::CertificateID);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__TLSConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TLSConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TLSConfiguration(struct soap *soap, const char *tag, int id, const tt__TLSConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TLSConfiguration), type ? type : "tt:TLSConfiguration"))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__TLSConfiguration::CertificateID, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TLSConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TLSConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_in_tt__TLSConfiguration(struct soap *soap, const char *tag, tt__TLSConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TLSConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TLSConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TLSConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__TLSConfiguration::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TLSConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TLSConfiguration, SOAP_TYPE_tt__TLSConfiguration, sizeof(tt__TLSConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_dup_tt__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *d, tt__TLSConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__TLSConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__TLSConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__TLSConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->tt__TLSConfiguration::CertificateID, &a->tt__TLSConfiguration::CertificateID);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__TLSConfiguration(tt__TLSConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->tt__TLSConfiguration::CertificateID);
}

SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TLSConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TLSConfiguration *p;
	size_t k = sizeof(tt__TLSConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TLSConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TLSConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TLSConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TLSConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TLSConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TLSConfiguration(soap, tag ? tag : "tt:TLSConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TLSConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TLSConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__TLSConfiguration * SOAP_FMAC4 soap_get_tt__TLSConfiguration(struct soap *soap, tt__TLSConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EapMethodExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__EapMethodExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EapMethodExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EapMethodExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EapMethodExtension(struct soap *soap, const char *tag, int id, const tt__EapMethodExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:EapMethodExtension");
}

void *tt__EapMethodExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EapMethodExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_in_tt__EapMethodExtension(struct soap *soap, const char *tag, tt__EapMethodExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__EapMethodExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EapMethodExtension, sizeof(tt__EapMethodExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EapMethodExtension)
		return (tt__EapMethodExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_dup_tt__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *d, tt__EapMethodExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__EapMethodExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__EapMethodExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__EapMethodExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__EapMethodExtension(tt__EapMethodExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EapMethodExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EapMethodExtension *p;
	size_t k = sizeof(tt__EapMethodExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EapMethodExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EapMethodExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EapMethodExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EapMethodExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EapMethodExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EapMethodExtension(soap, tag ? tag : "tt:EapMethodExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EapMethodExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EapMethodExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EapMethodExtension * SOAP_FMAC4 soap_get_tt__EapMethodExtension(struct soap *soap, tt__EapMethodExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EAPMethodConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__EAPMethodConfiguration::TLSConfiguration = NULL;
	this->tt__EAPMethodConfiguration::Password = NULL;
	this->tt__EAPMethodConfiguration::Extension = NULL;
}

void tt__EAPMethodConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__TLSConfiguration(soap, &this->tt__EAPMethodConfiguration::TLSConfiguration);
	soap_serialize_PointerTostd__string(soap, &this->tt__EAPMethodConfiguration::Password);
	soap_serialize_PointerTott__EapMethodExtension(soap, &this->tt__EAPMethodConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EAPMethodConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EAPMethodConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, const tt__EAPMethodConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EAPMethodConfiguration), type ? type : "tt:EAPMethodConfiguration"))
		return soap->error;
	if (soap_out_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", -1, &a->tt__EAPMethodConfiguration::TLSConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__EAPMethodConfiguration::Password, ""))
		return soap->error;
	if (soap_out_PointerTott__EapMethodExtension(soap, "tt:Extension", -1, &a->tt__EAPMethodConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EAPMethodConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EAPMethodConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_in_tt__EAPMethodConfiguration(struct soap *soap, const char *tag, tt__EAPMethodConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EAPMethodConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EAPMethodConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EAPMethodConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_TLSConfiguration1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLSConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TLSConfiguration(soap, "tt:TLSConfiguration", &a->tt__EAPMethodConfiguration::TLSConfiguration, "tt:TLSConfiguration"))
				{	soap_flag_TLSConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__EAPMethodConfiguration::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EapMethodExtension(soap, "tt:Extension", &a->tt__EAPMethodConfiguration::Extension, "tt:EapMethodExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EAPMethodConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EAPMethodConfiguration, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(tt__EAPMethodConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_dup_tt__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *d, tt__EAPMethodConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__EAPMethodConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__EAPMethodConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__EAPMethodConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__TLSConfiguration(soap, &d->tt__EAPMethodConfiguration::TLSConfiguration, &a->tt__EAPMethodConfiguration::TLSConfiguration);
	soap_dup_PointerTostd__string(soap, &d->tt__EAPMethodConfiguration::Password, &a->tt__EAPMethodConfiguration::Password);
	soap_dup_PointerTott__EapMethodExtension(soap, &d->tt__EAPMethodConfiguration::Extension, &a->tt__EAPMethodConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__EAPMethodConfiguration(tt__EAPMethodConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__TLSConfiguration(&a->tt__EAPMethodConfiguration::TLSConfiguration);
	soap_del_PointerTostd__string(&a->tt__EAPMethodConfiguration::Password);
	soap_del_PointerTott__EapMethodExtension(&a->tt__EAPMethodConfiguration::Extension);
}

SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EAPMethodConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EAPMethodConfiguration *p;
	size_t k = sizeof(tt__EAPMethodConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EAPMethodConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EAPMethodConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EAPMethodConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EAPMethodConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EAPMethodConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EAPMethodConfiguration(soap, tag ? tag : "tt:EAPMethodConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EAPMethodConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EAPMethodConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__EAPMethodConfiguration * SOAP_FMAC4 soap_get_tt__EAPMethodConfiguration(struct soap *soap, tt__EAPMethodConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__Dot1XConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot1XConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Dot1XConfigurationExtension");
}

void *tt__Dot1XConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot1XConfigurationExtension(struct soap *soap, const char *tag, tt__Dot1XConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot1XConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(tt__Dot1XConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfigurationExtension)
		return (tt__Dot1XConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_dup_tt__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *d, tt__Dot1XConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot1XConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot1XConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot1XConfigurationExtension(tt__Dot1XConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfigurationExtension *p;
	size_t k = sizeof(tt__Dot1XConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfigurationExtension(soap, tag ? tag : "tt:Dot1XConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot1XConfigurationExtension(struct soap *soap, tt__Dot1XConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_default_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	this->tt__Dot1XConfiguration::AnonymousID = NULL;
	soap_default_int(soap, &this->tt__Dot1XConfiguration::EAPMethod);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	this->tt__Dot1XConfiguration::EAPMethodConfiguration = NULL;
	this->tt__Dot1XConfiguration::Extension = NULL;
}

void tt__Dot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::Identity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__Dot1XConfiguration::Identity);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot1XConfiguration::AnonymousID);
	soap_embedded(soap, &this->tt__Dot1XConfiguration::EAPMethod, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__Dot1XConfiguration::CACertificateID);
	soap_serialize_PointerTott__EAPMethodConfiguration(soap, &this->tt__Dot1XConfiguration::EAPMethodConfiguration);
	soap_serialize_PointerTott__Dot1XConfigurationExtension(soap, &this->tt__Dot1XConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot1XConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot1XConfiguration), type ? type : "tt:Dot1XConfiguration"))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", -1, &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Identity", -1, &a->tt__Dot1XConfiguration::Identity, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:AnonymousID", -1, &a->tt__Dot1XConfiguration::AnonymousID, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EAPMethod", -1, &a->tt__Dot1XConfiguration::EAPMethod, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", -1, &a->tt__Dot1XConfiguration::CACertificateID, ""))
		return soap->error;
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", -1, &a->tt__Dot1XConfiguration::EAPMethodConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot1XConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_in_tt__Dot1XConfiguration(struct soap *soap, const char *tag, tt__Dot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	size_t soap_flag_Identity1 = 1;
	size_t soap_flag_AnonymousID1 = 1;
	size_t soap_flag_EAPMethod1 = 1;
	size_t soap_flag_EAPMethodConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:Dot1XConfigurationToken", &a->tt__Dot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap_flag_Identity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Identity", &a->tt__Dot1XConfiguration::Identity, "xsd:string"))
				{	soap_flag_Identity1--;
					continue;
				}
			}
			if (soap_flag_AnonymousID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:AnonymousID", &a->tt__Dot1XConfiguration::AnonymousID, "xsd:string"))
				{	soap_flag_AnonymousID1--;
					continue;
				}
			}
			if (soap_flag_EAPMethod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EAPMethod", &a->tt__Dot1XConfiguration::EAPMethod, "xsd:int"))
				{	soap_flag_EAPMethod1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:CACertificateID", &a->tt__Dot1XConfiguration::CACertificateID, "xsd:token"))
					continue;
			}
			if (soap_flag_EAPMethodConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EAPMethodConfiguration(soap, "tt:EAPMethodConfiguration", &a->tt__Dot1XConfiguration::EAPMethodConfiguration, "tt:EAPMethodConfiguration"))
				{	soap_flag_EAPMethodConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfigurationExtension(soap, "tt:Extension", &a->tt__Dot1XConfiguration::Extension, "tt:Dot1XConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Dot1XConfigurationToken1 > 0 || soap_flag_Identity1 > 0 || soap_flag_EAPMethod1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot1XConfiguration, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_dup_tt__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *d, tt__Dot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__Dot1XConfiguration::Dot1XConfigurationToken, &a->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_dup_std__string(soap, &d->tt__Dot1XConfiguration::Identity, &a->tt__Dot1XConfiguration::Identity);
	soap_dup_PointerTostd__string(soap, &d->tt__Dot1XConfiguration::AnonymousID, &a->tt__Dot1XConfiguration::AnonymousID);
	d->tt__Dot1XConfiguration::EAPMethod = a->tt__Dot1XConfiguration::EAPMethod;
	soap_dup_std__vectorTemplateOfxsd__token(soap, &d->tt__Dot1XConfiguration::CACertificateID, &a->tt__Dot1XConfiguration::CACertificateID);
	soap_dup_PointerTott__EAPMethodConfiguration(soap, &d->tt__Dot1XConfiguration::EAPMethodConfiguration, &a->tt__Dot1XConfiguration::EAPMethodConfiguration);
	soap_dup_PointerTott__Dot1XConfigurationExtension(soap, &d->tt__Dot1XConfiguration::Extension, &a->tt__Dot1XConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot1XConfiguration(tt__Dot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__ReferenceToken(&a->tt__Dot1XConfiguration::Dot1XConfigurationToken);
	soap_del_std__string(&a->tt__Dot1XConfiguration::Identity);
	soap_del_PointerTostd__string(&a->tt__Dot1XConfiguration::AnonymousID);
	/* EAPMethod skipped */
	soap_del_std__vectorTemplateOfxsd__token(&a->tt__Dot1XConfiguration::CACertificateID);
	soap_del_PointerTott__EAPMethodConfiguration(&a->tt__Dot1XConfiguration::EAPMethodConfiguration);
	soap_del_PointerTott__Dot1XConfigurationExtension(&a->tt__Dot1XConfiguration::Extension);
}

SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot1XConfiguration *p;
	size_t k = sizeof(tt__Dot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot1XConfiguration * SOAP_FMAC4 soap_get_tt__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__CertificateInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CertificateInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformationExtension(struct soap *soap, const char *tag, int id, const tt__CertificateInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:CertificateInformationExtension");
}

void *tt__CertificateInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_in_tt__CertificateInformationExtension(struct soap *soap, const char *tag, tt__CertificateInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CertificateInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(tt__CertificateInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformationExtension)
		return (tt__CertificateInformationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_dup_tt__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *d, tt__CertificateInformationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CertificateInformationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CertificateInformationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CertificateInformationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CertificateInformationExtension(tt__CertificateInformationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformationExtension *p;
	size_t k = sizeof(tt__CertificateInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformationExtension(soap, tag ? tag : "tt:CertificateInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformationExtension * SOAP_FMAC4 soap_get_tt__CertificateInformationExtension(struct soap *soap, tt__CertificateInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateUsage::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__CertificateUsage::__item);
	soap_default_bool(soap, &this->tt__CertificateUsage::Critical);
}

void tt__CertificateUsage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateUsage::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__CertificateUsage::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CertificateUsage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateUsage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateUsage(struct soap *soap, const char *tag, int id, const tt__CertificateUsage *a, const char *type)
{
	soap_set_attr(soap, "Critical", soap_bool2s(soap, ((tt__CertificateUsage*)a)->Critical), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->tt__CertificateUsage::__item, "tt:CertificateUsage");
}

void *tt__CertificateUsage::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateUsage(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_in_tt__CertificateUsage(struct soap *soap, const char *tag, tt__CertificateUsage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CertificateUsage*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateUsage, sizeof(tt__CertificateUsage), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateUsage)
		return (tt__CertificateUsage *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2bool(soap, soap_attr_value(soap, "Critical", 5, 3), &((tt__CertificateUsage*)a)->Critical))
		return NULL;
	if (!soap_in_std__string(soap, tag, &a->tt__CertificateUsage::__item, "tt:CertificateUsage"))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_dup_tt__CertificateUsage(struct soap *soap, tt__CertificateUsage *d, tt__CertificateUsage const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CertificateUsage*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CertificateUsage, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CertificateUsage(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__CertificateUsage::__item, &a->tt__CertificateUsage::__item);
	d->tt__CertificateUsage::Critical = a->tt__CertificateUsage::Critical;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CertificateUsage(tt__CertificateUsage const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__CertificateUsage::__item);
	/* Critical skipped */
}

SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateUsage(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateUsage *p;
	size_t k = sizeof(tt__CertificateUsage);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateUsage, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateUsage);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateUsage, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateUsage location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateUsage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateUsage(soap, tag ? tag : "tt:CertificateUsage", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateUsage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateUsage(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateUsage * SOAP_FMAC4 soap_get_tt__CertificateUsage(struct soap *soap, tt__CertificateUsage *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	this->tt__CertificateInformation::IssuerDN = NULL;
	this->tt__CertificateInformation::SubjectDN = NULL;
	this->tt__CertificateInformation::KeyUsage = NULL;
	this->tt__CertificateInformation::ExtendedKeyUsage = NULL;
	this->tt__CertificateInformation::KeyLength = NULL;
	this->tt__CertificateInformation::Version = NULL;
	this->tt__CertificateInformation::SerialNum = NULL;
	this->tt__CertificateInformation::SignatureAlgorithm = NULL;
	this->tt__CertificateInformation::Validity = NULL;
	this->tt__CertificateInformation::Extension = NULL;
}

void tt__CertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateInformation::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::IssuerDN);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SubjectDN);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::KeyUsage);
	soap_serialize_PointerTott__CertificateUsage(soap, &this->tt__CertificateInformation::ExtendedKeyUsage);
	soap_serialize_PointerToint(soap, &this->tt__CertificateInformation::KeyLength);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::Version);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SerialNum);
	soap_serialize_PointerTostd__string(soap, &this->tt__CertificateInformation::SignatureAlgorithm);
	soap_serialize_PointerTott__DateTimeRange(soap, &this->tt__CertificateInformation::Validity);
	soap_serialize_PointerTott__CertificateInformationExtension(soap, &this->tt__CertificateInformation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateInformation(struct soap *soap, const char *tag, int id, const tt__CertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateInformation), type ? type : "tt:CertificateInformation"))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateInformation::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:IssuerDN", -1, &a->tt__CertificateInformation::IssuerDN, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SubjectDN", -1, &a->tt__CertificateInformation::SubjectDN, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:KeyUsage", -1, &a->tt__CertificateInformation::KeyUsage, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", -1, &a->tt__CertificateInformation::ExtendedKeyUsage, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:KeyLength", -1, &a->tt__CertificateInformation::KeyLength, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Version", -1, &a->tt__CertificateInformation::Version, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SerialNum", -1, &a->tt__CertificateInformation::SerialNum, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:SignatureAlgorithm", -1, &a->tt__CertificateInformation::SignatureAlgorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTimeRange(soap, "tt:Validity", -1, &a->tt__CertificateInformation::Validity, ""))
		return soap->error;
	if (soap_out_PointerTott__CertificateInformationExtension(soap, "tt:Extension", -1, &a->tt__CertificateInformation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_in_tt__CertificateInformation(struct soap *soap, const char *tag, tt__CertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_IssuerDN1 = 1;
	size_t soap_flag_SubjectDN1 = 1;
	size_t soap_flag_KeyUsage1 = 1;
	size_t soap_flag_ExtendedKeyUsage1 = 1;
	size_t soap_flag_KeyLength1 = 1;
	size_t soap_flag_Version1 = 1;
	size_t soap_flag_SerialNum1 = 1;
	size_t soap_flag_SignatureAlgorithm1 = 1;
	size_t soap_flag_Validity1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_IssuerDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:IssuerDN", &a->tt__CertificateInformation::IssuerDN, "xsd:string"))
				{	soap_flag_IssuerDN1--;
					continue;
				}
			}
			if (soap_flag_SubjectDN1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SubjectDN", &a->tt__CertificateInformation::SubjectDN, "xsd:string"))
				{	soap_flag_SubjectDN1--;
					continue;
				}
			}
			if (soap_flag_KeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:KeyUsage", &a->tt__CertificateInformation::KeyUsage, "tt:CertificateUsage"))
				{	soap_flag_KeyUsage1--;
					continue;
				}
			}
			if (soap_flag_ExtendedKeyUsage1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateUsage(soap, "tt:ExtendedKeyUsage", &a->tt__CertificateInformation::ExtendedKeyUsage, "tt:CertificateUsage"))
				{	soap_flag_ExtendedKeyUsage1--;
					continue;
				}
			}
			if (soap_flag_KeyLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:KeyLength", &a->tt__CertificateInformation::KeyLength, "xsd:int"))
				{	soap_flag_KeyLength1--;
					continue;
				}
			}
			if (soap_flag_Version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Version", &a->tt__CertificateInformation::Version, "xsd:string"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag_SerialNum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SerialNum", &a->tt__CertificateInformation::SerialNum, "xsd:string"))
				{	soap_flag_SerialNum1--;
					continue;
				}
			}
			if (soap_flag_SignatureAlgorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:SignatureAlgorithm", &a->tt__CertificateInformation::SignatureAlgorithm, "xsd:string"))
				{	soap_flag_SignatureAlgorithm1--;
					continue;
				}
			}
			if (soap_flag_Validity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTimeRange(soap, "tt:Validity", &a->tt__CertificateInformation::Validity, "tt:DateTimeRange"))
				{	soap_flag_Validity1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformationExtension(soap, "tt:Extension", &a->tt__CertificateInformation::Extension, "tt:CertificateInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateInformation, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_dup_tt__CertificateInformation(struct soap *soap, tt__CertificateInformation *d, tt__CertificateInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CertificateInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CertificateInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CertificateInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->tt__CertificateInformation::CertificateID, &a->tt__CertificateInformation::CertificateID);
	soap_dup_PointerTostd__string(soap, &d->tt__CertificateInformation::IssuerDN, &a->tt__CertificateInformation::IssuerDN);
	soap_dup_PointerTostd__string(soap, &d->tt__CertificateInformation::SubjectDN, &a->tt__CertificateInformation::SubjectDN);
	soap_dup_PointerTott__CertificateUsage(soap, &d->tt__CertificateInformation::KeyUsage, &a->tt__CertificateInformation::KeyUsage);
	soap_dup_PointerTott__CertificateUsage(soap, &d->tt__CertificateInformation::ExtendedKeyUsage, &a->tt__CertificateInformation::ExtendedKeyUsage);
	soap_dup_PointerToint(soap, &d->tt__CertificateInformation::KeyLength, &a->tt__CertificateInformation::KeyLength);
	soap_dup_PointerTostd__string(soap, &d->tt__CertificateInformation::Version, &a->tt__CertificateInformation::Version);
	soap_dup_PointerTostd__string(soap, &d->tt__CertificateInformation::SerialNum, &a->tt__CertificateInformation::SerialNum);
	soap_dup_PointerTostd__string(soap, &d->tt__CertificateInformation::SignatureAlgorithm, &a->tt__CertificateInformation::SignatureAlgorithm);
	soap_dup_PointerTott__DateTimeRange(soap, &d->tt__CertificateInformation::Validity, &a->tt__CertificateInformation::Validity);
	soap_dup_PointerTott__CertificateInformationExtension(soap, &d->tt__CertificateInformation::Extension, &a->tt__CertificateInformation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CertificateInformation(tt__CertificateInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->tt__CertificateInformation::CertificateID);
	soap_del_PointerTostd__string(&a->tt__CertificateInformation::IssuerDN);
	soap_del_PointerTostd__string(&a->tt__CertificateInformation::SubjectDN);
	soap_del_PointerTott__CertificateUsage(&a->tt__CertificateInformation::KeyUsage);
	soap_del_PointerTott__CertificateUsage(&a->tt__CertificateInformation::ExtendedKeyUsage);
	soap_del_PointerToint(&a->tt__CertificateInformation::KeyLength);
	soap_del_PointerTostd__string(&a->tt__CertificateInformation::Version);
	soap_del_PointerTostd__string(&a->tt__CertificateInformation::SerialNum);
	soap_del_PointerTostd__string(&a->tt__CertificateInformation::SignatureAlgorithm);
	soap_del_PointerTott__DateTimeRange(&a->tt__CertificateInformation::Validity);
	soap_del_PointerTott__CertificateInformationExtension(&a->tt__CertificateInformation::Extension);
}

SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateInformation *p;
	size_t k = sizeof(tt__CertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateInformation * SOAP_FMAC4 soap_get_tt__CertificateInformation(struct soap *soap, tt__CertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__CertificateWithPrivateKey::CertificateID = NULL;
	this->tt__CertificateWithPrivateKey::Certificate = NULL;
	this->tt__CertificateWithPrivateKey::PrivateKey = NULL;
}

void tt__CertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->tt__CertificateWithPrivateKey::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::Certificate);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__CertificateWithPrivateKey::PrivateKey);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateWithPrivateKey), type ? type : "tt:CertificateWithPrivateKey"))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateWithPrivateKey::CertificateID, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__CertificateWithPrivateKey::Certificate, ""))
		return soap->error;
	if (!a->tt__CertificateWithPrivateKey::PrivateKey)
	{	if (soap_element_empty(soap, "tt:PrivateKey", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:PrivateKey", -1, &a->tt__CertificateWithPrivateKey::PrivateKey, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_in_tt__CertificateWithPrivateKey(struct soap *soap, const char *tag, tt__CertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	size_t soap_flag_PrivateKey1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:CertificateID", &a->tt__CertificateWithPrivateKey::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__CertificateWithPrivateKey::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap_flag_PrivateKey1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:PrivateKey", &a->tt__CertificateWithPrivateKey::PrivateKey, "tt:BinaryData"))
				{	soap_flag_PrivateKey1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__CertificateWithPrivateKey::Certificate || !a->tt__CertificateWithPrivateKey::PrivateKey))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateWithPrivateKey, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_dup_tt__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *d, tt__CertificateWithPrivateKey const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CertificateWithPrivateKey*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CertificateWithPrivateKey, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CertificateWithPrivateKey(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerToxsd__token(soap, &d->tt__CertificateWithPrivateKey::CertificateID, &a->tt__CertificateWithPrivateKey::CertificateID);
	soap_dup_PointerTott__BinaryData(soap, &d->tt__CertificateWithPrivateKey::Certificate, &a->tt__CertificateWithPrivateKey::Certificate);
	soap_dup_PointerTott__BinaryData(soap, &d->tt__CertificateWithPrivateKey::PrivateKey, &a->tt__CertificateWithPrivateKey::PrivateKey);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CertificateWithPrivateKey(tt__CertificateWithPrivateKey const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerToxsd__token(&a->tt__CertificateWithPrivateKey::CertificateID);
	soap_del_PointerTott__BinaryData(&a->tt__CertificateWithPrivateKey::Certificate);
	soap_del_PointerTott__BinaryData(&a->tt__CertificateWithPrivateKey::PrivateKey);
}

SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateWithPrivateKey *p;
	size_t k = sizeof(tt__CertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateWithPrivateKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateWithPrivateKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey * SOAP_FMAC4 soap_get_tt__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CertificateStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_default_bool(soap, &this->tt__CertificateStatus::Status);
}

void tt__CertificateStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__CertificateStatus::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__CertificateStatus::CertificateID);
	soap_embedded(soap, &this->tt__CertificateStatus::Status, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CertificateStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CertificateStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CertificateStatus(struct soap *soap, const char *tag, int id, const tt__CertificateStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CertificateStatus), type ? type : "tt:CertificateStatus"))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__CertificateStatus::CertificateID, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__CertificateStatus::Status, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CertificateStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CertificateStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_in_tt__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CertificateStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CertificateStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CertificateStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__CertificateStatus::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__CertificateStatus::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0 || soap_flag_Status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__CertificateStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CertificateStatus, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_dup_tt__CertificateStatus(struct soap *soap, tt__CertificateStatus *d, tt__CertificateStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CertificateStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CertificateStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CertificateStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->tt__CertificateStatus::CertificateID, &a->tt__CertificateStatus::CertificateID);
	d->tt__CertificateStatus::Status = a->tt__CertificateStatus::Status;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CertificateStatus(tt__CertificateStatus const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->tt__CertificateStatus::CertificateID);
	/* Status skipped */
}

SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CertificateStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CertificateStatus *p;
	size_t k = sizeof(tt__CertificateStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CertificateStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CertificateStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CertificateStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CertificateStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CertificateStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CertificateStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CertificateStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__CertificateStatus * SOAP_FMAC4 soap_get_tt__CertificateStatus(struct soap *soap, tt__CertificateStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Certificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->tt__Certificate::CertificateID);
	this->tt__Certificate::Certificate = NULL;
}

void tt__Certificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Certificate::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__Certificate::CertificateID);
	soap_serialize_PointerTott__BinaryData(soap, &this->tt__Certificate::Certificate);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Certificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Certificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Certificate(struct soap *soap, const char *tag, int id, const tt__Certificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Certificate), type ? type : "tt:Certificate"))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:CertificateID", -1, &a->tt__Certificate::CertificateID, ""))
		return soap->error;
	if (!a->tt__Certificate::Certificate)
	{	if (soap_element_empty(soap, "tt:Certificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tt:Certificate", -1, &a->tt__Certificate::Certificate, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Certificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Certificate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_in_tt__Certificate(struct soap *soap, const char *tag, tt__Certificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Certificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Certificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Certificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Certificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:CertificateID", &a->tt__Certificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Certificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tt:Certificate", &a->tt__Certificate::Certificate, "tt:BinaryData"))
				{	soap_flag_Certificate1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0 || !a->tt__Certificate::Certificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Certificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Certificate, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_dup_tt__Certificate(struct soap *soap, tt__Certificate *d, tt__Certificate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Certificate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Certificate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Certificate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->tt__Certificate::CertificateID, &a->tt__Certificate::CertificateID);
	soap_dup_PointerTott__BinaryData(soap, &d->tt__Certificate::Certificate, &a->tt__Certificate::Certificate);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Certificate(tt__Certificate const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->tt__Certificate::CertificateID);
	soap_del_PointerTott__BinaryData(&a->tt__Certificate::Certificate);
}

SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Certificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Certificate *p;
	size_t k = sizeof(tt__Certificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Certificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Certificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Certificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Certificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Certificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Certificate(soap, tag ? tag : "tt:Certificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Certificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Certificate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Certificate * SOAP_FMAC4 soap_get_tt__Certificate(struct soap *soap, tt__Certificate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__UserExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__UserExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__UserExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__UserExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__UserExtension(struct soap *soap, const char *tag, int id, const tt__UserExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:UserExtension");
}

void *tt__UserExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__UserExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_in_tt__UserExtension(struct soap *soap, const char *tag, tt__UserExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__UserExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__UserExtension, sizeof(tt__UserExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__UserExtension)
		return (tt__UserExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_dup_tt__UserExtension(struct soap *soap, tt__UserExtension *d, tt__UserExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__UserExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__UserExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__UserExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__UserExtension(tt__UserExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__UserExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__UserExtension *p;
	size_t k = sizeof(tt__UserExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__UserExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__UserExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__UserExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__UserExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__UserExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__UserExtension(soap, tag ? tag : "tt:UserExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__UserExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__UserExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__UserExtension * SOAP_FMAC4 soap_get_tt__UserExtension(struct soap *soap, tt__UserExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__User::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__User::Username);
	this->tt__User::Password = NULL;
	soap_default_tt__UserLevel(soap, &this->tt__User::UserLevel);
	this->tt__User::Extension = NULL;
}

void tt__User::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__User::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__User::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__User::Password);
	soap_serialize_PointerTott__UserExtension(soap, &this->tt__User::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__User::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__User(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__User(struct soap *soap, const char *tag, int id, const tt__User *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__User), type ? type : "tt:User"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__User::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__User::Password, ""))
		return soap->error;
	if (soap_out_tt__UserLevel(soap, "tt:UserLevel", -1, &a->tt__User::UserLevel, ""))
		return soap->error;
	if (soap_out_PointerTott__UserExtension(soap, "tt:Extension", -1, &a->tt__User::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__User::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__User(soap, tag, this, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_in_tt__User(struct soap *soap, const char *tag, tt__User *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__User*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__User, sizeof(tt__User), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__User)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__User *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UserLevel1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__User::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__User::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UserLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__UserLevel(soap, "tt:UserLevel", &a->tt__User::UserLevel, "tt:UserLevel"))
				{	soap_flag_UserLevel1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__UserExtension(soap, "tt:Extension", &a->tt__User::Extension, "tt:UserExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Username1 > 0 || soap_flag_UserLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__User *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__User, SOAP_TYPE_tt__User, sizeof(tt__User), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_dup_tt__User(struct soap *soap, tt__User *d, tt__User const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__User*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__User, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__User(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__User::Username, &a->tt__User::Username);
	soap_dup_PointerTostd__string(soap, &d->tt__User::Password, &a->tt__User::Password);
	d->tt__User::UserLevel = a->tt__User::UserLevel;
	soap_dup_PointerTott__UserExtension(soap, &d->tt__User::Extension, &a->tt__User::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__User(tt__User const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__User::Username);
	soap_del_PointerTostd__string(&a->tt__User::Password);
	/* UserLevel skipped */
	soap_del_PointerTott__UserExtension(&a->tt__User::Extension);
}

SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__User(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__User *p;
	size_t k = sizeof(tt__User);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__User, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__User);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__User, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__User location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__User::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__User(soap, tag ? tag : "tt:User", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__User::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__User(soap, this, tag, type);
}

SOAP_FMAC3 tt__User * SOAP_FMAC4 soap_get_tt__User(struct soap *soap, tt__User *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__RemoteUser::Username);
	this->tt__RemoteUser::Password = NULL;
	soap_default_bool(soap, &this->tt__RemoteUser::UseDerivedPassword);
}

void tt__RemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RemoteUser::Username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__RemoteUser::Username);
	soap_serialize_PointerTostd__string(soap, &this->tt__RemoteUser::Password);
	soap_embedded(soap, &this->tt__RemoteUser::UseDerivedPassword, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RemoteUser(struct soap *soap, const char *tag, int id, const tt__RemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RemoteUser), type ? type : "tt:RemoteUser"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Username", -1, &a->tt__RemoteUser::Username, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Password", -1, &a->tt__RemoteUser::Password, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:UseDerivedPassword", -1, &a->tt__RemoteUser::UseDerivedPassword, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_in_tt__RemoteUser(struct soap *soap, const char *tag, tt__RemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Username1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_UseDerivedPassword1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Username", &a->tt__RemoteUser::Username, "xsd:string"))
				{	soap_flag_Username1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Password", &a->tt__RemoteUser::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_UseDerivedPassword1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:UseDerivedPassword", &a->tt__RemoteUser::UseDerivedPassword, "xsd:boolean"))
				{	soap_flag_UseDerivedPassword1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Username1 > 0 || soap_flag_UseDerivedPassword1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RemoteUser, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_dup_tt__RemoteUser(struct soap *soap, tt__RemoteUser *d, tt__RemoteUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RemoteUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RemoteUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RemoteUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__RemoteUser::Username, &a->tt__RemoteUser::Username);
	soap_dup_PointerTostd__string(soap, &d->tt__RemoteUser::Password, &a->tt__RemoteUser::Password);
	d->tt__RemoteUser::UseDerivedPassword = a->tt__RemoteUser::UseDerivedPassword;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RemoteUser(tt__RemoteUser const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__RemoteUser::Username);
	soap_del_PointerTostd__string(&a->tt__RemoteUser::Password);
	/* UseDerivedPassword skipped */
}

SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RemoteUser *p;
	size_t k = sizeof(tt__RemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 tt__RemoteUser * SOAP_FMAC4 soap_get_tt__RemoteUser(struct soap *soap, tt__RemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__TimeZone::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->tt__TimeZone::TZ);
}

void tt__TimeZone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__TimeZone::TZ, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->tt__TimeZone::TZ);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__TimeZone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__TimeZone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TimeZone(struct soap *soap, const char *tag, int id, const tt__TimeZone *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__TimeZone), type ? type : "tt:TimeZone"))
		return soap->error;
	if (soap_out_xsd__token(soap, "tt:TZ", -1, &a->tt__TimeZone::TZ, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__TimeZone::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__TimeZone(soap, tag, this, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_in_tt__TimeZone(struct soap *soap, const char *tag, tt__TimeZone *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__TimeZone*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__TimeZone)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__TimeZone *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_TZ1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TZ1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tt:TZ", &a->tt__TimeZone::TZ, "xsd:token"))
				{	soap_flag_TZ1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_TZ1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__TimeZone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__TimeZone, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_dup_tt__TimeZone(struct soap *soap, tt__TimeZone *d, tt__TimeZone const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__TimeZone*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__TimeZone, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__TimeZone(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->tt__TimeZone::TZ, &a->tt__TimeZone::TZ);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__TimeZone(tt__TimeZone const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->tt__TimeZone::TZ);
}

SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__TimeZone(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__TimeZone *p;
	size_t k = sizeof(tt__TimeZone);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__TimeZone, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__TimeZone);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__TimeZone, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__TimeZone location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__TimeZone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__TimeZone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__TimeZone(soap, this, tag, type);
}

SOAP_FMAC3 tt__TimeZone * SOAP_FMAC4 soap_get_tt__TimeZone(struct soap *soap, tt__TimeZone *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Time::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__Time::Hour);
	soap_default_int(soap, &this->tt__Time::Minute);
	soap_default_int(soap, &this->tt__Time::Second);
}

void tt__Time::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Time::Hour, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Minute, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Time::Second, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Time::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Time(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Time(struct soap *soap, const char *tag, int id, const tt__Time *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Time), type ? type : "tt:Time"))
		return soap->error;
	if (soap_out_int(soap, "tt:Hour", -1, &a->tt__Time::Hour, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minute", -1, &a->tt__Time::Minute, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Second", -1, &a->tt__Time::Second, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Time::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Time(soap, tag, this, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_in_tt__Time(struct soap *soap, const char *tag, tt__Time *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Time*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Time, sizeof(tt__Time), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Time)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Time *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Hour1 = 1;
	size_t soap_flag_Minute1 = 1;
	size_t soap_flag_Second1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Hour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Hour", &a->tt__Time::Hour, "xsd:int"))
				{	soap_flag_Hour1--;
					continue;
				}
			}
			if (soap_flag_Minute1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minute", &a->tt__Time::Minute, "xsd:int"))
				{	soap_flag_Minute1--;
					continue;
				}
			}
			if (soap_flag_Second1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Second", &a->tt__Time::Second, "xsd:int"))
				{	soap_flag_Second1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Hour1 > 0 || soap_flag_Minute1 > 0 || soap_flag_Second1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Time *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Time, SOAP_TYPE_tt__Time, sizeof(tt__Time), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_dup_tt__Time(struct soap *soap, tt__Time *d, tt__Time const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Time*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Time, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Time(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Time::Hour = a->tt__Time::Hour;
	d->tt__Time::Minute = a->tt__Time::Minute;
	d->tt__Time::Second = a->tt__Time::Second;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Time(tt__Time const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Hour skipped */
	/* Minute skipped */
	/* Second skipped */
}

SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Time(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Time *p;
	size_t k = sizeof(tt__Time);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Time, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Time);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Time, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Time location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Time::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Time(soap, tag ? tag : "tt:Time", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Time::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Time(soap, this, tag, type);
}

SOAP_FMAC3 tt__Time * SOAP_FMAC4 soap_get_tt__Time(struct soap *soap, tt__Time *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Date::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__Date::Year);
	soap_default_int(soap, &this->tt__Date::Month);
	soap_default_int(soap, &this->tt__Date::Day);
}

void tt__Date::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Date::Year, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Month, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Date::Day, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Date::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Date(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Date(struct soap *soap, const char *tag, int id, const tt__Date *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Date), type ? type : "tt:Date"))
		return soap->error;
	if (soap_out_int(soap, "tt:Year", -1, &a->tt__Date::Year, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Month", -1, &a->tt__Date::Month, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Day", -1, &a->tt__Date::Day, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Date::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Date(soap, tag, this, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_in_tt__Date(struct soap *soap, const char *tag, tt__Date *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Date*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Date, sizeof(tt__Date), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Date)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Date *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Year1 = 1;
	size_t soap_flag_Month1 = 1;
	size_t soap_flag_Day1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Year1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Year", &a->tt__Date::Year, "xsd:int"))
				{	soap_flag_Year1--;
					continue;
				}
			}
			if (soap_flag_Month1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Month", &a->tt__Date::Month, "xsd:int"))
				{	soap_flag_Month1--;
					continue;
				}
			}
			if (soap_flag_Day1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Day", &a->tt__Date::Day, "xsd:int"))
				{	soap_flag_Day1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Year1 > 0 || soap_flag_Month1 > 0 || soap_flag_Day1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Date *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Date, SOAP_TYPE_tt__Date, sizeof(tt__Date), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_dup_tt__Date(struct soap *soap, tt__Date *d, tt__Date const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Date*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Date, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Date(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Date::Year = a->tt__Date::Year;
	d->tt__Date::Month = a->tt__Date::Month;
	d->tt__Date::Day = a->tt__Date::Day;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Date(tt__Date const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Year skipped */
	/* Month skipped */
	/* Day skipped */
}

SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Date(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Date *p;
	size_t k = sizeof(tt__Date);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Date, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Date);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Date, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Date location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Date::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Date(soap, tag ? tag : "tt:Date", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Date::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Date(soap, this, tag, type);
}

SOAP_FMAC3 tt__Date * SOAP_FMAC4 soap_get_tt__Date(struct soap *soap, tt__Date *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__DateTime::Time = NULL;
	this->tt__DateTime::Date = NULL;
}

void tt__DateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Time(soap, &this->tt__DateTime::Time);
	soap_serialize_PointerTott__Date(soap, &this->tt__DateTime::Date);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DateTime(struct soap *soap, const char *tag, int id, const tt__DateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DateTime), type ? type : "tt:DateTime"))
		return soap->error;
	if (!a->tt__DateTime::Time)
	{	if (soap_element_empty(soap, "tt:Time", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Time(soap, "tt:Time", -1, &a->tt__DateTime::Time, ""))
		return soap->error;
	if (!a->tt__DateTime::Date)
	{	if (soap_element_empty(soap, "tt:Date", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Date(soap, "tt:Date", -1, &a->tt__DateTime::Date, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_in_tt__DateTime(struct soap *soap, const char *tag, tt__DateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Time1 = 1;
	size_t soap_flag_Date1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Time1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Time(soap, "tt:Time", &a->tt__DateTime::Time, "tt:Time"))
				{	soap_flag_Time1--;
					continue;
				}
			}
			if (soap_flag_Date1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Date(soap, "tt:Date", &a->tt__DateTime::Date, "tt:Date"))
				{	soap_flag_Date1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__DateTime::Time || !a->tt__DateTime::Date))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DateTime, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_dup_tt__DateTime(struct soap *soap, tt__DateTime *d, tt__DateTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DateTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DateTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DateTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Time(soap, &d->tt__DateTime::Time, &a->tt__DateTime::Time);
	soap_dup_PointerTott__Date(soap, &d->tt__DateTime::Date, &a->tt__DateTime::Date);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DateTime(tt__DateTime const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Time(&a->tt__DateTime::Time);
	soap_del_PointerTott__Date(&a->tt__DateTime::Date);
}

SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DateTime *p;
	size_t k = sizeof(tt__DateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DateTime(soap, tag ? tag : "tt:DateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__DateTime * SOAP_FMAC4 soap_get_tt__DateTime(struct soap *soap, tt__DateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTimeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__SystemDateTimeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemDateTimeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, const tt__SystemDateTimeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:SystemDateTimeExtension");
}

void *tt__SystemDateTimeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTimeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_in_tt__SystemDateTimeExtension(struct soap *soap, const char *tag, tt__SystemDateTimeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SystemDateTimeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(tt__SystemDateTimeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTimeExtension)
		return (tt__SystemDateTimeExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_dup_tt__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *d, tt__SystemDateTimeExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemDateTimeExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemDateTimeExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemDateTimeExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemDateTimeExtension(tt__SystemDateTimeExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTimeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTimeExtension *p;
	size_t k = sizeof(tt__SystemDateTimeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTimeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTimeExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTimeExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTimeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTimeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTimeExtension(soap, tag ? tag : "tt:SystemDateTimeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTimeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTimeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTimeExtension * SOAP_FMAC4 soap_get_tt__SystemDateTimeExtension(struct soap *soap, tt__SystemDateTimeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__SetDateTimeType(soap, &this->tt__SystemDateTime::DateTimeType);
	soap_default_bool(soap, &this->tt__SystemDateTime::DaylightSavings);
	this->tt__SystemDateTime::TimeZone = NULL;
	this->tt__SystemDateTime::UTCDateTime = NULL;
	this->tt__SystemDateTime::LocalDateTime = NULL;
	this->tt__SystemDateTime::Extension = NULL;
}

void tt__SystemDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemDateTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->tt__SystemDateTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::UTCDateTime);
	soap_serialize_PointerTott__DateTime(soap, &this->tt__SystemDateTime::LocalDateTime);
	soap_serialize_PointerTott__SystemDateTimeExtension(soap, &this->tt__SystemDateTime::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemDateTime(struct soap *soap, const char *tag, int id, const tt__SystemDateTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemDateTime), type ? type : "tt:SystemDateTime"))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tt:DateTimeType", -1, &a->tt__SystemDateTime::DateTimeType, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DaylightSavings", -1, &a->tt__SystemDateTime::DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tt:TimeZone", -1, &a->tt__SystemDateTime::TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:UTCDateTime", -1, &a->tt__SystemDateTime::UTCDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tt:LocalDateTime", -1, &a->tt__SystemDateTime::LocalDateTime, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", -1, &a->tt__SystemDateTime::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemDateTime(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_in_tt__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemDateTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemDateTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemDateTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	size_t soap_flag_LocalDateTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tt:DateTimeType", &a->tt__SystemDateTime::DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DaylightSavings", &a->tt__SystemDateTime::DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tt:TimeZone", &a->tt__SystemDateTime::TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:UTCDateTime", &a->tt__SystemDateTime::UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			}
			if (soap_flag_LocalDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tt:LocalDateTime", &a->tt__SystemDateTime::LocalDateTime, "tt:DateTime"))
				{	soap_flag_LocalDateTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTimeExtension(soap, "tt:Extension", &a->tt__SystemDateTime::Extension, "tt:SystemDateTimeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemDateTime, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_dup_tt__SystemDateTime(struct soap *soap, tt__SystemDateTime *d, tt__SystemDateTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemDateTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemDateTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemDateTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SystemDateTime::DateTimeType = a->tt__SystemDateTime::DateTimeType;
	d->tt__SystemDateTime::DaylightSavings = a->tt__SystemDateTime::DaylightSavings;
	soap_dup_PointerTott__TimeZone(soap, &d->tt__SystemDateTime::TimeZone, &a->tt__SystemDateTime::TimeZone);
	soap_dup_PointerTott__DateTime(soap, &d->tt__SystemDateTime::UTCDateTime, &a->tt__SystemDateTime::UTCDateTime);
	soap_dup_PointerTott__DateTime(soap, &d->tt__SystemDateTime::LocalDateTime, &a->tt__SystemDateTime::LocalDateTime);
	soap_dup_PointerTott__SystemDateTimeExtension(soap, &d->tt__SystemDateTime::Extension, &a->tt__SystemDateTime::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemDateTime(tt__SystemDateTime const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* DateTimeType skipped */
	/* DaylightSavings skipped */
	soap_del_PointerTott__TimeZone(&a->tt__SystemDateTime::TimeZone);
	soap_del_PointerTott__DateTime(&a->tt__SystemDateTime::UTCDateTime);
	soap_del_PointerTott__DateTime(&a->tt__SystemDateTime::LocalDateTime);
	soap_del_PointerTott__SystemDateTimeExtension(&a->tt__SystemDateTime::Extension);
}

SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemDateTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemDateTime *p;
	size_t k = sizeof(tt__SystemDateTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemDateTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemDateTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemDateTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemDateTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemDateTime(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemDateTime * SOAP_FMAC4 soap_get_tt__SystemDateTime(struct soap *soap, tt__SystemDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUri::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__SystemLogType(soap, &this->tt__SystemLogUri::Type);
	soap_default_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
}

void tt__SystemLogUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemLogUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SystemLogUri::Uri);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemLogUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUri(struct soap *soap, const char *tag, int id, const tt__SystemLogUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUri), type ? type : "tt:SystemLogUri"))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tt:Type", -1, &a->tt__SystemLogUri::Type, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &a->tt__SystemLogUri::Uri, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUri::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_in_tt__SystemLogUri(struct soap *soap, const char *tag, tt__SystemLogUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUri)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUri *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Uri1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tt:Type", &a->tt__SystemLogUri::Type, "tt:SystemLogType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", &a->tt__SystemLogUri::Uri, "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0 || soap_flag_Uri1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemLogUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUri, SOAP_TYPE_tt__SystemLogUri, sizeof(tt__SystemLogUri), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_dup_tt__SystemLogUri(struct soap *soap, tt__SystemLogUri *d, tt__SystemLogUri const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemLogUri*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemLogUri, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemLogUri(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SystemLogUri::Type = a->tt__SystemLogUri::Type;
	soap_dup_xsd__anyURI(soap, &d->tt__SystemLogUri::Uri, &a->tt__SystemLogUri::Uri);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemLogUri(tt__SystemLogUri const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_xsd__anyURI(&a->tt__SystemLogUri::Uri);
}

SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUri *p;
	size_t k = sizeof(tt__SystemLogUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUri);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUri, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUri(soap, tag ? tag : "tt:SystemLogUri", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUri * SOAP_FMAC4 soap_get_tt__SystemLogUri(struct soap *soap, tt__SystemLogUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLogUriList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
}

void tt__SystemLogUriList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &this->tt__SystemLogUriList::SystemLog);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemLogUriList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLogUriList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLogUriList(struct soap *soap, const char *tag, int id, const tt__SystemLogUriList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLogUriList), type ? type : "tt:SystemLogUriList"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", -1, &a->tt__SystemLogUriList::SystemLog, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLogUriList::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLogUriList(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_in_tt__SystemLogUriList(struct soap *soap, const char *tag, tt__SystemLogUriList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLogUriList*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLogUriList)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLogUriList *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__SystemLogUri(soap, "tt:SystemLog", &a->tt__SystemLogUriList::SystemLog, "tt:SystemLogUri"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLogUriList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLogUriList, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_dup_tt__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *d, tt__SystemLogUriList const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemLogUriList*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemLogUriList, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemLogUriList(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__SystemLogUri(soap, &d->tt__SystemLogUriList::SystemLog, &a->tt__SystemLogUriList::SystemLog);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemLogUriList(tt__SystemLogUriList const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__SystemLogUri(&a->tt__SystemLogUriList::SystemLog);
}

SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLogUriList(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLogUriList *p;
	size_t k = sizeof(tt__SystemLogUriList);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLogUriList, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLogUriList);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLogUriList, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLogUriList location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLogUriList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLogUriList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLogUriList(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLogUriList * SOAP_FMAC4 soap_get_tt__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BackupFile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tt__BackupFile::Name);
	this->tt__BackupFile::Data = NULL;
}

void tt__BackupFile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__BackupFile::Name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tt__BackupFile::Name);
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__BackupFile::Data);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BackupFile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BackupFile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BackupFile(struct soap *soap, const char *tag, int id, const tt__BackupFile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BackupFile), type ? type : "tt:BackupFile"))
		return soap->error;
	if (soap_out_std__string(soap, "tt:Name", -1, &a->tt__BackupFile::Name, ""))
		return soap->error;
	if (!a->tt__BackupFile::Data)
	{	if (soap_element_empty(soap, "tt:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tt:Data", -1, &a->tt__BackupFile::Data, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BackupFile::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BackupFile(soap, tag, this, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_in_tt__BackupFile(struct soap *soap, const char *tag, tt__BackupFile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BackupFile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BackupFile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BackupFile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tt:Name", &a->tt__BackupFile::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Data", &a->tt__BackupFile::Data, "tt:AttachmentData"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name1 > 0 || !a->tt__BackupFile::Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BackupFile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BackupFile, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_dup_tt__BackupFile(struct soap *soap, tt__BackupFile *d, tt__BackupFile const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__BackupFile*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__BackupFile, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__BackupFile(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tt__BackupFile::Name, &a->tt__BackupFile::Name);
	soap_dup_PointerTott__AttachmentData(soap, &d->tt__BackupFile::Data, &a->tt__BackupFile::Data);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__BackupFile(tt__BackupFile const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tt__BackupFile::Name);
	soap_del_PointerTott__AttachmentData(&a->tt__BackupFile::Data);
}

SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BackupFile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BackupFile *p;
	size_t k = sizeof(tt__BackupFile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BackupFile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BackupFile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BackupFile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BackupFile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BackupFile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BackupFile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BackupFile(soap, this, tag, type);
}

SOAP_FMAC3 tt__BackupFile * SOAP_FMAC4 soap_get_tt__BackupFile(struct soap *soap, tt__BackupFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AttachmentData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
	soap_default_string(soap, &this->tt__AttachmentData::xmime__contentType);
}

void tt__AttachmentData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__xop__Include(soap, &this->tt__AttachmentData::xop__Include);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AttachmentData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AttachmentData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AttachmentData(struct soap *soap, const char *tag, int id, const tt__AttachmentData *a, const char *type)
{
	if (((tt__AttachmentData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, ((tt__AttachmentData*)a)->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AttachmentData), type ? type : "tt:AttachmentData"))
		return soap->error;
	if (soap_out__xop__Include(soap, "xop:Include", -1, &a->tt__AttachmentData::xop__Include, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AttachmentData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AttachmentData(soap, tag, this, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_in_tt__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AttachmentData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AttachmentData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AttachmentData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &((tt__AttachmentData*)a)->xmime__contentType))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_xop__Include1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_xop__Include1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__xop__Include(soap, "xop:Include", &a->tt__AttachmentData::xop__Include, ""))
				{	soap_flag_xop__Include1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_xop__Include1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AttachmentData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AttachmentData, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_dup_tt__AttachmentData(struct soap *soap, tt__AttachmentData *d, tt__AttachmentData const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AttachmentData*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AttachmentData, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AttachmentData(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup__xop__Include(soap, &d->tt__AttachmentData::xop__Include, &a->tt__AttachmentData::xop__Include);
	soap_dup_string(soap, &d->tt__AttachmentData::xmime__contentType, &a->tt__AttachmentData::xmime__contentType);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AttachmentData(tt__AttachmentData const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del__xop__Include(&a->tt__AttachmentData::xop__Include);
	soap_del_string(&a->tt__AttachmentData::xmime__contentType);
}

SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AttachmentData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AttachmentData *p;
	size_t k = sizeof(tt__AttachmentData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AttachmentData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AttachmentData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AttachmentData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AttachmentData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AttachmentData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AttachmentData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AttachmentData(soap, this, tag, type);
}

SOAP_FMAC3 tt__AttachmentData * SOAP_FMAC4 soap_get_tt__AttachmentData(struct soap *soap, tt__AttachmentData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__BinaryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__BinaryData::Data.xsd__base64Binary::soap_default(soap);
	soap_default_string(soap, &this->tt__BinaryData::xmime__contentType);
}

void tt__BinaryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->tt__BinaryData::Data.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__BinaryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__BinaryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__BinaryData(struct soap *soap, const char *tag, int id, const tt__BinaryData *a, const char *type)
{
	if (((tt__BinaryData*)a)->xmime__contentType)
		soap_set_attr(soap, "xmime:contentType", soap_string2s(soap, ((tt__BinaryData*)a)->xmime__contentType), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__BinaryData), type ? type : "tt:BinaryData"))
		return soap->error;
	if ((a->tt__BinaryData::Data).soap_out(soap, "tt:Data", -1, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__BinaryData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__BinaryData(soap, tag, this, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_in_tt__BinaryData(struct soap *soap, const char *tag, tt__BinaryData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__BinaryData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__BinaryData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__BinaryData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2string(soap, soap_attr_value(soap, "xmime:contentType", 1, 0), &((tt__BinaryData*)a)->xmime__contentType))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->tt__BinaryData::Data).soap_in(soap, "tt:Data", "xsd:base64Binary"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Data1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__BinaryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__BinaryData, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_dup_tt__BinaryData(struct soap *soap, tt__BinaryData *d, tt__BinaryData const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__BinaryData*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__BinaryData, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__BinaryData(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__base64Binary(soap, &d->tt__BinaryData::Data, &a->tt__BinaryData::Data);
	soap_dup_string(soap, &d->tt__BinaryData::xmime__contentType, &a->tt__BinaryData::xmime__contentType);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__BinaryData(tt__BinaryData const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__base64Binary(&a->tt__BinaryData::Data);
	soap_del_string(&a->tt__BinaryData::xmime__contentType);
}

SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__BinaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__BinaryData *p;
	size_t k = sizeof(tt__BinaryData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__BinaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__BinaryData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__BinaryData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__BinaryData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__BinaryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__BinaryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__BinaryData(soap, this, tag, type);
}

SOAP_FMAC3 tt__BinaryData * SOAP_FMAC4 soap_get_tt__BinaryData(struct soap *soap, tt__BinaryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SupportInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__SupportInformation::Binary = NULL;
	this->tt__SupportInformation::String = NULL;
}

void tt__SupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SupportInformation::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SupportInformation::String);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SupportInformation(struct soap *soap, const char *tag, int id, const tt__SupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SupportInformation), type ? type : "tt:SupportInformation"))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SupportInformation::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SupportInformation::String, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_in_tt__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SupportInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SupportInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SupportInformation::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SupportInformation::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SupportInformation, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_dup_tt__SupportInformation(struct soap *soap, tt__SupportInformation *d, tt__SupportInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SupportInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SupportInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SupportInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AttachmentData(soap, &d->tt__SupportInformation::Binary, &a->tt__SupportInformation::Binary);
	soap_dup_PointerTostd__string(soap, &d->tt__SupportInformation::String, &a->tt__SupportInformation::String);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SupportInformation(tt__SupportInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AttachmentData(&a->tt__SupportInformation::Binary);
	soap_del_PointerTostd__string(&a->tt__SupportInformation::String);
}

SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SupportInformation *p;
	size_t k = sizeof(tt__SupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SupportInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SupportInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SupportInformation * SOAP_FMAC4 soap_get_tt__SupportInformation(struct soap *soap, tt__SupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__SystemLog::Binary = NULL;
	this->tt__SystemLog::String = NULL;
}

void tt__SystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->tt__SystemLog::Binary);
	soap_serialize_PointerTostd__string(soap, &this->tt__SystemLog::String);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemLog(struct soap *soap, const char *tag, int id, const tt__SystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemLog), type ? type : "tt:SystemLog"))
		return soap->error;
	if (soap_out_PointerTott__AttachmentData(soap, "tt:Binary", -1, &a->tt__SystemLog::Binary, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:String", -1, &a->tt__SystemLog::String, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemLog(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_in_tt__SystemLog(struct soap *soap, const char *tag, tt__SystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Binary1 = 1;
	size_t soap_flag_String1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Binary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tt:Binary", &a->tt__SystemLog::Binary, "tt:AttachmentData"))
				{	soap_flag_Binary1--;
					continue;
				}
			}
			if (soap_flag_String1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:String", &a->tt__SystemLog::String, "xsd:string"))
				{	soap_flag_String1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemLog, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_dup_tt__SystemLog(struct soap *soap, tt__SystemLog *d, tt__SystemLog const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemLog*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemLog, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemLog(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AttachmentData(soap, &d->tt__SystemLog::Binary, &a->tt__SystemLog::Binary);
	soap_dup_PointerTostd__string(soap, &d->tt__SystemLog::String, &a->tt__SystemLog::String);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemLog(tt__SystemLog const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AttachmentData(&a->tt__SystemLog::Binary);
	soap_del_PointerTostd__string(&a->tt__SystemLog::String);
}

SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemLog *p;
	size_t k = sizeof(tt__SystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemLog);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemLog, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemLog(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemLog * SOAP_FMAC4 soap_get_tt__SystemLog(struct soap *soap, tt__SystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__AnalyticsDeviceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsDeviceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:AnalyticsDeviceExtension");
}

void *tt__AnalyticsDeviceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AnalyticsDeviceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(tt__AnalyticsDeviceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceExtension)
		return (tt__AnalyticsDeviceExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_dup_tt__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *d, tt__AnalyticsDeviceExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AnalyticsDeviceExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AnalyticsDeviceExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AnalyticsDeviceExtension(tt__AnalyticsDeviceExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceExtension *p;
	size_t k = sizeof(tt__AnalyticsDeviceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceExtension(soap, tag ? tag : "tt:AnalyticsDeviceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceExtension * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceExtension(struct soap *soap, tt__AnalyticsDeviceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsDeviceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	this->tt__AnalyticsDeviceCapabilities::RuleSupport = NULL;
	this->tt__AnalyticsDeviceCapabilities::Extension = NULL;
}

void tt__AnalyticsDeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsDeviceCapabilities::XAddr);
	soap_serialize_PointerTobool(soap, &this->tt__AnalyticsDeviceCapabilities::RuleSupport);
	soap_serialize_PointerTott__AnalyticsDeviceExtension(soap, &this->tt__AnalyticsDeviceCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsDeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsDeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities), type ? type : "tt:AnalyticsDeviceCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsDeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsDeviceCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", -1, &a->tt__AnalyticsDeviceCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsDeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, tt__AnalyticsDeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsDeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsDeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsDeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsDeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RuleSupport", &a->tt__AnalyticsDeviceCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceExtension(soap, "tt:Extension", &a->tt__AnalyticsDeviceCapabilities::Extension, "tt:AnalyticsDeviceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsDeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(tt__AnalyticsDeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_dup_tt__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *d, tt__AnalyticsDeviceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AnalyticsDeviceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AnalyticsDeviceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__AnalyticsDeviceCapabilities::XAddr, &a->tt__AnalyticsDeviceCapabilities::XAddr);
	soap_dup_PointerTobool(soap, &d->tt__AnalyticsDeviceCapabilities::RuleSupport, &a->tt__AnalyticsDeviceCapabilities::RuleSupport);
	soap_dup_PointerTott__AnalyticsDeviceExtension(soap, &d->tt__AnalyticsDeviceCapabilities::Extension, &a->tt__AnalyticsDeviceCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AnalyticsDeviceCapabilities(tt__AnalyticsDeviceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__AnalyticsDeviceCapabilities::XAddr);
	soap_del_PointerTobool(&a->tt__AnalyticsDeviceCapabilities::RuleSupport);
	soap_del_PointerTott__AnalyticsDeviceExtension(&a->tt__AnalyticsDeviceCapabilities::Extension);
}

SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsDeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsDeviceCapabilities *p;
	size_t k = sizeof(tt__AnalyticsDeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsDeviceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsDeviceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsDeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsDeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsDeviceCapabilities(soap, tag ? tag : "tt:AnalyticsDeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsDeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsDeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsDeviceCapabilities(struct soap *soap, tt__AnalyticsDeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReceiverCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP);
	soap_default_bool(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::SupportedReceivers);
	soap_default_int(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength);
}

void tt__ReceiverCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReceiverCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReceiverCapabilities::XAddr);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCOREMulticast, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::SupportedReceivers, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__ReceiverCapabilities::MaximumRTSPURILength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ReceiverCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverCapabilities(struct soap *soap, const char *tag, int id, const tt__ReceiverCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReceiverCapabilities), type ? type : "tt:ReceiverCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReceiverCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_Multicast", -1, &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SupportedReceivers", -1, &a->tt__ReceiverCapabilities::SupportedReceivers, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumRTSPURILength", -1, &a->tt__ReceiverCapabilities::MaximumRTSPURILength, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReceiverCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReceiverCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_in_tt__ReceiverCapabilities(struct soap *soap, const char *tag, tt__ReceiverCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReceiverCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReceiverCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReceiverCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RTP_USCOREMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_SupportedReceivers1 = 1;
	size_t soap_flag_MaximumRTSPURILength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReceiverCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCOREMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_Multicast", &a->tt__ReceiverCapabilities::RTP_USCOREMulticast, "xsd:boolean"))
				{	soap_flag_RTP_USCOREMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RTP_RTSP_TCP", &a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_SupportedReceivers1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SupportedReceivers", &a->tt__ReceiverCapabilities::SupportedReceivers, "xsd:int"))
				{	soap_flag_SupportedReceivers1--;
					continue;
				}
			}
			if (soap_flag_MaximumRTSPURILength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumRTSPURILength", &a->tt__ReceiverCapabilities::MaximumRTSPURILength, "xsd:int"))
				{	soap_flag_MaximumRTSPURILength1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_RTP_USCOREMulticast1 > 0 || soap_flag_RTP_USCORETCP1 > 0 || soap_flag_RTP_USCORERTSP_USCORETCP1 > 0 || soap_flag_SupportedReceivers1 > 0 || soap_flag_MaximumRTSPURILength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReceiverCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReceiverCapabilities, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(tt__ReceiverCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_dup_tt__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *d, tt__ReceiverCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ReceiverCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ReceiverCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ReceiverCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__ReceiverCapabilities::XAddr, &a->tt__ReceiverCapabilities::XAddr);
	d->tt__ReceiverCapabilities::RTP_USCOREMulticast = a->tt__ReceiverCapabilities::RTP_USCOREMulticast;
	d->tt__ReceiverCapabilities::RTP_USCORETCP = a->tt__ReceiverCapabilities::RTP_USCORETCP;
	d->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP = a->tt__ReceiverCapabilities::RTP_USCORERTSP_USCORETCP;
	d->tt__ReceiverCapabilities::SupportedReceivers = a->tt__ReceiverCapabilities::SupportedReceivers;
	d->tt__ReceiverCapabilities::MaximumRTSPURILength = a->tt__ReceiverCapabilities::MaximumRTSPURILength;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ReceiverCapabilities(tt__ReceiverCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__ReceiverCapabilities::XAddr);
	/* RTP_USCOREMulticast skipped */
	/* RTP_USCORETCP skipped */
	/* RTP_USCORERTSP_USCORETCP skipped */
	/* SupportedReceivers skipped */
	/* MaximumRTSPURILength skipped */
}

SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReceiverCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReceiverCapabilities *p;
	size_t k = sizeof(tt__ReceiverCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReceiverCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReceiverCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReceiverCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReceiverCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReceiverCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReceiverCapabilities(soap, tag ? tag : "tt:ReceiverCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReceiverCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReceiverCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReceiverCapabilities * SOAP_FMAC4 soap_get_tt__ReceiverCapabilities(struct soap *soap, tt__ReceiverCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReplayCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
}

void tt__ReplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ReplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ReplayCapabilities::XAddr);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ReplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReplayCapabilities(struct soap *soap, const char *tag, int id, const tt__ReplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReplayCapabilities), type ? type : "tt:ReplayCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ReplayCapabilities::XAddr, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_in_tt__ReplayCapabilities(struct soap *soap, const char *tag, tt__ReplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ReplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ReplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReplayCapabilities, SOAP_TYPE_tt__ReplayCapabilities, sizeof(tt__ReplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_dup_tt__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *d, tt__ReplayCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ReplayCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ReplayCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ReplayCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__ReplayCapabilities::XAddr, &a->tt__ReplayCapabilities::XAddr);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ReplayCapabilities(tt__ReplayCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__ReplayCapabilities::XAddr);
}

SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReplayCapabilities *p;
	size_t k = sizeof(tt__ReplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReplayCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReplayCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReplayCapabilities(soap, tag ? tag : "tt:ReplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReplayCapabilities * SOAP_FMAC4 soap_get_tt__ReplayCapabilities(struct soap *soap, tt__ReplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SearchCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__SearchCapabilities::MetadataSearch);
}

void tt__SearchCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SearchCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__SearchCapabilities::XAddr);
	soap_embedded(soap, &this->tt__SearchCapabilities::MetadataSearch, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SearchCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SearchCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SearchCapabilities(struct soap *soap, const char *tag, int id, const tt__SearchCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SearchCapabilities), type ? type : "tt:SearchCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__SearchCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MetadataSearch", -1, &a->tt__SearchCapabilities::MetadataSearch, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SearchCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SearchCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_in_tt__SearchCapabilities(struct soap *soap, const char *tag, tt__SearchCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SearchCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SearchCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SearchCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_MetadataSearch1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__SearchCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_MetadataSearch1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MetadataSearch", &a->tt__SearchCapabilities::MetadataSearch, "xsd:boolean"))
				{	soap_flag_MetadataSearch1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_MetadataSearch1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SearchCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SearchCapabilities, SOAP_TYPE_tt__SearchCapabilities, sizeof(tt__SearchCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_dup_tt__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *d, tt__SearchCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SearchCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SearchCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SearchCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__SearchCapabilities::XAddr, &a->tt__SearchCapabilities::XAddr);
	d->tt__SearchCapabilities::MetadataSearch = a->tt__SearchCapabilities::MetadataSearch;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SearchCapabilities(tt__SearchCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__SearchCapabilities::XAddr);
	/* MetadataSearch skipped */
}

SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SearchCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SearchCapabilities *p;
	size_t k = sizeof(tt__SearchCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SearchCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SearchCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SearchCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SearchCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SearchCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SearchCapabilities(soap, tag ? tag : "tt:SearchCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SearchCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SearchCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SearchCapabilities * SOAP_FMAC4 soap_get_tt__SearchCapabilities(struct soap *soap, tt__SearchCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RecordingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::ReceiverSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::MediaProfileSource);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicRecordings);
	soap_default_bool(soap, &this->tt__RecordingCapabilities::DynamicTracks);
	soap_default_int(soap, &this->tt__RecordingCapabilities::MaxStringLength);
}

void tt__RecordingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__RecordingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__RecordingCapabilities::XAddr);
	soap_embedded(soap, &this->tt__RecordingCapabilities::ReceiverSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MediaProfileSource, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicRecordings, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::DynamicTracks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__RecordingCapabilities::MaxStringLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RecordingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RecordingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingCapabilities(struct soap *soap, const char *tag, int id, const tt__RecordingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RecordingCapabilities), type ? type : "tt:RecordingCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__RecordingCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ReceiverSource", -1, &a->tt__RecordingCapabilities::ReceiverSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MediaProfileSource", -1, &a->tt__RecordingCapabilities::MediaProfileSource, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicRecordings", -1, &a->tt__RecordingCapabilities::DynamicRecordings, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DynamicTracks", -1, &a->tt__RecordingCapabilities::DynamicTracks, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaxStringLength", -1, &a->tt__RecordingCapabilities::MaxStringLength, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RecordingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RecordingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_in_tt__RecordingCapabilities(struct soap *soap, const char *tag, tt__RecordingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RecordingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RecordingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RecordingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_ReceiverSource1 = 1;
	size_t soap_flag_MediaProfileSource1 = 1;
	size_t soap_flag_DynamicRecordings1 = 1;
	size_t soap_flag_DynamicTracks1 = 1;
	size_t soap_flag_MaxStringLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__RecordingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_ReceiverSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ReceiverSource", &a->tt__RecordingCapabilities::ReceiverSource, "xsd:boolean"))
				{	soap_flag_ReceiverSource1--;
					continue;
				}
			}
			if (soap_flag_MediaProfileSource1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MediaProfileSource", &a->tt__RecordingCapabilities::MediaProfileSource, "xsd:boolean"))
				{	soap_flag_MediaProfileSource1--;
					continue;
				}
			}
			if (soap_flag_DynamicRecordings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicRecordings", &a->tt__RecordingCapabilities::DynamicRecordings, "xsd:boolean"))
				{	soap_flag_DynamicRecordings1--;
					continue;
				}
			}
			if (soap_flag_DynamicTracks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DynamicTracks", &a->tt__RecordingCapabilities::DynamicTracks, "xsd:boolean"))
				{	soap_flag_DynamicTracks1--;
					continue;
				}
			}
			if (soap_flag_MaxStringLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaxStringLength", &a->tt__RecordingCapabilities::MaxStringLength, "xsd:int"))
				{	soap_flag_MaxStringLength1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_ReceiverSource1 > 0 || soap_flag_MediaProfileSource1 > 0 || soap_flag_DynamicRecordings1 > 0 || soap_flag_DynamicTracks1 > 0 || soap_flag_MaxStringLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RecordingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RecordingCapabilities, SOAP_TYPE_tt__RecordingCapabilities, sizeof(tt__RecordingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_dup_tt__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *d, tt__RecordingCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RecordingCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RecordingCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RecordingCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__RecordingCapabilities::XAddr, &a->tt__RecordingCapabilities::XAddr);
	d->tt__RecordingCapabilities::ReceiverSource = a->tt__RecordingCapabilities::ReceiverSource;
	d->tt__RecordingCapabilities::MediaProfileSource = a->tt__RecordingCapabilities::MediaProfileSource;
	d->tt__RecordingCapabilities::DynamicRecordings = a->tt__RecordingCapabilities::DynamicRecordings;
	d->tt__RecordingCapabilities::DynamicTracks = a->tt__RecordingCapabilities::DynamicTracks;
	d->tt__RecordingCapabilities::MaxStringLength = a->tt__RecordingCapabilities::MaxStringLength;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RecordingCapabilities(tt__RecordingCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__RecordingCapabilities::XAddr);
	/* ReceiverSource skipped */
	/* MediaProfileSource skipped */
	/* DynamicRecordings skipped */
	/* DynamicTracks skipped */
	/* MaxStringLength skipped */
}

SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RecordingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RecordingCapabilities *p;
	size_t k = sizeof(tt__RecordingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RecordingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RecordingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RecordingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RecordingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RecordingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RecordingCapabilities(soap, tag ? tag : "tt:RecordingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RecordingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RecordingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RecordingCapabilities * SOAP_FMAC4 soap_get_tt__RecordingCapabilities(struct soap *soap, tt__RecordingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DisplayCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__DisplayCapabilities::FixedLayout);
}

void tt__DisplayCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DisplayCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DisplayCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DisplayCapabilities::FixedLayout, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DisplayCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DisplayCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DisplayCapabilities(struct soap *soap, const char *tag, int id, const tt__DisplayCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DisplayCapabilities), type ? type : "tt:DisplayCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DisplayCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FixedLayout", -1, &a->tt__DisplayCapabilities::FixedLayout, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DisplayCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DisplayCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_in_tt__DisplayCapabilities(struct soap *soap, const char *tag, tt__DisplayCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DisplayCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DisplayCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DisplayCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_FixedLayout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DisplayCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_FixedLayout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FixedLayout", &a->tt__DisplayCapabilities::FixedLayout, "xsd:boolean"))
				{	soap_flag_FixedLayout1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_FixedLayout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DisplayCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DisplayCapabilities, SOAP_TYPE_tt__DisplayCapabilities, sizeof(tt__DisplayCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_dup_tt__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *d, tt__DisplayCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DisplayCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DisplayCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DisplayCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__DisplayCapabilities::XAddr, &a->tt__DisplayCapabilities::XAddr);
	d->tt__DisplayCapabilities::FixedLayout = a->tt__DisplayCapabilities::FixedLayout;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DisplayCapabilities(tt__DisplayCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__DisplayCapabilities::XAddr);
	/* FixedLayout skipped */
}

SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DisplayCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DisplayCapabilities *p;
	size_t k = sizeof(tt__DisplayCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DisplayCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DisplayCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DisplayCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DisplayCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DisplayCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DisplayCapabilities(soap, tag ? tag : "tt:DisplayCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DisplayCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DisplayCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DisplayCapabilities * SOAP_FMAC4 soap_get_tt__DisplayCapabilities(struct soap *soap, tt__DisplayCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceIOCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::VideoOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioSources);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::AudioOutputs);
	soap_default_int(soap, &this->tt__DeviceIOCapabilities::RelayOutputs);
}

void tt__DeviceIOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceIOCapabilities::XAddr);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::VideoOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioSources, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::AudioOutputs, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__DeviceIOCapabilities::RelayOutputs, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceIOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceIOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceIOCapabilities), type ? type : "tt:DeviceIOCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceIOCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoSources", -1, &a->tt__DeviceIOCapabilities::VideoSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:VideoOutputs", -1, &a->tt__DeviceIOCapabilities::VideoOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioSources", -1, &a->tt__DeviceIOCapabilities::AudioSources, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:AudioOutputs", -1, &a->tt__DeviceIOCapabilities::AudioOutputs, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:RelayOutputs", -1, &a->tt__DeviceIOCapabilities::RelayOutputs, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceIOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceIOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_in_tt__DeviceIOCapabilities(struct soap *soap, const char *tag, tt__DeviceIOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceIOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceIOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceIOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_VideoSources1 = 1;
	size_t soap_flag_VideoOutputs1 = 1;
	size_t soap_flag_AudioSources1 = 1;
	size_t soap_flag_AudioOutputs1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceIOCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_VideoSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoSources", &a->tt__DeviceIOCapabilities::VideoSources, "xsd:int"))
				{	soap_flag_VideoSources1--;
					continue;
				}
			}
			if (soap_flag_VideoOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:VideoOutputs", &a->tt__DeviceIOCapabilities::VideoOutputs, "xsd:int"))
				{	soap_flag_VideoOutputs1--;
					continue;
				}
			}
			if (soap_flag_AudioSources1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioSources", &a->tt__DeviceIOCapabilities::AudioSources, "xsd:int"))
				{	soap_flag_AudioSources1--;
					continue;
				}
			}
			if (soap_flag_AudioOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:AudioOutputs", &a->tt__DeviceIOCapabilities::AudioOutputs, "xsd:int"))
				{	soap_flag_AudioOutputs1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:RelayOutputs", &a->tt__DeviceIOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_VideoSources1 > 0 || soap_flag_VideoOutputs1 > 0 || soap_flag_AudioSources1 > 0 || soap_flag_AudioOutputs1 > 0 || soap_flag_RelayOutputs1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceIOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceIOCapabilities, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(tt__DeviceIOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_dup_tt__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *d, tt__DeviceIOCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceIOCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceIOCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceIOCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__DeviceIOCapabilities::XAddr, &a->tt__DeviceIOCapabilities::XAddr);
	d->tt__DeviceIOCapabilities::VideoSources = a->tt__DeviceIOCapabilities::VideoSources;
	d->tt__DeviceIOCapabilities::VideoOutputs = a->tt__DeviceIOCapabilities::VideoOutputs;
	d->tt__DeviceIOCapabilities::AudioSources = a->tt__DeviceIOCapabilities::AudioSources;
	d->tt__DeviceIOCapabilities::AudioOutputs = a->tt__DeviceIOCapabilities::AudioOutputs;
	d->tt__DeviceIOCapabilities::RelayOutputs = a->tt__DeviceIOCapabilities::RelayOutputs;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceIOCapabilities(tt__DeviceIOCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__DeviceIOCapabilities::XAddr);
	/* VideoSources skipped */
	/* VideoOutputs skipped */
	/* AudioSources skipped */
	/* AudioOutputs skipped */
	/* RelayOutputs skipped */
}

SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceIOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceIOCapabilities *p;
	size_t k = sizeof(tt__DeviceIOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceIOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceIOCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceIOCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceIOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceIOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceIOCapabilities(soap, tag ? tag : "tt:DeviceIOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceIOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceIOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceIOCapabilities * SOAP_FMAC4 soap_get_tt__DeviceIOCapabilities(struct soap *soap, tt__DeviceIOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
}

void tt__PTZCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__PTZCapabilities::XAddr);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZCapabilities(struct soap *soap, const char *tag, int id, const tt__PTZCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZCapabilities), type ? type : "tt:PTZCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__PTZCapabilities::XAddr, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_in_tt__PTZCapabilities(struct soap *soap, const char *tag, tt__PTZCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__PTZCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZCapabilities, SOAP_TYPE_tt__PTZCapabilities, sizeof(tt__PTZCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_dup_tt__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *d, tt__PTZCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__PTZCapabilities::XAddr, &a->tt__PTZCapabilities::XAddr);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZCapabilities(tt__PTZCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__PTZCapabilities::XAddr);
}

SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZCapabilities *p;
	size_t k = sizeof(tt__PTZCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZCapabilities(soap, tag ? tag : "tt:PTZCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZCapabilities * SOAP_FMAC4 soap_get_tt__PTZCapabilities(struct soap *soap, tt__PTZCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ImagingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
}

void tt__ImagingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ImagingCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__ImagingCapabilities::XAddr);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ImagingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ImagingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ImagingCapabilities(struct soap *soap, const char *tag, int id, const tt__ImagingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ImagingCapabilities), type ? type : "tt:ImagingCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__ImagingCapabilities::XAddr, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ImagingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ImagingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_in_tt__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ImagingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ImagingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ImagingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__ImagingCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ImagingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ImagingCapabilities, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_dup_tt__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *d, tt__ImagingCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ImagingCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ImagingCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ImagingCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__ImagingCapabilities::XAddr, &a->tt__ImagingCapabilities::XAddr);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ImagingCapabilities(tt__ImagingCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__ImagingCapabilities::XAddr);
}

SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ImagingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ImagingCapabilities *p;
	size_t k = sizeof(tt__ImagingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ImagingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ImagingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ImagingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ImagingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ImagingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ImagingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ImagingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ImagingCapabilities * SOAP_FMAC4 soap_get_tt__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__OnvifVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__OnvifVersion::Major);
	soap_default_int(soap, &this->tt__OnvifVersion::Minor);
}

void tt__OnvifVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__OnvifVersion::Major, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__OnvifVersion::Minor, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__OnvifVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__OnvifVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__OnvifVersion(struct soap *soap, const char *tag, int id, const tt__OnvifVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__OnvifVersion), type ? type : "tt:OnvifVersion"))
		return soap->error;
	if (soap_out_int(soap, "tt:Major", -1, &a->tt__OnvifVersion::Major, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Minor", -1, &a->tt__OnvifVersion::Minor, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__OnvifVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__OnvifVersion(soap, tag, this, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_in_tt__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__OnvifVersion*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__OnvifVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__OnvifVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Major1 = 1;
	size_t soap_flag_Minor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Major1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Major", &a->tt__OnvifVersion::Major, "xsd:int"))
				{	soap_flag_Major1--;
					continue;
				}
			}
			if (soap_flag_Minor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Minor", &a->tt__OnvifVersion::Minor, "xsd:int"))
				{	soap_flag_Minor1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Major1 > 0 || soap_flag_Minor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__OnvifVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__OnvifVersion, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_dup_tt__OnvifVersion(struct soap *soap, tt__OnvifVersion *d, tt__OnvifVersion const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__OnvifVersion*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__OnvifVersion, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__OnvifVersion(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__OnvifVersion::Major = a->tt__OnvifVersion::Major;
	d->tt__OnvifVersion::Minor = a->tt__OnvifVersion::Minor;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__OnvifVersion(tt__OnvifVersion const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Major skipped */
	/* Minor skipped */
}

SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__OnvifVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__OnvifVersion *p;
	size_t k = sizeof(tt__OnvifVersion);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__OnvifVersion, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__OnvifVersion);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__OnvifVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__OnvifVersion location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__OnvifVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__OnvifVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__OnvifVersion(soap, this, tag, type);
}

SOAP_FMAC3 tt__OnvifVersion * SOAP_FMAC4 soap_get_tt__OnvifVersion(struct soap *soap, tt__OnvifVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__SystemCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:SystemCapabilitiesExtension2");
}

void *tt__SystemCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__SystemCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(tt__SystemCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension2)
		return (tt__SystemCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_dup_tt__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *d, tt__SystemCapabilitiesExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemCapabilitiesExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemCapabilitiesExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemCapabilitiesExtension2(tt__SystemCapabilitiesExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension2(soap, tag ? tag : "tt:SystemCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension2(struct soap *soap, tt__SystemCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemBackup = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSystemLogging = NULL;
	this->tt__SystemCapabilitiesExtension::HttpSupportInformation = NULL;
	this->tt__SystemCapabilitiesExtension::Extension = NULL;
}

void tt__SystemCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemBackup);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSystemLogging);
	soap_serialize_PointerTobool(soap, &this->tt__SystemCapabilitiesExtension::HttpSupportInformation);
	soap_serialize_PointerTott__SystemCapabilitiesExtension2(soap, &this->tt__SystemCapabilitiesExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension), type ? type : "tt:SystemCapabilitiesExtension"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpFirmwareUpgrade", -1, &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemBackup", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSystemLogging", -1, &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:HttpSupportInformation", -1, &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SystemCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SystemCapabilitiesExtension(struct soap *soap, const char *tag, tt__SystemCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_HttpFirmwareUpgrade1 = 1;
	size_t soap_flag_HttpSystemBackup1 = 1;
	size_t soap_flag_HttpSystemLogging1 = 1;
	size_t soap_flag_HttpSupportInformation1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HttpFirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpFirmwareUpgrade", &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_HttpFirmwareUpgrade1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemBackup", &a->tt__SystemCapabilitiesExtension::HttpSystemBackup, "xsd:boolean"))
				{	soap_flag_HttpSystemBackup1--;
					continue;
				}
			}
			if (soap_flag_HttpSystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSystemLogging", &a->tt__SystemCapabilitiesExtension::HttpSystemLogging, "xsd:boolean"))
				{	soap_flag_HttpSystemLogging1--;
					continue;
				}
			}
			if (soap_flag_HttpSupportInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:HttpSupportInformation", &a->tt__SystemCapabilitiesExtension::HttpSupportInformation, "xsd:boolean"))
				{	soap_flag_HttpSupportInformation1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SystemCapabilitiesExtension::Extension, "tt:SystemCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__SystemCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilitiesExtension, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(tt__SystemCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *d, tt__SystemCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade, &a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade);
	soap_dup_PointerTobool(soap, &d->tt__SystemCapabilitiesExtension::HttpSystemBackup, &a->tt__SystemCapabilitiesExtension::HttpSystemBackup);
	soap_dup_PointerTobool(soap, &d->tt__SystemCapabilitiesExtension::HttpSystemLogging, &a->tt__SystemCapabilitiesExtension::HttpSystemLogging);
	soap_dup_PointerTobool(soap, &d->tt__SystemCapabilitiesExtension::HttpSupportInformation, &a->tt__SystemCapabilitiesExtension::HttpSupportInformation);
	soap_dup_PointerTott__SystemCapabilitiesExtension2(soap, &d->tt__SystemCapabilitiesExtension::Extension, &a->tt__SystemCapabilitiesExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemCapabilitiesExtension(tt__SystemCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__SystemCapabilitiesExtension::HttpFirmwareUpgrade);
	soap_del_PointerTobool(&a->tt__SystemCapabilitiesExtension::HttpSystemBackup);
	soap_del_PointerTobool(&a->tt__SystemCapabilitiesExtension::HttpSystemLogging);
	soap_del_PointerTobool(&a->tt__SystemCapabilitiesExtension::HttpSupportInformation);
	soap_del_PointerTott__SystemCapabilitiesExtension2(&a->tt__SystemCapabilitiesExtension::Extension);
}

SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilitiesExtension *p;
	size_t k = sizeof(tt__SystemCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilitiesExtension(soap, tag ? tag : "tt:SystemCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SystemCapabilitiesExtension(struct soap *soap, tt__SystemCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SystemCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryResolve);
	soap_default_bool(soap, &this->tt__SystemCapabilities::DiscoveryBye);
	soap_default_bool(soap, &this->tt__SystemCapabilities::RemoteDiscovery);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemBackup);
	soap_default_bool(soap, &this->tt__SystemCapabilities::SystemLogging);
	soap_default_bool(soap, &this->tt__SystemCapabilities::FirmwareUpgrade);
	soap_default_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	this->tt__SystemCapabilities::Extension = NULL;
}

void tt__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryResolve, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::DiscoveryBye, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::RemoteDiscovery, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemBackup, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::SystemLogging, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SystemCapabilities::FirmwareUpgrade, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &this->tt__SystemCapabilities::SupportedVersions);
	soap_serialize_PointerTott__SystemCapabilitiesExtension(soap, &this->tt__SystemCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SystemCapabilities(struct soap *soap, const char *tag, int id, const tt__SystemCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SystemCapabilities), type ? type : "tt:SystemCapabilities"))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryResolve", -1, &a->tt__SystemCapabilities::DiscoveryResolve, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DiscoveryBye", -1, &a->tt__SystemCapabilities::DiscoveryBye, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteDiscovery", -1, &a->tt__SystemCapabilities::RemoteDiscovery, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemBackup", -1, &a->tt__SystemCapabilities::SystemBackup, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SystemLogging", -1, &a->tt__SystemCapabilities::SystemLogging, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:FirmwareUpgrade", -1, &a->tt__SystemCapabilities::FirmwareUpgrade, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", -1, &a->tt__SystemCapabilities::SupportedVersions, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SystemCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_in_tt__SystemCapabilities(struct soap *soap, const char *tag, tt__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SystemCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SystemCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DiscoveryResolve1 = 1;
	size_t soap_flag_DiscoveryBye1 = 1;
	size_t soap_flag_RemoteDiscovery1 = 1;
	size_t soap_flag_SystemBackup1 = 1;
	size_t soap_flag_SystemLogging1 = 1;
	size_t soap_flag_FirmwareUpgrade1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryResolve1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryResolve", &a->tt__SystemCapabilities::DiscoveryResolve, "xsd:boolean"))
				{	soap_flag_DiscoveryResolve1--;
					continue;
				}
			}
			if (soap_flag_DiscoveryBye1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DiscoveryBye", &a->tt__SystemCapabilities::DiscoveryBye, "xsd:boolean"))
				{	soap_flag_DiscoveryBye1--;
					continue;
				}
			}
			if (soap_flag_RemoteDiscovery1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteDiscovery", &a->tt__SystemCapabilities::RemoteDiscovery, "xsd:boolean"))
				{	soap_flag_RemoteDiscovery1--;
					continue;
				}
			}
			if (soap_flag_SystemBackup1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemBackup", &a->tt__SystemCapabilities::SystemBackup, "xsd:boolean"))
				{	soap_flag_SystemBackup1--;
					continue;
				}
			}
			if (soap_flag_SystemLogging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SystemLogging", &a->tt__SystemCapabilities::SystemLogging, "xsd:boolean"))
				{	soap_flag_SystemLogging1--;
					continue;
				}
			}
			if (soap_flag_FirmwareUpgrade1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FirmwareUpgrade", &a->tt__SystemCapabilities::FirmwareUpgrade, "xsd:boolean"))
				{	soap_flag_FirmwareUpgrade1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__OnvifVersion(soap, "tt:SupportedVersions", &a->tt__SystemCapabilities::SupportedVersions, "tt:OnvifVersion"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilitiesExtension(soap, "tt:Extension", &a->tt__SystemCapabilities::Extension, "tt:SystemCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DiscoveryResolve1 > 0 || soap_flag_DiscoveryBye1 > 0 || soap_flag_RemoteDiscovery1 > 0 || soap_flag_SystemBackup1 > 0 || soap_flag_SystemLogging1 > 0 || soap_flag_FirmwareUpgrade1 > 0 || a->tt__SystemCapabilities::SupportedVersions.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SystemCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SystemCapabilities, SOAP_TYPE_tt__SystemCapabilities, sizeof(tt__SystemCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_dup_tt__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *d, tt__SystemCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SystemCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SystemCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SystemCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SystemCapabilities::DiscoveryResolve = a->tt__SystemCapabilities::DiscoveryResolve;
	d->tt__SystemCapabilities::DiscoveryBye = a->tt__SystemCapabilities::DiscoveryBye;
	d->tt__SystemCapabilities::RemoteDiscovery = a->tt__SystemCapabilities::RemoteDiscovery;
	d->tt__SystemCapabilities::SystemBackup = a->tt__SystemCapabilities::SystemBackup;
	d->tt__SystemCapabilities::SystemLogging = a->tt__SystemCapabilities::SystemLogging;
	d->tt__SystemCapabilities::FirmwareUpgrade = a->tt__SystemCapabilities::FirmwareUpgrade;
	soap_dup_std__vectorTemplateOfPointerTott__OnvifVersion(soap, &d->tt__SystemCapabilities::SupportedVersions, &a->tt__SystemCapabilities::SupportedVersions);
	soap_dup_PointerTott__SystemCapabilitiesExtension(soap, &d->tt__SystemCapabilities::Extension, &a->tt__SystemCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SystemCapabilities(tt__SystemCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* DiscoveryResolve skipped */
	/* DiscoveryBye skipped */
	/* RemoteDiscovery skipped */
	/* SystemBackup skipped */
	/* SystemLogging skipped */
	/* FirmwareUpgrade skipped */
	soap_del_std__vectorTemplateOfPointerTott__OnvifVersion(&a->tt__SystemCapabilities::SupportedVersions);
	soap_del_PointerTott__SystemCapabilitiesExtension(&a->tt__SystemCapabilities::Extension);
}

SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SystemCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SystemCapabilities *p;
	size_t k = sizeof(tt__SystemCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SystemCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SystemCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SystemCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SystemCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SystemCapabilities(soap, tag ? tag : "tt:SystemCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SystemCapabilities * SOAP_FMAC4 soap_get_tt__SystemCapabilities(struct soap *soap, tt__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling);
}

void tt__SecurityCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::Dot1X, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SecurityCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2), type ? type : "tt:SecurityCapabilitiesExtension2"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Dot1X", -1, &a->tt__SecurityCapabilitiesExtension2::Dot1X, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", -1, &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RemoteUserHandling", -1, &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_RemoteUserHandling1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1X1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Dot1X", &a->tt__SecurityCapabilitiesExtension2::Dot1X, "xsd:boolean"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:SupportedEAPMethod", &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, "xsd:int"))
					continue;
			}
			if (soap_flag_RemoteUserHandling1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RemoteUserHandling", &a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling, "xsd:boolean"))
				{	soap_flag_RemoteUserHandling1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Dot1X1 > 0 || soap_flag_RemoteUserHandling1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(tt__SecurityCapabilitiesExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_dup_tt__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *d, tt__SecurityCapabilitiesExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SecurityCapabilitiesExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SecurityCapabilitiesExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SecurityCapabilitiesExtension2::Dot1X = a->tt__SecurityCapabilitiesExtension2::Dot1X;
	soap_dup_std__vectorTemplateOfint(soap, &d->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod, &a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	d->tt__SecurityCapabilitiesExtension2::RemoteUserHandling = a->tt__SecurityCapabilitiesExtension2::RemoteUserHandling;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SecurityCapabilitiesExtension2(tt__SecurityCapabilitiesExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Dot1X skipped */
	soap_del_std__vectorTemplateOfint(&a->tt__SecurityCapabilitiesExtension2::SupportedEAPMethod);
	/* RemoteUserHandling skipped */
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension2(soap, tag ? tag : "tt:SecurityCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension2(struct soap *soap, tt__SecurityCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0);
	this->tt__SecurityCapabilitiesExtension::Extension = NULL;
}

void tt__SecurityCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilitiesExtension::TLS1_x002e0, SOAP_TYPE_bool);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension2(soap, &this->tt__SecurityCapabilitiesExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SecurityCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension), type ? type : "tt:SecurityCapabilitiesExtension"))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.0", -1, &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__SecurityCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, tt__SecurityCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_TLS1_x002e01 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e01 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.0", &a->tt__SecurityCapabilitiesExtension::TLS1_x002e0, "xsd:boolean"))
				{	soap_flag_TLS1_x002e01--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, "tt:Extension", &a->tt__SecurityCapabilitiesExtension::Extension, "tt:SecurityCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_TLS1_x002e01 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilitiesExtension, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(tt__SecurityCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *d, tt__SecurityCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SecurityCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SecurityCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SecurityCapabilitiesExtension::TLS1_x002e0 = a->tt__SecurityCapabilitiesExtension::TLS1_x002e0;
	soap_dup_PointerTott__SecurityCapabilitiesExtension2(soap, &d->tt__SecurityCapabilitiesExtension::Extension, &a->tt__SecurityCapabilitiesExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SecurityCapabilitiesExtension(tt__SecurityCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* TLS1_x002e0 skipped */
	soap_del_PointerTott__SecurityCapabilitiesExtension2(&a->tt__SecurityCapabilitiesExtension::Extension);
}

SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilitiesExtension *p;
	size_t k = sizeof(tt__SecurityCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilitiesExtension(soap, tag ? tag : "tt:SecurityCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__SecurityCapabilitiesExtension(struct soap *soap, tt__SecurityCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SecurityCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e1);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::TLS1_x002e2);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::X_x002e509Token);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::SAMLToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::KerberosToken);
	soap_default_bool(soap, &this->tt__SecurityCapabilities::RELToken);
	this->tt__SecurityCapabilities::Extension = NULL;
}

void tt__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e1, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::TLS1_x002e2, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::OnboardKeyGeneration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::AccessPolicyConfig, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::X_x002e509Token, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::SAMLToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::KerberosToken, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__SecurityCapabilities::RELToken, SOAP_TYPE_bool);
	soap_serialize_PointerTott__SecurityCapabilitiesExtension(soap, &this->tt__SecurityCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tt__SecurityCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SecurityCapabilities), type ? type : "tt:SecurityCapabilities"))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.1", -1, &a->tt__SecurityCapabilities::TLS1_x002e1, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:TLS1.2", -1, &a->tt__SecurityCapabilities::TLS1_x002e2, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:OnboardKeyGeneration", -1, &a->tt__SecurityCapabilities::OnboardKeyGeneration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AccessPolicyConfig", -1, &a->tt__SecurityCapabilities::AccessPolicyConfig, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:X.509Token", -1, &a->tt__SecurityCapabilities::X_x002e509Token, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:SAMLToken", -1, &a->tt__SecurityCapabilities::SAMLToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:KerberosToken", -1, &a->tt__SecurityCapabilities::KerberosToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RELToken", -1, &a->tt__SecurityCapabilities::RELToken, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__SecurityCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_in_tt__SecurityCapabilities(struct soap *soap, const char *tag, tt__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SecurityCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SecurityCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_TLS1_x002e11 = 1;
	size_t soap_flag_TLS1_x002e21 = 1;
	size_t soap_flag_OnboardKeyGeneration1 = 1;
	size_t soap_flag_AccessPolicyConfig1 = 1;
	size_t soap_flag_X_x002e509Token1 = 1;
	size_t soap_flag_SAMLToken1 = 1;
	size_t soap_flag_KerberosToken1 = 1;
	size_t soap_flag_RELToken1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TLS1_x002e11 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.1", &a->tt__SecurityCapabilities::TLS1_x002e1, "xsd:boolean"))
				{	soap_flag_TLS1_x002e11--;
					continue;
				}
			}
			if (soap_flag_TLS1_x002e21 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TLS1.2", &a->tt__SecurityCapabilities::TLS1_x002e2, "xsd:boolean"))
				{	soap_flag_TLS1_x002e21--;
					continue;
				}
			}
			if (soap_flag_OnboardKeyGeneration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:OnboardKeyGeneration", &a->tt__SecurityCapabilities::OnboardKeyGeneration, "xsd:boolean"))
				{	soap_flag_OnboardKeyGeneration1--;
					continue;
				}
			}
			if (soap_flag_AccessPolicyConfig1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AccessPolicyConfig", &a->tt__SecurityCapabilities::AccessPolicyConfig, "xsd:boolean"))
				{	soap_flag_AccessPolicyConfig1--;
					continue;
				}
			}
			if (soap_flag_X_x002e509Token1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:X.509Token", &a->tt__SecurityCapabilities::X_x002e509Token, "xsd:boolean"))
				{	soap_flag_X_x002e509Token1--;
					continue;
				}
			}
			if (soap_flag_SAMLToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:SAMLToken", &a->tt__SecurityCapabilities::SAMLToken, "xsd:boolean"))
				{	soap_flag_SAMLToken1--;
					continue;
				}
			}
			if (soap_flag_KerberosToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:KerberosToken", &a->tt__SecurityCapabilities::KerberosToken, "xsd:boolean"))
				{	soap_flag_KerberosToken1--;
					continue;
				}
			}
			if (soap_flag_RELToken1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RELToken", &a->tt__SecurityCapabilities::RELToken, "xsd:boolean"))
				{	soap_flag_RELToken1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilitiesExtension(soap, "tt:Extension", &a->tt__SecurityCapabilities::Extension, "tt:SecurityCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_TLS1_x002e11 > 0 || soap_flag_TLS1_x002e21 > 0 || soap_flag_OnboardKeyGeneration1 > 0 || soap_flag_AccessPolicyConfig1 > 0 || soap_flag_X_x002e509Token1 > 0 || soap_flag_SAMLToken1 > 0 || soap_flag_KerberosToken1 > 0 || soap_flag_RELToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SecurityCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SecurityCapabilities, SOAP_TYPE_tt__SecurityCapabilities, sizeof(tt__SecurityCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_dup_tt__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *d, tt__SecurityCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SecurityCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SecurityCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SecurityCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SecurityCapabilities::TLS1_x002e1 = a->tt__SecurityCapabilities::TLS1_x002e1;
	d->tt__SecurityCapabilities::TLS1_x002e2 = a->tt__SecurityCapabilities::TLS1_x002e2;
	d->tt__SecurityCapabilities::OnboardKeyGeneration = a->tt__SecurityCapabilities::OnboardKeyGeneration;
	d->tt__SecurityCapabilities::AccessPolicyConfig = a->tt__SecurityCapabilities::AccessPolicyConfig;
	d->tt__SecurityCapabilities::X_x002e509Token = a->tt__SecurityCapabilities::X_x002e509Token;
	d->tt__SecurityCapabilities::SAMLToken = a->tt__SecurityCapabilities::SAMLToken;
	d->tt__SecurityCapabilities::KerberosToken = a->tt__SecurityCapabilities::KerberosToken;
	d->tt__SecurityCapabilities::RELToken = a->tt__SecurityCapabilities::RELToken;
	soap_dup_PointerTott__SecurityCapabilitiesExtension(soap, &d->tt__SecurityCapabilities::Extension, &a->tt__SecurityCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SecurityCapabilities(tt__SecurityCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* TLS1_x002e1 skipped */
	/* TLS1_x002e2 skipped */
	/* OnboardKeyGeneration skipped */
	/* AccessPolicyConfig skipped */
	/* X_x002e509Token skipped */
	/* SAMLToken skipped */
	/* KerberosToken skipped */
	/* RELToken skipped */
	soap_del_PointerTott__SecurityCapabilitiesExtension(&a->tt__SecurityCapabilities::Extension);
}

SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SecurityCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SecurityCapabilities *p;
	size_t k = sizeof(tt__SecurityCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SecurityCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SecurityCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SecurityCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SecurityCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SecurityCapabilities(soap, tag ? tag : "tt:SecurityCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__SecurityCapabilities * SOAP_FMAC4 soap_get_tt__SecurityCapabilities(struct soap *soap, tt__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkCapabilitiesExtension2");
}

void *tt__NetworkCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(tt__NetworkCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension2)
		return (tt__NetworkCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_dup_tt__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *d, tt__NetworkCapabilitiesExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkCapabilitiesExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkCapabilitiesExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkCapabilitiesExtension2(tt__NetworkCapabilitiesExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension2(soap, tag ? tag : "tt:NetworkCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension2(struct soap *soap, tt__NetworkCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__NetworkCapabilitiesExtension::Dot11Configuration = NULL;
	this->tt__NetworkCapabilitiesExtension::Extension = NULL;
}

void tt__NetworkCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilitiesExtension::Dot11Configuration);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension2(soap, &this->tt__NetworkCapabilitiesExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension), type ? type : "tt:NetworkCapabilitiesExtension"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Dot11Configuration", -1, &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__NetworkCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, tt__NetworkCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Dot11Configuration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot11Configuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Dot11Configuration", &a->tt__NetworkCapabilitiesExtension::Dot11Configuration, "xsd:boolean"))
				{	soap_flag_Dot11Configuration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, "tt:Extension", &a->tt__NetworkCapabilitiesExtension::Extension, "tt:NetworkCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilitiesExtension, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(tt__NetworkCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *d, tt__NetworkCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__NetworkCapabilitiesExtension::Dot11Configuration, &a->tt__NetworkCapabilitiesExtension::Dot11Configuration);
	soap_dup_PointerTott__NetworkCapabilitiesExtension2(soap, &d->tt__NetworkCapabilitiesExtension::Extension, &a->tt__NetworkCapabilitiesExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkCapabilitiesExtension(tt__NetworkCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__NetworkCapabilitiesExtension::Dot11Configuration);
	soap_del_PointerTott__NetworkCapabilitiesExtension2(&a->tt__NetworkCapabilitiesExtension::Extension);
}

SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilitiesExtension *p;
	size_t k = sizeof(tt__NetworkCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilitiesExtension(soap, tag ? tag : "tt:NetworkCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__NetworkCapabilitiesExtension(struct soap *soap, tt__NetworkCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__NetworkCapabilities::IPFilter = NULL;
	this->tt__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tt__NetworkCapabilities::IPVersion6 = NULL;
	this->tt__NetworkCapabilities::DynDNS = NULL;
	this->tt__NetworkCapabilities::Extension = NULL;
}

void tt__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPFilter);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::ZeroConfiguration);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::IPVersion6);
	soap_serialize_PointerTobool(soap, &this->tt__NetworkCapabilities::DynDNS);
	soap_serialize_PointerTott__NetworkCapabilitiesExtension(soap, &this->tt__NetworkCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tt__NetworkCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkCapabilities), type ? type : "tt:NetworkCapabilities"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPFilter", -1, &a->tt__NetworkCapabilities::IPFilter, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZeroConfiguration", -1, &a->tt__NetworkCapabilities::ZeroConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:IPVersion6", -1, &a->tt__NetworkCapabilities::IPVersion6, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DynDNS", -1, &a->tt__NetworkCapabilities::DynDNS, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__NetworkCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_in_tt__NetworkCapabilities(struct soap *soap, const char *tag, tt__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_IPFilter1 = 1;
	size_t soap_flag_ZeroConfiguration1 = 1;
	size_t soap_flag_IPVersion61 = 1;
	size_t soap_flag_DynDNS1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPFilter", &a->tt__NetworkCapabilities::IPFilter, "xsd:boolean"))
				{	soap_flag_IPFilter1--;
					continue;
				}
			}
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:ZeroConfiguration", &a->tt__NetworkCapabilities::ZeroConfiguration, "xsd:boolean"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			if (soap_flag_IPVersion61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:IPVersion6", &a->tt__NetworkCapabilities::IPVersion6, "xsd:boolean"))
				{	soap_flag_IPVersion61--;
					continue;
				}
			}
			if (soap_flag_DynDNS1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DynDNS", &a->tt__NetworkCapabilities::DynDNS, "xsd:boolean"))
				{	soap_flag_DynDNS1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilitiesExtension(soap, "tt:Extension", &a->tt__NetworkCapabilities::Extension, "tt:NetworkCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkCapabilities, SOAP_TYPE_tt__NetworkCapabilities, sizeof(tt__NetworkCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_dup_tt__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *d, tt__NetworkCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__NetworkCapabilities::IPFilter, &a->tt__NetworkCapabilities::IPFilter);
	soap_dup_PointerTobool(soap, &d->tt__NetworkCapabilities::ZeroConfiguration, &a->tt__NetworkCapabilities::ZeroConfiguration);
	soap_dup_PointerTobool(soap, &d->tt__NetworkCapabilities::IPVersion6, &a->tt__NetworkCapabilities::IPVersion6);
	soap_dup_PointerTobool(soap, &d->tt__NetworkCapabilities::DynDNS, &a->tt__NetworkCapabilities::DynDNS);
	soap_dup_PointerTott__NetworkCapabilitiesExtension(soap, &d->tt__NetworkCapabilities::Extension, &a->tt__NetworkCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkCapabilities(tt__NetworkCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__NetworkCapabilities::IPFilter);
	soap_del_PointerTobool(&a->tt__NetworkCapabilities::ZeroConfiguration);
	soap_del_PointerTobool(&a->tt__NetworkCapabilities::IPVersion6);
	soap_del_PointerTobool(&a->tt__NetworkCapabilities::DynDNS);
	soap_del_PointerTott__NetworkCapabilitiesExtension(&a->tt__NetworkCapabilities::Extension);
}

SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkCapabilities *p;
	size_t k = sizeof(tt__NetworkCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkCapabilities(soap, tag ? tag : "tt:NetworkCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkCapabilities * SOAP_FMAC4 soap_get_tt__NetworkCapabilities(struct soap *soap, tt__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles);
}

void tt__ProfileCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ProfileCapabilities::MaximumNumberOfProfiles, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ProfileCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileCapabilities(struct soap *soap, const char *tag, int id, const tt__ProfileCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileCapabilities), type ? type : "tt:ProfileCapabilities"))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfProfiles", -1, &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_in_tt__ProfileCapabilities(struct soap *soap, const char *tag, tt__ProfileCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_MaximumNumberOfProfiles1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfProfiles1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfProfiles", &a->tt__ProfileCapabilities::MaximumNumberOfProfiles, "xsd:int"))
				{	soap_flag_MaximumNumberOfProfiles1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_MaximumNumberOfProfiles1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ProfileCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileCapabilities, SOAP_TYPE_tt__ProfileCapabilities, sizeof(tt__ProfileCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_dup_tt__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *d, tt__ProfileCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ProfileCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ProfileCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ProfileCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__ProfileCapabilities::MaximumNumberOfProfiles = a->tt__ProfileCapabilities::MaximumNumberOfProfiles;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ProfileCapabilities(tt__ProfileCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* MaximumNumberOfProfiles skipped */
}

SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileCapabilities *p;
	size_t k = sizeof(tt__ProfileCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileCapabilities(soap, tag ? tag : "tt:ProfileCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileCapabilities * SOAP_FMAC4 soap_get_tt__ProfileCapabilities(struct soap *soap, tt__ProfileCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__RealTimeStreamingCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:RealTimeStreamingCapabilitiesExtension");
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RealTimeStreamingCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(tt__RealTimeStreamingCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension)
		return (tt__RealTimeStreamingCapabilitiesExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *d, tt__RealTimeStreamingCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RealTimeStreamingCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RealTimeStreamingCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RealTimeStreamingCapabilitiesExtension(tt__RealTimeStreamingCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilitiesExtension *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag ? tag : "tt:RealTimeStreamingCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilitiesExtension(struct soap *soap, tt__RealTimeStreamingCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RealTimeStreamingCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RealTimeStreamingCapabilities::RTPMulticast = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP = NULL;
	this->tt__RealTimeStreamingCapabilities::Extension = NULL;
}

void tt__RealTimeStreamingCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_serialize_PointerTobool(soap, &this->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &this->tt__RealTimeStreamingCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RealTimeStreamingCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, const tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities), type ? type : "tt:RealTimeStreamingCapabilities"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTPMulticast", -1, &a->tt__RealTimeStreamingCapabilities::RTPMulticast, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:RTP_RTSP_TCP", -1, &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, ""))
		return soap->error;
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__RealTimeStreamingCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RealTimeStreamingCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RealTimeStreamingCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_in_tt__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, tt__RealTimeStreamingCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RealTimeStreamingCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RealTimeStreamingCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RealTimeStreamingCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_RTPMulticast1 = 1;
	size_t soap_flag_RTP_USCORETCP1 = 1;
	size_t soap_flag_RTP_USCORERTSP_USCORETCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RTPMulticast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTPMulticast", &a->tt__RealTimeStreamingCapabilities::RTPMulticast, "xsd:boolean"))
				{	soap_flag_RTPMulticast1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_RTP_USCORERTSP_USCORETCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:RTP_RTSP_TCP", &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, "xsd:boolean"))
				{	soap_flag_RTP_USCORERTSP_USCORETCP1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, "tt:Extension", &a->tt__RealTimeStreamingCapabilities::Extension, "tt:RealTimeStreamingCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RealTimeStreamingCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RealTimeStreamingCapabilities, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(tt__RealTimeStreamingCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_dup_tt__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *d, tt__RealTimeStreamingCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RealTimeStreamingCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RealTimeStreamingCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__RealTimeStreamingCapabilities::RTPMulticast, &a->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_dup_PointerTobool(soap, &d->tt__RealTimeStreamingCapabilities::RTP_USCORETCP, &a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_dup_PointerTobool(soap, &d->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP, &a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_dup_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, &d->tt__RealTimeStreamingCapabilities::Extension, &a->tt__RealTimeStreamingCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RealTimeStreamingCapabilities(tt__RealTimeStreamingCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__RealTimeStreamingCapabilities::RTPMulticast);
	soap_del_PointerTobool(&a->tt__RealTimeStreamingCapabilities::RTP_USCORETCP);
	soap_del_PointerTobool(&a->tt__RealTimeStreamingCapabilities::RTP_USCORERTSP_USCORETCP);
	soap_del_PointerTott__RealTimeStreamingCapabilitiesExtension(&a->tt__RealTimeStreamingCapabilities::Extension);
}

SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RealTimeStreamingCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RealTimeStreamingCapabilities *p;
	size_t k = sizeof(tt__RealTimeStreamingCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RealTimeStreamingCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RealTimeStreamingCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RealTimeStreamingCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RealTimeStreamingCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RealTimeStreamingCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RealTimeStreamingCapabilities(soap, tag ? tag : "tt:RealTimeStreamingCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RealTimeStreamingCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RealTimeStreamingCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__RealTimeStreamingCapabilities * SOAP_FMAC4 soap_get_tt__RealTimeStreamingCapabilities(struct soap *soap, tt__RealTimeStreamingCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MediaCapabilitiesExtension::ProfileCapabilities = NULL;
}

void tt__MediaCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ProfileCapabilities(soap, &this->tt__MediaCapabilitiesExtension::ProfileCapabilities);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MediaCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension), type ? type : "tt:MediaCapabilitiesExtension"))
		return soap->error;
	if (!a->tt__MediaCapabilitiesExtension::ProfileCapabilities)
	{	if (soap_element_empty(soap, "tt:ProfileCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", -1, &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__MediaCapabilitiesExtension(struct soap *soap, const char *tag, tt__MediaCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ProfileCapabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileCapabilities(soap, "tt:ProfileCapabilities", &a->tt__MediaCapabilitiesExtension::ProfileCapabilities, "tt:ProfileCapabilities"))
				{	soap_flag_ProfileCapabilities1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__MediaCapabilitiesExtension::ProfileCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilitiesExtension, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(tt__MediaCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *d, tt__MediaCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MediaCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MediaCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ProfileCapabilities(soap, &d->tt__MediaCapabilitiesExtension::ProfileCapabilities, &a->tt__MediaCapabilitiesExtension::ProfileCapabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MediaCapabilitiesExtension(tt__MediaCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ProfileCapabilities(&a->tt__MediaCapabilitiesExtension::ProfileCapabilities);
}

SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilitiesExtension *p;
	size_t k = sizeof(tt__MediaCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilitiesExtension(soap, tag ? tag : "tt:MediaCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__MediaCapabilitiesExtension(struct soap *soap, tt__MediaCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	this->tt__MediaCapabilities::StreamingCapabilities = NULL;
	this->tt__MediaCapabilities::Extension = NULL;
}

void tt__MediaCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MediaCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaCapabilities::XAddr);
	soap_serialize_PointerTott__RealTimeStreamingCapabilities(soap, &this->tt__MediaCapabilities::StreamingCapabilities);
	soap_serialize_PointerTott__MediaCapabilitiesExtension(soap, &this->tt__MediaCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MediaCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaCapabilities(struct soap *soap, const char *tag, int id, const tt__MediaCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaCapabilities), type ? type : "tt:MediaCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__MediaCapabilities::XAddr, ""))
		return soap->error;
	if (!a->tt__MediaCapabilities::StreamingCapabilities)
	{	if (soap_element_empty(soap, "tt:StreamingCapabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", -1, &a->tt__MediaCapabilities::StreamingCapabilities, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__MediaCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_in_tt__MediaCapabilities(struct soap *soap, const char *tag, tt__MediaCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_StreamingCapabilities1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__MediaCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_StreamingCapabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RealTimeStreamingCapabilities(soap, "tt:StreamingCapabilities", &a->tt__MediaCapabilities::StreamingCapabilities, "tt:RealTimeStreamingCapabilities"))
				{	soap_flag_StreamingCapabilities1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilitiesExtension(soap, "tt:Extension", &a->tt__MediaCapabilities::Extension, "tt:MediaCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || !a->tt__MediaCapabilities::StreamingCapabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaCapabilities, SOAP_TYPE_tt__MediaCapabilities, sizeof(tt__MediaCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_dup_tt__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *d, tt__MediaCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MediaCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MediaCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MediaCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__MediaCapabilities::XAddr, &a->tt__MediaCapabilities::XAddr);
	soap_dup_PointerTott__RealTimeStreamingCapabilities(soap, &d->tt__MediaCapabilities::StreamingCapabilities, &a->tt__MediaCapabilities::StreamingCapabilities);
	soap_dup_PointerTott__MediaCapabilitiesExtension(soap, &d->tt__MediaCapabilities::Extension, &a->tt__MediaCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MediaCapabilities(tt__MediaCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__MediaCapabilities::XAddr);
	soap_del_PointerTott__RealTimeStreamingCapabilities(&a->tt__MediaCapabilities::StreamingCapabilities);
	soap_del_PointerTott__MediaCapabilitiesExtension(&a->tt__MediaCapabilities::Extension);
}

SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaCapabilities *p;
	size_t k = sizeof(tt__MediaCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaCapabilities(soap, tag ? tag : "tt:MediaCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaCapabilities * SOAP_FMAC4 soap_get_tt__MediaCapabilities(struct soap *soap, tt__MediaCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__IOCapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IOCapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IOCapabilitiesExtension2");
}

void *tt__IOCapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension2(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IOCapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(tt__IOCapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension2)
		return (tt__IOCapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_dup_tt__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *d, tt__IOCapabilitiesExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IOCapabilitiesExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IOCapabilitiesExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IOCapabilitiesExtension2(tt__IOCapabilitiesExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension2 *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension2(soap, tag ? tag : "tt:IOCapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension2(struct soap *soap, tt__IOCapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IOCapabilitiesExtension::Auxiliary = NULL;
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	this->tt__IOCapabilitiesExtension::Extension = NULL;
}

void tt__IOCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IOCapabilitiesExtension::Auxiliary);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	soap_serialize_PointerTott__IOCapabilitiesExtension2(soap, &this->tt__IOCapabilitiesExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IOCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilitiesExtension), type ? type : "tt:IOCapabilitiesExtension"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Auxiliary", -1, &a->tt__IOCapabilitiesExtension::Auxiliary, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, ""))
		return soap->error;
	if (!a->tt__IOCapabilitiesExtension::Extension)
	{	if (soap_element_empty(soap, "tt:Extension", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", -1, &a->tt__IOCapabilitiesExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__IOCapabilitiesExtension(struct soap *soap, const char *tag, tt__IOCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Auxiliary1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Auxiliary1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Auxiliary", &a->tt__IOCapabilitiesExtension::Auxiliary, "xsd:boolean"))
				{	soap_flag_Auxiliary1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &a->tt__IOCapabilitiesExtension::AuxiliaryCommands, "tt:AuxiliaryData"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension2(soap, "tt:Extension", &a->tt__IOCapabilitiesExtension::Extension, "tt:IOCapabilitiesExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__IOCapabilitiesExtension::Extension))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IOCapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilitiesExtension, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(tt__IOCapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *d, tt__IOCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IOCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IOCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IOCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__IOCapabilitiesExtension::Auxiliary, &a->tt__IOCapabilitiesExtension::Auxiliary);
	soap_dup_std__vectorTemplateOftt__AuxiliaryData(soap, &d->tt__IOCapabilitiesExtension::AuxiliaryCommands, &a->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	soap_dup_PointerTott__IOCapabilitiesExtension2(soap, &d->tt__IOCapabilitiesExtension::Extension, &a->tt__IOCapabilitiesExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IOCapabilitiesExtension(tt__IOCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__IOCapabilitiesExtension::Auxiliary);
	soap_del_std__vectorTemplateOftt__AuxiliaryData(&a->tt__IOCapabilitiesExtension::AuxiliaryCommands);
	soap_del_PointerTott__IOCapabilitiesExtension2(&a->tt__IOCapabilitiesExtension::Extension);
}

SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilitiesExtension *p;
	size_t k = sizeof(tt__IOCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilitiesExtension(soap, tag ? tag : "tt:IOCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__IOCapabilitiesExtension(struct soap *soap, tt__IOCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IOCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IOCapabilities::InputConnectors = NULL;
	this->tt__IOCapabilities::RelayOutputs = NULL;
	this->tt__IOCapabilities::Extension = NULL;
}

void tt__IOCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::InputConnectors);
	soap_serialize_PointerToint(soap, &this->tt__IOCapabilities::RelayOutputs);
	soap_serialize_PointerTott__IOCapabilitiesExtension(soap, &this->tt__IOCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IOCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IOCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IOCapabilities(struct soap *soap, const char *tag, int id, const tt__IOCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IOCapabilities), type ? type : "tt:IOCapabilities"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:InputConnectors", -1, &a->tt__IOCapabilities::InputConnectors, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RelayOutputs", -1, &a->tt__IOCapabilities::RelayOutputs, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__IOCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IOCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IOCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_in_tt__IOCapabilities(struct soap *soap, const char *tag, tt__IOCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IOCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IOCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IOCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_InputConnectors1 = 1;
	size_t soap_flag_RelayOutputs1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InputConnectors1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:InputConnectors", &a->tt__IOCapabilities::InputConnectors, "xsd:int"))
				{	soap_flag_InputConnectors1--;
					continue;
				}
			}
			if (soap_flag_RelayOutputs1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RelayOutputs", &a->tt__IOCapabilities::RelayOutputs, "xsd:int"))
				{	soap_flag_RelayOutputs1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilitiesExtension(soap, "tt:Extension", &a->tt__IOCapabilities::Extension, "tt:IOCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IOCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IOCapabilities, SOAP_TYPE_tt__IOCapabilities, sizeof(tt__IOCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_dup_tt__IOCapabilities(struct soap *soap, tt__IOCapabilities *d, tt__IOCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IOCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IOCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IOCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerToint(soap, &d->tt__IOCapabilities::InputConnectors, &a->tt__IOCapabilities::InputConnectors);
	soap_dup_PointerToint(soap, &d->tt__IOCapabilities::RelayOutputs, &a->tt__IOCapabilities::RelayOutputs);
	soap_dup_PointerTott__IOCapabilitiesExtension(soap, &d->tt__IOCapabilities::Extension, &a->tt__IOCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IOCapabilities(tt__IOCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerToint(&a->tt__IOCapabilities::InputConnectors);
	soap_del_PointerToint(&a->tt__IOCapabilities::RelayOutputs);
	soap_del_PointerTott__IOCapabilitiesExtension(&a->tt__IOCapabilities::Extension);
}

SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IOCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IOCapabilities *p;
	size_t k = sizeof(tt__IOCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IOCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IOCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IOCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IOCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IOCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IOCapabilities(soap, tag ? tag : "tt:IOCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IOCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IOCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__IOCapabilities * SOAP_FMAC4 soap_get_tt__IOCapabilities(struct soap *soap, tt__IOCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPullPointSupport);
	soap_default_bool(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport);
}

void tt__EventCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__EventCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__EventCapabilities::XAddr);
	soap_embedded(soap, &this->tt__EventCapabilities::WSSubscriptionPolicySupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPullPointSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EventCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventCapabilities(struct soap *soap, const char *tag, int id, const tt__EventCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventCapabilities), type ? type : "tt:EventCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__EventCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSSubscriptionPolicySupport", -1, &a->tt__EventCapabilities::WSSubscriptionPolicySupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPullPointSupport", -1, &a->tt__EventCapabilities::WSPullPointSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", -1, &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_in_tt__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_WSSubscriptionPolicySupport1 = 1;
	size_t soap_flag_WSPullPointSupport1 = 1;
	size_t soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__EventCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_WSSubscriptionPolicySupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSSubscriptionPolicySupport", &a->tt__EventCapabilities::WSSubscriptionPolicySupport, "xsd:boolean"))
				{	soap_flag_WSSubscriptionPolicySupport1--;
					continue;
				}
			}
			if (soap_flag_WSPullPointSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPullPointSupport", &a->tt__EventCapabilities::WSPullPointSupport, "xsd:boolean"))
				{	soap_flag_WSPullPointSupport1--;
					continue;
				}
			}
			if (soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WSPausableSubscriptionManagerInterfaceSupport", &a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport, "xsd:boolean"))
				{	soap_flag_WSPausableSubscriptionManagerInterfaceSupport1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_WSSubscriptionPolicySupport1 > 0 || soap_flag_WSPullPointSupport1 > 0 || soap_flag_WSPausableSubscriptionManagerInterfaceSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EventCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventCapabilities, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_dup_tt__EventCapabilities(struct soap *soap, tt__EventCapabilities *d, tt__EventCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__EventCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__EventCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__EventCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__EventCapabilities::XAddr, &a->tt__EventCapabilities::XAddr);
	d->tt__EventCapabilities::WSSubscriptionPolicySupport = a->tt__EventCapabilities::WSSubscriptionPolicySupport;
	d->tt__EventCapabilities::WSPullPointSupport = a->tt__EventCapabilities::WSPullPointSupport;
	d->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport = a->tt__EventCapabilities::WSPausableSubscriptionManagerInterfaceSupport;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__EventCapabilities(tt__EventCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__EventCapabilities::XAddr);
	/* WSSubscriptionPolicySupport skipped */
	/* WSPullPointSupport skipped */
	/* WSPausableSubscriptionManagerInterfaceSupport skipped */
}

SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventCapabilities *p;
	size_t k = sizeof(tt__EventCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventCapabilities * SOAP_FMAC4 soap_get_tt__EventCapabilities(struct soap *soap, tt__EventCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__DeviceCapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceCapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:DeviceCapabilitiesExtension");
}

void *tt__DeviceCapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_in_tt__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, tt__DeviceCapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DeviceCapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(tt__DeviceCapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilitiesExtension)
		return (tt__DeviceCapabilitiesExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *d, tt__DeviceCapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceCapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceCapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceCapabilitiesExtension(tt__DeviceCapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilitiesExtension *p;
	size_t k = sizeof(tt__DeviceCapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilitiesExtension(soap, tag ? tag : "tt:DeviceCapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilitiesExtension * SOAP_FMAC4 soap_get_tt__DeviceCapabilitiesExtension(struct soap *soap, tt__DeviceCapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	this->tt__DeviceCapabilities::Network = NULL;
	this->tt__DeviceCapabilities::System = NULL;
	this->tt__DeviceCapabilities::IO = NULL;
	this->tt__DeviceCapabilities::Security = NULL;
	this->tt__DeviceCapabilities::Extension = NULL;
}

void tt__DeviceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DeviceCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__DeviceCapabilities::XAddr);
	soap_serialize_PointerTott__NetworkCapabilities(soap, &this->tt__DeviceCapabilities::Network);
	soap_serialize_PointerTott__SystemCapabilities(soap, &this->tt__DeviceCapabilities::System);
	soap_serialize_PointerTott__IOCapabilities(soap, &this->tt__DeviceCapabilities::IO);
	soap_serialize_PointerTott__SecurityCapabilities(soap, &this->tt__DeviceCapabilities::Security);
	soap_serialize_PointerTott__DeviceCapabilitiesExtension(soap, &this->tt__DeviceCapabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceCapabilities(struct soap *soap, const char *tag, int id, const tt__DeviceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceCapabilities), type ? type : "tt:DeviceCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__DeviceCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkCapabilities(soap, "tt:Network", -1, &a->tt__DeviceCapabilities::Network, ""))
		return soap->error;
	if (soap_out_PointerTott__SystemCapabilities(soap, "tt:System", -1, &a->tt__DeviceCapabilities::System, ""))
		return soap->error;
	if (soap_out_PointerTott__IOCapabilities(soap, "tt:IO", -1, &a->tt__DeviceCapabilities::IO, ""))
		return soap->error;
	if (soap_out_PointerTott__SecurityCapabilities(soap, "tt:Security", -1, &a->tt__DeviceCapabilities::Security, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__DeviceCapabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_in_tt__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_IO1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__DeviceCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkCapabilities(soap, "tt:Network", &a->tt__DeviceCapabilities::Network, "tt:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemCapabilities(soap, "tt:System", &a->tt__DeviceCapabilities::System, "tt:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			}
			if (soap_flag_IO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IOCapabilities(soap, "tt:IO", &a->tt__DeviceCapabilities::IO, "tt:IOCapabilities"))
				{	soap_flag_IO1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SecurityCapabilities(soap, "tt:Security", &a->tt__DeviceCapabilities::Security, "tt:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilitiesExtension(soap, "tt:Extension", &a->tt__DeviceCapabilities::Extension, "tt:DeviceCapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DeviceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceCapabilities, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_dup_tt__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *d, tt__DeviceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__DeviceCapabilities::XAddr, &a->tt__DeviceCapabilities::XAddr);
	soap_dup_PointerTott__NetworkCapabilities(soap, &d->tt__DeviceCapabilities::Network, &a->tt__DeviceCapabilities::Network);
	soap_dup_PointerTott__SystemCapabilities(soap, &d->tt__DeviceCapabilities::System, &a->tt__DeviceCapabilities::System);
	soap_dup_PointerTott__IOCapabilities(soap, &d->tt__DeviceCapabilities::IO, &a->tt__DeviceCapabilities::IO);
	soap_dup_PointerTott__SecurityCapabilities(soap, &d->tt__DeviceCapabilities::Security, &a->tt__DeviceCapabilities::Security);
	soap_dup_PointerTott__DeviceCapabilitiesExtension(soap, &d->tt__DeviceCapabilities::Extension, &a->tt__DeviceCapabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceCapabilities(tt__DeviceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__DeviceCapabilities::XAddr);
	soap_del_PointerTott__NetworkCapabilities(&a->tt__DeviceCapabilities::Network);
	soap_del_PointerTott__SystemCapabilities(&a->tt__DeviceCapabilities::System);
	soap_del_PointerTott__IOCapabilities(&a->tt__DeviceCapabilities::IO);
	soap_del_PointerTott__SecurityCapabilities(&a->tt__DeviceCapabilities::Security);
	soap_del_PointerTott__DeviceCapabilitiesExtension(&a->tt__DeviceCapabilities::Extension);
}

SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DeviceCapabilities *p;
	size_t k = sizeof(tt__DeviceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceCapabilities * SOAP_FMAC4 soap_get_tt__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AnalyticsCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::RuleSupport);
	soap_default_bool(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport);
}

void tt__AnalyticsCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__AnalyticsCapabilities::XAddr);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::RuleSupport, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__AnalyticsCapabilities::AnalyticsModuleSupport, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnalyticsCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, const tt__AnalyticsCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnalyticsCapabilities), type ? type : "tt:AnalyticsCapabilities"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:XAddr", -1, &a->tt__AnalyticsCapabilities::XAddr, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:RuleSupport", -1, &a->tt__AnalyticsCapabilities::RuleSupport, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AnalyticsModuleSupport", -1, &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AnalyticsCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AnalyticsCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_in_tt__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnalyticsCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AnalyticsCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AnalyticsCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_RuleSupport1 = 1;
	size_t soap_flag_AnalyticsModuleSupport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:XAddr", &a->tt__AnalyticsCapabilities::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_RuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:RuleSupport", &a->tt__AnalyticsCapabilities::RuleSupport, "xsd:boolean"))
				{	soap_flag_RuleSupport1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsModuleSupport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AnalyticsModuleSupport", &a->tt__AnalyticsCapabilities::AnalyticsModuleSupport, "xsd:boolean"))
				{	soap_flag_AnalyticsModuleSupport1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_XAddr1 > 0 || soap_flag_RuleSupport1 > 0 || soap_flag_AnalyticsModuleSupport1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AnalyticsCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnalyticsCapabilities, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_dup_tt__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *d, tt__AnalyticsCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AnalyticsCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AnalyticsCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AnalyticsCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__AnalyticsCapabilities::XAddr, &a->tt__AnalyticsCapabilities::XAddr);
	d->tt__AnalyticsCapabilities::RuleSupport = a->tt__AnalyticsCapabilities::RuleSupport;
	d->tt__AnalyticsCapabilities::AnalyticsModuleSupport = a->tt__AnalyticsCapabilities::AnalyticsModuleSupport;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AnalyticsCapabilities(tt__AnalyticsCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__AnalyticsCapabilities::XAddr);
	/* RuleSupport skipped */
	/* AnalyticsModuleSupport skipped */
}

SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnalyticsCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AnalyticsCapabilities *p;
	size_t k = sizeof(tt__AnalyticsCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AnalyticsCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AnalyticsCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AnalyticsCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AnalyticsCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AnalyticsCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnalyticsCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnalyticsCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnalyticsCapabilities * SOAP_FMAC4 soap_get_tt__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__CapabilitiesExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CapabilitiesExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:CapabilitiesExtension2");
}

void *tt__CapabilitiesExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension2(struct soap *soap, const char *tag, tt__CapabilitiesExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__CapabilitiesExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(tt__CapabilitiesExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension2)
		return (tt__CapabilitiesExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_dup_tt__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *d, tt__CapabilitiesExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CapabilitiesExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CapabilitiesExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CapabilitiesExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CapabilitiesExtension2(tt__CapabilitiesExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension2 *p;
	size_t k = sizeof(tt__CapabilitiesExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension2(soap, tag ? tag : "tt:CapabilitiesExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension2 * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension2(struct soap *soap, tt__CapabilitiesExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__CapabilitiesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__CapabilitiesExtension::DeviceIO = NULL;
	this->tt__CapabilitiesExtension::Display = NULL;
	this->tt__CapabilitiesExtension::Recording = NULL;
	this->tt__CapabilitiesExtension::Search = NULL;
	this->tt__CapabilitiesExtension::Replay = NULL;
	this->tt__CapabilitiesExtension::Receiver = NULL;
	this->tt__CapabilitiesExtension::AnalyticsDevice = NULL;
	this->tt__CapabilitiesExtension::Extensions = NULL;
}

void tt__CapabilitiesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DeviceIOCapabilities(soap, &this->tt__CapabilitiesExtension::DeviceIO);
	soap_serialize_PointerTott__DisplayCapabilities(soap, &this->tt__CapabilitiesExtension::Display);
	soap_serialize_PointerTott__RecordingCapabilities(soap, &this->tt__CapabilitiesExtension::Recording);
	soap_serialize_PointerTott__SearchCapabilities(soap, &this->tt__CapabilitiesExtension::Search);
	soap_serialize_PointerTott__ReplayCapabilities(soap, &this->tt__CapabilitiesExtension::Replay);
	soap_serialize_PointerTott__ReceiverCapabilities(soap, &this->tt__CapabilitiesExtension::Receiver);
	soap_serialize_PointerTott__AnalyticsDeviceCapabilities(soap, &this->tt__CapabilitiesExtension::AnalyticsDevice);
	soap_serialize_PointerTott__CapabilitiesExtension2(soap, &this->tt__CapabilitiesExtension::Extensions);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__CapabilitiesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__CapabilitiesExtension(struct soap *soap, const char *tag, int id, const tt__CapabilitiesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__CapabilitiesExtension), type ? type : "tt:CapabilitiesExtension"))
		return soap->error;
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", -1, &a->tt__CapabilitiesExtension::DeviceIO, ""))
		return soap->error;
	if (soap_out_PointerTott__DisplayCapabilities(soap, "tt:Display", -1, &a->tt__CapabilitiesExtension::Display, ""))
		return soap->error;
	if (soap_out_PointerTott__RecordingCapabilities(soap, "tt:Recording", -1, &a->tt__CapabilitiesExtension::Recording, ""))
		return soap->error;
	if (soap_out_PointerTott__SearchCapabilities(soap, "tt:Search", -1, &a->tt__CapabilitiesExtension::Search, ""))
		return soap->error;
	if (soap_out_PointerTott__ReplayCapabilities(soap, "tt:Replay", -1, &a->tt__CapabilitiesExtension::Replay, ""))
		return soap->error;
	if (soap_out_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", -1, &a->tt__CapabilitiesExtension::Receiver, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", -1, &a->tt__CapabilitiesExtension::AnalyticsDevice, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", -1, &a->tt__CapabilitiesExtension::Extensions, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__CapabilitiesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__CapabilitiesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_in_tt__CapabilitiesExtension(struct soap *soap, const char *tag, tt__CapabilitiesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__CapabilitiesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__CapabilitiesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__CapabilitiesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DeviceIO1 = 1;
	size_t soap_flag_Display1 = 1;
	size_t soap_flag_Recording1 = 1;
	size_t soap_flag_Search1 = 1;
	size_t soap_flag_Replay1 = 1;
	size_t soap_flag_Receiver1 = 1;
	size_t soap_flag_AnalyticsDevice1 = 1;
	size_t soap_flag_Extensions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DeviceIO1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceIOCapabilities(soap, "tt:DeviceIO", &a->tt__CapabilitiesExtension::DeviceIO, "tt:DeviceIOCapabilities"))
				{	soap_flag_DeviceIO1--;
					continue;
				}
			}
			if (soap_flag_Display1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DisplayCapabilities(soap, "tt:Display", &a->tt__CapabilitiesExtension::Display, "tt:DisplayCapabilities"))
				{	soap_flag_Display1--;
					continue;
				}
			}
			if (soap_flag_Recording1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RecordingCapabilities(soap, "tt:Recording", &a->tt__CapabilitiesExtension::Recording, "tt:RecordingCapabilities"))
				{	soap_flag_Recording1--;
					continue;
				}
			}
			if (soap_flag_Search1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SearchCapabilities(soap, "tt:Search", &a->tt__CapabilitiesExtension::Search, "tt:SearchCapabilities"))
				{	soap_flag_Search1--;
					continue;
				}
			}
			if (soap_flag_Replay1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReplayCapabilities(soap, "tt:Replay", &a->tt__CapabilitiesExtension::Replay, "tt:ReplayCapabilities"))
				{	soap_flag_Replay1--;
					continue;
				}
			}
			if (soap_flag_Receiver1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReceiverCapabilities(soap, "tt:Receiver", &a->tt__CapabilitiesExtension::Receiver, "tt:ReceiverCapabilities"))
				{	soap_flag_Receiver1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsDevice1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, "tt:AnalyticsDevice", &a->tt__CapabilitiesExtension::AnalyticsDevice, "tt:AnalyticsDeviceCapabilities"))
				{	soap_flag_AnalyticsDevice1--;
					continue;
				}
			}
			if (soap_flag_Extensions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension2(soap, "tt:Extensions", &a->tt__CapabilitiesExtension::Extensions, "tt:CapabilitiesExtension2"))
				{	soap_flag_Extensions1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__CapabilitiesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__CapabilitiesExtension, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(tt__CapabilitiesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_dup_tt__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *d, tt__CapabilitiesExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__CapabilitiesExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__CapabilitiesExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__CapabilitiesExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__DeviceIOCapabilities(soap, &d->tt__CapabilitiesExtension::DeviceIO, &a->tt__CapabilitiesExtension::DeviceIO);
	soap_dup_PointerTott__DisplayCapabilities(soap, &d->tt__CapabilitiesExtension::Display, &a->tt__CapabilitiesExtension::Display);
	soap_dup_PointerTott__RecordingCapabilities(soap, &d->tt__CapabilitiesExtension::Recording, &a->tt__CapabilitiesExtension::Recording);
	soap_dup_PointerTott__SearchCapabilities(soap, &d->tt__CapabilitiesExtension::Search, &a->tt__CapabilitiesExtension::Search);
	soap_dup_PointerTott__ReplayCapabilities(soap, &d->tt__CapabilitiesExtension::Replay, &a->tt__CapabilitiesExtension::Replay);
	soap_dup_PointerTott__ReceiverCapabilities(soap, &d->tt__CapabilitiesExtension::Receiver, &a->tt__CapabilitiesExtension::Receiver);
	soap_dup_PointerTott__AnalyticsDeviceCapabilities(soap, &d->tt__CapabilitiesExtension::AnalyticsDevice, &a->tt__CapabilitiesExtension::AnalyticsDevice);
	soap_dup_PointerTott__CapabilitiesExtension2(soap, &d->tt__CapabilitiesExtension::Extensions, &a->tt__CapabilitiesExtension::Extensions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__CapabilitiesExtension(tt__CapabilitiesExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__DeviceIOCapabilities(&a->tt__CapabilitiesExtension::DeviceIO);
	soap_del_PointerTott__DisplayCapabilities(&a->tt__CapabilitiesExtension::Display);
	soap_del_PointerTott__RecordingCapabilities(&a->tt__CapabilitiesExtension::Recording);
	soap_del_PointerTott__SearchCapabilities(&a->tt__CapabilitiesExtension::Search);
	soap_del_PointerTott__ReplayCapabilities(&a->tt__CapabilitiesExtension::Replay);
	soap_del_PointerTott__ReceiverCapabilities(&a->tt__CapabilitiesExtension::Receiver);
	soap_del_PointerTott__AnalyticsDeviceCapabilities(&a->tt__CapabilitiesExtension::AnalyticsDevice);
	soap_del_PointerTott__CapabilitiesExtension2(&a->tt__CapabilitiesExtension::Extensions);
}

SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__CapabilitiesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__CapabilitiesExtension *p;
	size_t k = sizeof(tt__CapabilitiesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__CapabilitiesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__CapabilitiesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__CapabilitiesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__CapabilitiesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__CapabilitiesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__CapabilitiesExtension(soap, tag ? tag : "tt:CapabilitiesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__CapabilitiesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__CapabilitiesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__CapabilitiesExtension * SOAP_FMAC4 soap_get_tt__CapabilitiesExtension(struct soap *soap, tt__CapabilitiesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Capabilities::Analytics = NULL;
	this->tt__Capabilities::Device = NULL;
	this->tt__Capabilities::Events = NULL;
	this->tt__Capabilities::Imaging = NULL;
	this->tt__Capabilities::Media = NULL;
	this->tt__Capabilities::PTZ = NULL;
	this->tt__Capabilities::Extension = NULL;
}

void tt__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsCapabilities(soap, &this->tt__Capabilities::Analytics);
	soap_serialize_PointerTott__DeviceCapabilities(soap, &this->tt__Capabilities::Device);
	soap_serialize_PointerTott__EventCapabilities(soap, &this->tt__Capabilities::Events);
	soap_serialize_PointerTott__ImagingCapabilities(soap, &this->tt__Capabilities::Imaging);
	soap_serialize_PointerTott__MediaCapabilities(soap, &this->tt__Capabilities::Media);
	soap_serialize_PointerTott__PTZCapabilities(soap, &this->tt__Capabilities::PTZ);
	soap_serialize_PointerTott__CapabilitiesExtension(soap, &this->tt__Capabilities::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Capabilities(struct soap *soap, const char *tag, int id, const tt__Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Capabilities), type ? type : "tt:Capabilities"))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", -1, &a->tt__Capabilities::Analytics, ""))
		return soap->error;
	if (soap_out_PointerTott__DeviceCapabilities(soap, "tt:Device", -1, &a->tt__Capabilities::Device, ""))
		return soap->error;
	if (soap_out_PointerTott__EventCapabilities(soap, "tt:Events", -1, &a->tt__Capabilities::Events, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingCapabilities(soap, "tt:Imaging", -1, &a->tt__Capabilities::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__MediaCapabilities(soap, "tt:Media", -1, &a->tt__Capabilities::Media, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZCapabilities(soap, "tt:PTZ", -1, &a->tt__Capabilities::PTZ, ""))
		return soap->error;
	if (soap_out_PointerTott__CapabilitiesExtension(soap, "tt:Extension", -1, &a->tt__Capabilities::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_in_tt__Capabilities(struct soap *soap, const char *tag, tt__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Device1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Media1 = 1;
	size_t soap_flag_PTZ1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsCapabilities(soap, "tt:Analytics", &a->tt__Capabilities::Analytics, "tt:AnalyticsCapabilities"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Device1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DeviceCapabilities(soap, "tt:Device", &a->tt__Capabilities::Device, "tt:DeviceCapabilities"))
				{	soap_flag_Device1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventCapabilities(soap, "tt:Events", &a->tt__Capabilities::Events, "tt:EventCapabilities"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingCapabilities(soap, "tt:Imaging", &a->tt__Capabilities::Imaging, "tt:ImagingCapabilities"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Media1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MediaCapabilities(soap, "tt:Media", &a->tt__Capabilities::Media, "tt:MediaCapabilities"))
				{	soap_flag_Media1--;
					continue;
				}
			}
			if (soap_flag_PTZ1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZCapabilities(soap, "tt:PTZ", &a->tt__Capabilities::PTZ, "tt:PTZCapabilities"))
				{	soap_flag_PTZ1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CapabilitiesExtension(soap, "tt:Extension", &a->tt__Capabilities::Extension, "tt:CapabilitiesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Capabilities, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_dup_tt__Capabilities(struct soap *soap, tt__Capabilities *d, tt__Capabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Capabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Capabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Capabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AnalyticsCapabilities(soap, &d->tt__Capabilities::Analytics, &a->tt__Capabilities::Analytics);
	soap_dup_PointerTott__DeviceCapabilities(soap, &d->tt__Capabilities::Device, &a->tt__Capabilities::Device);
	soap_dup_PointerTott__EventCapabilities(soap, &d->tt__Capabilities::Events, &a->tt__Capabilities::Events);
	soap_dup_PointerTott__ImagingCapabilities(soap, &d->tt__Capabilities::Imaging, &a->tt__Capabilities::Imaging);
	soap_dup_PointerTott__MediaCapabilities(soap, &d->tt__Capabilities::Media, &a->tt__Capabilities::Media);
	soap_dup_PointerTott__PTZCapabilities(soap, &d->tt__Capabilities::PTZ, &a->tt__Capabilities::PTZ);
	soap_dup_PointerTott__CapabilitiesExtension(soap, &d->tt__Capabilities::Extension, &a->tt__Capabilities::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Capabilities(tt__Capabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AnalyticsCapabilities(&a->tt__Capabilities::Analytics);
	soap_del_PointerTott__DeviceCapabilities(&a->tt__Capabilities::Device);
	soap_del_PointerTott__EventCapabilities(&a->tt__Capabilities::Events);
	soap_del_PointerTott__ImagingCapabilities(&a->tt__Capabilities::Imaging);
	soap_del_PointerTott__MediaCapabilities(&a->tt__Capabilities::Media);
	soap_del_PointerTott__PTZCapabilities(&a->tt__Capabilities::PTZ);
	soap_del_PointerTott__CapabilitiesExtension(&a->tt__Capabilities::Extension);
}

SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Capabilities *p;
	size_t k = sizeof(tt__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Capabilities * SOAP_FMAC4 soap_get_tt__Capabilities(struct soap *soap, tt__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworksExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__Dot11AvailableNetworksExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11AvailableNetworksExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworksExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Dot11AvailableNetworksExtension");
}

void *tt__Dot11AvailableNetworksExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, tt__Dot11AvailableNetworksExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11AvailableNetworksExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworksExtension)
		return (tt__Dot11AvailableNetworksExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_dup_tt__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *d, tt__Dot11AvailableNetworksExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11AvailableNetworksExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11AvailableNetworksExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11AvailableNetworksExtension(tt__Dot11AvailableNetworksExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworksExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworksExtension *p;
	size_t k = sizeof(tt__Dot11AvailableNetworksExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworksExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworksExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworksExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworksExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworksExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworksExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11AvailableNetworks::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	this->tt__Dot11AvailableNetworks::BSSID = NULL;
	soap_default_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_default_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	this->tt__Dot11AvailableNetworks::SignalStrength = NULL;
	this->tt__Dot11AvailableNetworks::Extension = NULL;
}

void tt__Dot11AvailableNetworks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11AvailableNetworks::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11AvailableNetworks::BSSID);
	soap_serialize_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &this->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::PairCipher);
	soap_serialize_std__vectorTemplateOftt__Dot11Cipher(soap, &this->tt__Dot11AvailableNetworks::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11AvailableNetworks::SignalStrength);
	soap_serialize_PointerTott__Dot11AvailableNetworksExtension(soap, &this->tt__Dot11AvailableNetworks::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11AvailableNetworks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, const tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11AvailableNetworks), type ? type : "tt:Dot11AvailableNetworks"))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11AvailableNetworks::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11AvailableNetworks::BSSID, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", -1, &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11AvailableNetworks::PairCipher, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11AvailableNetworks::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11AvailableNetworks::SignalStrength, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", -1, &a->tt__Dot11AvailableNetworks::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11AvailableNetworks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11AvailableNetworks(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_in_tt__Dot11AvailableNetworks(struct soap *soap, const char *tag, tt__Dot11AvailableNetworks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11AvailableNetworks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11AvailableNetworks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11AvailableNetworks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11AvailableNetworks::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11AvailableNetworks::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, "tt:AuthAndMangementSuite", &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite, "tt:Dot11AuthAndMangementSuite"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11AvailableNetworks::PairCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11AvailableNetworks::GroupCipher, "tt:Dot11Cipher"))
					continue;
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11AvailableNetworks::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, "tt:Extension", &a->tt__Dot11AvailableNetworks::Extension, "tt:Dot11AvailableNetworksExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_SSID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11AvailableNetworks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11AvailableNetworks, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_dup_tt__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *d, tt__Dot11AvailableNetworks const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11AvailableNetworks*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11AvailableNetworks, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11AvailableNetworks(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__Dot11SSIDType(soap, &d->tt__Dot11AvailableNetworks::SSID, &a->tt__Dot11AvailableNetworks::SSID);
	soap_dup_PointerTostd__string(soap, &d->tt__Dot11AvailableNetworks::BSSID, &a->tt__Dot11AvailableNetworks::BSSID);
	soap_dup_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(soap, &d->tt__Dot11AvailableNetworks::AuthAndMangementSuite, &a->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_dup_std__vectorTemplateOftt__Dot11Cipher(soap, &d->tt__Dot11AvailableNetworks::PairCipher, &a->tt__Dot11AvailableNetworks::PairCipher);
	soap_dup_std__vectorTemplateOftt__Dot11Cipher(soap, &d->tt__Dot11AvailableNetworks::GroupCipher, &a->tt__Dot11AvailableNetworks::GroupCipher);
	soap_dup_PointerTott__Dot11SignalStrength(soap, &d->tt__Dot11AvailableNetworks::SignalStrength, &a->tt__Dot11AvailableNetworks::SignalStrength);
	soap_dup_PointerTott__Dot11AvailableNetworksExtension(soap, &d->tt__Dot11AvailableNetworks::Extension, &a->tt__Dot11AvailableNetworks::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11AvailableNetworks(tt__Dot11AvailableNetworks const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__Dot11SSIDType(&a->tt__Dot11AvailableNetworks::SSID);
	soap_del_PointerTostd__string(&a->tt__Dot11AvailableNetworks::BSSID);
	soap_del_std__vectorTemplateOftt__Dot11AuthAndMangementSuite(&a->tt__Dot11AvailableNetworks::AuthAndMangementSuite);
	soap_del_std__vectorTemplateOftt__Dot11Cipher(&a->tt__Dot11AvailableNetworks::PairCipher);
	soap_del_std__vectorTemplateOftt__Dot11Cipher(&a->tt__Dot11AvailableNetworks::GroupCipher);
	soap_del_PointerTott__Dot11SignalStrength(&a->tt__Dot11AvailableNetworks::SignalStrength);
	soap_del_PointerTott__Dot11AvailableNetworksExtension(&a->tt__Dot11AvailableNetworks::Extension);
}

SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11AvailableNetworks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11AvailableNetworks *p;
	size_t k = sizeof(tt__Dot11AvailableNetworks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11AvailableNetworks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11AvailableNetworks);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11AvailableNetworks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11AvailableNetworks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11AvailableNetworks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11AvailableNetworks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11AvailableNetworks(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks * SOAP_FMAC4 soap_get_tt__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	this->tt__Dot11Status::BSSID = NULL;
	this->tt__Dot11Status::PairCipher = NULL;
	this->tt__Dot11Status::GroupCipher = NULL;
	this->tt__Dot11Status::SignalStrength = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
}

void tt__Dot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Status::SSID);
	soap_serialize_PointerTostd__string(soap, &this->tt__Dot11Status::BSSID);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::PairCipher);
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11Status::GroupCipher);
	soap_serialize_PointerTott__Dot11SignalStrength(soap, &this->tt__Dot11Status::SignalStrength);
	soap_embedded(soap, &this->tt__Dot11Status::ActiveConfigAlias, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__Dot11Status::ActiveConfigAlias);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Status(struct soap *soap, const char *tag, int id, const tt__Dot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Status), type ? type : "tt:Dot11Status"))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Status::SSID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:BSSID", -1, &a->tt__Dot11Status::BSSID, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:PairCipher", -1, &a->tt__Dot11Status::PairCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", -1, &a->tt__Dot11Status::GroupCipher, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", -1, &a->tt__Dot11Status::SignalStrength, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", -1, &a->tt__Dot11Status::ActiveConfigAlias, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Status(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_in_tt__Dot11Status(struct soap *soap, const char *tag, tt__Dot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_BSSID1 = 1;
	size_t soap_flag_PairCipher1 = 1;
	size_t soap_flag_GroupCipher1 = 1;
	size_t soap_flag_SignalStrength1 = 1;
	size_t soap_flag_ActiveConfigAlias1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Status::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_BSSID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:BSSID", &a->tt__Dot11Status::BSSID, "xsd:string"))
				{	soap_flag_BSSID1--;
					continue;
				}
			}
			if (soap_flag_PairCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:PairCipher", &a->tt__Dot11Status::PairCipher, "tt:Dot11Cipher"))
				{	soap_flag_PairCipher1--;
					continue;
				}
			}
			if (soap_flag_GroupCipher1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:GroupCipher", &a->tt__Dot11Status::GroupCipher, "tt:Dot11Cipher"))
				{	soap_flag_GroupCipher1--;
					continue;
				}
			}
			if (soap_flag_SignalStrength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SignalStrength(soap, "tt:SignalStrength", &a->tt__Dot11Status::SignalStrength, "tt:Dot11SignalStrength"))
				{	soap_flag_SignalStrength1--;
					continue;
				}
			}
			if (soap_flag_ActiveConfigAlias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:ActiveConfigAlias", &a->tt__Dot11Status::ActiveConfigAlias, "tt:ReferenceToken"))
				{	soap_flag_ActiveConfigAlias1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_SSID1 > 0 || soap_flag_ActiveConfigAlias1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Status, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_dup_tt__Dot11Status(struct soap *soap, tt__Dot11Status *d, tt__Dot11Status const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11Status*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11Status, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11Status(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__Dot11SSIDType(soap, &d->tt__Dot11Status::SSID, &a->tt__Dot11Status::SSID);
	soap_dup_PointerTostd__string(soap, &d->tt__Dot11Status::BSSID, &a->tt__Dot11Status::BSSID);
	soap_dup_PointerTott__Dot11Cipher(soap, &d->tt__Dot11Status::PairCipher, &a->tt__Dot11Status::PairCipher);
	soap_dup_PointerTott__Dot11Cipher(soap, &d->tt__Dot11Status::GroupCipher, &a->tt__Dot11Status::GroupCipher);
	soap_dup_PointerTott__Dot11SignalStrength(soap, &d->tt__Dot11Status::SignalStrength, &a->tt__Dot11Status::SignalStrength);
	soap_dup_tt__ReferenceToken(soap, &d->tt__Dot11Status::ActiveConfigAlias, &a->tt__Dot11Status::ActiveConfigAlias);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11Status(tt__Dot11Status const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__Dot11SSIDType(&a->tt__Dot11Status::SSID);
	soap_del_PointerTostd__string(&a->tt__Dot11Status::BSSID);
	soap_del_PointerTott__Dot11Cipher(&a->tt__Dot11Status::PairCipher);
	soap_del_PointerTott__Dot11Cipher(&a->tt__Dot11Status::GroupCipher);
	soap_del_PointerTott__Dot11SignalStrength(&a->tt__Dot11Status::SignalStrength);
	soap_del_tt__ReferenceToken(&a->tt__Dot11Status::ActiveConfigAlias);
}

SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Status *p;
	size_t k = sizeof(tt__Dot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Status);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Status(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Status * SOAP_FMAC4 soap_get_tt__Dot11Status(struct soap *soap, tt__Dot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::TKIP);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::MultipleConfiguration);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::AdHocStationMode);
	soap_default_bool(soap, &this->tt__Dot11Capabilities::WEP);
}

void tt__Dot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Dot11Capabilities::TKIP, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::ScanAvailableNetworks, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::MultipleConfiguration, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::AdHocStationMode, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__Dot11Capabilities::WEP, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Capabilities(struct soap *soap, const char *tag, int id, const tt__Dot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Capabilities), type ? type : "tt:Dot11Capabilities"))
		return soap->error;
	if (soap_out_bool(soap, "tt:TKIP", -1, &a->tt__Dot11Capabilities::TKIP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ScanAvailableNetworks", -1, &a->tt__Dot11Capabilities::ScanAvailableNetworks, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:MultipleConfiguration", -1, &a->tt__Dot11Capabilities::MultipleConfiguration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AdHocStationMode", -1, &a->tt__Dot11Capabilities::AdHocStationMode, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:WEP", -1, &a->tt__Dot11Capabilities::WEP, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_in_tt__Dot11Capabilities(struct soap *soap, const char *tag, tt__Dot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_TKIP1 = 1;
	size_t soap_flag_ScanAvailableNetworks1 = 1;
	size_t soap_flag_MultipleConfiguration1 = 1;
	size_t soap_flag_AdHocStationMode1 = 1;
	size_t soap_flag_WEP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TKIP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:TKIP", &a->tt__Dot11Capabilities::TKIP, "xsd:boolean"))
				{	soap_flag_TKIP1--;
					continue;
				}
			}
			if (soap_flag_ScanAvailableNetworks1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ScanAvailableNetworks", &a->tt__Dot11Capabilities::ScanAvailableNetworks, "xsd:boolean"))
				{	soap_flag_ScanAvailableNetworks1--;
					continue;
				}
			}
			if (soap_flag_MultipleConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:MultipleConfiguration", &a->tt__Dot11Capabilities::MultipleConfiguration, "xsd:boolean"))
				{	soap_flag_MultipleConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AdHocStationMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AdHocStationMode", &a->tt__Dot11Capabilities::AdHocStationMode, "xsd:boolean"))
				{	soap_flag_AdHocStationMode1--;
					continue;
				}
			}
			if (soap_flag_WEP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:WEP", &a->tt__Dot11Capabilities::WEP, "xsd:boolean"))
				{	soap_flag_WEP1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_TKIP1 > 0 || soap_flag_ScanAvailableNetworks1 > 0 || soap_flag_MultipleConfiguration1 > 0 || soap_flag_AdHocStationMode1 > 0 || soap_flag_WEP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Capabilities, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_dup_tt__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *d, tt__Dot11Capabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11Capabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11Capabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11Capabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Dot11Capabilities::TKIP = a->tt__Dot11Capabilities::TKIP;
	d->tt__Dot11Capabilities::ScanAvailableNetworks = a->tt__Dot11Capabilities::ScanAvailableNetworks;
	d->tt__Dot11Capabilities::MultipleConfiguration = a->tt__Dot11Capabilities::MultipleConfiguration;
	d->tt__Dot11Capabilities::AdHocStationMode = a->tt__Dot11Capabilities::AdHocStationMode;
	d->tt__Dot11Capabilities::WEP = a->tt__Dot11Capabilities::WEP;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11Capabilities(tt__Dot11Capabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* TKIP skipped */
	/* ScanAvailableNetworks skipped */
	/* MultipleConfiguration skipped */
	/* AdHocStationMode skipped */
	/* WEP skipped */
}

SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Capabilities *p;
	size_t k = sizeof(tt__Dot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Capabilities * SOAP_FMAC4 soap_get_tt__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkInterfaceSetConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkInterfaceSetConfigurationExtension2");
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkInterfaceSetConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2)
		return (tt__NetworkInterfaceSetConfigurationExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *d, tt__NetworkInterfaceSetConfigurationExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceSetConfigurationExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceSetConfigurationExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceSetConfigurationExtension2(tt__NetworkInterfaceSetConfigurationExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSetExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__Dot11PSKSetExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11PSKSetExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Dot11PSKSetExtension");
}

void *tt__Dot11PSKSetExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSetExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_in_tt__Dot11PSKSetExtension(struct soap *soap, const char *tag, tt__Dot11PSKSetExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11PSKSetExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSetExtension)
		return (tt__Dot11PSKSetExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_dup_tt__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *d, tt__Dot11PSKSetExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11PSKSetExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11PSKSetExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11PSKSetExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11PSKSetExtension(tt__Dot11PSKSetExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSetExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSetExtension *p;
	size_t k = sizeof(tt__Dot11PSKSetExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSetExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSetExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSetExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSetExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSetExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSetExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSetExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension * SOAP_FMAC4 soap_get_tt__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11PSKSet::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Dot11PSKSet::Key = NULL;
	this->tt__Dot11PSKSet::Passphrase = NULL;
	this->tt__Dot11PSKSet::Extension = NULL;
}

void tt__Dot11PSKSet::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11PSK(soap, &this->tt__Dot11PSKSet::Key);
	soap_serialize_PointerTott__Dot11PSKPassphrase(soap, &this->tt__Dot11PSKSet::Passphrase);
	soap_serialize_PointerTott__Dot11PSKSetExtension(soap, &this->tt__Dot11PSKSet::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11PSKSet::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11PSKSet(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKSet(struct soap *soap, const char *tag, int id, const tt__Dot11PSKSet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11PSKSet), type ? type : "tt:Dot11PSKSet"))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSK(soap, "tt:Key", -1, &a->tt__Dot11PSKSet::Key, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", -1, &a->tt__Dot11PSKSet::Passphrase, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", -1, &a->tt__Dot11PSKSet::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11PSKSet::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11PSKSet(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_in_tt__Dot11PSKSet(struct soap *soap, const char *tag, tt__Dot11PSKSet *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11PSKSet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11PSKSet)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11PSKSet *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Key1 = 1;
	size_t soap_flag_Passphrase1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Key1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSK(soap, "tt:Key", &a->tt__Dot11PSKSet::Key, "tt:Dot11PSK"))
				{	soap_flag_Key1--;
					continue;
				}
			}
			if (soap_flag_Passphrase1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Dot11PSKPassphrase(soap, "tt:Passphrase", &a->tt__Dot11PSKSet::Passphrase, "tt:Dot11PSKPassphrase"))
				{	soap_flag_Passphrase1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSetExtension(soap, "tt:Extension", &a->tt__Dot11PSKSet::Extension, "tt:Dot11PSKSetExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Dot11PSKSet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11PSKSet, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_dup_tt__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *d, tt__Dot11PSKSet const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11PSKSet*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11PSKSet, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11PSKSet(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Dot11PSK(soap, &d->tt__Dot11PSKSet::Key, &a->tt__Dot11PSKSet::Key);
	soap_dup_PointerTott__Dot11PSKPassphrase(soap, &d->tt__Dot11PSKSet::Passphrase, &a->tt__Dot11PSKSet::Passphrase);
	soap_dup_PointerTott__Dot11PSKSetExtension(soap, &d->tt__Dot11PSKSet::Extension, &a->tt__Dot11PSKSet::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11PSKSet(tt__Dot11PSKSet const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Dot11PSK(&a->tt__Dot11PSKSet::Key);
	soap_del_PointerTott__Dot11PSKPassphrase(&a->tt__Dot11PSKSet::Passphrase);
	soap_del_PointerTott__Dot11PSKSetExtension(&a->tt__Dot11PSKSet::Extension);
}

SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11PSKSet(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11PSKSet *p;
	size_t k = sizeof(tt__Dot11PSKSet);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11PSKSet, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11PSKSet);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11PSKSet, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11PSKSet location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11PSKSet::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11PSKSet::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11PSKSet(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11PSKSet * SOAP_FMAC4 soap_get_tt__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__Dot11SecurityConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11SecurityConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Dot11SecurityConfigurationExtension");
}

void *tt__Dot11SecurityConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, tt__Dot11SecurityConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot11SecurityConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfigurationExtension)
		return (tt__Dot11SecurityConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_dup_tt__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *d, tt__Dot11SecurityConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11SecurityConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11SecurityConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11SecurityConfigurationExtension(tt__Dot11SecurityConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfigurationExtension *p;
	size_t k = sizeof(tt__Dot11SecurityConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11SecurityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Dot11SecurityMode(soap, &this->tt__Dot11SecurityConfiguration::Mode);
	this->tt__Dot11SecurityConfiguration::Algorithm = NULL;
	this->tt__Dot11SecurityConfiguration::PSK = NULL;
	this->tt__Dot11SecurityConfiguration::Dot1X = NULL;
	this->tt__Dot11SecurityConfiguration::Extension = NULL;
}

void tt__Dot11SecurityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Cipher(soap, &this->tt__Dot11SecurityConfiguration::Algorithm);
	soap_serialize_PointerTott__Dot11PSKSet(soap, &this->tt__Dot11SecurityConfiguration::PSK);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->tt__Dot11SecurityConfiguration::Dot1X);
	soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(soap, &this->tt__Dot11SecurityConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11SecurityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, const tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration), type ? type : "tt:Dot11SecurityConfiguration"))
		return soap->error;
	if (soap_out_tt__Dot11SecurityMode(soap, "tt:Mode", -1, &a->tt__Dot11SecurityConfiguration::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11Cipher(soap, "tt:Algorithm", -1, &a->tt__Dot11SecurityConfiguration::Algorithm, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11PSKSet(soap, "tt:PSK", -1, &a->tt__Dot11SecurityConfiguration::PSK, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tt:Dot1X", -1, &a->tt__Dot11SecurityConfiguration::Dot1X, ""))
		return soap->error;
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", -1, &a->tt__Dot11SecurityConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11SecurityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11SecurityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_in_tt__Dot11SecurityConfiguration(struct soap *soap, const char *tag, tt__Dot11SecurityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11SecurityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11SecurityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11SecurityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Algorithm1 = 1;
	size_t soap_flag_PSK1 = 1;
	size_t soap_flag_Dot1X1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SecurityMode(soap, "tt:Mode", &a->tt__Dot11SecurityConfiguration::Mode, "tt:Dot11SecurityMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Algorithm1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Cipher(soap, "tt:Algorithm", &a->tt__Dot11SecurityConfiguration::Algorithm, "tt:Dot11Cipher"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			}
			if (soap_flag_PSK1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11PSKSet(soap, "tt:PSK", &a->tt__Dot11SecurityConfiguration::PSK, "tt:Dot11PSKSet"))
				{	soap_flag_PSK1--;
					continue;
				}
			}
			if (soap_flag_Dot1X1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tt:Dot1X", &a->tt__Dot11SecurityConfiguration::Dot1X, "tt:ReferenceToken"))
				{	soap_flag_Dot1X1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, "tt:Extension", &a->tt__Dot11SecurityConfiguration::Extension, "tt:Dot11SecurityConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11SecurityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11SecurityConfiguration, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_dup_tt__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *d, tt__Dot11SecurityConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11SecurityConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11SecurityConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Dot11SecurityConfiguration::Mode = a->tt__Dot11SecurityConfiguration::Mode;
	soap_dup_PointerTott__Dot11Cipher(soap, &d->tt__Dot11SecurityConfiguration::Algorithm, &a->tt__Dot11SecurityConfiguration::Algorithm);
	soap_dup_PointerTott__Dot11PSKSet(soap, &d->tt__Dot11SecurityConfiguration::PSK, &a->tt__Dot11SecurityConfiguration::PSK);
	soap_dup_PointerTott__ReferenceToken(soap, &d->tt__Dot11SecurityConfiguration::Dot1X, &a->tt__Dot11SecurityConfiguration::Dot1X);
	soap_dup_PointerTott__Dot11SecurityConfigurationExtension(soap, &d->tt__Dot11SecurityConfiguration::Extension, &a->tt__Dot11SecurityConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11SecurityConfiguration(tt__Dot11SecurityConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTott__Dot11Cipher(&a->tt__Dot11SecurityConfiguration::Algorithm);
	soap_del_PointerTott__Dot11PSKSet(&a->tt__Dot11SecurityConfiguration::PSK);
	soap_del_PointerTott__ReferenceToken(&a->tt__Dot11SecurityConfiguration::Dot1X);
	soap_del_PointerTott__Dot11SecurityConfigurationExtension(&a->tt__Dot11SecurityConfiguration::Extension);
}

SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11SecurityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11SecurityConfiguration *p;
	size_t k = sizeof(tt__Dot11SecurityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11SecurityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11SecurityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11SecurityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11SecurityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11SecurityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11SecurityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11SecurityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration * SOAP_FMAC4 soap_get_tt__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot11Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_default_tt__Dot11StationMode(soap, &this->tt__Dot11Configuration::Mode);
	soap_default_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_default_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	this->tt__Dot11Configuration::Security = NULL;
}

void tt__Dot11Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Dot11SSIDType(soap, &this->tt__Dot11Configuration::SSID);
	soap_serialize_tt__Name(soap, &this->tt__Dot11Configuration::Alias);
	soap_serialize_tt__NetworkInterfaceConfigPriority(soap, &this->tt__Dot11Configuration::Priority);
	soap_serialize_PointerTott__Dot11SecurityConfiguration(soap, &this->tt__Dot11Configuration::Security);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot11Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot11Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11Configuration(struct soap *soap, const char *tag, int id, const tt__Dot11Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Dot11Configuration), type ? type : "tt:Dot11Configuration"))
		return soap->error;
	if (soap_out_tt__Dot11SSIDType(soap, "tt:SSID", -1, &a->tt__Dot11Configuration::SSID, ""))
		return soap->error;
	if (soap_out_tt__Dot11StationMode(soap, "tt:Mode", -1, &a->tt__Dot11Configuration::Mode, ""))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Alias", -1, &a->tt__Dot11Configuration::Alias, ""))
		return soap->error;
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", -1, &a->tt__Dot11Configuration::Priority, ""))
		return soap->error;
	if (!a->tt__Dot11Configuration::Security)
	{	if (soap_element_empty(soap, "tt:Security", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", -1, &a->tt__Dot11Configuration::Security, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Dot11Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot11Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_in_tt__Dot11Configuration(struct soap *soap, const char *tag, tt__Dot11Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Dot11Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot11Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Dot11Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SSID1 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Alias1 = 1;
	size_t soap_flag_Priority1 = 1;
	size_t soap_flag_Security1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SSID1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11SSIDType(soap, "tt:SSID", &a->tt__Dot11Configuration::SSID, "tt:Dot11SSIDType"))
				{	soap_flag_SSID1--;
					continue;
				}
			}
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Dot11StationMode(soap, "tt:Mode", &a->tt__Dot11Configuration::Mode, "tt:Dot11StationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Alias", &a->tt__Dot11Configuration::Alias, "tt:Name"))
				{	soap_flag_Alias1--;
					continue;
				}
			}
			if (soap_flag_Priority1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__NetworkInterfaceConfigPriority(soap, "tt:Priority", &a->tt__Dot11Configuration::Priority, "tt:NetworkInterfaceConfigPriority"))
				{	soap_flag_Priority1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11SecurityConfiguration(soap, "tt:Security", &a->tt__Dot11Configuration::Security, "tt:Dot11SecurityConfiguration"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_SSID1 > 0 || soap_flag_Mode1 > 0 || soap_flag_Alias1 > 0 || soap_flag_Priority1 > 0 || !a->tt__Dot11Configuration::Security))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Dot11Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Dot11Configuration, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_dup_tt__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *d, tt__Dot11Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot11Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot11Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot11Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__Dot11SSIDType(soap, &d->tt__Dot11Configuration::SSID, &a->tt__Dot11Configuration::SSID);
	d->tt__Dot11Configuration::Mode = a->tt__Dot11Configuration::Mode;
	soap_dup_tt__Name(soap, &d->tt__Dot11Configuration::Alias, &a->tt__Dot11Configuration::Alias);
	soap_dup_tt__NetworkInterfaceConfigPriority(soap, &d->tt__Dot11Configuration::Priority, &a->tt__Dot11Configuration::Priority);
	soap_dup_PointerTott__Dot11SecurityConfiguration(soap, &d->tt__Dot11Configuration::Security, &a->tt__Dot11Configuration::Security);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot11Configuration(tt__Dot11Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__Dot11SSIDType(&a->tt__Dot11Configuration::SSID);
	/* Mode skipped */
	soap_del_tt__Name(&a->tt__Dot11Configuration::Alias);
	soap_del_tt__NetworkInterfaceConfigPriority(&a->tt__Dot11Configuration::Priority);
	soap_del_PointerTott__Dot11SecurityConfiguration(&a->tt__Dot11Configuration::Security);
}

SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot11Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot11Configuration *p;
	size_t k = sizeof(tt__Dot11Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot11Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot11Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot11Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot11Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot11Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot11Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot11Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot11Configuration * SOAP_FMAC4 soap_get_tt__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilterExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__IPAddressFilterExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPAddressFilterExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, const tt__IPAddressFilterExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IPAddressFilterExtension");
}

void *tt__IPAddressFilterExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilterExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_in_tt__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPAddressFilterExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilterExtension)
		return (tt__IPAddressFilterExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_dup_tt__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *d, tt__IPAddressFilterExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPAddressFilterExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPAddressFilterExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPAddressFilterExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPAddressFilterExtension(tt__IPAddressFilterExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilterExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilterExtension *p;
	size_t k = sizeof(tt__IPAddressFilterExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilterExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilterExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilterExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilterExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilterExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilterExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilterExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilterExtension * SOAP_FMAC4 soap_get_tt__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPAddressFilterType(soap, &this->tt__IPAddressFilter::Type);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	this->tt__IPAddressFilter::Extension = NULL;
}

void tt__IPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPAddressFilter::IPv4Address);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPAddressFilter::IPv6Address);
	soap_serialize_PointerTott__IPAddressFilterExtension(soap, &this->tt__IPAddressFilter::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddressFilter(struct soap *soap, const char *tag, int id, const tt__IPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddressFilter), type ? type : "tt:IPAddressFilter"))
		return soap->error;
	if (soap_out_tt__IPAddressFilterType(soap, "tt:Type", -1, &a->tt__IPAddressFilter::Type, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddressFilter::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddressFilter::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", -1, &a->tt__IPAddressFilter::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_in_tt__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPAddressFilterType(soap, "tt:Type", &a->tt__IPAddressFilter::Type, "tt:IPAddressFilterType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddressFilter::IPv4Address, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddressFilter::IPv6Address, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilterExtension(soap, "tt:Extension", &a->tt__IPAddressFilter::Extension, "tt:IPAddressFilterExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddressFilter, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_dup_tt__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *d, tt__IPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IPAddressFilter::Type = a->tt__IPAddressFilter::Type;
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &d->tt__IPAddressFilter::IPv4Address, &a->tt__IPAddressFilter::IPv4Address);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPAddressFilter::IPv6Address, &a->tt__IPAddressFilter::IPv6Address);
	soap_dup_PointerTott__IPAddressFilterExtension(soap, &d->tt__IPAddressFilter::Extension, &a->tt__IPAddressFilter::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPAddressFilter(tt__IPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(&a->tt__IPAddressFilter::IPv4Address);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPAddressFilter::IPv6Address);
	soap_del_PointerTott__IPAddressFilterExtension(&a->tt__IPAddressFilter::Extension);
}

SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddressFilter *p;
	size_t k = sizeof(tt__IPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddressFilter * SOAP_FMAC4 soap_get_tt__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkZeroConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkZeroConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkZeroConfigurationExtension2");
}

void *tt__NetworkZeroConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkZeroConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension2)
		return (tt__NetworkZeroConfigurationExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_dup_tt__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *d, tt__NetworkZeroConfigurationExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkZeroConfigurationExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkZeroConfigurationExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkZeroConfigurationExtension2(tt__NetworkZeroConfigurationExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension2 *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	this->tt__NetworkZeroConfigurationExtension::Extension = NULL;
}

void tt__NetworkZeroConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &this->tt__NetworkZeroConfigurationExtension::Additional);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(soap, &this->tt__NetworkZeroConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkZeroConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension), type ? type : "tt:NetworkZeroConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", -1, &a->tt__NetworkZeroConfigurationExtension::Additional, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, "tt:Additional", &a->tt__NetworkZeroConfigurationExtension::Additional, "tt:NetworkZeroConfiguration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkZeroConfigurationExtension::Extension, "tt:NetworkZeroConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_dup_tt__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *d, tt__NetworkZeroConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	char *mark = NULL;
	if (!a)
		return NULL;
	if (!d && ((d = (tt__NetworkZeroConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, &pp, &mark)) || soap_mark_cycle(soap, pp)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkZeroConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(soap, &d->tt__NetworkZeroConfigurationExtension::Additional, &a->tt__NetworkZeroConfigurationExtension::Additional);
	soap_dup_PointerTott__NetworkZeroConfigurationExtension2(soap, &d->tt__NetworkZeroConfigurationExtension::Extension, &a->tt__NetworkZeroConfigurationExtension::Extension);
	soap_unmark(soap, mark);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkZeroConfigurationExtension(tt__NetworkZeroConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration(&a->tt__NetworkZeroConfigurationExtension::Additional);
	soap_del_PointerTott__NetworkZeroConfigurationExtension2(&a->tt__NetworkZeroConfigurationExtension::Extension);
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkZeroConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->tt__NetworkZeroConfiguration::Enabled);
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	this->tt__NetworkZeroConfiguration::Extension = NULL;
}

void tt__NetworkZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__NetworkZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->tt__NetworkZeroConfiguration::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkZeroConfiguration::Addresses);
	soap_serialize_PointerTott__NetworkZeroConfigurationExtension(soap, &this->tt__NetworkZeroConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkZeroConfiguration), type ? type : "tt:NetworkZeroConfiguration"))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:InterfaceToken", -1, &a->tt__NetworkZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkZeroConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", -1, &a->tt__NetworkZeroConfiguration::Addresses, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkZeroConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_in_tt__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:InterfaceToken", &a->tt__NetworkZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:Addresses", &a->tt__NetworkZeroConfiguration::Addresses, "tt:IPv4Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkZeroConfiguration::Extension, "tt:NetworkZeroConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkZeroConfiguration, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_dup_tt__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *d, tt__NetworkZeroConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkZeroConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkZeroConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkZeroConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__NetworkZeroConfiguration::InterfaceToken, &a->tt__NetworkZeroConfiguration::InterfaceToken);
	d->tt__NetworkZeroConfiguration::Enabled = a->tt__NetworkZeroConfiguration::Enabled;
	soap_dup_std__vectorTemplateOftt__IPv4Address(soap, &d->tt__NetworkZeroConfiguration::Addresses, &a->tt__NetworkZeroConfiguration::Addresses);
	soap_dup_PointerTott__NetworkZeroConfigurationExtension(soap, &d->tt__NetworkZeroConfiguration::Extension, &a->tt__NetworkZeroConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkZeroConfiguration(tt__NetworkZeroConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__ReferenceToken(&a->tt__NetworkZeroConfiguration::InterfaceToken);
	/* Enabled skipped */
	soap_del_std__vectorTemplateOftt__IPv4Address(&a->tt__NetworkZeroConfiguration::Addresses);
	soap_del_PointerTott__NetworkZeroConfigurationExtension(&a->tt__NetworkZeroConfiguration::Extension);
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkZeroConfiguration *p;
	size_t k = sizeof(tt__NetworkZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration * SOAP_FMAC4 soap_get_tt__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
}

void tt__NetworkGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->tt__NetworkGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->tt__NetworkGateway::IPv6Address);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkGateway(struct soap *soap, const char *tag, int id, const tt__NetworkGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkGateway), type ? type : "tt:NetworkGateway"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkGateway::IPv6Address, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkGateway(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_in_tt__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkGateway, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_dup_tt__NetworkGateway(struct soap *soap, tt__NetworkGateway *d, tt__NetworkGateway const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkGateway*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkGateway, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkGateway(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__IPv4Address(soap, &d->tt__NetworkGateway::IPv4Address, &a->tt__NetworkGateway::IPv4Address);
	soap_dup_std__vectorTemplateOftt__IPv6Address(soap, &d->tt__NetworkGateway::IPv6Address, &a->tt__NetworkGateway::IPv6Address);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkGateway(tt__NetworkGateway const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__IPv4Address(&a->tt__NetworkGateway::IPv4Address);
	soap_del_std__vectorTemplateOftt__IPv6Address(&a->tt__NetworkGateway::IPv6Address);
}

SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkGateway *p;
	size_t k = sizeof(tt__NetworkGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkGateway(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkGateway * SOAP_FMAC4 soap_get_tt__NetworkGateway(struct soap *soap, tt__NetworkGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv4NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTobool(soap, &this->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration), type ? type : "tt:IPv4NetworkInterfaceSetConfiguration"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:DHCP", -1, &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:DHCP", &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_dup_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *d, tt__IPv4NetworkInterfaceSetConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv4NetworkInterfaceSetConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv4NetworkInterfaceSetConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__IPv4NetworkInterfaceSetConfiguration::Enabled, &a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &d->tt__IPv4NetworkInterfaceSetConfiguration::Manual, &a->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_dup_PointerTobool(soap, &d->tt__IPv4NetworkInterfaceSetConfiguration::DHCP, &a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv4NetworkInterfaceSetConfiguration(tt__IPv4NetworkInterfaceSetConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__IPv4NetworkInterfaceSetConfiguration::Enabled);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(&a->tt__IPv4NetworkInterfaceSetConfiguration::Manual);
	soap_del_PointerTobool(&a->tt__IPv4NetworkInterfaceSetConfiguration::DHCP);
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv4NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP = NULL;
}

void tt__IPv6NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTobool(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_serialize_PointerTott__IPv6DHCPConfiguration(soap, &this->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration), type ? type : "tt:IPv6NetworkInterfaceSetConfiguration"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_dup_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *d, tt__IPv6NetworkInterfaceSetConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv6NetworkInterfaceSetConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv6NetworkInterfaceSetConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__IPv6NetworkInterfaceSetConfiguration::Enabled, &a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_dup_PointerTobool(soap, &d->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert, &a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPv6NetworkInterfaceSetConfiguration::Manual, &a->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_dup_PointerTott__IPv6DHCPConfiguration(soap, &d->tt__IPv6NetworkInterfaceSetConfiguration::DHCP, &a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv6NetworkInterfaceSetConfiguration(tt__IPv6NetworkInterfaceSetConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__IPv6NetworkInterfaceSetConfiguration::Enabled);
	soap_del_PointerTobool(&a->tt__IPv6NetworkInterfaceSetConfiguration::AcceptRouterAdvert);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPv6NetworkInterfaceSetConfiguration::Manual);
	soap_del_PointerTott__IPv6DHCPConfiguration(&a->tt__IPv6NetworkInterfaceSetConfiguration::DHCP);
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__IPv6NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	this->tt__NetworkInterfaceSetConfigurationExtension::Extension = NULL;
}

void tt__NetworkInterfaceSetConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &this->tt__NetworkInterfaceSetConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension), type ? type : "tt:NetworkInterfaceSetConfigurationExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfigurationExtension::Extension, "tt:NetworkInterfaceSetConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *d, tt__NetworkInterfaceSetConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceSetConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceSetConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &d->tt__NetworkInterfaceSetConfigurationExtension::Dot3, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_dup_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &d->tt__NetworkInterfaceSetConfigurationExtension::Dot11, &a->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	soap_dup_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, &d->tt__NetworkInterfaceSetConfigurationExtension::Extension, &a->tt__NetworkInterfaceSetConfigurationExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceSetConfigurationExtension(tt__NetworkInterfaceSetConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__Dot3Configuration(&a->tt__NetworkInterfaceSetConfigurationExtension::Dot3);
	soap_del_std__vectorTemplateOfPointerTott__Dot11Configuration(&a->tt__NetworkInterfaceSetConfigurationExtension::Dot11);
	soap_del_PointerTott__NetworkInterfaceSetConfigurationExtension2(&a->tt__NetworkInterfaceSetConfigurationExtension::Extension);
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfigurationExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceSetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__NetworkInterfaceSetConfiguration::Enabled = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Link = NULL;
	this->tt__NetworkInterfaceSetConfiguration::MTU = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv4 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::IPv6 = NULL;
	this->tt__NetworkInterfaceSetConfiguration::Extension = NULL;
}

void tt__NetworkInterfaceSetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceSetConfiguration::Link);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &this->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &this->tt__NetworkInterfaceSetConfiguration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceSetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration), type ? type : "tt:NetworkInterfaceSetConfiguration"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Enabled", -1, &a->tt__NetworkInterfaceSetConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", -1, &a->tt__NetworkInterfaceSetConfiguration::Link, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceSetConfiguration::MTU, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", -1, &a->tt__NetworkInterfaceSetConfiguration::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceSetConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceSetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_in_tt__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceSetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceSetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceSetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_MTU1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Enabled", &a->tt__NetworkInterfaceSetConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:Link", &a->tt__NetworkInterfaceSetConfiguration::Link, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceSetConfiguration::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, "tt:IPv4", &a->tt__NetworkInterfaceSetConfiguration::IPv4, "tt:IPv4NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, "tt:IPv6", &a->tt__NetworkInterfaceSetConfiguration::IPv6, "tt:IPv6NetworkInterfaceSetConfiguration"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, "tt:Extension", &a->tt__NetworkInterfaceSetConfiguration::Extension, "tt:NetworkInterfaceSetConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *d, tt__NetworkInterfaceSetConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceSetConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceSetConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__NetworkInterfaceSetConfiguration::Enabled, &a->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_dup_PointerTott__NetworkInterfaceConnectionSetting(soap, &d->tt__NetworkInterfaceSetConfiguration::Link, &a->tt__NetworkInterfaceSetConfiguration::Link);
	soap_dup_PointerToint(soap, &d->tt__NetworkInterfaceSetConfiguration::MTU, &a->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_dup_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, &d->tt__NetworkInterfaceSetConfiguration::IPv4, &a->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_dup_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, &d->tt__NetworkInterfaceSetConfiguration::IPv6, &a->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_dup_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, &d->tt__NetworkInterfaceSetConfiguration::Extension, &a->tt__NetworkInterfaceSetConfiguration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceSetConfiguration(tt__NetworkInterfaceSetConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__NetworkInterfaceSetConfiguration::Enabled);
	soap_del_PointerTott__NetworkInterfaceConnectionSetting(&a->tt__NetworkInterfaceSetConfiguration::Link);
	soap_del_PointerToint(&a->tt__NetworkInterfaceSetConfiguration::MTU);
	soap_del_PointerTott__IPv4NetworkInterfaceSetConfiguration(&a->tt__NetworkInterfaceSetConfiguration::IPv4);
	soap_del_PointerTott__IPv6NetworkInterfaceSetConfiguration(&a->tt__NetworkInterfaceSetConfiguration::IPv6);
	soap_del_PointerTott__NetworkInterfaceSetConfigurationExtension(&a->tt__NetworkInterfaceSetConfiguration::Extension);
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceSetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceSetConfiguration *p;
	size_t k = sizeof(tt__NetworkInterfaceSetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceSetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceSetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceSetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceSetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceSetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceSetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC4 soap_get_tt__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__DynamicDNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DynamicDNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:DynamicDNSInformationExtension");
}

void *tt__DynamicDNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_in_tt__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DynamicDNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformationExtension)
		return (tt__DynamicDNSInformationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_dup_tt__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *d, tt__DynamicDNSInformationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DynamicDNSInformationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DynamicDNSInformationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DynamicDNSInformationExtension(tt__DynamicDNSInformationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformationExtension *p;
	size_t k = sizeof(tt__DynamicDNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension * SOAP_FMAC4 soap_get_tt__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DynamicDNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__DynamicDNSType(soap, &this->tt__DynamicDNSInformation::Type);
	this->tt__DynamicDNSInformation::Name = NULL;
	this->tt__DynamicDNSInformation::TTL = NULL;
	this->tt__DynamicDNSInformation::Extension = NULL;
}

void tt__DynamicDNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->tt__DynamicDNSInformation::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__DynamicDNSInformation::TTL);
	soap_serialize_PointerTott__DynamicDNSInformationExtension(soap, &this->tt__DynamicDNSInformation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DynamicDNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DynamicDNSInformation(struct soap *soap, const char *tag, int id, const tt__DynamicDNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DynamicDNSInformation), type ? type : "tt:DynamicDNSInformation"))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tt:Type", -1, &a->tt__DynamicDNSInformation::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:Name", -1, &a->tt__DynamicDNSInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:TTL", -1, &a->tt__DynamicDNSInformation::TTL, ""))
		return soap->error;
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DynamicDNSInformation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DynamicDNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DynamicDNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_in_tt__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DynamicDNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DynamicDNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DynamicDNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tt:Type", &a->tt__DynamicDNSInformation::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:Name", &a->tt__DynamicDNSInformation::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:TTL", &a->tt__DynamicDNSInformation::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformationExtension(soap, "tt:Extension", &a->tt__DynamicDNSInformation::Extension, "tt:DynamicDNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DynamicDNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DynamicDNSInformation, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_dup_tt__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *d, tt__DynamicDNSInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DynamicDNSInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DynamicDNSInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DynamicDNSInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__DynamicDNSInformation::Type = a->tt__DynamicDNSInformation::Type;
	soap_dup_PointerTott__DNSName(soap, &d->tt__DynamicDNSInformation::Name, &a->tt__DynamicDNSInformation::Name);
	soap_dup_PointerToxsd__duration(soap, &d->tt__DynamicDNSInformation::TTL, &a->tt__DynamicDNSInformation::TTL);
	soap_dup_PointerTott__DynamicDNSInformationExtension(soap, &d->tt__DynamicDNSInformation::Extension, &a->tt__DynamicDNSInformation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DynamicDNSInformation(tt__DynamicDNSInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_PointerTott__DNSName(&a->tt__DynamicDNSInformation::Name);
	soap_del_PointerToxsd__duration(&a->tt__DynamicDNSInformation::TTL);
	soap_del_PointerTott__DynamicDNSInformationExtension(&a->tt__DynamicDNSInformation::Extension);
}

SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DynamicDNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DynamicDNSInformation *p;
	size_t k = sizeof(tt__DynamicDNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DynamicDNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DynamicDNSInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DynamicDNSInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DynamicDNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DynamicDNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DynamicDNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DynamicDNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DynamicDNSInformation * SOAP_FMAC4 soap_get_tt__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NTPInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NTPInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformationExtension(struct soap *soap, const char *tag, int id, const tt__NTPInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NTPInformationExtension");
}

void *tt__NTPInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_in_tt__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NTPInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformationExtension)
		return (tt__NTPInformationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_dup_tt__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *d, tt__NTPInformationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NTPInformationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NTPInformationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NTPInformationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NTPInformationExtension(tt__NTPInformationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformationExtension *p;
	size_t k = sizeof(tt__NTPInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformationExtension * SOAP_FMAC4 soap_get_tt__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NTPInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__NTPInformation::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	this->tt__NTPInformation::Extension = NULL;
}

void tt__NTPInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NTPInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->tt__NTPInformation::NTPManual);
	soap_serialize_PointerTott__NTPInformationExtension(soap, &this->tt__NTPInformation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NTPInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NTPInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NTPInformation(struct soap *soap, const char *tag, int id, const tt__NTPInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NTPInformation), type ? type : "tt:NTPInformation"))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__NTPInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", -1, &a->tt__NTPInformation::NTPFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", -1, &a->tt__NTPInformation::NTPManual, ""))
		return soap->error;
	if (soap_out_PointerTott__NTPInformationExtension(soap, "tt:Extension", -1, &a->tt__NTPInformation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NTPInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NTPInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_in_tt__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NTPInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NTPInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NTPInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__NTPInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPFromDHCP", &a->tt__NTPInformation::NTPFromDHCP, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tt:NTPManual", &a->tt__NTPInformation::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformationExtension(soap, "tt:Extension", &a->tt__NTPInformation::Extension, "tt:NTPInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NTPInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NTPInformation, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_dup_tt__NTPInformation(struct soap *soap, tt__NTPInformation *d, tt__NTPInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NTPInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NTPInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NTPInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NTPInformation::FromDHCP = a->tt__NTPInformation::FromDHCP;
	soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(soap, &d->tt__NTPInformation::NTPFromDHCP, &a->tt__NTPInformation::NTPFromDHCP);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(soap, &d->tt__NTPInformation::NTPManual, &a->tt__NTPInformation::NTPManual);
	soap_dup_PointerTott__NTPInformationExtension(soap, &d->tt__NTPInformation::Extension, &a->tt__NTPInformation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NTPInformation(tt__NTPInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* FromDHCP skipped */
	soap_del_std__vectorTemplateOfPointerTott__NetworkHost(&a->tt__NTPInformation::NTPFromDHCP);
	soap_del_std__vectorTemplateOfPointerTott__NetworkHost(&a->tt__NTPInformation::NTPManual);
	soap_del_PointerTott__NTPInformationExtension(&a->tt__NTPInformation::Extension);
}

SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NTPInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NTPInformation *p;
	size_t k = sizeof(tt__NTPInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NTPInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NTPInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NTPInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NTPInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NTPInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NTPInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NTPInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__NTPInformation * SOAP_FMAC4 soap_get_tt__NTPInformation(struct soap *soap, tt__NTPInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__DNSInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DNSInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformationExtension(struct soap *soap, const char *tag, int id, const tt__DNSInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:DNSInformationExtension");
}

void *tt__DNSInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_in_tt__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DNSInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformationExtension)
		return (tt__DNSInformationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_dup_tt__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *d, tt__DNSInformationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DNSInformationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DNSInformationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DNSInformationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DNSInformationExtension(tt__DNSInformationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformationExtension *p;
	size_t k = sizeof(tt__DNSInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformationExtension * SOAP_FMAC4 soap_get_tt__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DNSInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__DNSInformation::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	this->tt__DNSInformation::Extension = NULL;
}

void tt__DNSInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DNSInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->tt__DNSInformation::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSFromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->tt__DNSInformation::DNSManual);
	soap_serialize_PointerTott__DNSInformationExtension(soap, &this->tt__DNSInformation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DNSInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DNSInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSInformation(struct soap *soap, const char *tag, int id, const tt__DNSInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DNSInformation), type ? type : "tt:DNSInformation"))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__DNSInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", -1, &a->tt__DNSInformation::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", -1, &a->tt__DNSInformation::DNSFromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", -1, &a->tt__DNSInformation::DNSManual, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSInformationExtension(soap, "tt:Extension", -1, &a->tt__DNSInformation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DNSInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DNSInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_in_tt__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DNSInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DNSInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DNSInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__DNSInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tt:SearchDomain", &a->tt__DNSInformation::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSFromDHCP", &a->tt__DNSInformation::DNSFromDHCP, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tt:DNSManual", &a->tt__DNSInformation::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformationExtension(soap, "tt:Extension", &a->tt__DNSInformation::Extension, "tt:DNSInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DNSInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DNSInformation, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_dup_tt__DNSInformation(struct soap *soap, tt__DNSInformation *d, tt__DNSInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DNSInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DNSInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DNSInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__DNSInformation::FromDHCP = a->tt__DNSInformation::FromDHCP;
	soap_dup_std__vectorTemplateOfxsd__token(soap, &d->tt__DNSInformation::SearchDomain, &a->tt__DNSInformation::SearchDomain);
	soap_dup_std__vectorTemplateOfPointerTott__IPAddress(soap, &d->tt__DNSInformation::DNSFromDHCP, &a->tt__DNSInformation::DNSFromDHCP);
	soap_dup_std__vectorTemplateOfPointerTott__IPAddress(soap, &d->tt__DNSInformation::DNSManual, &a->tt__DNSInformation::DNSManual);
	soap_dup_PointerTott__DNSInformationExtension(soap, &d->tt__DNSInformation::Extension, &a->tt__DNSInformation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DNSInformation(tt__DNSInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* FromDHCP skipped */
	soap_del_std__vectorTemplateOfxsd__token(&a->tt__DNSInformation::SearchDomain);
	soap_del_std__vectorTemplateOfPointerTott__IPAddress(&a->tt__DNSInformation::DNSFromDHCP);
	soap_del_std__vectorTemplateOfPointerTott__IPAddress(&a->tt__DNSInformation::DNSManual);
	soap_del_PointerTott__DNSInformationExtension(&a->tt__DNSInformation::Extension);
}

SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DNSInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DNSInformation *p;
	size_t k = sizeof(tt__DNSInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DNSInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DNSInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DNSInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DNSInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DNSInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DNSInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DNSInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__DNSInformation * SOAP_FMAC4 soap_get_tt__DNSInformation(struct soap *soap, tt__DNSInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__HostnameInformationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__HostnameInformationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformationExtension(struct soap *soap, const char *tag, int id, const tt__HostnameInformationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:HostnameInformationExtension");
}

void *tt__HostnameInformationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_in_tt__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__HostnameInformationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformationExtension)
		return (tt__HostnameInformationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_dup_tt__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *d, tt__HostnameInformationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__HostnameInformationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__HostnameInformationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__HostnameInformationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__HostnameInformationExtension(tt__HostnameInformationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformationExtension *p;
	size_t k = sizeof(tt__HostnameInformationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformationExtension * SOAP_FMAC4 soap_get_tt__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__HostnameInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__HostnameInformation::FromDHCP);
	this->tt__HostnameInformation::Name = NULL;
	this->tt__HostnameInformation::Extension = NULL;
}

void tt__HostnameInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__HostnameInformation::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_PointerToxsd__token(soap, &this->tt__HostnameInformation::Name);
	soap_serialize_PointerTott__HostnameInformationExtension(soap, &this->tt__HostnameInformation::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__HostnameInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__HostnameInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HostnameInformation(struct soap *soap, const char *tag, int id, const tt__HostnameInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__HostnameInformation), type ? type : "tt:HostnameInformation"))
		return soap->error;
	if (soap_out_bool(soap, "tt:FromDHCP", -1, &a->tt__HostnameInformation::FromDHCP, ""))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tt:Name", -1, &a->tt__HostnameInformation::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__HostnameInformationExtension(soap, "tt:Extension", -1, &a->tt__HostnameInformation::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__HostnameInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__HostnameInformation(soap, tag, this, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_in_tt__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__HostnameInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__HostnameInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__HostnameInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:FromDHCP", &a->tt__HostnameInformation::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tt:Name", &a->tt__HostnameInformation::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformationExtension(soap, "tt:Extension", &a->tt__HostnameInformation::Extension, "tt:HostnameInformationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__HostnameInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__HostnameInformation, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_dup_tt__HostnameInformation(struct soap *soap, tt__HostnameInformation *d, tt__HostnameInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__HostnameInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__HostnameInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__HostnameInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__HostnameInformation::FromDHCP = a->tt__HostnameInformation::FromDHCP;
	soap_dup_PointerToxsd__token(soap, &d->tt__HostnameInformation::Name, &a->tt__HostnameInformation::Name);
	soap_dup_PointerTott__HostnameInformationExtension(soap, &d->tt__HostnameInformation::Extension, &a->tt__HostnameInformation::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__HostnameInformation(tt__HostnameInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* FromDHCP skipped */
	soap_del_PointerToxsd__token(&a->tt__HostnameInformation::Name);
	soap_del_PointerTott__HostnameInformationExtension(&a->tt__HostnameInformation::Extension);
}

SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__HostnameInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__HostnameInformation *p;
	size_t k = sizeof(tt__HostnameInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__HostnameInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__HostnameInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__HostnameInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__HostnameInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__HostnameInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__HostnameInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__HostnameInformation(soap, this, tag, type);
}

SOAP_FMAC3 tt__HostnameInformation * SOAP_FMAC4 soap_get_tt__HostnameInformation(struct soap *soap, tt__HostnameInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv6Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv6Address::PrefixLength);
}

void tt__PrefixedIPv6Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::Address, SOAP_TYPE_tt__IPv6Address);
	soap_serialize_tt__IPv6Address(soap, &this->tt__PrefixedIPv6Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv6Address::PrefixLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PrefixedIPv6Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv6Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv6Address), type ? type : "tt:PrefixedIPv6Address"))
		return soap->error;
	if (soap_out_tt__IPv6Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv6Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv6Address::PrefixLength, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv6Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv6Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv6Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv6Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv6Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv6Address(soap, "tt:Address", &a->tt__PrefixedIPv6Address::Address, "tt:IPv6Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv6Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv6Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv6Address, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_dup_tt__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *d, tt__PrefixedIPv6Address const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PrefixedIPv6Address*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PrefixedIPv6Address, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PrefixedIPv6Address(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__IPv6Address(soap, &d->tt__PrefixedIPv6Address::Address, &a->tt__PrefixedIPv6Address::Address);
	d->tt__PrefixedIPv6Address::PrefixLength = a->tt__PrefixedIPv6Address::PrefixLength;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PrefixedIPv6Address(tt__PrefixedIPv6Address const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__IPv6Address(&a->tt__PrefixedIPv6Address::Address);
	/* PrefixLength skipped */
}

SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv6Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv6Address *p;
	size_t k = sizeof(tt__PrefixedIPv6Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv6Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv6Address);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv6Address, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv6Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv6Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv6Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv6Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv6Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PrefixedIPv4Address::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_default_int(soap, &this->tt__PrefixedIPv4Address::PrefixLength);
}

void tt__PrefixedIPv4Address::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::Address, SOAP_TYPE_tt__IPv4Address);
	soap_serialize_tt__IPv4Address(soap, &this->tt__PrefixedIPv4Address::Address);
	soap_embedded(soap, &this->tt__PrefixedIPv4Address::PrefixLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PrefixedIPv4Address::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, const tt__PrefixedIPv4Address *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PrefixedIPv4Address), type ? type : "tt:PrefixedIPv4Address"))
		return soap->error;
	if (soap_out_tt__IPv4Address(soap, "tt:Address", -1, &a->tt__PrefixedIPv4Address::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:PrefixLength", -1, &a->tt__PrefixedIPv4Address::PrefixLength, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PrefixedIPv4Address::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PrefixedIPv4Address(soap, tag, this, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_in_tt__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PrefixedIPv4Address*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PrefixedIPv4Address)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PrefixedIPv4Address *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_PrefixLength1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__IPv4Address(soap, "tt:Address", &a->tt__PrefixedIPv4Address::Address, "tt:IPv4Address"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_PrefixLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:PrefixLength", &a->tt__PrefixedIPv4Address::PrefixLength, "xsd:int"))
				{	soap_flag_PrefixLength1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Address1 > 0 || soap_flag_PrefixLength1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PrefixedIPv4Address *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PrefixedIPv4Address, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_dup_tt__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *d, tt__PrefixedIPv4Address const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PrefixedIPv4Address*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PrefixedIPv4Address, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PrefixedIPv4Address(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__IPv4Address(soap, &d->tt__PrefixedIPv4Address::Address, &a->tt__PrefixedIPv4Address::Address);
	d->tt__PrefixedIPv4Address::PrefixLength = a->tt__PrefixedIPv4Address::PrefixLength;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PrefixedIPv4Address(tt__PrefixedIPv4Address const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__IPv4Address(&a->tt__PrefixedIPv4Address::Address);
	/* PrefixLength skipped */
}

SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PrefixedIPv4Address(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PrefixedIPv4Address *p;
	size_t k = sizeof(tt__PrefixedIPv4Address);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PrefixedIPv4Address, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PrefixedIPv4Address);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PrefixedIPv4Address, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PrefixedIPv4Address location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PrefixedIPv4Address::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PrefixedIPv4Address::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PrefixedIPv4Address(soap, this, tag, type);
}

SOAP_FMAC3 tt__PrefixedIPv4Address * SOAP_FMAC4 soap_get_tt__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPAddress::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IPType(soap, &this->tt__IPAddress::Type);
	this->tt__IPAddress::IPv4Address = NULL;
	this->tt__IPAddress::IPv6Address = NULL;
}

void tt__IPAddress::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__IPAddress::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__IPAddress::IPv6Address);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPAddress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPAddress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPAddress(struct soap *soap, const char *tag, int id, const tt__IPAddress *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPAddress), type ? type : "tt:IPAddress"))
		return soap->error;
	if (soap_out_tt__IPType(soap, "tt:Type", -1, &a->tt__IPAddress::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__IPAddress::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__IPAddress::IPv6Address, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPAddress::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPAddress(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_in_tt__IPAddress(struct soap *soap, const char *tag, tt__IPAddress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPAddress*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPAddress)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPAddress *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPType(soap, "tt:Type", &a->tt__IPAddress::Type, "tt:IPType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__IPAddress::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__IPAddress::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPAddress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPAddress, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_dup_tt__IPAddress(struct soap *soap, tt__IPAddress *d, tt__IPAddress const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPAddress*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPAddress, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPAddress(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IPAddress::Type = a->tt__IPAddress::Type;
	soap_dup_PointerTott__IPv4Address(soap, &d->tt__IPAddress::IPv4Address, &a->tt__IPAddress::IPv4Address);
	soap_dup_PointerTott__IPv6Address(soap, &d->tt__IPAddress::IPv6Address, &a->tt__IPAddress::IPv6Address);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPAddress(tt__IPAddress const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_PointerTott__IPv4Address(&a->tt__IPAddress::IPv4Address);
	soap_del_PointerTott__IPv6Address(&a->tt__IPAddress::IPv6Address);
}

SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPAddress(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPAddress *p;
	size_t k = sizeof(tt__IPAddress);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPAddress, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPAddress);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPAddress, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPAddress location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPAddress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPAddress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPAddress(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPAddress * SOAP_FMAC4 soap_get_tt__IPAddress(struct soap *soap, tt__IPAddress *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHostExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkHostExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkHostExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHostExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHostExtension(struct soap *soap, const char *tag, int id, const tt__NetworkHostExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkHostExtension");
}

void *tt__NetworkHostExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHostExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_in_tt__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkHostExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHostExtension)
		return (tt__NetworkHostExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_dup_tt__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *d, tt__NetworkHostExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkHostExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkHostExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkHostExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkHostExtension(tt__NetworkHostExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHostExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHostExtension *p;
	size_t k = sizeof(tt__NetworkHostExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHostExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHostExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHostExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHostExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHostExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHostExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHostExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHostExtension * SOAP_FMAC4 soap_get_tt__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkHost::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__NetworkHostType(soap, &this->tt__NetworkHost::Type);
	this->tt__NetworkHost::IPv4Address = NULL;
	this->tt__NetworkHost::IPv6Address = NULL;
	this->tt__NetworkHost::DNSname = NULL;
	this->tt__NetworkHost::Extension = NULL;
}

void tt__NetworkHost::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPv4Address(soap, &this->tt__NetworkHost::IPv4Address);
	soap_serialize_PointerTott__IPv6Address(soap, &this->tt__NetworkHost::IPv6Address);
	soap_serialize_PointerTott__DNSName(soap, &this->tt__NetworkHost::DNSname);
	soap_serialize_PointerTott__NetworkHostExtension(soap, &this->tt__NetworkHost::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkHost::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkHost(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkHost(struct soap *soap, const char *tag, int id, const tt__NetworkHost *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkHost), type ? type : "tt:NetworkHost"))
		return soap->error;
	if (soap_out_tt__NetworkHostType(soap, "tt:Type", -1, &a->tt__NetworkHost::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4Address(soap, "tt:IPv4Address", -1, &a->tt__NetworkHost::IPv4Address, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Address(soap, "tt:IPv6Address", -1, &a->tt__NetworkHost::IPv6Address, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tt:DNSname", -1, &a->tt__NetworkHost::DNSname, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkHostExtension(soap, "tt:Extension", -1, &a->tt__NetworkHost::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkHost::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkHost(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_in_tt__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkHost*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkHost)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkHost *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_IPv4Address1 = 1;
	size_t soap_flag_IPv6Address1 = 1;
	size_t soap_flag_DNSname1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkHostType(soap, "tt:Type", &a->tt__NetworkHost::Type, "tt:NetworkHostType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_IPv4Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv4Address(soap, "tt:IPv4Address", &a->tt__NetworkHost::IPv4Address, "tt:IPv4Address"))
				{	soap_flag_IPv4Address1--;
					continue;
				}
			}
			if (soap_flag_IPv6Address1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__IPv6Address(soap, "tt:IPv6Address", &a->tt__NetworkHost::IPv6Address, "tt:IPv6Address"))
				{	soap_flag_IPv6Address1--;
					continue;
				}
			}
			if (soap_flag_DNSname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tt:DNSname", &a->tt__NetworkHost::DNSname, "tt:DNSName"))
				{	soap_flag_DNSname1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkHostExtension(soap, "tt:Extension", &a->tt__NetworkHost::Extension, "tt:NetworkHostExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkHost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkHost, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_dup_tt__NetworkHost(struct soap *soap, tt__NetworkHost *d, tt__NetworkHost const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkHost*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkHost, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkHost(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NetworkHost::Type = a->tt__NetworkHost::Type;
	soap_dup_PointerTott__IPv4Address(soap, &d->tt__NetworkHost::IPv4Address, &a->tt__NetworkHost::IPv4Address);
	soap_dup_PointerTott__IPv6Address(soap, &d->tt__NetworkHost::IPv6Address, &a->tt__NetworkHost::IPv6Address);
	soap_dup_PointerTott__DNSName(soap, &d->tt__NetworkHost::DNSname, &a->tt__NetworkHost::DNSname);
	soap_dup_PointerTott__NetworkHostExtension(soap, &d->tt__NetworkHost::Extension, &a->tt__NetworkHost::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkHost(tt__NetworkHost const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Type skipped */
	soap_del_PointerTott__IPv4Address(&a->tt__NetworkHost::IPv4Address);
	soap_del_PointerTott__IPv6Address(&a->tt__NetworkHost::IPv6Address);
	soap_del_PointerTott__DNSName(&a->tt__NetworkHost::DNSname);
	soap_del_PointerTott__NetworkHostExtension(&a->tt__NetworkHost::Extension);
}

SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkHost(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkHost *p;
	size_t k = sizeof(tt__NetworkHost);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkHost, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkHost);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkHost, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkHost location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkHost::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkHost::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkHost(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkHost * SOAP_FMAC4 soap_get_tt__NetworkHost(struct soap *soap, tt__NetworkHost *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocolExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkProtocolExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkProtocolExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, const tt__NetworkProtocolExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkProtocolExtension");
}

void *tt__NetworkProtocolExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocolExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_in_tt__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkProtocolExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocolExtension)
		return (tt__NetworkProtocolExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_dup_tt__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *d, tt__NetworkProtocolExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkProtocolExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkProtocolExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkProtocolExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkProtocolExtension(tt__NetworkProtocolExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocolExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocolExtension *p;
	size_t k = sizeof(tt__NetworkProtocolExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocolExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocolExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocolExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocolExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocolExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocolExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocolExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocolExtension * SOAP_FMAC4 soap_get_tt__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkProtocol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__NetworkProtocolType(soap, &this->tt__NetworkProtocol::Name);
	soap_default_bool(soap, &this->tt__NetworkProtocol::Enabled);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	this->tt__NetworkProtocol::Extension = NULL;
}

void tt__NetworkProtocol::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkProtocol::Enabled, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__NetworkProtocol::Port);
	soap_serialize_PointerTott__NetworkProtocolExtension(soap, &this->tt__NetworkProtocol::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkProtocol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkProtocol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkProtocol(struct soap *soap, const char *tag, int id, const tt__NetworkProtocol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkProtocol), type ? type : "tt:NetworkProtocol"))
		return soap->error;
	if (soap_out_tt__NetworkProtocolType(soap, "tt:Name", -1, &a->tt__NetworkProtocol::Name, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkProtocol::Enabled, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Port", -1, &a->tt__NetworkProtocol::Port, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", -1, &a->tt__NetworkProtocol::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkProtocol::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkProtocol(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_in_tt__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkProtocol*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkProtocol)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkProtocol *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__NetworkProtocolType(soap, "tt:Name", &a->tt__NetworkProtocol::Name, "tt:NetworkProtocolType"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkProtocol::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:Port", &a->tt__NetworkProtocol::Port, "xsd:int"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkProtocolExtension(soap, "tt:Extension", &a->tt__NetworkProtocol::Extension, "tt:NetworkProtocolExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name1 > 0 || soap_flag_Enabled1 > 0 || a->tt__NetworkProtocol::Port.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkProtocol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkProtocol, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_dup_tt__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *d, tt__NetworkProtocol const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkProtocol*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkProtocol, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkProtocol(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NetworkProtocol::Name = a->tt__NetworkProtocol::Name;
	d->tt__NetworkProtocol::Enabled = a->tt__NetworkProtocol::Enabled;
	soap_dup_std__vectorTemplateOfint(soap, &d->tt__NetworkProtocol::Port, &a->tt__NetworkProtocol::Port);
	soap_dup_PointerTott__NetworkProtocolExtension(soap, &d->tt__NetworkProtocol::Extension, &a->tt__NetworkProtocol::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkProtocol(tt__NetworkProtocol const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Name skipped */
	/* Enabled skipped */
	soap_del_std__vectorTemplateOfint(&a->tt__NetworkProtocol::Port);
	soap_del_PointerTott__NetworkProtocolExtension(&a->tt__NetworkProtocol::Extension);
}

SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkProtocol(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkProtocol *p;
	size_t k = sizeof(tt__NetworkProtocol);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkProtocol, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkProtocol);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkProtocol, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkProtocol location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkProtocol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkProtocol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkProtocol(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkProtocol * SOAP_FMAC4 soap_get_tt__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6ConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__IPv6ConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv6ConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IPv6ConfigurationExtension");
}

void *tt__IPv6ConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6ConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_in_tt__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IPv6ConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6ConfigurationExtension)
		return (tt__IPv6ConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_dup_tt__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *d, tt__IPv6ConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv6ConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv6ConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv6ConfigurationExtension(tt__IPv6ConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6ConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6ConfigurationExtension *p;
	size_t k = sizeof(tt__IPv6ConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6ConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6ConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6ConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6ConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6ConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6ConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6ConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension * SOAP_FMAC4 soap_get_tt__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IPv6Configuration::AcceptRouterAdvert = NULL;
	soap_default_tt__IPv6DHCPConfiguration(soap, &this->tt__IPv6Configuration::DHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	this->tt__IPv6Configuration::Extension = NULL;
}

void tt__IPv6Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTobool(soap, &this->tt__IPv6Configuration::AcceptRouterAdvert);
	soap_embedded(soap, &this->tt__IPv6Configuration::DHCP, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::Manual);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::LinkLocal);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromDHCP);
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &this->tt__IPv6Configuration::FromRA);
	soap_serialize_PointerTott__IPv6ConfigurationExtension(soap, &this->tt__IPv6Configuration::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv6Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Configuration(struct soap *soap, const char *tag, int id, const tt__IPv6Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6Configuration), type ? type : "tt:IPv6Configuration"))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:AcceptRouterAdvert", -1, &a->tt__IPv6Configuration::AcceptRouterAdvert, ""))
		return soap->error;
	if (soap_out_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", -1, &a->tt__IPv6Configuration::DHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", -1, &a->tt__IPv6Configuration::Manual, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", -1, &a->tt__IPv6Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", -1, &a->tt__IPv6Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", -1, &a->tt__IPv6Configuration::FromRA, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", -1, &a->tt__IPv6Configuration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_in_tt__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AcceptRouterAdvert1 = 1;
	size_t soap_flag_DHCP1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AcceptRouterAdvert1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:AcceptRouterAdvert", &a->tt__IPv6Configuration::AcceptRouterAdvert, "xsd:boolean"))
				{	soap_flag_AcceptRouterAdvert1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IPv6DHCPConfiguration(soap, "tt:DHCP", &a->tt__IPv6Configuration::DHCP, "tt:IPv6DHCPConfiguration"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:Manual", &a->tt__IPv6Configuration::Manual, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:LinkLocal", &a->tt__IPv6Configuration::LinkLocal, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromDHCP", &a->tt__IPv6Configuration::FromDHCP, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, "tt:FromRA", &a->tt__IPv6Configuration::FromRA, "tt:PrefixedIPv6Address"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6ConfigurationExtension(soap, "tt:Extension", &a->tt__IPv6Configuration::Extension, "tt:IPv6ConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6Configuration, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_dup_tt__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *d, tt__IPv6Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv6Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv6Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv6Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tt__IPv6Configuration::AcceptRouterAdvert, &a->tt__IPv6Configuration::AcceptRouterAdvert);
	d->tt__IPv6Configuration::DHCP = a->tt__IPv6Configuration::DHCP;
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPv6Configuration::Manual, &a->tt__IPv6Configuration::Manual);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPv6Configuration::LinkLocal, &a->tt__IPv6Configuration::LinkLocal);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPv6Configuration::FromDHCP, &a->tt__IPv6Configuration::FromDHCP);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(soap, &d->tt__IPv6Configuration::FromRA, &a->tt__IPv6Configuration::FromRA);
	soap_dup_PointerTott__IPv6ConfigurationExtension(soap, &d->tt__IPv6Configuration::Extension, &a->tt__IPv6Configuration::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv6Configuration(tt__IPv6Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tt__IPv6Configuration::AcceptRouterAdvert);
	/* DHCP skipped */
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPv6Configuration::Manual);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPv6Configuration::LinkLocal);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPv6Configuration::FromDHCP);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv6Address(&a->tt__IPv6Configuration::FromRA);
	soap_del_PointerTott__IPv6ConfigurationExtension(&a->tt__IPv6Configuration::Extension);
}

SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6Configuration *p;
	size_t k = sizeof(tt__IPv6Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6Configuration * SOAP_FMAC4 soap_get_tt__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	this->tt__IPv4Configuration::LinkLocal = NULL;
	this->tt__IPv4Configuration::FromDHCP = NULL;
	soap_default_bool(soap, &this->tt__IPv4Configuration::DHCP);
}

void tt__IPv4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::Manual);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::LinkLocal);
	soap_serialize_PointerTott__PrefixedIPv4Address(soap, &this->tt__IPv4Configuration::FromDHCP);
	soap_embedded(soap, &this->tt__IPv4Configuration::DHCP, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Configuration(struct soap *soap, const char *tag, int id, const tt__IPv4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4Configuration), type ? type : "tt:IPv4Configuration"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", -1, &a->tt__IPv4Configuration::Manual, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", -1, &a->tt__IPv4Configuration::LinkLocal, ""))
		return soap->error;
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", -1, &a->tt__IPv4Configuration::FromDHCP, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:DHCP", -1, &a->tt__IPv4Configuration::DHCP, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_in_tt__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_LinkLocal1 = 1;
	size_t soap_flag_FromDHCP1 = 1;
	size_t soap_flag_DHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, "tt:Manual", &a->tt__IPv4Configuration::Manual, "tt:PrefixedIPv4Address"))
					continue;
			}
			if (soap_flag_LinkLocal1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:LinkLocal", &a->tt__IPv4Configuration::LinkLocal, "tt:PrefixedIPv4Address"))
				{	soap_flag_LinkLocal1--;
					continue;
				}
			}
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PrefixedIPv4Address(soap, "tt:FromDHCP", &a->tt__IPv4Configuration::FromDHCP, "tt:PrefixedIPv4Address"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap_flag_DHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:DHCP", &a->tt__IPv4Configuration::DHCP, "xsd:boolean"))
				{	soap_flag_DHCP1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4Configuration, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_dup_tt__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *d, tt__IPv4Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv4Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv4Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv4Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(soap, &d->tt__IPv4Configuration::Manual, &a->tt__IPv4Configuration::Manual);
	soap_dup_PointerTott__PrefixedIPv4Address(soap, &d->tt__IPv4Configuration::LinkLocal, &a->tt__IPv4Configuration::LinkLocal);
	soap_dup_PointerTott__PrefixedIPv4Address(soap, &d->tt__IPv4Configuration::FromDHCP, &a->tt__IPv4Configuration::FromDHCP);
	d->tt__IPv4Configuration::DHCP = a->tt__IPv4Configuration::DHCP;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv4Configuration(tt__IPv4Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__PrefixedIPv4Address(&a->tt__IPv4Configuration::Manual);
	soap_del_PointerTott__PrefixedIPv4Address(&a->tt__IPv4Configuration::LinkLocal);
	soap_del_PointerTott__PrefixedIPv4Address(&a->tt__IPv4Configuration::FromDHCP);
	/* DHCP skipped */
}

SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4Configuration *p;
	size_t k = sizeof(tt__IPv4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4Configuration * SOAP_FMAC4 soap_get_tt__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv4NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__IPv4NetworkInterface::Enabled);
	this->tt__IPv4NetworkInterface::Config = NULL;
}

void tt__IPv4NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv4NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv4Configuration(soap, &this->tt__IPv4NetworkInterface::Config);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv4NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv4NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv4NetworkInterface), type ? type : "tt:IPv4NetworkInterface"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv4NetworkInterface::Enabled, ""))
		return soap->error;
	if (!a->tt__IPv4NetworkInterface::Config)
	{	if (soap_element_empty(soap, "tt:Config", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPv4Configuration(soap, "tt:Config", -1, &a->tt__IPv4NetworkInterface::Config, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv4NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv4NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv4NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv4NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv4NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv4NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4Configuration(soap, "tt:Config", &a->tt__IPv4NetworkInterface::Config, "tt:IPv4Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0 || !a->tt__IPv4NetworkInterface::Config))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv4NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv4NetworkInterface, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_dup_tt__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *d, tt__IPv4NetworkInterface const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv4NetworkInterface*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv4NetworkInterface, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv4NetworkInterface(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IPv4NetworkInterface::Enabled = a->tt__IPv4NetworkInterface::Enabled;
	soap_dup_PointerTott__IPv4Configuration(soap, &d->tt__IPv4NetworkInterface::Config, &a->tt__IPv4NetworkInterface::Config);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv4NetworkInterface(tt__IPv4NetworkInterface const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Enabled skipped */
	soap_del_PointerTott__IPv4Configuration(&a->tt__IPv4NetworkInterface::Config);
}

SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv4NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv4NetworkInterface *p;
	size_t k = sizeof(tt__IPv4NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv4NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv4NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv4NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv4NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv4NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv4NetworkInterface(soap, tag ? tag : "tt:IPv4NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv4NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv4NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IPv6NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__IPv6NetworkInterface::Enabled);
	this->tt__IPv6NetworkInterface::Config = NULL;
}

void tt__IPv6NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IPv6NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__IPv6Configuration(soap, &this->tt__IPv6NetworkInterface::Config);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IPv6NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, const tt__IPv6NetworkInterface *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IPv6NetworkInterface), type ? type : "tt:IPv6NetworkInterface"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__IPv6NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6Configuration(soap, "tt:Config", -1, &a->tt__IPv6NetworkInterface::Config, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IPv6NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IPv6NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_in_tt__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IPv6NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IPv6NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IPv6NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Config1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__IPv6NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Config1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6Configuration(soap, "tt:Config", &a->tt__IPv6NetworkInterface::Config, "tt:IPv6Configuration"))
				{	soap_flag_Config1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IPv6NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IPv6NetworkInterface, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_dup_tt__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *d, tt__IPv6NetworkInterface const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IPv6NetworkInterface*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IPv6NetworkInterface, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IPv6NetworkInterface(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IPv6NetworkInterface::Enabled = a->tt__IPv6NetworkInterface::Enabled;
	soap_dup_PointerTott__IPv6Configuration(soap, &d->tt__IPv6NetworkInterface::Config, &a->tt__IPv6NetworkInterface::Config);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IPv6NetworkInterface(tt__IPv6NetworkInterface const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Enabled skipped */
	soap_del_PointerTott__IPv6Configuration(&a->tt__IPv6NetworkInterface::Config);
}

SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IPv6NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IPv6NetworkInterface *p;
	size_t k = sizeof(tt__IPv6NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IPv6NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IPv6NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IPv6NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IPv6NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IPv6NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IPv6NetworkInterface(soap, tag ? tag : "tt:IPv6NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IPv6NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IPv6NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface * SOAP_FMAC4 soap_get_tt__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__NetworkInterfaceInfo::Name = NULL;
	soap_default_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	this->tt__NetworkInterfaceInfo::MTU = NULL;
}

void tt__NetworkInterfaceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__NetworkInterfaceInfo::Name);
	soap_serialize_tt__HwAddress(soap, &this->tt__NetworkInterfaceInfo::HwAddress);
	soap_serialize_PointerToint(soap, &this->tt__NetworkInterfaceInfo::MTU);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceInfo), type ? type : "tt:NetworkInterfaceInfo"))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Name", -1, &a->tt__NetworkInterfaceInfo::Name, ""))
		return soap->error;
	if (soap_out_tt__HwAddress(soap, "tt:HwAddress", -1, &a->tt__NetworkInterfaceInfo::HwAddress, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:MTU", -1, &a->tt__NetworkInterfaceInfo::MTU, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceInfo(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_in_tt__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceInfo*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceInfo)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceInfo *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_HwAddress1 = 1;
	size_t soap_flag_MTU1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Name", &a->tt__NetworkInterfaceInfo::Name, "xsd:string"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_HwAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__HwAddress(soap, "tt:HwAddress", &a->tt__NetworkInterfaceInfo::HwAddress, "tt:HwAddress"))
				{	soap_flag_HwAddress1--;
					continue;
				}
			}
			if (soap_flag_MTU1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:MTU", &a->tt__NetworkInterfaceInfo::MTU, "xsd:int"))
				{	soap_flag_MTU1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_HwAddress1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceInfo, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *d, tt__NetworkInterfaceInfo const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceInfo*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceInfo, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceInfo(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTostd__string(soap, &d->tt__NetworkInterfaceInfo::Name, &a->tt__NetworkInterfaceInfo::Name);
	soap_dup_tt__HwAddress(soap, &d->tt__NetworkInterfaceInfo::HwAddress, &a->tt__NetworkInterfaceInfo::HwAddress);
	soap_dup_PointerToint(soap, &d->tt__NetworkInterfaceInfo::MTU, &a->tt__NetworkInterfaceInfo::MTU);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceInfo(tt__NetworkInterfaceInfo const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTostd__string(&a->tt__NetworkInterfaceInfo::Name);
	soap_del_tt__HwAddress(&a->tt__NetworkInterfaceInfo::HwAddress);
	soap_del_PointerToint(&a->tt__NetworkInterfaceInfo::MTU);
}

SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceInfo(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceInfo *p;
	size_t k = sizeof(tt__NetworkInterfaceInfo);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceInfo, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceInfo);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceInfo, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceInfo location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceInfo(soap, tag ? tag : "tt:NetworkInterfaceInfo", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceInfo(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo * SOAP_FMAC4 soap_get_tt__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceConnectionSetting::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation);
	soap_default_int(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed);
	soap_default_tt__Duplex(soap, &this->tt__NetworkInterfaceConnectionSetting::Duplex);
}

void tt__NetworkInterfaceConnectionSetting::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__NetworkInterfaceConnectionSetting::Speed, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceConnectionSetting::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting), type ? type : "tt:NetworkInterfaceConnectionSetting"))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoNegotiation", -1, &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Speed", -1, &a->tt__NetworkInterfaceConnectionSetting::Speed, ""))
		return soap->error;
	if (soap_out_tt__Duplex(soap, "tt:Duplex", -1, &a->tt__NetworkInterfaceConnectionSetting::Duplex, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceConnectionSetting::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceConnectionSetting*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceConnectionSetting)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceConnectionSetting *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AutoNegotiation1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_Duplex1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoNegotiation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoNegotiation", &a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation, "xsd:boolean"))
				{	soap_flag_AutoNegotiation1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Speed", &a->tt__NetworkInterfaceConnectionSetting::Speed, "xsd:int"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_Duplex1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Duplex(soap, "tt:Duplex", &a->tt__NetworkInterfaceConnectionSetting::Duplex, "tt:Duplex"))
				{	soap_flag_Duplex1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_AutoNegotiation1 > 0 || soap_flag_Speed1 > 0 || soap_flag_Duplex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *d, tt__NetworkInterfaceConnectionSetting const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceConnectionSetting*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceConnectionSetting(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NetworkInterfaceConnectionSetting::AutoNegotiation = a->tt__NetworkInterfaceConnectionSetting::AutoNegotiation;
	d->tt__NetworkInterfaceConnectionSetting::Speed = a->tt__NetworkInterfaceConnectionSetting::Speed;
	d->tt__NetworkInterfaceConnectionSetting::Duplex = a->tt__NetworkInterfaceConnectionSetting::Duplex;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceConnectionSetting(tt__NetworkInterfaceConnectionSetting const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* AutoNegotiation skipped */
	/* Speed skipped */
	/* Duplex skipped */
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceConnectionSetting(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceConnectionSetting *p;
	size_t k = sizeof(tt__NetworkInterfaceConnectionSetting);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceConnectionSetting);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceConnectionSetting, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceConnectionSetting location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceConnectionSetting::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceConnectionSetting::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceConnectionSetting(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC4 soap_get_tt__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceLink::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__NetworkInterfaceLink::AdminSettings = NULL;
	this->tt__NetworkInterfaceLink::OperSettings = NULL;
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceLink::InterfaceType);
}

void tt__NetworkInterfaceLink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::AdminSettings);
	soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(soap, &this->tt__NetworkInterfaceLink::OperSettings);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceLink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceLink *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceLink), type ? type : "tt:NetworkInterfaceLink"))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::AdminSettings)
	{	if (soap_element_empty(soap, "tt:AdminSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", -1, &a->tt__NetworkInterfaceLink::AdminSettings, ""))
		return soap->error;
	if (!a->tt__NetworkInterfaceLink::OperSettings)
	{	if (soap_element_empty(soap, "tt:OperSettings", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", -1, &a->tt__NetworkInterfaceLink::OperSettings, ""))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceLink::InterfaceType, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceLink::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceLink(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_in_tt__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceLink*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceLink)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceLink *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AdminSettings1 = 1;
	size_t soap_flag_OperSettings1 = 1;
	size_t soap_flag_InterfaceType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AdminSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:AdminSettings", &a->tt__NetworkInterfaceLink::AdminSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_AdminSettings1--;
					continue;
				}
			}
			if (soap_flag_OperSettings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, "tt:OperSettings", &a->tt__NetworkInterfaceLink::OperSettings, "tt:NetworkInterfaceConnectionSetting"))
				{	soap_flag_OperSettings1--;
					continue;
				}
			}
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceLink::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__NetworkInterfaceLink::AdminSettings || !a->tt__NetworkInterfaceLink::OperSettings || soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceLink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceLink, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *d, tt__NetworkInterfaceLink const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceLink*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceLink, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceLink(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__NetworkInterfaceConnectionSetting(soap, &d->tt__NetworkInterfaceLink::AdminSettings, &a->tt__NetworkInterfaceLink::AdminSettings);
	soap_dup_PointerTott__NetworkInterfaceConnectionSetting(soap, &d->tt__NetworkInterfaceLink::OperSettings, &a->tt__NetworkInterfaceLink::OperSettings);
	d->tt__NetworkInterfaceLink::InterfaceType = a->tt__NetworkInterfaceLink::InterfaceType;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceLink(tt__NetworkInterfaceLink const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__NetworkInterfaceConnectionSetting(&a->tt__NetworkInterfaceLink::AdminSettings);
	soap_del_PointerTott__NetworkInterfaceConnectionSetting(&a->tt__NetworkInterfaceLink::OperSettings);
	/* InterfaceType skipped */
}

SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceLink(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceLink *p;
	size_t k = sizeof(tt__NetworkInterfaceLink);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceLink, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceLink);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceLink, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceLink location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceLink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceLink(soap, tag ? tag : "tt:NetworkInterfaceLink", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceLink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceLink(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink * SOAP_FMAC4 soap_get_tt__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__NetworkInterfaceExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:NetworkInterfaceExtension2");
}

void *tt__NetworkInterfaceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__NetworkInterfaceExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension2)
		return (tt__NetworkInterfaceExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *d, tt__NetworkInterfaceExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceExtension2(tt__NetworkInterfaceExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension2 *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Dot3Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__Dot3Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Dot3Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Dot3Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot3Configuration(struct soap *soap, const char *tag, int id, const tt__Dot3Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:Dot3Configuration");
}

void *tt__Dot3Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Dot3Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_in_tt__Dot3Configuration(struct soap *soap, const char *tag, tt__Dot3Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__Dot3Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Dot3Configuration)
		return (tt__Dot3Configuration *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_dup_tt__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *d, tt__Dot3Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Dot3Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Dot3Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Dot3Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Dot3Configuration(tt__Dot3Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Dot3Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Dot3Configuration *p;
	size_t k = sizeof(tt__Dot3Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Dot3Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Dot3Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Dot3Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Dot3Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Dot3Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Dot3Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Dot3Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Dot3Configuration * SOAP_FMAC4 soap_get_tt__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterfaceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__IANA_IfTypes(soap, &this->tt__NetworkInterfaceExtension::InterfaceType);
	soap_default_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_default_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	this->tt__NetworkInterfaceExtension::Extension = NULL;
}

void tt__NetworkInterfaceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot3);
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &this->tt__NetworkInterfaceExtension::Dot11);
	soap_serialize_PointerTott__NetworkInterfaceExtension2(soap, &this->tt__NetworkInterfaceExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__NetworkInterfaceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, const tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterfaceExtension), type ? type : "tt:NetworkInterfaceExtension"))
		return soap->error;
	if (soap_out_tt__IANA_IfTypes(soap, "tt:InterfaceType", -1, &a->tt__NetworkInterfaceExtension::InterfaceType, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", -1, &a->tt__NetworkInterfaceExtension::Dot3, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", -1, &a->tt__NetworkInterfaceExtension::Dot11, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", -1, &a->tt__NetworkInterfaceExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterfaceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterfaceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_in_tt__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterfaceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterfaceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterfaceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_InterfaceType1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__IANA_IfTypes(soap, "tt:InterfaceType", &a->tt__NetworkInterfaceExtension::InterfaceType, "tt:IANA-IfTypes"))
				{	soap_flag_InterfaceType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, "tt:Dot3", &a->tt__NetworkInterfaceExtension::Dot3, "tt:Dot3Configuration"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, "tt:Dot11", &a->tt__NetworkInterfaceExtension::Dot11, "tt:Dot11Configuration"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension2(soap, "tt:Extension", &a->tt__NetworkInterfaceExtension::Extension, "tt:NetworkInterfaceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterfaceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterfaceExtension, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_dup_tt__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *d, tt__NetworkInterfaceExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterfaceExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterfaceExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterfaceExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__NetworkInterfaceExtension::InterfaceType = a->tt__NetworkInterfaceExtension::InterfaceType;
	soap_dup_std__vectorTemplateOfPointerTott__Dot3Configuration(soap, &d->tt__NetworkInterfaceExtension::Dot3, &a->tt__NetworkInterfaceExtension::Dot3);
	soap_dup_std__vectorTemplateOfPointerTott__Dot11Configuration(soap, &d->tt__NetworkInterfaceExtension::Dot11, &a->tt__NetworkInterfaceExtension::Dot11);
	soap_dup_PointerTott__NetworkInterfaceExtension2(soap, &d->tt__NetworkInterfaceExtension::Extension, &a->tt__NetworkInterfaceExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterfaceExtension(tt__NetworkInterfaceExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* InterfaceType skipped */
	soap_del_std__vectorTemplateOfPointerTott__Dot3Configuration(&a->tt__NetworkInterfaceExtension::Dot3);
	soap_del_std__vectorTemplateOfPointerTott__Dot11Configuration(&a->tt__NetworkInterfaceExtension::Dot11);
	soap_del_PointerTott__NetworkInterfaceExtension2(&a->tt__NetworkInterfaceExtension::Extension);
}

SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterfaceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterfaceExtension *p;
	size_t k = sizeof(tt__NetworkInterfaceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterfaceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterfaceExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterfaceExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterfaceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterfaceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterfaceExtension(soap, tag ? tag : "tt:NetworkInterfaceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterfaceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterfaceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension * SOAP_FMAC4 soap_get_tt__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__NetworkInterface::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_bool(soap, &this->tt__NetworkInterface::Enabled);
	this->tt__NetworkInterface::Info = NULL;
	this->tt__NetworkInterface::Link = NULL;
	this->tt__NetworkInterface::IPv4 = NULL;
	this->tt__NetworkInterface::IPv6 = NULL;
	this->tt__NetworkInterface::Extension = NULL;
}

void tt__NetworkInterface::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__NetworkInterface::Enabled, SOAP_TYPE_bool);
	soap_serialize_PointerTott__NetworkInterfaceInfo(soap, &this->tt__NetworkInterface::Info);
	soap_serialize_PointerTott__NetworkInterfaceLink(soap, &this->tt__NetworkInterface::Link);
	soap_serialize_PointerTott__IPv4NetworkInterface(soap, &this->tt__NetworkInterface::IPv4);
	soap_serialize_PointerTott__IPv6NetworkInterface(soap, &this->tt__NetworkInterface::IPv6);
	soap_serialize_PointerTott__NetworkInterfaceExtension(soap, &this->tt__NetworkInterface::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__NetworkInterface::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__NetworkInterface(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterface(struct soap *soap, const char *tag, int id, const tt__NetworkInterface *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__NetworkInterface), type ? type : "tt:NetworkInterface"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Enabled", -1, &a->tt__NetworkInterface::Enabled, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", -1, &a->tt__NetworkInterface::Info, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, "tt:Link", -1, &a->tt__NetworkInterface::Link, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", -1, &a->tt__NetworkInterface::IPv4, ""))
		return soap->error;
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", -1, &a->tt__NetworkInterface::IPv6, ""))
		return soap->error;
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", -1, &a->tt__NetworkInterface::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__NetworkInterface::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__NetworkInterface(soap, tag, this, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_in_tt__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__NetworkInterface*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__NetworkInterface)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__NetworkInterface *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Info1 = 1;
	size_t soap_flag_Link1 = 1;
	size_t soap_flag_IPv41 = 1;
	size_t soap_flag_IPv61 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Enabled", &a->tt__NetworkInterface::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Info1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceInfo(soap, "tt:Info", &a->tt__NetworkInterface::Info, "tt:NetworkInterfaceInfo"))
				{	soap_flag_Info1--;
					continue;
				}
			}
			if (soap_flag_Link1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceLink(soap, "tt:Link", &a->tt__NetworkInterface::Link, "tt:NetworkInterfaceLink"))
				{	soap_flag_Link1--;
					continue;
				}
			}
			if (soap_flag_IPv41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv4NetworkInterface(soap, "tt:IPv4", &a->tt__NetworkInterface::IPv4, "tt:IPv4NetworkInterface"))
				{	soap_flag_IPv41--;
					continue;
				}
			}
			if (soap_flag_IPv61 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPv6NetworkInterface(soap, "tt:IPv6", &a->tt__NetworkInterface::IPv6, "tt:IPv6NetworkInterface"))
				{	soap_flag_IPv61--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceExtension(soap, "tt:Extension", &a->tt__NetworkInterface::Extension, "tt:NetworkInterfaceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__NetworkInterface *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__NetworkInterface, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_dup_tt__NetworkInterface(struct soap *soap, tt__NetworkInterface *d, tt__NetworkInterface const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__NetworkInterface*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__NetworkInterface, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__NetworkInterface(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	d->tt__NetworkInterface::Enabled = a->tt__NetworkInterface::Enabled;
	soap_dup_PointerTott__NetworkInterfaceInfo(soap, &d->tt__NetworkInterface::Info, &a->tt__NetworkInterface::Info);
	soap_dup_PointerTott__NetworkInterfaceLink(soap, &d->tt__NetworkInterface::Link, &a->tt__NetworkInterface::Link);
	soap_dup_PointerTott__IPv4NetworkInterface(soap, &d->tt__NetworkInterface::IPv4, &a->tt__NetworkInterface::IPv4);
	soap_dup_PointerTott__IPv6NetworkInterface(soap, &d->tt__NetworkInterface::IPv6, &a->tt__NetworkInterface::IPv6);
	soap_dup_PointerTott__NetworkInterfaceExtension(soap, &d->tt__NetworkInterface::Extension, &a->tt__NetworkInterface::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__NetworkInterface(tt__NetworkInterface const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	/* Enabled skipped */
	soap_del_PointerTott__NetworkInterfaceInfo(&a->tt__NetworkInterface::Info);
	soap_del_PointerTott__NetworkInterfaceLink(&a->tt__NetworkInterface::Link);
	soap_del_PointerTott__IPv4NetworkInterface(&a->tt__NetworkInterface::IPv4);
	soap_del_PointerTott__IPv6NetworkInterface(&a->tt__NetworkInterface::IPv6);
	soap_del_PointerTott__NetworkInterfaceExtension(&a->tt__NetworkInterface::Extension);
}

SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__NetworkInterface(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__NetworkInterface *p;
	size_t k = sizeof(tt__NetworkInterface);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__NetworkInterface, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__NetworkInterface);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__NetworkInterface, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__NetworkInterface location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__NetworkInterface::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__NetworkInterface::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__NetworkInterface(soap, this, tag, type);
}

SOAP_FMAC3 tt__NetworkInterface * SOAP_FMAC4 soap_get_tt__NetworkInterface(struct soap *soap, tt__NetworkInterface *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Scope::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ScopeDefinition(soap, &this->tt__Scope::ScopeDef);
	soap_default_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
}

void tt__Scope::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Scope::ScopeItem, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Scope::ScopeItem);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Scope::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Scope(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Scope(struct soap *soap, const char *tag, int id, const tt__Scope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Scope), type ? type : "tt:Scope"))
		return soap->error;
	if (soap_out_tt__ScopeDefinition(soap, "tt:ScopeDef", -1, &a->tt__Scope::ScopeDef, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:ScopeItem", -1, &a->tt__Scope::ScopeItem, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Scope::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Scope(soap, tag, this, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_in_tt__Scope(struct soap *soap, const char *tag, tt__Scope *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Scope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Scope)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Scope *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_ScopeDef1 = 1;
	size_t soap_flag_ScopeItem1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ScopeDef1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ScopeDefinition(soap, "tt:ScopeDef", &a->tt__Scope::ScopeDef, "tt:ScopeDefinition"))
				{	soap_flag_ScopeDef1--;
					continue;
				}
			}
			if (soap_flag_ScopeItem1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:ScopeItem", &a->tt__Scope::ScopeItem, "xsd:anyURI"))
				{	soap_flag_ScopeItem1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_ScopeDef1 > 0 || soap_flag_ScopeItem1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Scope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Scope, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_dup_tt__Scope(struct soap *soap, tt__Scope *d, tt__Scope const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Scope*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Scope, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Scope(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Scope::ScopeDef = a->tt__Scope::ScopeDef;
	soap_dup_xsd__anyURI(soap, &d->tt__Scope::ScopeItem, &a->tt__Scope::ScopeItem);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Scope(tt__Scope const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* ScopeDef skipped */
	soap_del_xsd__anyURI(&a->tt__Scope::ScopeItem);
}

SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Scope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Scope *p;
	size_t k = sizeof(tt__Scope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Scope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Scope);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Scope, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Scope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Scope::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Scope(soap, tag ? tag : "tt:Scope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Scope::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Scope(soap, this, tag, type);
}

SOAP_FMAC3 tt__Scope * SOAP_FMAC4 soap_get_tt__Scope(struct soap *soap, tt__Scope *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MediaUri::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterConnect);
	soap_default_bool(soap, &this->tt__MediaUri::InvalidAfterReboot);
	soap_default_xsd__duration(soap, &this->tt__MediaUri::Timeout);
}

void tt__MediaUri::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__MediaUri::Uri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__MediaUri::Uri);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterConnect, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::InvalidAfterReboot, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__MediaUri::Timeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__MediaUri::Timeout);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MediaUri::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MediaUri(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MediaUri(struct soap *soap, const char *tag, int id, const tt__MediaUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MediaUri), type ? type : "tt:MediaUri"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:Uri", -1, &a->tt__MediaUri::Uri, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterConnect", -1, &a->tt__MediaUri::InvalidAfterConnect, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:InvalidAfterReboot", -1, &a->tt__MediaUri::InvalidAfterReboot, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Timeout", -1, &a->tt__MediaUri::Timeout, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MediaUri::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MediaUri(soap, tag, this, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_in_tt__MediaUri(struct soap *soap, const char *tag, tt__MediaUri *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MediaUri*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MediaUri)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MediaUri *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Uri1 = 1;
	size_t soap_flag_InvalidAfterConnect1 = 1;
	size_t soap_flag_InvalidAfterReboot1 = 1;
	size_t soap_flag_Timeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:Uri", &a->tt__MediaUri::Uri, "xsd:anyURI"))
				{	soap_flag_Uri1--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterConnect1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:InvalidAfterConnect", &a->tt__MediaUri::InvalidAfterConnect, "xsd:boolean"))
				{	soap_flag_InvalidAfterConnect1--;
					continue;
				}
			}
			if (soap_flag_InvalidAfterReboot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:InvalidAfterReboot", &a->tt__MediaUri::InvalidAfterReboot, "xsd:boolean"))
				{	soap_flag_InvalidAfterReboot1--;
					continue;
				}
			}
			if (soap_flag_Timeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Timeout", &a->tt__MediaUri::Timeout, "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Uri1 > 0 || soap_flag_InvalidAfterConnect1 > 0 || soap_flag_InvalidAfterReboot1 > 0 || soap_flag_Timeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MediaUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MediaUri, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_dup_tt__MediaUri(struct soap *soap, tt__MediaUri *d, tt__MediaUri const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MediaUri*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MediaUri, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MediaUri(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tt__MediaUri::Uri, &a->tt__MediaUri::Uri);
	d->tt__MediaUri::InvalidAfterConnect = a->tt__MediaUri::InvalidAfterConnect;
	d->tt__MediaUri::InvalidAfterReboot = a->tt__MediaUri::InvalidAfterReboot;
	soap_dup_xsd__duration(soap, &d->tt__MediaUri::Timeout, &a->tt__MediaUri::Timeout);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MediaUri(tt__MediaUri const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tt__MediaUri::Uri);
	/* InvalidAfterConnect skipped */
	/* InvalidAfterReboot skipped */
	soap_del_xsd__duration(&a->tt__MediaUri::Timeout);
}

SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MediaUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MediaUri *p;
	size_t k = sizeof(tt__MediaUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MediaUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MediaUri);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MediaUri, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MediaUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MediaUri::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MediaUri(soap, tag ? tag : "tt:MediaUri", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MediaUri::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MediaUri(soap, this, tag, type);
}

SOAP_FMAC3 tt__MediaUri * SOAP_FMAC4 soap_get_tt__MediaUri(struct soap *soap, tt__MediaUri *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Transport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__TransportProtocol(soap, &this->tt__Transport::Protocol);
	this->tt__Transport::Tunnel = NULL;
}

void tt__Transport::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &this->tt__Transport::Tunnel);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Transport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Transport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Transport(struct soap *soap, const char *tag, int id, const tt__Transport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Transport), type ? type : "tt:Transport"))
		return soap->error;
	if (soap_out_tt__TransportProtocol(soap, "tt:Protocol", -1, &a->tt__Transport::Protocol, ""))
		return soap->error;
	if (soap_out_PointerTott__Transport(soap, "tt:Tunnel", -1, &a->tt__Transport::Tunnel, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Transport::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Transport(soap, tag, this, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_in_tt__Transport(struct soap *soap, const char *tag, tt__Transport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Transport*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Transport)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Transport *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Protocol1 = 1;
	size_t soap_flag_Tunnel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Protocol1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__TransportProtocol(soap, "tt:Protocol", &a->tt__Transport::Protocol, "tt:TransportProtocol"))
				{	soap_flag_Protocol1--;
					continue;
				}
			}
			if (soap_flag_Tunnel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transport(soap, "tt:Tunnel", &a->tt__Transport::Tunnel, "tt:Transport"))
				{	soap_flag_Tunnel1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Protocol1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Transport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Transport, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_dup_tt__Transport(struct soap *soap, tt__Transport *d, tt__Transport const*a)
{
	struct soap_plist *pp = NULL;
	char *mark = NULL;
	if (!a)
		return NULL;
	if (!d && ((d = (tt__Transport*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Transport, &pp, &mark)) || soap_mark_cycle(soap, pp)))
		return d;
	if (!d && !(d = soap_new_tt__Transport(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Transport::Protocol = a->tt__Transport::Protocol;
	soap_dup_PointerTott__Transport(soap, &d->tt__Transport::Tunnel, &a->tt__Transport::Tunnel);
	soap_unmark(soap, mark);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Transport(tt__Transport const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Protocol skipped */
	soap_del_PointerTott__Transport(&a->tt__Transport::Tunnel);
}

SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Transport(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Transport *p;
	size_t k = sizeof(tt__Transport);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Transport, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Transport);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Transport, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Transport location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Transport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Transport(soap, tag ? tag : "tt:Transport", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Transport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Transport(soap, this, tag, type);
}

SOAP_FMAC3 tt__Transport * SOAP_FMAC4 soap_get_tt__Transport(struct soap *soap, tt__Transport *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__StreamSetup::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__StreamType(soap, &this->tt__StreamSetup::Stream);
	this->tt__StreamSetup::Transport = NULL;
}

void tt__StreamSetup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Transport(soap, &this->tt__StreamSetup::Transport);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__StreamSetup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__StreamSetup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StreamSetup(struct soap *soap, const char *tag, int id, const tt__StreamSetup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__StreamSetup), type ? type : "tt:StreamSetup"))
		return soap->error;
	if (soap_out_tt__StreamType(soap, "tt:Stream", -1, &a->tt__StreamSetup::Stream, ""))
		return soap->error;
	if (!a->tt__StreamSetup::Transport)
	{	if (soap_element_empty(soap, "tt:Transport", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Transport(soap, "tt:Transport", -1, &a->tt__StreamSetup::Transport, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__StreamSetup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__StreamSetup(soap, tag, this, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_in_tt__StreamSetup(struct soap *soap, const char *tag, tt__StreamSetup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__StreamSetup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__StreamSetup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__StreamSetup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Stream1 = 1;
	size_t soap_flag_Transport1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Stream1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__StreamType(soap, "tt:Stream", &a->tt__StreamSetup::Stream, "tt:StreamType"))
				{	soap_flag_Stream1--;
					continue;
				}
			}
			if (soap_flag_Transport1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Transport(soap, "tt:Transport", &a->tt__StreamSetup::Transport, "tt:Transport"))
				{	soap_flag_Transport1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Stream1 > 0 || !a->tt__StreamSetup::Transport))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__StreamSetup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__StreamSetup, SOAP_TYPE_tt__StreamSetup, sizeof(tt__StreamSetup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_dup_tt__StreamSetup(struct soap *soap, tt__StreamSetup *d, tt__StreamSetup const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__StreamSetup*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__StreamSetup, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__StreamSetup(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__StreamSetup::Stream = a->tt__StreamSetup::Stream;
	soap_dup_PointerTott__Transport(soap, &d->tt__StreamSetup::Transport, &a->tt__StreamSetup::Transport);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__StreamSetup(tt__StreamSetup const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Stream skipped */
	soap_del_PointerTott__Transport(&a->tt__StreamSetup::Transport);
}

SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__StreamSetup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__StreamSetup *p;
	size_t k = sizeof(tt__StreamSetup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__StreamSetup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__StreamSetup);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__StreamSetup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__StreamSetup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__StreamSetup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__StreamSetup(soap, tag ? tag : "tt:StreamSetup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__StreamSetup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__StreamSetup(soap, this, tag, type);
}

SOAP_FMAC3 tt__StreamSetup * SOAP_FMAC4 soap_get_tt__StreamSetup(struct soap *soap, tt__StreamSetup *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MulticastConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MulticastConfiguration::Address = NULL;
	soap_default_int(soap, &this->tt__MulticastConfiguration::Port);
	soap_default_int(soap, &this->tt__MulticastConfiguration::TTL);
	soap_default_bool(soap, &this->tt__MulticastConfiguration::AutoStart);
}

void tt__MulticastConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddress(soap, &this->tt__MulticastConfiguration::Address);
	soap_embedded(soap, &this->tt__MulticastConfiguration::Port, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::TTL, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__MulticastConfiguration::AutoStart, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MulticastConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MulticastConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MulticastConfiguration(struct soap *soap, const char *tag, int id, const tt__MulticastConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MulticastConfiguration), type ? type : "tt:MulticastConfiguration"))
		return soap->error;
	if (!a->tt__MulticastConfiguration::Address)
	{	if (soap_element_empty(soap, "tt:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddress(soap, "tt:Address", -1, &a->tt__MulticastConfiguration::Address, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Port", -1, &a->tt__MulticastConfiguration::Port, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:TTL", -1, &a->tt__MulticastConfiguration::TTL, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__MulticastConfiguration::AutoStart, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MulticastConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MulticastConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_in_tt__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MulticastConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MulticastConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MulticastConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Address1 = 1;
	size_t soap_flag_Port1 = 1;
	size_t soap_flag_TTL1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddress(soap, "tt:Address", &a->tt__MulticastConfiguration::Address, "tt:IPAddress"))
				{	soap_flag_Address1--;
					continue;
				}
			}
			if (soap_flag_Port1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Port", &a->tt__MulticastConfiguration::Port, "xsd:int"))
				{	soap_flag_Port1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:TTL", &a->tt__MulticastConfiguration::TTL, "xsd:int"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__MulticastConfiguration::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__MulticastConfiguration::Address || soap_flag_Port1 > 0 || soap_flag_TTL1 > 0 || soap_flag_AutoStart1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MulticastConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MulticastConfiguration, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_dup_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *d, tt__MulticastConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MulticastConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MulticastConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MulticastConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IPAddress(soap, &d->tt__MulticastConfiguration::Address, &a->tt__MulticastConfiguration::Address);
	d->tt__MulticastConfiguration::Port = a->tt__MulticastConfiguration::Port;
	d->tt__MulticastConfiguration::TTL = a->tt__MulticastConfiguration::TTL;
	d->tt__MulticastConfiguration::AutoStart = a->tt__MulticastConfiguration::AutoStart;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MulticastConfiguration(tt__MulticastConfiguration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IPAddress(&a->tt__MulticastConfiguration::Address);
	/* Port skipped */
	/* TTL skipped */
	/* AutoStart skipped */
}

SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MulticastConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MulticastConfiguration *p;
	size_t k = sizeof(tt__MulticastConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MulticastConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MulticastConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MulticastConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MulticastConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MulticastConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MulticastConfiguration(soap, tag ? tag : "tt:MulticastConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MulticastConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MulticastConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MulticastConfiguration * SOAP_FMAC4 soap_get_tt__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__AudioDecoderConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioDecoderConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:AudioDecoderConfigurationOptionsExtension");
}

void *tt__AudioDecoderConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioDecoderConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(tt__AudioDecoderConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension)
		return (tt__AudioDecoderConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_dup_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension *d, tt__AudioDecoderConfigurationOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioDecoderConfigurationOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioDecoderConfigurationOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioDecoderConfigurationOptionsExtension(tt__AudioDecoderConfigurationOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__AudioDecoderConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfigurationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfigurationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:AudioDecoderConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__G726DecOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__G726DecOptions::Bitrate = NULL;
	this->tt__G726DecOptions::SampleRateRange = NULL;
}

void tt__G726DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntItems(soap, &this->tt__G726DecOptions::Bitrate);
	soap_serialize_PointerTott__IntItems(soap, &this->tt__G726DecOptions::SampleRateRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__G726DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__G726DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G726DecOptions(struct soap *soap, const char *tag, int id, const tt__G726DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G726DecOptions), type ? type : "tt:G726DecOptions"))
		return soap->error;
	if (!a->tt__G726DecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:Bitrate", -1, &a->tt__G726DecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__G726DecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:SampleRateRange", -1, &a->tt__G726DecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__G726DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__G726DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__G726DecOptions * SOAP_FMAC4 soap_in_tt__G726DecOptions(struct soap *soap, const char *tag, tt__G726DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__G726DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G726DecOptions, sizeof(tt__G726DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__G726DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__G726DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:Bitrate", &a->tt__G726DecOptions::Bitrate, "tt:IntItems"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:SampleRateRange", &a->tt__G726DecOptions::SampleRateRange, "tt:IntItems"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__G726DecOptions::Bitrate || !a->tt__G726DecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__G726DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G726DecOptions, SOAP_TYPE_tt__G726DecOptions, sizeof(tt__G726DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_dup_tt__G726DecOptions(struct soap *soap, tt__G726DecOptions *d, tt__G726DecOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__G726DecOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__G726DecOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__G726DecOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntItems(soap, &d->tt__G726DecOptions::Bitrate, &a->tt__G726DecOptions::Bitrate);
	soap_dup_PointerTott__IntItems(soap, &d->tt__G726DecOptions::SampleRateRange, &a->tt__G726DecOptions::SampleRateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__G726DecOptions(tt__G726DecOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntItems(&a->tt__G726DecOptions::Bitrate);
	soap_del_PointerTott__IntItems(&a->tt__G726DecOptions::SampleRateRange);
}

SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__G726DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__G726DecOptions *p;
	size_t k = sizeof(tt__G726DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__G726DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__G726DecOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__G726DecOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__G726DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__G726DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__G726DecOptions(soap, tag ? tag : "tt:G726DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__G726DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__G726DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__G726DecOptions * SOAP_FMAC4 soap_get_tt__G726DecOptions(struct soap *soap, tt__G726DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AACDecOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AACDecOptions::Bitrate = NULL;
	this->tt__AACDecOptions::SampleRateRange = NULL;
}

void tt__AACDecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntItems(soap, &this->tt__AACDecOptions::Bitrate);
	soap_serialize_PointerTott__IntItems(soap, &this->tt__AACDecOptions::SampleRateRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AACDecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AACDecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AACDecOptions(struct soap *soap, const char *tag, int id, const tt__AACDecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AACDecOptions), type ? type : "tt:AACDecOptions"))
		return soap->error;
	if (!a->tt__AACDecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:Bitrate", -1, &a->tt__AACDecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__AACDecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:SampleRateRange", -1, &a->tt__AACDecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AACDecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AACDecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AACDecOptions * SOAP_FMAC4 soap_in_tt__AACDecOptions(struct soap *soap, const char *tag, tt__AACDecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AACDecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AACDecOptions, sizeof(tt__AACDecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AACDecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AACDecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:Bitrate", &a->tt__AACDecOptions::Bitrate, "tt:IntItems"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:SampleRateRange", &a->tt__AACDecOptions::SampleRateRange, "tt:IntItems"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__AACDecOptions::Bitrate || !a->tt__AACDecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AACDecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AACDecOptions, SOAP_TYPE_tt__AACDecOptions, sizeof(tt__AACDecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_dup_tt__AACDecOptions(struct soap *soap, tt__AACDecOptions *d, tt__AACDecOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AACDecOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AACDecOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AACDecOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntItems(soap, &d->tt__AACDecOptions::Bitrate, &a->tt__AACDecOptions::Bitrate);
	soap_dup_PointerTott__IntItems(soap, &d->tt__AACDecOptions::SampleRateRange, &a->tt__AACDecOptions::SampleRateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AACDecOptions(tt__AACDecOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntItems(&a->tt__AACDecOptions::Bitrate);
	soap_del_PointerTott__IntItems(&a->tt__AACDecOptions::SampleRateRange);
}

SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AACDecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AACDecOptions *p;
	size_t k = sizeof(tt__AACDecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AACDecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AACDecOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AACDecOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AACDecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AACDecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AACDecOptions(soap, tag ? tag : "tt:AACDecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AACDecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AACDecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AACDecOptions * SOAP_FMAC4 soap_get_tt__AACDecOptions(struct soap *soap, tt__AACDecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__G711DecOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__G711DecOptions::Bitrate = NULL;
	this->tt__G711DecOptions::SampleRateRange = NULL;
}

void tt__G711DecOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntItems(soap, &this->tt__G711DecOptions::Bitrate);
	soap_serialize_PointerTott__IntItems(soap, &this->tt__G711DecOptions::SampleRateRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__G711DecOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__G711DecOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__G711DecOptions(struct soap *soap, const char *tag, int id, const tt__G711DecOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__G711DecOptions), type ? type : "tt:G711DecOptions"))
		return soap->error;
	if (!a->tt__G711DecOptions::Bitrate)
	{	if (soap_element_empty(soap, "tt:Bitrate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:Bitrate", -1, &a->tt__G711DecOptions::Bitrate, ""))
		return soap->error;
	if (!a->tt__G711DecOptions::SampleRateRange)
	{	if (soap_element_empty(soap, "tt:SampleRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:SampleRateRange", -1, &a->tt__G711DecOptions::SampleRateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__G711DecOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__G711DecOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__G711DecOptions * SOAP_FMAC4 soap_in_tt__G711DecOptions(struct soap *soap, const char *tag, tt__G711DecOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__G711DecOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__G711DecOptions, sizeof(tt__G711DecOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__G711DecOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__G711DecOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:Bitrate", &a->tt__G711DecOptions::Bitrate, "tt:IntItems"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:SampleRateRange", &a->tt__G711DecOptions::SampleRateRange, "tt:IntItems"))
				{	soap_flag_SampleRateRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__G711DecOptions::Bitrate || !a->tt__G711DecOptions::SampleRateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__G711DecOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__G711DecOptions, SOAP_TYPE_tt__G711DecOptions, sizeof(tt__G711DecOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_dup_tt__G711DecOptions(struct soap *soap, tt__G711DecOptions *d, tt__G711DecOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__G711DecOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__G711DecOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__G711DecOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntItems(soap, &d->tt__G711DecOptions::Bitrate, &a->tt__G711DecOptions::Bitrate);
	soap_dup_PointerTott__IntItems(soap, &d->tt__G711DecOptions::SampleRateRange, &a->tt__G711DecOptions::SampleRateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__G711DecOptions(tt__G711DecOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntItems(&a->tt__G711DecOptions::Bitrate);
	soap_del_PointerTott__IntItems(&a->tt__G711DecOptions::SampleRateRange);
}

SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__G711DecOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__G711DecOptions *p;
	size_t k = sizeof(tt__G711DecOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__G711DecOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__G711DecOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__G711DecOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__G711DecOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__G711DecOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__G711DecOptions(soap, tag ? tag : "tt:G711DecOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__G711DecOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__G711DecOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__G711DecOptions * SOAP_FMAC4 soap_get_tt__G711DecOptions(struct soap *soap, tt__G711DecOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AudioDecoderConfigurationOptions::AACDecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::G711DecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::G726DecOptions = NULL;
	this->tt__AudioDecoderConfigurationOptions::Extension = NULL;
}

void tt__AudioDecoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AACDecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::AACDecOptions);
	soap_serialize_PointerTott__G711DecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::G711DecOptions);
	soap_serialize_PointerTott__G726DecOptions(soap, &this->tt__AudioDecoderConfigurationOptions::G726DecOptions);
	soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, &this->tt__AudioDecoderConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioDecoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions), type ? type : "tt:AudioDecoderConfigurationOptions"))
		return soap->error;
	if (soap_out_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::AACDecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::G711DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", -1, &a->tt__AudioDecoderConfigurationOptions::G726DecOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__AudioDecoderConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AACDecOptions1 = 1;
	size_t soap_flag_G711DecOptions1 = 1;
	size_t soap_flag_G726DecOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AACDecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AACDecOptions(soap, "tt:AACDecOptions", &a->tt__AudioDecoderConfigurationOptions::AACDecOptions, "tt:AACDecOptions"))
				{	soap_flag_AACDecOptions1--;
					continue;
				}
			}
			if (soap_flag_G711DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__G711DecOptions(soap, "tt:G711DecOptions", &a->tt__AudioDecoderConfigurationOptions::G711DecOptions, "tt:G711DecOptions"))
				{	soap_flag_G711DecOptions1--;
					continue;
				}
			}
			if (soap_flag_G726DecOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__G726DecOptions(soap, "tt:G726DecOptions", &a->tt__AudioDecoderConfigurationOptions::G726DecOptions, "tt:G726DecOptions"))
				{	soap_flag_G726DecOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__AudioDecoderConfigurationOptions::Extension, "tt:AudioDecoderConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(tt__AudioDecoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_dup_tt__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *d, tt__AudioDecoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioDecoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioDecoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AACDecOptions(soap, &d->tt__AudioDecoderConfigurationOptions::AACDecOptions, &a->tt__AudioDecoderConfigurationOptions::AACDecOptions);
	soap_dup_PointerTott__G711DecOptions(soap, &d->tt__AudioDecoderConfigurationOptions::G711DecOptions, &a->tt__AudioDecoderConfigurationOptions::G711DecOptions);
	soap_dup_PointerTott__G726DecOptions(soap, &d->tt__AudioDecoderConfigurationOptions::G726DecOptions, &a->tt__AudioDecoderConfigurationOptions::G726DecOptions);
	soap_dup_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, &d->tt__AudioDecoderConfigurationOptions::Extension, &a->tt__AudioDecoderConfigurationOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioDecoderConfigurationOptions(tt__AudioDecoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AACDecOptions(&a->tt__AudioDecoderConfigurationOptions::AACDecOptions);
	soap_del_PointerTott__G711DecOptions(&a->tt__AudioDecoderConfigurationOptions::G711DecOptions);
	soap_del_PointerTott__G726DecOptions(&a->tt__AudioDecoderConfigurationOptions::G726DecOptions);
	soap_del_PointerTott__AudioDecoderConfigurationOptionsExtension(&a->tt__AudioDecoderConfigurationOptions::Extension);
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfigurationOptions *p;
	size_t k = sizeof(tt__AudioDecoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfigurationOptions(soap, tag ? tag : "tt:AudioDecoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioDecoderConfigurationOptions(struct soap *soap, tt__AudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioDecoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
}

void tt__AudioDecoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioDecoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioDecoderConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioDecoderConfiguration), type ? type : "tt:AudioDecoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioDecoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioDecoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioDecoderConfiguration(struct soap *soap, const char *tag, tt__AudioDecoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioDecoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioDecoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioDecoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_dup_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *d, tt__AudioDecoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioDecoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioDecoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioDecoderConfiguration(tt__AudioDecoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
}

SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioDecoderConfiguration *p;
	size_t k = sizeof(tt__AudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioDecoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioDecoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioDecoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioDecoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioDecoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutputConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	this->tt__AudioOutputConfigurationOptions::OutputLevelRange = NULL;
}

void tt__AudioOutputConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__AudioOutputConfigurationOptions::OutputLevelRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioOutputConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions), type ? type : "tt:AudioOutputConfigurationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:OutputTokensAvailable", -1, &a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tt:SendPrimacyOptions", -1, &a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions, ""))
		return soap->error;
	if (!a->tt__AudioOutputConfigurationOptions::OutputLevelRange)
	{	if (soap_element_empty(soap, "tt:OutputLevelRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:OutputLevelRange", -1, &a->tt__AudioOutputConfigurationOptions::OutputLevelRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutputConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutputConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, tt__AudioOutputConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutputConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutputConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutputConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_OutputLevelRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:OutputTokensAvailable", &a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tt:SendPrimacyOptions", &a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions, "xsd:anyURI"))
					continue;
			}
			if (soap_flag_OutputLevelRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:OutputLevelRange", &a->tt__AudioOutputConfigurationOptions::OutputLevelRange, "tt:IntRange"))
				{	soap_flag_OutputLevelRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable.size() < 1 || !a->tt__AudioOutputConfigurationOptions::OutputLevelRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioOutputConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfigurationOptions, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_dup_tt__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *d, tt__AudioOutputConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioOutputConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioOutputConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__ReferenceToken(soap, &d->tt__AudioOutputConfigurationOptions::OutputTokensAvailable, &a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->tt__AudioOutputConfigurationOptions::SendPrimacyOptions, &a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	soap_dup_PointerTott__IntRange(soap, &d->tt__AudioOutputConfigurationOptions::OutputLevelRange, &a->tt__AudioOutputConfigurationOptions::OutputLevelRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioOutputConfigurationOptions(tt__AudioOutputConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__ReferenceToken(&a->tt__AudioOutputConfigurationOptions::OutputTokensAvailable);
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->tt__AudioOutputConfigurationOptions::SendPrimacyOptions);
	soap_del_PointerTott__IntRange(&a->tt__AudioOutputConfigurationOptions::OutputLevelRange);
}

SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutputConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutputConfigurationOptions *p;
	size_t k = sizeof(tt__AudioOutputConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutputConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutputConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutputConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutputConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutputConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutputConfigurationOptions(soap, tag ? tag : "tt:AudioOutputConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutputConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutputConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutputConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	this->tt__AudioOutputConfiguration::SendPrimacy = NULL;
	soap_default_int(soap, &this->tt__AudioOutputConfiguration::OutputLevel);
}

void tt__AudioOutputConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioOutputConfiguration::OutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioOutputConfiguration::OutputToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__AudioOutputConfiguration::SendPrimacy);
	soap_embedded(soap, &this->tt__AudioOutputConfiguration::OutputLevel, SOAP_TYPE_int);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioOutputConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioOutputConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioOutputConfiguration), type ? type : "tt:AudioOutputConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:OutputToken", -1, &a->tt__AudioOutputConfiguration::OutputToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:SendPrimacy", -1, &a->tt__AudioOutputConfiguration::SendPrimacy, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:OutputLevel", -1, &a->tt__AudioOutputConfiguration::OutputLevel, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioOutputConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutputConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_in_tt__AudioOutputConfiguration(struct soap *soap, const char *tag, tt__AudioOutputConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioOutputConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutputConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioOutputConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_OutputToken1 = 1;
	size_t soap_flag_SendPrimacy1 = 1;
	size_t soap_flag_OutputLevel1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_OutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:OutputToken", &a->tt__AudioOutputConfiguration::OutputToken, "tt:ReferenceToken"))
				{	soap_flag_OutputToken1--;
					continue;
				}
			}
			if (soap_flag_SendPrimacy1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:SendPrimacy", &a->tt__AudioOutputConfiguration::SendPrimacy, "xsd:anyURI"))
				{	soap_flag_SendPrimacy1--;
					continue;
				}
			}
			if (soap_flag_OutputLevel1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:OutputLevel", &a->tt__AudioOutputConfiguration::OutputLevel, "xsd:int"))
				{	soap_flag_OutputLevel1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_OutputToken1 > 0 || soap_flag_OutputLevel1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioOutputConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_dup_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *d, tt__AudioOutputConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioOutputConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioOutputConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__AudioOutputConfiguration::OutputToken, &a->tt__AudioOutputConfiguration::OutputToken);
	soap_dup_PointerToxsd__anyURI(soap, &d->tt__AudioOutputConfiguration::SendPrimacy, &a->tt__AudioOutputConfiguration::SendPrimacy);
	d->tt__AudioOutputConfiguration::OutputLevel = a->tt__AudioOutputConfiguration::OutputLevel;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioOutputConfiguration(tt__AudioOutputConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_tt__ReferenceToken(&a->tt__AudioOutputConfiguration::OutputToken);
	soap_del_PointerToxsd__anyURI(&a->tt__AudioOutputConfiguration::SendPrimacy);
	/* OutputLevel skipped */
}

SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutputConfiguration *p;
	size_t k = sizeof(tt__AudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutputConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutputConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutputConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutputConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutputConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration * SOAP_FMAC4 soap_get_tt__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioOutput::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
}

void tt__AudioOutput::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__AudioOutput::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioOutput(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioOutput(struct soap *soap, const char *tag, int id, const tt__AudioOutput *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:AudioOutput");
}

void *tt__AudioOutput::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioOutput(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioOutput * SOAP_FMAC4 soap_in_tt__AudioOutput(struct soap *soap, const char *tag, tt__AudioOutput *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioOutput*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioOutput, sizeof(tt__AudioOutput), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioOutput)
		return (tt__AudioOutput *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_dup_tt__AudioOutput(struct soap *soap, tt__AudioOutput *d, tt__AudioOutput const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioOutput*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioOutput, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioOutput(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioOutput(tt__AudioOutput const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
}

SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioOutput *p;
	size_t k = sizeof(tt__AudioOutput);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioOutput);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioOutput, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioOutput location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioOutput::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioOutput(soap, tag ? tag : "tt:AudioOutput", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioOutput::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioOutput(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioOutput * SOAP_FMAC4 soap_get_tt__AudioOutput(struct soap *soap, tt__AudioOutput *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatusFilterOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__PTZStatusFilterOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZStatusFilterOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:PTZStatusFilterOptionsExtension");
}

void *tt__PTZStatusFilterOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, tt__PTZStatusFilterOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__PTZStatusFilterOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(tt__PTZStatusFilterOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatusFilterOptionsExtension)
		return (tt__PTZStatusFilterOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_dup_tt__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension *d, tt__PTZStatusFilterOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZStatusFilterOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZStatusFilterOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZStatusFilterOptionsExtension(tt__PTZStatusFilterOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatusFilterOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatusFilterOptionsExtension *p;
	size_t k = sizeof(tt__PTZStatusFilterOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatusFilterOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatusFilterOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatusFilterOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatusFilterOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag ? tag : "tt:PTZStatusFilterOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatusFilterOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatusFilterOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatusFilterOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported);
	soap_default_bool(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported);
	this->tt__PTZStatusFilterOptions::PanTiltPositionSupported = NULL;
	this->tt__PTZStatusFilterOptions::ZoomPositionSupported = NULL;
	this->tt__PTZStatusFilterOptions::Extension = NULL;
}

void tt__PTZStatusFilterOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::PanTiltStatusSupported, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZStatusFilterOptions::ZoomStatusSupported, SOAP_TYPE_bool);
	soap_serialize_PointerTobool(soap, &this->tt__PTZStatusFilterOptions::PanTiltPositionSupported);
	soap_serialize_PointerTobool(soap, &this->tt__PTZStatusFilterOptions::ZoomPositionSupported);
	soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(soap, &this->tt__PTZStatusFilterOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZStatusFilterOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatusFilterOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, const tt__PTZStatusFilterOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatusFilterOptions), type ? type : "tt:PTZStatusFilterOptions"))
		return soap->error;
	if (soap_out_bool(soap, "tt:PanTiltStatusSupported", -1, &a->tt__PTZStatusFilterOptions::PanTiltStatusSupported, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:ZoomStatusSupported", -1, &a->tt__PTZStatusFilterOptions::ZoomStatusSupported, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:PanTiltPositionSupported", -1, &a->tt__PTZStatusFilterOptions::PanTiltPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:ZoomPositionSupported", -1, &a->tt__PTZStatusFilterOptions::ZoomPositionSupported, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZStatusFilterOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatusFilterOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatusFilterOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_in_tt__PTZStatusFilterOptions(struct soap *soap, const char *tag, tt__PTZStatusFilterOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatusFilterOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatusFilterOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZStatusFilterOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PanTiltStatusSupported1 = 1;
	size_t soap_flag_ZoomStatusSupported1 = 1;
	size_t soap_flag_PanTiltPositionSupported1 = 1;
	size_t soap_flag_ZoomPositionSupported1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTiltStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:PanTiltStatusSupported", &a->tt__PTZStatusFilterOptions::PanTiltStatusSupported, "xsd:boolean"))
				{	soap_flag_PanTiltStatusSupported1--;
					continue;
				}
			}
			if (soap_flag_ZoomStatusSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:ZoomStatusSupported", &a->tt__PTZStatusFilterOptions::ZoomStatusSupported, "xsd:boolean"))
				{	soap_flag_ZoomStatusSupported1--;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:PanTiltPositionSupported", &a->tt__PTZStatusFilterOptions::PanTiltPositionSupported, "xsd:boolean"))
				{	soap_flag_PanTiltPositionSupported1--;
					continue;
				}
			}
			if (soap_flag_ZoomPositionSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:ZoomPositionSupported", &a->tt__PTZStatusFilterOptions::ZoomPositionSupported, "xsd:boolean"))
				{	soap_flag_ZoomPositionSupported1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, "tt:Extension", &a->tt__PTZStatusFilterOptions::Extension, "tt:PTZStatusFilterOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_PanTiltStatusSupported1 > 0 || soap_flag_ZoomStatusSupported1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZStatusFilterOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatusFilterOptions, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_dup_tt__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *d, tt__PTZStatusFilterOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZStatusFilterOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZStatusFilterOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZStatusFilterOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__PTZStatusFilterOptions::PanTiltStatusSupported = a->tt__PTZStatusFilterOptions::PanTiltStatusSupported;
	d->tt__PTZStatusFilterOptions::ZoomStatusSupported = a->tt__PTZStatusFilterOptions::ZoomStatusSupported;
	soap_dup_PointerTobool(soap, &d->tt__PTZStatusFilterOptions::PanTiltPositionSupported, &a->tt__PTZStatusFilterOptions::PanTiltPositionSupported);
	soap_dup_PointerTobool(soap, &d->tt__PTZStatusFilterOptions::ZoomPositionSupported, &a->tt__PTZStatusFilterOptions::ZoomPositionSupported);
	soap_dup_PointerTott__PTZStatusFilterOptionsExtension(soap, &d->tt__PTZStatusFilterOptions::Extension, &a->tt__PTZStatusFilterOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZStatusFilterOptions(tt__PTZStatusFilterOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* PanTiltStatusSupported skipped */
	/* ZoomStatusSupported skipped */
	soap_del_PointerTobool(&a->tt__PTZStatusFilterOptions::PanTiltPositionSupported);
	soap_del_PointerTobool(&a->tt__PTZStatusFilterOptions::ZoomPositionSupported);
	soap_del_PointerTott__PTZStatusFilterOptionsExtension(&a->tt__PTZStatusFilterOptions::Extension);
}

SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatusFilterOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatusFilterOptions *p;
	size_t k = sizeof(tt__PTZStatusFilterOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatusFilterOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatusFilterOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatusFilterOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatusFilterOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatusFilterOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatusFilterOptions(soap, tag ? tag : "tt:PTZStatusFilterOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatusFilterOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatusFilterOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions * SOAP_FMAC4 soap_get_tt__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptionsExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__MetadataConfigurationOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MetadataConfigurationOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:MetadataConfigurationOptionsExtension2");
}

void *tt__MetadataConfigurationOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MetadataConfigurationOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(tt__MetadataConfigurationOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2)
		return (tt__MetadataConfigurationOptionsExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_dup_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 *d, tt__MetadataConfigurationOptionsExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MetadataConfigurationOptionsExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MetadataConfigurationOptionsExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MetadataConfigurationOptionsExtension2(tt__MetadataConfigurationOptionsExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptionsExtension2 *p;
	size_t k = sizeof(tt__MetadataConfigurationOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptionsExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptionsExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension2(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfstd__string(soap, &this->tt__MetadataConfigurationOptionsExtension::CompressionType);
	this->tt__MetadataConfigurationOptionsExtension::Extension = NULL;
}

void tt__MetadataConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->tt__MetadataConfigurationOptionsExtension::CompressionType);
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension2(soap, &this->tt__MetadataConfigurationOptionsExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MetadataConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension), type ? type : "tt:MetadataConfigurationOptionsExtension"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tt:CompressionType", -1, &a->tt__MetadataConfigurationOptionsExtension::CompressionType, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->tt__MetadataConfigurationOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(tt__MetadataConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tt:CompressionType", &a->tt__MetadataConfigurationOptionsExtension::CompressionType, "xsd:string"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationOptionsExtension2(soap, "tt:Extension", &a->tt__MetadataConfigurationOptionsExtension::Extension, "tt:MetadataConfigurationOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(tt__MetadataConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_dup_tt__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension *d, tt__MetadataConfigurationOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MetadataConfigurationOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MetadataConfigurationOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->tt__MetadataConfigurationOptionsExtension::CompressionType, &a->tt__MetadataConfigurationOptionsExtension::CompressionType);
	soap_dup_PointerTott__MetadataConfigurationOptionsExtension2(soap, &d->tt__MetadataConfigurationOptionsExtension::Extension, &a->tt__MetadataConfigurationOptionsExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MetadataConfigurationOptionsExtension(tt__MetadataConfigurationOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfstd__string(&a->tt__MetadataConfigurationOptionsExtension::CompressionType);
	soap_del_PointerTott__MetadataConfigurationOptionsExtension2(&a->tt__MetadataConfigurationOptionsExtension::Extension);
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__MetadataConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptionsExtension(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions = NULL;
	this->tt__MetadataConfigurationOptions::Extension = NULL;
	this->tt__MetadataConfigurationOptions::GeoLocation = NULL;
	this->tt__MetadataConfigurationOptions::MaxContentFilterSize = NULL;
}

void tt__MetadataConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatusFilterOptions(soap, &this->tt__MetadataConfigurationOptions::PTZStatusFilterOptions);
	soap_serialize_PointerTott__MetadataConfigurationOptionsExtension(soap, &this->tt__MetadataConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MetadataConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationOptions *a, const char *type)
{
	if (((tt__MetadataConfigurationOptions*)a)->GeoLocation)
	{	soap_set_attr(soap, "GeoLocation", soap_bool2s(soap, *((tt__MetadataConfigurationOptions*)a)->GeoLocation), 1);
	}
	if (((tt__MetadataConfigurationOptions*)a)->MaxContentFilterSize)
	{	soap_set_attr(soap, "MaxContentFilterSize", soap_int2s(soap, *((tt__MetadataConfigurationOptions*)a)->MaxContentFilterSize), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfigurationOptions), type ? type : "tt:MetadataConfigurationOptions"))
		return soap->error;
	if (!a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions)
	{	if (soap_element_empty(soap, "tt:PTZStatusFilterOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", -1, &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__MetadataConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_in_tt__MetadataConfigurationOptions(struct soap *soap, const char *tag, tt__MetadataConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GeoLocation", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfigurationOptions*)a)->GeoLocation = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__MetadataConfigurationOptions*)a)->GeoLocation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxContentFilterSize", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfigurationOptions*)a)->MaxContentFilterSize = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__MetadataConfigurationOptions*)a)->MaxContentFilterSize))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_PTZStatusFilterOptions1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatusFilterOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatusFilterOptions(soap, "tt:PTZStatusFilterOptions", &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, "tt:PTZStatusFilterOptions"))
				{	soap_flag_PTZStatusFilterOptions1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__MetadataConfigurationOptions::Extension, "tt:MetadataConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfigurationOptions, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_dup_tt__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *d, tt__MetadataConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MetadataConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MetadataConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MetadataConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__PTZStatusFilterOptions(soap, &d->tt__MetadataConfigurationOptions::PTZStatusFilterOptions, &a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions);
	soap_dup_PointerTott__MetadataConfigurationOptionsExtension(soap, &d->tt__MetadataConfigurationOptions::Extension, &a->tt__MetadataConfigurationOptions::Extension);
	soap_dup_PointerTobool(soap, &d->tt__MetadataConfigurationOptions::GeoLocation, &a->tt__MetadataConfigurationOptions::GeoLocation);
	soap_dup_PointerToint(soap, &d->tt__MetadataConfigurationOptions::MaxContentFilterSize, &a->tt__MetadataConfigurationOptions::MaxContentFilterSize);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MetadataConfigurationOptions(tt__MetadataConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__PTZStatusFilterOptions(&a->tt__MetadataConfigurationOptions::PTZStatusFilterOptions);
	soap_del_PointerTott__MetadataConfigurationOptionsExtension(&a->tt__MetadataConfigurationOptions::Extension);
	soap_del_PointerTobool(&a->tt__MetadataConfigurationOptions::GeoLocation);
	soap_del_PointerToint(&a->tt__MetadataConfigurationOptions::MaxContentFilterSize);
}

SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationOptions *p;
	size_t k = sizeof(tt__MetadataConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationOptions(soap, tag ? tag : "tt:MetadataConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions * SOAP_FMAC4 soap_get_tt__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EventSubscription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__EventSubscription::Filter = NULL;
	this->tt__EventSubscription::SubscriptionPolicy = NULL;
}

void tt__EventSubscription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsnt__FilterType(soap, &this->tt__EventSubscription::Filter);
	soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &this->tt__EventSubscription::SubscriptionPolicy);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__EventSubscription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EventSubscription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventSubscription(struct soap *soap, const char *tag, int id, const tt__EventSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventSubscription), type ? type : "tt:EventSubscription"))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tt:Filter", -1, &a->tt__EventSubscription::Filter, ""))
		return soap->error;
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", -1, &a->tt__EventSubscription::SubscriptionPolicy, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EventSubscription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EventSubscription(soap, tag, this, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_in_tt__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EventSubscription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EventSubscription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EventSubscription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Filter1 = 1;
	size_t soap_flag_SubscriptionPolicy1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsnt__FilterType(soap, "tt:Filter", &a->tt__EventSubscription::Filter, "wsnt:FilterType"))
				{	soap_flag_Filter1--;
					continue;
				}
			}
			if (soap_flag_SubscriptionPolicy1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, "tt:SubscriptionPolicy", &a->tt__EventSubscription::SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EventSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventSubscription, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_dup_tt__EventSubscription(struct soap *soap, tt__EventSubscription *d, tt__EventSubscription const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__EventSubscription*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__EventSubscription, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__EventSubscription(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTowsnt__FilterType(soap, &d->tt__EventSubscription::Filter, &a->tt__EventSubscription::Filter);
	soap_dup_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, &d->tt__EventSubscription::SubscriptionPolicy, &a->tt__EventSubscription::SubscriptionPolicy);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__EventSubscription(tt__EventSubscription const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTowsnt__FilterType(&a->tt__EventSubscription::Filter);
	soap_del_PointerTo_tt__EventSubscription_SubscriptionPolicy(&a->tt__EventSubscription::SubscriptionPolicy);
}

SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EventSubscription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EventSubscription *p;
	size_t k = sizeof(tt__EventSubscription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EventSubscription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EventSubscription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EventSubscription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EventSubscription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EventSubscription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EventSubscription(soap, tag ? tag : "tt:EventSubscription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EventSubscription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EventSubscription(soap, this, tag, type);
}

SOAP_FMAC3 tt__EventSubscription * SOAP_FMAC4 soap_get_tt__EventSubscription(struct soap *soap, tt__EventSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->tt__PTZFilter::Status);
	soap_default_bool(soap, &this->tt__PTZFilter::Position);
}

void tt__PTZFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZFilter::Status, SOAP_TYPE_bool);
	soap_embedded(soap, &this->tt__PTZFilter::Position, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__PTZFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZFilter(struct soap *soap, const char *tag, int id, const tt__PTZFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZFilter), type ? type : "tt:PTZFilter"))
		return soap->error;
	if (soap_out_bool(soap, "tt:Status", -1, &a->tt__PTZFilter::Status, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:Position", -1, &a->tt__PTZFilter::Position, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZFilter(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_in_tt__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_Position1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Status", &a->tt__PTZFilter::Status, "xsd:boolean"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:Position", &a->tt__PTZFilter::Position, "xsd:boolean"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Status1 > 0 || soap_flag_Position1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZFilter, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_dup_tt__PTZFilter(struct soap *soap, tt__PTZFilter *d, tt__PTZFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__PTZFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__PTZFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__PTZFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__PTZFilter::Status = a->tt__PTZFilter::Status;
	d->tt__PTZFilter::Position = a->tt__PTZFilter::Position;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__PTZFilter(tt__PTZFilter const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Status skipped */
	/* Position skipped */
}

SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZFilter *p;
	size_t k = sizeof(tt__PTZFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZFilter(soap, tag ? tag : "tt:PTZFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZFilter(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZFilter * SOAP_FMAC4 soap_get_tt__PTZFilter(struct soap *soap, tt__PTZFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__MetadataConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__MetadataConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:MetadataConfigurationExtension");
}

void *tt__MetadataConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_in_tt__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__MetadataConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfigurationExtension)
		return (tt__MetadataConfigurationExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_dup_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *d, tt__MetadataConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MetadataConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MetadataConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MetadataConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MetadataConfigurationExtension(tt__MetadataConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfigurationExtension *p;
	size_t k = sizeof(tt__MetadataConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfigurationExtension(soap, tag ? tag : "tt:MetadataConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension * SOAP_FMAC4 soap_get_tt__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__MetadataConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__MetadataConfiguration::PTZStatus = NULL;
	this->tt__MetadataConfiguration::Events = NULL;
	this->tt__MetadataConfiguration::Analytics = NULL;
	this->tt__MetadataConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	this->tt__MetadataConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__MetadataConfiguration::Extension = NULL;
	this->tt__MetadataConfiguration::CompressionType = NULL;
	this->tt__MetadataConfiguration::GeoLocation = NULL;
	this->tt__MetadataConfiguration::ShapePolygon = NULL;
}

void tt__MetadataConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZFilter(soap, &this->tt__MetadataConfiguration::PTZStatus);
	soap_serialize_PointerTott__EventSubscription(soap, &this->tt__MetadataConfiguration::Events);
	soap_serialize_PointerTobool(soap, &this->tt__MetadataConfiguration::Analytics);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__MetadataConfiguration::Multicast);
	soap_embedded(soap, &this->tt__MetadataConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__MetadataConfiguration::SessionTimeout);
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__MetadataConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__MetadataConfigurationExtension(soap, &this->tt__MetadataConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__MetadataConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__MetadataConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MetadataConfiguration(struct soap *soap, const char *tag, int id, const tt__MetadataConfiguration *a, const char *type)
{
	if (((tt__MetadataConfiguration*)a)->CompressionType)
	{	soap_set_attr(soap, "CompressionType", soap_std__string2s(soap, *((tt__MetadataConfiguration*)a)->CompressionType), 1);
	}
	if (((tt__MetadataConfiguration*)a)->GeoLocation)
	{	soap_set_attr(soap, "GeoLocation", soap_bool2s(soap, *((tt__MetadataConfiguration*)a)->GeoLocation), 1);
	}
	if (((tt__MetadataConfiguration*)a)->ShapePolygon)
	{	soap_set_attr(soap, "ShapePolygon", soap_bool2s(soap, *((tt__MetadataConfiguration*)a)->ShapePolygon), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MetadataConfiguration), type ? type : "tt:MetadataConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZFilter(soap, "tt:PTZStatus", -1, &a->tt__MetadataConfiguration::PTZStatus, ""))
		return soap->error;
	if (soap_out_PointerTott__EventSubscription(soap, "tt:Events", -1, &a->tt__MetadataConfiguration::Events, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Analytics", -1, &a->tt__MetadataConfiguration::Analytics, ""))
		return soap->error;
	if (!a->tt__MetadataConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__MetadataConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__MetadataConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", -1, &a->tt__MetadataConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__MetadataConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__MetadataConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_in_tt__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__MetadataConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__MetadataConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__MetadataConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "CompressionType", 1, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->CompressionType = soap_new_std__string(soap)))
				return NULL;
			if (soap_s2std__string(soap, t, ((tt__MetadataConfiguration*)a)->CompressionType))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocation", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->GeoLocation = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__MetadataConfiguration*)a)->GeoLocation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ShapePolygon", 5, 0);
		if (t)
		{
			if (!(((tt__MetadataConfiguration*)a)->ShapePolygon = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__MetadataConfiguration*)a)->ShapePolygon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_PTZStatus1 = 1;
	size_t soap_flag_Events1 = 1;
	size_t soap_flag_Analytics1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZFilter(soap, "tt:PTZStatus", &a->tt__MetadataConfiguration::PTZStatus, "tt:PTZFilter"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			}
			if (soap_flag_Events1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EventSubscription(soap, "tt:Events", &a->tt__MetadataConfiguration::Events, "tt:EventSubscription"))
				{	soap_flag_Events1--;
					continue;
				}
			}
			if (soap_flag_Analytics1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Analytics", &a->tt__MetadataConfiguration::Analytics, "xsd:boolean"))
				{	soap_flag_Analytics1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__MetadataConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__MetadataConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfigurationExtension(soap, "tt:Extension", &a->tt__MetadataConfiguration::Extension, "tt:MetadataConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__MetadataConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__MetadataConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_dup_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *d, tt__MetadataConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__MetadataConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__MetadataConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__MetadataConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_PointerTott__PTZFilter(soap, &d->tt__MetadataConfiguration::PTZStatus, &a->tt__MetadataConfiguration::PTZStatus);
	soap_dup_PointerTott__EventSubscription(soap, &d->tt__MetadataConfiguration::Events, &a->tt__MetadataConfiguration::Events);
	soap_dup_PointerTobool(soap, &d->tt__MetadataConfiguration::Analytics, &a->tt__MetadataConfiguration::Analytics);
	soap_dup_PointerTott__MulticastConfiguration(soap, &d->tt__MetadataConfiguration::Multicast, &a->tt__MetadataConfiguration::Multicast);
	soap_dup_xsd__duration(soap, &d->tt__MetadataConfiguration::SessionTimeout, &a->tt__MetadataConfiguration::SessionTimeout);
	soap_dup_PointerTott__AnalyticsEngineConfiguration(soap, &d->tt__MetadataConfiguration::AnalyticsEngineConfiguration, &a->tt__MetadataConfiguration::AnalyticsEngineConfiguration);
	soap_dup_PointerTott__MetadataConfigurationExtension(soap, &d->tt__MetadataConfiguration::Extension, &a->tt__MetadataConfiguration::Extension);
	soap_dup_PointerTostd__string(soap, &d->tt__MetadataConfiguration::CompressionType, &a->tt__MetadataConfiguration::CompressionType);
	soap_dup_PointerTobool(soap, &d->tt__MetadataConfiguration::GeoLocation, &a->tt__MetadataConfiguration::GeoLocation);
	soap_dup_PointerTobool(soap, &d->tt__MetadataConfiguration::ShapePolygon, &a->tt__MetadataConfiguration::ShapePolygon);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__MetadataConfiguration(tt__MetadataConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_PointerTott__PTZFilter(&a->tt__MetadataConfiguration::PTZStatus);
	soap_del_PointerTott__EventSubscription(&a->tt__MetadataConfiguration::Events);
	soap_del_PointerTobool(&a->tt__MetadataConfiguration::Analytics);
	soap_del_PointerTott__MulticastConfiguration(&a->tt__MetadataConfiguration::Multicast);
	soap_del_xsd__duration(&a->tt__MetadataConfiguration::SessionTimeout);
	soap_del_PointerTott__AnalyticsEngineConfiguration(&a->tt__MetadataConfiguration::AnalyticsEngineConfiguration);
	soap_del_PointerTott__MetadataConfigurationExtension(&a->tt__MetadataConfiguration::Extension);
	soap_del_PointerTostd__string(&a->tt__MetadataConfiguration::CompressionType);
	soap_del_PointerTobool(&a->tt__MetadataConfiguration::GeoLocation);
	soap_del_PointerTobool(&a->tt__MetadataConfiguration::ShapePolygon);
}

SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__MetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__MetadataConfiguration *p;
	size_t k = sizeof(tt__MetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__MetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__MetadataConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__MetadataConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__MetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__MetadataConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__MetadataConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__MetadataConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__MetadataConfiguration * SOAP_FMAC4 soap_get_tt__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoAnalyticsConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration = NULL;
	this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration = NULL;
}

void tt__VideoAnalyticsConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AnalyticsEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_serialize_PointerTott__RuleEngineConfiguration(soap, &this->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoAnalyticsConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoAnalyticsConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration), type ? type : "tt:VideoAnalyticsConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:AnalyticsEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, ""))
		return soap->error;
	if (!a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration)
	{	if (soap_element_empty(soap, "tt:RuleEngineConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", -1, &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoAnalyticsConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoAnalyticsConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_in_tt__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoAnalyticsConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoAnalyticsConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoAnalyticsConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_AnalyticsEngineConfiguration1 = 1;
	size_t soap_flag_RuleEngineConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_AnalyticsEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AnalyticsEngineConfiguration(soap, "tt:AnalyticsEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, "tt:AnalyticsEngineConfiguration"))
				{	soap_flag_AnalyticsEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag_RuleEngineConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RuleEngineConfiguration(soap, "tt:RuleEngineConfiguration", &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, "tt:RuleEngineConfiguration"))
				{	soap_flag_RuleEngineConfiguration1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || !a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration || !a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_dup_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *d, tt__VideoAnalyticsConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoAnalyticsConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_PointerTott__AnalyticsEngineConfiguration(soap, &d->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration, &a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_dup_PointerTott__RuleEngineConfiguration(soap, &d->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration, &a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoAnalyticsConfiguration(tt__VideoAnalyticsConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_PointerTott__AnalyticsEngineConfiguration(&a->tt__VideoAnalyticsConfiguration::AnalyticsEngineConfiguration);
	soap_del_PointerTott__RuleEngineConfiguration(&a->tt__VideoAnalyticsConfiguration::RuleEngineConfiguration);
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoAnalyticsConfiguration *p;
	size_t k = sizeof(tt__VideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoAnalyticsConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoAnalyticsConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoAnalyticsConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoAnalyticsConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoAnalyticsConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration * SOAP_FMAC4 soap_get_tt__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfigurationOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfigurationOption::Encoding);
	this->tt__AudioEncoderConfigurationOption::BitrateList = NULL;
	this->tt__AudioEncoderConfigurationOption::SampleRateList = NULL;
}

void tt__AudioEncoderConfigurationOption::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntItems(soap, &this->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_serialize_PointerTott__IntItems(soap, &this->tt__AudioEncoderConfigurationOption::SampleRateList);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfigurationOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), type ? type : "tt:AudioEncoderConfigurationOption"))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->tt__AudioEncoderConfigurationOption::Encoding, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfigurationOption::BitrateList)
	{	if (soap_element_empty(soap, "tt:BitrateList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:BitrateList", -1, &a->tt__AudioEncoderConfigurationOption::BitrateList, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfigurationOption::SampleRateList)
	{	if (soap_element_empty(soap, "tt:SampleRateList", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntItems(soap, "tt:SampleRateList", -1, &a->tt__AudioEncoderConfigurationOption::SampleRateList, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOption::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfigurationOption(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOption*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfigurationOption)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfigurationOption *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_BitrateList1 = 1;
	size_t soap_flag_SampleRateList1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->tt__AudioEncoderConfigurationOption::Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_BitrateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:BitrateList", &a->tt__AudioEncoderConfigurationOption::BitrateList, "tt:IntItems"))
				{	soap_flag_BitrateList1--;
					continue;
				}
			}
			if (soap_flag_SampleRateList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:SampleRateList", &a->tt__AudioEncoderConfigurationOption::SampleRateList, "tt:IntItems"))
				{	soap_flag_SampleRateList1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Encoding1 > 0 || !a->tt__AudioEncoderConfigurationOption::BitrateList || !a->tt__AudioEncoderConfigurationOption::SampleRateList))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_dup_tt__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *d, tt__AudioEncoderConfigurationOption const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioEncoderConfigurationOption*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioEncoderConfigurationOption(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__AudioEncoderConfigurationOption::Encoding = a->tt__AudioEncoderConfigurationOption::Encoding;
	soap_dup_PointerTott__IntItems(soap, &d->tt__AudioEncoderConfigurationOption::BitrateList, &a->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_dup_PointerTott__IntItems(soap, &d->tt__AudioEncoderConfigurationOption::SampleRateList, &a->tt__AudioEncoderConfigurationOption::SampleRateList);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioEncoderConfigurationOption(tt__AudioEncoderConfigurationOption const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Encoding skipped */
	soap_del_PointerTott__IntItems(&a->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_del_PointerTott__IntItems(&a->tt__AudioEncoderConfigurationOption::SampleRateList);
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOption(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfigurationOption *p;
	size_t k = sizeof(tt__AudioEncoderConfigurationOption);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfigurationOption);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfigurationOption, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfigurationOption location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfigurationOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfigurationOption(soap, tag ? tag : "tt:AudioEncoderConfigurationOption", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOption(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
}

void tt__AudioEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &this->tt__AudioEncoderConfigurationOptions::Options);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), type ? type : "tt:AudioEncoderConfigurationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", -1, &a->tt__AudioEncoderConfigurationOptions::Options, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", &a->tt__AudioEncoderConfigurationOptions::Options, "tt:AudioEncoderConfigurationOption"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_dup_tt__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *d, tt__AudioEncoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioEncoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioEncoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(soap, &d->tt__AudioEncoderConfigurationOptions::Options, &a->tt__AudioEncoderConfigurationOptions::Options);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioEncoderConfigurationOptions(tt__AudioEncoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption(&a->tt__AudioEncoderConfigurationOptions::Options);
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfigurationOptions *p;
	size_t k = sizeof(tt__AudioEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfigurationOptions(soap, tag ? tag : "tt:AudioEncoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfiguration::Encoding);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::SampleRate);
	this->tt__AudioEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
}

void tt__AudioEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), type ? type : "tt:AudioEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &a->tt__AudioEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &a->tt__AudioEncoderConfiguration::Bitrate, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &a->tt__AudioEncoderConfiguration::SampleRate, ""))
		return soap->error;
	if (!a->tt__AudioEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__AudioEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &a->tt__AudioEncoderConfiguration::Encoding, "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Bitrate", &a->tt__AudioEncoderConfiguration::Bitrate, "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:SampleRate", &a->tt__AudioEncoderConfiguration::SampleRate, "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__AudioEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__AudioEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0 || !a->tt__AudioEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_dup_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *d, tt__AudioEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	d->tt__AudioEncoderConfiguration::Encoding = a->tt__AudioEncoderConfiguration::Encoding;
	d->tt__AudioEncoderConfiguration::Bitrate = a->tt__AudioEncoderConfiguration::Bitrate;
	d->tt__AudioEncoderConfiguration::SampleRate = a->tt__AudioEncoderConfiguration::SampleRate;
	soap_dup_PointerTott__MulticastConfiguration(soap, &d->tt__AudioEncoderConfiguration::Multicast, &a->tt__AudioEncoderConfiguration::Multicast);
	soap_dup_xsd__duration(soap, &d->tt__AudioEncoderConfiguration::SessionTimeout, &a->tt__AudioEncoderConfiguration::SessionTimeout);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioEncoderConfiguration(tt__AudioEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	/* Encoding skipped */
	/* Bitrate skipped */
	/* SampleRate skipped */
	soap_del_PointerTott__MulticastConfiguration(&a->tt__AudioEncoderConfiguration::Multicast);
	soap_del_xsd__duration(&a->tt__AudioEncoderConfiguration::SessionTimeout);
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioEncoderConfiguration *p;
	size_t k = sizeof(tt__AudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioEncoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioEncoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__AudioSourceOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSourceOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:AudioSourceOptionsExtension");
}

void *tt__AudioSourceOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__AudioSourceOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceOptionsExtension)
		return (tt__AudioSourceOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_dup_tt__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *d, tt__AudioSourceOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioSourceOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioSourceOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioSourceOptionsExtension(tt__AudioSourceOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceOptionsExtension *p;
	size_t k = sizeof(tt__AudioSourceOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceOptionsExtension(soap, tag ? tag : "tt:AudioSourceOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	this->tt__AudioSourceConfigurationOptions::Extension = NULL;
}

void tt__AudioSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &this->tt__AudioSourceConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), type ? type : "tt:AudioSourceConfigurationOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", -1, &a->tt__AudioSourceConfigurationOptions::InputTokensAvailable, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &a->tt__AudioSourceConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:InputTokensAvailable", &a->tt__AudioSourceConfigurationOptions::InputTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &a->tt__AudioSourceConfigurationOptions::Extension, "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__AudioSourceConfigurationOptions::InputTokensAvailable.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_dup_tt__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *d, tt__AudioSourceConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioSourceConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioSourceConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__ReferenceToken(soap, &d->tt__AudioSourceConfigurationOptions::InputTokensAvailable, &a->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	soap_dup_PointerTott__AudioSourceOptionsExtension(soap, &d->tt__AudioSourceConfigurationOptions::Extension, &a->tt__AudioSourceConfigurationOptions::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioSourceConfigurationOptions(tt__AudioSourceConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__ReferenceToken(&a->tt__AudioSourceConfigurationOptions::InputTokensAvailable);
	soap_del_PointerTott__AudioSourceOptionsExtension(&a->tt__AudioSourceConfigurationOptions::Extension);
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceConfigurationOptions *p;
	size_t k = sizeof(tt__AudioSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceConfigurationOptions(soap, tag ? tag : "tt:AudioSourceConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
}

void tt__AudioSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), type ? type : "tt:AudioSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__AudioSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__AudioSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_dup_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *d, tt__AudioSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__AudioSourceConfiguration::SourceToken, &a->tt__AudioSourceConfiguration::SourceToken);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioSourceConfiguration(tt__AudioSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_tt__ReferenceToken(&a->tt__AudioSourceConfiguration::SourceToken);
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSourceConfiguration *p;
	size_t k = sizeof(tt__AudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSourceConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSourceConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Options2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__H264Options::soap_default(soap);
	this->tt__H264Options2::BitrateRange = NULL;
}

void tt__H264Options2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options2::BitrateRange);
	this->tt__H264Options::soap_serialize(soap);
#endif
}

int tt__H264Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const tt__H264Options2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), type ? type : "tt:H264Options2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__H264Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__H264Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__H264Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", -1, &a->tt__H264Options::H264ProfilesSupported, ""))
		return soap->error;
	if (!a->tt__H264Options2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__H264Options2::BitrateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, tt__H264Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Options2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Options2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item3 = 1;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__H264Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__H264Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__H264Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", &a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
					continue;
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__H264Options2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__H264Options::ResolutionsAvailable.size() < 1 || !a->tt__H264Options::GovLengthRange || !a->tt__H264Options::FrameRateRange || !a->tt__H264Options::EncodingIntervalRange || a->tt__H264Options::H264ProfilesSupported.size() < 1 || !a->tt__H264Options2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_dup_tt__H264Options2(struct soap *soap, tt__H264Options2 *d, tt__H264Options2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__H264Options2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__H264Options2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__H264Options2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__H264Options(soap, d, a);
	soap_dup_PointerTott__IntRange(soap, &d->tt__H264Options2::BitrateRange, &a->tt__H264Options2::BitrateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__H264Options2(tt__H264Options2 const*a)
{
	if (!a)
		return;
	soap_del_tt__H264Options(a);
	soap_del_PointerTott__IntRange(&a->tt__H264Options2::BitrateRange);
}

SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Options2 *p;
	size_t k = sizeof(tt__H264Options2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Options2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Options2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Options2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Options2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	this->tt__H264Options::GovLengthRange = NULL;
	this->tt__H264Options::FrameRateRange = NULL;
	this->tt__H264Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
}

void tt__H264Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__H264Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__H264Profile(soap, &this->tt__H264Options::H264ProfilesSupported);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const tt__H264Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), type ? type : "tt:H264Options"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__H264Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__H264Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__H264Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", -1, &a->tt__H264Options::H264ProfilesSupported, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, tt__H264Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Options)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Options *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__H264Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__H264Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__H264Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__H264Profile(soap, "tt:H264ProfilesSupported", &a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__H264Options::ResolutionsAvailable.size() < 1 || !a->tt__H264Options::GovLengthRange || !a->tt__H264Options::FrameRateRange || !a->tt__H264Options::EncodingIntervalRange || a->tt__H264Options::H264ProfilesSupported.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_dup_tt__H264Options(struct soap *soap, tt__H264Options *d, tt__H264Options const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__H264Options*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__H264Options, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__H264Options(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__VideoResolution(soap, &d->tt__H264Options::ResolutionsAvailable, &a->tt__H264Options::ResolutionsAvailable);
	soap_dup_PointerTott__IntRange(soap, &d->tt__H264Options::GovLengthRange, &a->tt__H264Options::GovLengthRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__H264Options::FrameRateRange, &a->tt__H264Options::FrameRateRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__H264Options::EncodingIntervalRange, &a->tt__H264Options::EncodingIntervalRange);
	soap_dup_std__vectorTemplateOftt__H264Profile(soap, &d->tt__H264Options::H264ProfilesSupported, &a->tt__H264Options::H264ProfilesSupported);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__H264Options(tt__H264Options const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__VideoResolution(&a->tt__H264Options::ResolutionsAvailable);
	soap_del_PointerTott__IntRange(&a->tt__H264Options::GovLengthRange);
	soap_del_PointerTott__IntRange(&a->tt__H264Options::FrameRateRange);
	soap_del_PointerTott__IntRange(&a->tt__H264Options::EncodingIntervalRange);
	soap_del_std__vectorTemplateOftt__H264Profile(&a->tt__H264Options::H264ProfilesSupported);
}

SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Options2"))
		return soap_instantiate_tt__H264Options2(soap, n, NULL, NULL, size);
	tt__H264Options *p;
	size_t k = sizeof(tt__H264Options);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Options, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Options);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Options, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Options location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Options(soap, tag ? tag : "tt:H264Options", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Options2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Mpeg4Options::soap_default(soap);
	this->tt__Mpeg4Options2::BitrateRange = NULL;
}

void tt__Mpeg4Options2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options2::BitrateRange);
	this->tt__Mpeg4Options::soap_serialize(soap);
#endif
}

int tt__Mpeg4Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), type ? type : "tt:Mpeg4Options2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__Mpeg4Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__Mpeg4Options2::BitrateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, tt__Mpeg4Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Options2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Options2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item3 = 1;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__Mpeg4Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__Mpeg4Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__Mpeg4Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
					continue;
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__Mpeg4Options2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__Mpeg4Options::ResolutionsAvailable.size() < 1 || !a->tt__Mpeg4Options::GovLengthRange || !a->tt__Mpeg4Options::FrameRateRange || !a->tt__Mpeg4Options::EncodingIntervalRange || a->tt__Mpeg4Options::Mpeg4ProfilesSupported.size() < 1 || !a->tt__Mpeg4Options2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_dup_tt__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *d, tt__Mpeg4Options2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Mpeg4Options2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Mpeg4Options2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Mpeg4Options2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__Mpeg4Options(soap, d, a);
	soap_dup_PointerTott__IntRange(soap, &d->tt__Mpeg4Options2::BitrateRange, &a->tt__Mpeg4Options2::BitrateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Mpeg4Options2(tt__Mpeg4Options2 const*a)
{
	if (!a)
		return;
	soap_del_tt__Mpeg4Options(a);
	soap_del_PointerTott__IntRange(&a->tt__Mpeg4Options2::BitrateRange);
}

SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Options2 *p;
	size_t k = sizeof(tt__Mpeg4Options2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Options2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Options2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Options2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Options2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	this->tt__Mpeg4Options::GovLengthRange = NULL;
	this->tt__Mpeg4Options::FrameRateRange = NULL;
	this->tt__Mpeg4Options::EncodingIntervalRange = NULL;
	soap_default_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
}

void tt__Mpeg4Options::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__Mpeg4Options::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::EncodingIntervalRange);
	soap_serialize_std__vectorTemplateOftt__Mpeg4Profile(soap, &this->tt__Mpeg4Options::Mpeg4ProfilesSupported);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), type ? type : "tt:Mpeg4Options"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__Mpeg4Options::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_element_empty(soap, "tt:GovLengthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Options)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Options *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &a->tt__Mpeg4Options::GovLengthRange, "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__Mpeg4Options::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__Mpeg4Options::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", &a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__Mpeg4Options::ResolutionsAvailable.size() < 1 || !a->tt__Mpeg4Options::GovLengthRange || !a->tt__Mpeg4Options::FrameRateRange || !a->tt__Mpeg4Options::EncodingIntervalRange || a->tt__Mpeg4Options::Mpeg4ProfilesSupported.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_dup_tt__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *d, tt__Mpeg4Options const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Mpeg4Options*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Mpeg4Options, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Mpeg4Options(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__VideoResolution(soap, &d->tt__Mpeg4Options::ResolutionsAvailable, &a->tt__Mpeg4Options::ResolutionsAvailable);
	soap_dup_PointerTott__IntRange(soap, &d->tt__Mpeg4Options::GovLengthRange, &a->tt__Mpeg4Options::GovLengthRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__Mpeg4Options::FrameRateRange, &a->tt__Mpeg4Options::FrameRateRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__Mpeg4Options::EncodingIntervalRange, &a->tt__Mpeg4Options::EncodingIntervalRange);
	soap_dup_std__vectorTemplateOftt__Mpeg4Profile(soap, &d->tt__Mpeg4Options::Mpeg4ProfilesSupported, &a->tt__Mpeg4Options::Mpeg4ProfilesSupported);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Mpeg4Options(tt__Mpeg4Options const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__VideoResolution(&a->tt__Mpeg4Options::ResolutionsAvailable);
	soap_del_PointerTott__IntRange(&a->tt__Mpeg4Options::GovLengthRange);
	soap_del_PointerTott__IntRange(&a->tt__Mpeg4Options::FrameRateRange);
	soap_del_PointerTott__IntRange(&a->tt__Mpeg4Options::EncodingIntervalRange);
	soap_del_std__vectorTemplateOftt__Mpeg4Profile(&a->tt__Mpeg4Options::Mpeg4ProfilesSupported);
}

SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Options2"))
		return soap_instantiate_tt__Mpeg4Options2(soap, n, NULL, NULL, size);
	tt__Mpeg4Options *p;
	size_t k = sizeof(tt__Mpeg4Options);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Options, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Options);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Options, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Options location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__JpegOptions2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__JpegOptions::soap_default(soap);
	this->tt__JpegOptions2::BitrateRange = NULL;
}

void tt__JpegOptions2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions2::BitrateRange);
	this->tt__JpegOptions::soap_serialize(soap);
#endif
}

int tt__JpegOptions2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const tt__JpegOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), type ? type : "tt:JpegOptions2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__JpegOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__JpegOptions::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions2::BitrateRange)
	{	if (soap_element_empty(soap, "tt:BitrateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__JpegOptions2::BitrateRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__JpegOptions2(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, tt__JpegOptions2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__JpegOptions2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__JpegOptions2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item3 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__JpegOptions::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__JpegOptions::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &a->tt__JpegOptions2::BitrateRange, "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__JpegOptions::ResolutionsAvailable.size() < 1 || !a->tt__JpegOptions::FrameRateRange || !a->tt__JpegOptions::EncodingIntervalRange || !a->tt__JpegOptions2::BitrateRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_dup_tt__JpegOptions2(struct soap *soap, tt__JpegOptions2 *d, tt__JpegOptions2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__JpegOptions2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__JpegOptions2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__JpegOptions2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__JpegOptions(soap, d, a);
	soap_dup_PointerTott__IntRange(soap, &d->tt__JpegOptions2::BitrateRange, &a->tt__JpegOptions2::BitrateRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__JpegOptions2(tt__JpegOptions2 const*a)
{
	if (!a)
		return;
	soap_del_tt__JpegOptions(a);
	soap_del_PointerTott__IntRange(&a->tt__JpegOptions2::BitrateRange);
}

SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__JpegOptions2 *p;
	size_t k = sizeof(tt__JpegOptions2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__JpegOptions2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__JpegOptions2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__JpegOptions2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__JpegOptions2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__JpegOptions2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions2(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__JpegOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	this->tt__JpegOptions::FrameRateRange = NULL;
	this->tt__JpegOptions::EncodingIntervalRange = NULL;
}

void tt__JpegOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__VideoResolution(soap, &this->tt__JpegOptions::ResolutionsAvailable);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::EncodingIntervalRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__JpegOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const tt__JpegOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), type ? type : "tt:JpegOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, &a->tt__JpegOptions::ResolutionsAvailable, ""))
		return soap->error;
	if (!a->tt__JpegOptions::FrameRateRange)
	{	if (soap_element_empty(soap, "tt:FrameRateRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
		return soap->error;
	if (!a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_element_empty(soap, "tt:EncodingIntervalRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__JpegOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__JpegOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__JpegOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", &a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
					continue;
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &a->tt__JpegOptions::FrameRateRange, "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &a->tt__JpegOptions::EncodingIntervalRange, "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__JpegOptions::ResolutionsAvailable.size() < 1 || !a->tt__JpegOptions::FrameRateRange || !a->tt__JpegOptions::EncodingIntervalRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_dup_tt__JpegOptions(struct soap *soap, tt__JpegOptions *d, tt__JpegOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__JpegOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__JpegOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__JpegOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__VideoResolution(soap, &d->tt__JpegOptions::ResolutionsAvailable, &a->tt__JpegOptions::ResolutionsAvailable);
	soap_dup_PointerTott__IntRange(soap, &d->tt__JpegOptions::FrameRateRange, &a->tt__JpegOptions::FrameRateRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__JpegOptions::EncodingIntervalRange, &a->tt__JpegOptions::EncodingIntervalRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__JpegOptions(tt__JpegOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__VideoResolution(&a->tt__JpegOptions::ResolutionsAvailable);
	soap_del_PointerTott__IntRange(&a->tt__JpegOptions::FrameRateRange);
	soap_del_PointerTott__IntRange(&a->tt__JpegOptions::EncodingIntervalRange);
}

SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:JpegOptions2"))
		return soap_instantiate_tt__JpegOptions2(soap, n, NULL, NULL, size);
	tt__JpegOptions *p;
	size_t k = sizeof(tt__JpegOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__JpegOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__JpegOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__JpegOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__JpegOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__JpegOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderOptionsExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__VideoEncoderOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:VideoEncoderOptionsExtension2");
}

void *tt__VideoEncoderOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoEncoderOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(tt__VideoEncoderOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderOptionsExtension2)
		return (tt__VideoEncoderOptionsExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_dup_tt__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *d, tt__VideoEncoderOptionsExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoEncoderOptionsExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoEncoderOptionsExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoEncoderOptionsExtension2(tt__VideoEncoderOptionsExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderOptionsExtension2 *p;
	size_t k = sizeof(tt__VideoEncoderOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderOptionsExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderOptionsExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoEncoderOptionsExtension::JPEG = NULL;
	this->tt__VideoEncoderOptionsExtension::MPEG4 = NULL;
	this->tt__VideoEncoderOptionsExtension::H264 = NULL;
	this->tt__VideoEncoderOptionsExtension::Extension = NULL;
}

void tt__VideoEncoderOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__JpegOptions2(soap, &this->tt__VideoEncoderOptionsExtension::JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &this->tt__VideoEncoderOptionsExtension::MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &this->tt__VideoEncoderOptionsExtension::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &this->tt__VideoEncoderOptionsExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), type ? type : "tt:VideoEncoderOptionsExtension"))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &a->tt__VideoEncoderOptionsExtension::JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderOptionsExtension::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &a->tt__VideoEncoderOptionsExtension::H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &a->tt__VideoEncoderOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &a->tt__VideoEncoderOptionsExtension::JPEG, "tt:JpegOptions2"))
				{	soap_flag_JPEG1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &a->tt__VideoEncoderOptionsExtension::MPEG4, "tt:Mpeg4Options2"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &a->tt__VideoEncoderOptionsExtension::H264, "tt:H264Options2"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &a->tt__VideoEncoderOptionsExtension::Extension, "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_dup_tt__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *d, tt__VideoEncoderOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoEncoderOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoEncoderOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__JpegOptions2(soap, &d->tt__VideoEncoderOptionsExtension::JPEG, &a->tt__VideoEncoderOptionsExtension::JPEG);
	soap_dup_PointerTott__Mpeg4Options2(soap, &d->tt__VideoEncoderOptionsExtension::MPEG4, &a->tt__VideoEncoderOptionsExtension::MPEG4);
	soap_dup_PointerTott__H264Options2(soap, &d->tt__VideoEncoderOptionsExtension::H264, &a->tt__VideoEncoderOptionsExtension::H264);
	soap_dup_PointerTott__VideoEncoderOptionsExtension2(soap, &d->tt__VideoEncoderOptionsExtension::Extension, &a->tt__VideoEncoderOptionsExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoEncoderOptionsExtension(tt__VideoEncoderOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__JpegOptions2(&a->tt__VideoEncoderOptionsExtension::JPEG);
	soap_del_PointerTott__Mpeg4Options2(&a->tt__VideoEncoderOptionsExtension::MPEG4);
	soap_del_PointerTott__H264Options2(&a->tt__VideoEncoderOptionsExtension::H264);
	soap_del_PointerTott__VideoEncoderOptionsExtension2(&a->tt__VideoEncoderOptionsExtension::Extension);
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderOptionsExtension *p;
	size_t k = sizeof(tt__VideoEncoderOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoEncoderConfigurationOptions::QualityRange = NULL;
	this->tt__VideoEncoderConfigurationOptions::JPEG = NULL;
	this->tt__VideoEncoderConfigurationOptions::MPEG4 = NULL;
	this->tt__VideoEncoderConfigurationOptions::H264 = NULL;
	this->tt__VideoEncoderConfigurationOptions::Extension = NULL;
	this->tt__VideoEncoderConfigurationOptions::GuaranteedFrameRateSupported = NULL;
}

void tt__VideoEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &this->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &this->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &this->tt__VideoEncoderConfigurationOptions::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &this->tt__VideoEncoderConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (((tt__VideoEncoderConfigurationOptions*)a)->GuaranteedFrameRateSupported)
	{	soap_set_attr(soap, "GuaranteedFrameRateSupported", soap_bool2s(soap, *((tt__VideoEncoderConfigurationOptions*)a)->GuaranteedFrameRateSupported), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), type ? type : "tt:VideoEncoderConfigurationOptions"))
		return soap->error;
	if (!a->tt__VideoEncoderConfigurationOptions::QualityRange)
	{	if (soap_element_empty(soap, "tt:QualityRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->tt__VideoEncoderConfigurationOptions::QualityRange, ""))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &a->tt__VideoEncoderConfigurationOptions::JPEG, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderConfigurationOptions::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &a->tt__VideoEncoderConfigurationOptions::H264, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &a->tt__VideoEncoderConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRateSupported", 5, 0);
		if (t)
		{
			if (!(((tt__VideoEncoderConfigurationOptions*)a)->GuaranteedFrameRateSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__VideoEncoderConfigurationOptions*)a)->GuaranteedFrameRateSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_QualityRange1 = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_QualityRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &a->tt__VideoEncoderConfigurationOptions::QualityRange, "tt:IntRange"))
				{	soap_flag_QualityRange1--;
					continue;
				}
			}
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &a->tt__VideoEncoderConfigurationOptions::JPEG, "tt:JpegOptions"))
				{	soap_flag_JPEG1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &a->tt__VideoEncoderConfigurationOptions::MPEG4, "tt:Mpeg4Options"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Options(soap, "tt:H264", &a->tt__VideoEncoderConfigurationOptions::H264, "tt:H264Options"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &a->tt__VideoEncoderConfigurationOptions::Extension, "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__VideoEncoderConfigurationOptions::QualityRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_dup_tt__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *d, tt__VideoEncoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoEncoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoEncoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntRange(soap, &d->tt__VideoEncoderConfigurationOptions::QualityRange, &a->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_dup_PointerTott__JpegOptions(soap, &d->tt__VideoEncoderConfigurationOptions::JPEG, &a->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_dup_PointerTott__Mpeg4Options(soap, &d->tt__VideoEncoderConfigurationOptions::MPEG4, &a->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_dup_PointerTott__H264Options(soap, &d->tt__VideoEncoderConfigurationOptions::H264, &a->tt__VideoEncoderConfigurationOptions::H264);
	soap_dup_PointerTott__VideoEncoderOptionsExtension(soap, &d->tt__VideoEncoderConfigurationOptions::Extension, &a->tt__VideoEncoderConfigurationOptions::Extension);
	soap_dup_PointerTobool(soap, &d->tt__VideoEncoderConfigurationOptions::GuaranteedFrameRateSupported, &a->tt__VideoEncoderConfigurationOptions::GuaranteedFrameRateSupported);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoEncoderConfigurationOptions(tt__VideoEncoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntRange(&a->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_del_PointerTott__JpegOptions(&a->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_del_PointerTott__Mpeg4Options(&a->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_del_PointerTott__H264Options(&a->tt__VideoEncoderConfigurationOptions::H264);
	soap_del_PointerTott__VideoEncoderOptionsExtension(&a->tt__VideoEncoderConfigurationOptions::Extension);
	soap_del_PointerTobool(&a->tt__VideoEncoderConfigurationOptions::GuaranteedFrameRateSupported);
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderConfigurationOptions *p;
	size_t k = sizeof(tt__VideoEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderConfigurationOptions(soap, tag ? tag : "tt:VideoEncoderConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__H264Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__H264Configuration::GovLength);
	soap_default_tt__H264Profile(soap, &this->tt__H264Configuration::H264Profile);
}

void tt__H264Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__H264Configuration::GovLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const tt__H264Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), type ? type : "tt:H264Configuration"))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__H264Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &a->tt__H264Configuration::H264Profile, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__H264Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__H264Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__H264Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_H264Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__H264Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_H264Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &a->tt__H264Configuration::H264Profile, "tt:H264Profile"))
				{	soap_flag_H264Profile1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_GovLength1 > 0 || soap_flag_H264Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_dup_tt__H264Configuration(struct soap *soap, tt__H264Configuration *d, tt__H264Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__H264Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__H264Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__H264Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__H264Configuration::GovLength = a->tt__H264Configuration::GovLength;
	d->tt__H264Configuration::H264Profile = a->tt__H264Configuration::H264Profile;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__H264Configuration(tt__H264Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* GovLength skipped */
	/* H264Profile skipped */
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__H264Configuration *p;
	size_t k = sizeof(tt__H264Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__H264Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__H264Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__H264Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__H264Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__H264Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__H264Configuration(soap, tag ? tag : "tt:H264Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Mpeg4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__Mpeg4Configuration::GovLength);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile);
}

void tt__Mpeg4Configuration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Mpeg4Configuration::GovLength, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const tt__Mpeg4Configuration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), type ? type : "tt:Mpeg4Configuration"))
		return soap->error;
	if (soap_out_int(soap, "tt:GovLength", -1, &a->tt__Mpeg4Configuration::GovLength, ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &a->tt__Mpeg4Configuration::Mpeg4Profile, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Mpeg4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Configuration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Mpeg4Configuration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Mpeg4Configuration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_Mpeg4Profile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:GovLength", &a->tt__Mpeg4Configuration::GovLength, "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			}
			if (soap_flag_Mpeg4Profile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &a->tt__Mpeg4Configuration::Mpeg4Profile, "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_GovLength1 > 0 || soap_flag_Mpeg4Profile1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_dup_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *d, tt__Mpeg4Configuration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Mpeg4Configuration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Mpeg4Configuration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Mpeg4Configuration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Mpeg4Configuration::GovLength = a->tt__Mpeg4Configuration::GovLength;
	d->tt__Mpeg4Configuration::Mpeg4Profile = a->tt__Mpeg4Configuration::Mpeg4Profile;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Mpeg4Configuration(tt__Mpeg4Configuration const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* GovLength skipped */
	/* Mpeg4Profile skipped */
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Configuration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Mpeg4Configuration *p;
	size_t k = sizeof(tt__Mpeg4Configuration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Mpeg4Configuration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Mpeg4Configuration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Mpeg4Configuration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Mpeg4Configuration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Mpeg4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Mpeg4Configuration(soap, tag ? tag : "tt:Mpeg4Configuration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoRateControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoRateControl::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl::EncodingInterval);
	soap_default_int(soap, &this->tt__VideoRateControl::BitrateLimit);
}

void tt__VideoRateControl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoRateControl::FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::BitrateLimit, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoRateControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const tt__VideoRateControl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), type ? type : "tt:VideoRateControl"))
		return soap->error;
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &a->tt__VideoRateControl::FrameRateLimit, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &a->tt__VideoRateControl::EncodingInterval, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &a->tt__VideoRateControl::BitrateLimit, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoRateControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoRateControl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoRateControl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_EncodingInterval1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:FrameRateLimit", &a->tt__VideoRateControl::FrameRateLimit, "xsd:int"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			}
			if (soap_flag_EncodingInterval1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:EncodingInterval", &a->tt__VideoRateControl::EncodingInterval, "xsd:int"))
				{	soap_flag_EncodingInterval1--;
					continue;
				}
			}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:BitrateLimit", &a->tt__VideoRateControl::BitrateLimit, "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FrameRateLimit1 > 0 || soap_flag_EncodingInterval1 > 0 || soap_flag_BitrateLimit1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_dup_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *d, tt__VideoRateControl const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoRateControl*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoRateControl, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoRateControl(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__VideoRateControl::FrameRateLimit = a->tt__VideoRateControl::FrameRateLimit;
	d->tt__VideoRateControl::EncodingInterval = a->tt__VideoRateControl::EncodingInterval;
	d->tt__VideoRateControl::BitrateLimit = a->tt__VideoRateControl::BitrateLimit;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoRateControl(tt__VideoRateControl const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* FrameRateLimit skipped */
	/* EncodingInterval skipped */
	/* BitrateLimit skipped */
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoRateControl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoRateControl *p;
	size_t k = sizeof(tt__VideoRateControl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoRateControl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoRateControl);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoRateControl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoRateControl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoRateControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoRateControl(soap, tag ? tag : "tt:VideoRateControl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoResolution::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoResolution::Width);
	soap_default_int(soap, &this->tt__VideoResolution::Height);
}

void tt__VideoResolution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoResolution::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution::Height, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoResolution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const tt__VideoResolution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), type ? type : "tt:VideoResolution"))
		return soap->error;
	if (soap_out_int(soap, "tt:Width", -1, &a->tt__VideoResolution::Width, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &a->tt__VideoResolution::Height, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoResolution(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoResolution)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoResolution *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Width", &a->tt__VideoResolution::Width, "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Height", &a->tt__VideoResolution::Height, "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_dup_tt__VideoResolution(struct soap *soap, tt__VideoResolution *d, tt__VideoResolution const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoResolution*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoResolution, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoResolution(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__VideoResolution::Width = a->tt__VideoResolution::Width;
	d->tt__VideoResolution::Height = a->tt__VideoResolution::Height;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoResolution(tt__VideoResolution const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Width skipped */
	/* Height skipped */
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoResolution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoResolution *p;
	size_t k = sizeof(tt__VideoResolution);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoResolution, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoResolution);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoResolution, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoResolution location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoResolution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoderConfiguration::Encoding);
	this->tt__VideoEncoderConfiguration::Resolution = NULL;
	soap_default_float(soap, &this->tt__VideoEncoderConfiguration::Quality);
	this->tt__VideoEncoderConfiguration::RateControl = NULL;
	this->tt__VideoEncoderConfiguration::MPEG4 = NULL;
	this->tt__VideoEncoderConfiguration::H264 = NULL;
	this->tt__VideoEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	this->tt__VideoEncoderConfiguration::GuaranteedFrameRate = NULL;
}

void tt__VideoEncoderConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoEncoderConfiguration::Resolution);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &this->tt__VideoEncoderConfiguration::RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &this->tt__VideoEncoderConfiguration::MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &this->tt__VideoEncoderConfiguration::H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfiguration *a, const char *type)
{
	if (((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate)
	{	soap_set_attr(soap, "GuaranteedFrameRate", soap_bool2s(soap, *((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), type ? type : "tt:VideoEncoderConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &a->tt__VideoEncoderConfiguration::Encoding, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoEncoderConfiguration::Resolution, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &a->tt__VideoEncoderConfiguration::Quality, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &a->tt__VideoEncoderConfiguration::RateControl, ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &a->tt__VideoEncoderConfiguration::MPEG4, ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &a->tt__VideoEncoderConfiguration::H264, ""))
		return soap->error;
	if (!a->tt__VideoEncoderConfiguration::Multicast)
	{	if (soap_element_empty(soap, "tt:Multicast", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoderConfiguration::Multicast, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &a->tt__VideoEncoderConfiguration::SessionTimeout, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoEncoderConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoEncoderConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "GuaranteedFrameRate", 5, 0);
		if (t)
		{
			if (!(((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__VideoEncoderConfiguration*)a)->GuaranteedFrameRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Quality1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &a->tt__VideoEncoderConfiguration::Encoding, "tt:VideoEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoEncoderConfiguration::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Quality", &a->tt__VideoEncoderConfiguration::Quality, "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &a->tt__VideoEncoderConfiguration::RateControl, "tt:VideoRateControl"))
				{	soap_flag_RateControl1--;
					continue;
				}
			}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &a->tt__VideoEncoderConfiguration::MPEG4, "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG41--;
					continue;
				}
			}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &a->tt__VideoEncoderConfiguration::H264, "tt:H264Configuration"))
				{	soap_flag_H2641--;
					continue;
				}
			}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &a->tt__VideoEncoderConfiguration::Multicast, "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			}
			if (soap_flag_SessionTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &a->tt__VideoEncoderConfiguration::SessionTimeout, "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || !a->tt__VideoEncoderConfiguration::Resolution || soap_flag_Quality1 > 0 || !a->tt__VideoEncoderConfiguration::Multicast || soap_flag_SessionTimeout1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_dup_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *d, tt__VideoEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	d->tt__VideoEncoderConfiguration::Encoding = a->tt__VideoEncoderConfiguration::Encoding;
	soap_dup_PointerTott__VideoResolution(soap, &d->tt__VideoEncoderConfiguration::Resolution, &a->tt__VideoEncoderConfiguration::Resolution);
	d->tt__VideoEncoderConfiguration::Quality = a->tt__VideoEncoderConfiguration::Quality;
	soap_dup_PointerTott__VideoRateControl(soap, &d->tt__VideoEncoderConfiguration::RateControl, &a->tt__VideoEncoderConfiguration::RateControl);
	soap_dup_PointerTott__Mpeg4Configuration(soap, &d->tt__VideoEncoderConfiguration::MPEG4, &a->tt__VideoEncoderConfiguration::MPEG4);
	soap_dup_PointerTott__H264Configuration(soap, &d->tt__VideoEncoderConfiguration::H264, &a->tt__VideoEncoderConfiguration::H264);
	soap_dup_PointerTott__MulticastConfiguration(soap, &d->tt__VideoEncoderConfiguration::Multicast, &a->tt__VideoEncoderConfiguration::Multicast);
	soap_dup_xsd__duration(soap, &d->tt__VideoEncoderConfiguration::SessionTimeout, &a->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_dup_PointerTobool(soap, &d->tt__VideoEncoderConfiguration::GuaranteedFrameRate, &a->tt__VideoEncoderConfiguration::GuaranteedFrameRate);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoEncoderConfiguration(tt__VideoEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	/* Encoding skipped */
	soap_del_PointerTott__VideoResolution(&a->tt__VideoEncoderConfiguration::Resolution);
	/* Quality skipped */
	soap_del_PointerTott__VideoRateControl(&a->tt__VideoEncoderConfiguration::RateControl);
	soap_del_PointerTott__Mpeg4Configuration(&a->tt__VideoEncoderConfiguration::MPEG4);
	soap_del_PointerTott__H264Configuration(&a->tt__VideoEncoderConfiguration::H264);
	soap_del_PointerTott__MulticastConfiguration(&a->tt__VideoEncoderConfiguration::Multicast);
	soap_del_xsd__duration(&a->tt__VideoEncoderConfiguration::SessionTimeout);
	soap_del_PointerTobool(&a->tt__VideoEncoderConfiguration::GuaranteedFrameRate);
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoEncoderConfiguration *p;
	size_t k = sizeof(tt__VideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoEncoderConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoEncoderConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__SceneOrientation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__SceneOrientationMode(soap, &this->tt__SceneOrientation::Mode);
	this->tt__SceneOrientation::Orientation = NULL;
}

void tt__SceneOrientation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->tt__SceneOrientation::Orientation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__SceneOrientation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__SceneOrientation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__SceneOrientation(struct soap *soap, const char *tag, int id, const tt__SceneOrientation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__SceneOrientation), type ? type : "tt:SceneOrientation"))
		return soap->error;
	if (soap_out_tt__SceneOrientationMode(soap, "tt:Mode", -1, &a->tt__SceneOrientation::Mode, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Orientation", -1, &a->tt__SceneOrientation::Orientation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__SceneOrientation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__SceneOrientation(soap, tag, this, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_in_tt__SceneOrientation(struct soap *soap, const char *tag, tt__SceneOrientation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__SceneOrientation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__SceneOrientation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__SceneOrientation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Orientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SceneOrientationMode(soap, "tt:Mode", &a->tt__SceneOrientation::Mode, "tt:SceneOrientationMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Orientation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Orientation", &a->tt__SceneOrientation::Orientation, "xsd:string"))
				{	soap_flag_Orientation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__SceneOrientation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__SceneOrientation, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_dup_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *d, tt__SceneOrientation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__SceneOrientation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__SceneOrientation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__SceneOrientation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__SceneOrientation::Mode = a->tt__SceneOrientation::Mode;
	soap_dup_PointerTostd__string(soap, &d->tt__SceneOrientation::Orientation, &a->tt__SceneOrientation::Orientation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__SceneOrientation(tt__SceneOrientation const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerTostd__string(&a->tt__SceneOrientation::Orientation);
}

SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__SceneOrientation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__SceneOrientation *p;
	size_t k = sizeof(tt__SceneOrientation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__SceneOrientation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__SceneOrientation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__SceneOrientation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__SceneOrientation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__SceneOrientation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__SceneOrientation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__SceneOrientation(soap, this, tag, type);
}

SOAP_FMAC3 tt__SceneOrientation * SOAP_FMAC4 soap_get_tt__SceneOrientation(struct soap *soap, tt__SceneOrientation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__RotateOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptionsExtension(struct soap *soap, const char *tag, int id, const tt__RotateOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:RotateOptionsExtension");
}

void *tt__RotateOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_in_tt__RotateOptionsExtension(struct soap *soap, const char *tag, tt__RotateOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RotateOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(tt__RotateOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateOptionsExtension)
		return (tt__RotateOptionsExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_dup_tt__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *d, tt__RotateOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RotateOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RotateOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RotateOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RotateOptionsExtension(tt__RotateOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateOptionsExtension *p;
	size_t k = sizeof(tt__RotateOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_get_tt__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__RotateMode(soap, &this->tt__RotateOptions::Mode);
	this->tt__RotateOptions::DegreeList = NULL;
	this->tt__RotateOptions::Extension = NULL;
	this->tt__RotateOptions::Reboot = NULL;
}

void tt__RotateOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__RotateMode(soap, &this->tt__RotateOptions::Mode);
	soap_serialize_PointerTott__IntItems(soap, &this->tt__RotateOptions::DegreeList);
	soap_serialize_PointerTott__RotateOptionsExtension(soap, &this->tt__RotateOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptions(struct soap *soap, const char *tag, int id, const tt__RotateOptions *a, const char *type)
{
	if (((tt__RotateOptions*)a)->Reboot)
	{	soap_set_attr(soap, "Reboot", soap_bool2s(soap, *((tt__RotateOptions*)a)->Reboot), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptions), type ? type : "tt:RotateOptions"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__RotateMode(soap, "tt:Mode", -1, &a->tt__RotateOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__IntItems(soap, "tt:DegreeList", -1, &a->tt__RotateOptions::DegreeList, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateOptionsExtension(soap, "tt:Extension", -1, &a->tt__RotateOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_in_tt__RotateOptions(struct soap *soap, const char *tag, tt__RotateOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__RotateOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "Reboot", 5, 0);
		if (t)
		{
			if (!(((tt__RotateOptions*)a)->Reboot = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__RotateOptions*)a)->Reboot))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_DegreeList1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__RotateMode(soap, "tt:Mode", &a->tt__RotateOptions::Mode, "tt:RotateMode"))
					continue;
			}
			if (soap_flag_DegreeList1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntItems(soap, "tt:DegreeList", &a->tt__RotateOptions::DegreeList, "tt:IntItems"))
				{	soap_flag_DegreeList1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateOptionsExtension(soap, "tt:Extension", &a->tt__RotateOptions::Extension, "tt:RotateOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->tt__RotateOptions::Mode.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__RotateOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptions, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_dup_tt__RotateOptions(struct soap *soap, tt__RotateOptions *d, tt__RotateOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RotateOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RotateOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RotateOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__RotateMode(soap, &d->tt__RotateOptions::Mode, &a->tt__RotateOptions::Mode);
	soap_dup_PointerTott__IntItems(soap, &d->tt__RotateOptions::DegreeList, &a->tt__RotateOptions::DegreeList);
	soap_dup_PointerTott__RotateOptionsExtension(soap, &d->tt__RotateOptions::Extension, &a->tt__RotateOptions::Extension);
	soap_dup_PointerTobool(soap, &d->tt__RotateOptions::Reboot, &a->tt__RotateOptions::Reboot);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RotateOptions(tt__RotateOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__RotateMode(&a->tt__RotateOptions::Mode);
	soap_del_PointerTott__IntItems(&a->tt__RotateOptions::DegreeList);
	soap_del_PointerTott__RotateOptionsExtension(&a->tt__RotateOptions::Extension);
	soap_del_PointerTobool(&a->tt__RotateOptions::Reboot);
}

SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateOptions *p;
	size_t k = sizeof(tt__RotateOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_get_tt__RotateOptions(struct soap *soap, tt__RotateOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOftt__SceneOrientationMode(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__SceneOrientationMode(soap, &this->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2), type ? type : "tt:VideoSourceConfigurationOptionsExtension2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__SceneOrientationMode(soap, "tt:SceneOrientationMode", -1, &a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptionsExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__SceneOrientationMode(soap, "tt:SceneOrientationMode", &a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode, "tt:SceneOrientationMode"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_dup_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *d, tt__VideoSourceConfigurationOptionsExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfigurationOptionsExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfigurationOptionsExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOftt__SceneOrientationMode(soap, &d->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode, &a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfigurationOptionsExtension2(tt__VideoSourceConfigurationOptionsExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOftt__SceneOrientationMode(&a->tt__VideoSourceConfigurationOptionsExtension2::SceneOrientationMode);
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptionsExtension2 *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptionsExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptionsExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptionsExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptionsExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationOptionsExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationOptionsExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RotateOptions(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), type ? type : "tt:VideoSourceConfigurationOptionsExtension"))
		return soap->error;
	if (soap_out_PointerTott__RotateOptions(soap, "tt:Rotate", -1, &a->tt__VideoSourceConfigurationOptionsExtension::Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationOptionsExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateOptions(soap, "tt:Rotate", &a->tt__VideoSourceConfigurationOptionsExtension::Rotate, "tt:RotateOptions"))
				{	soap_flag_Rotate1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", &a->tt__VideoSourceConfigurationOptionsExtension::Extension, "tt:VideoSourceConfigurationOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_dup_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *d, tt__VideoSourceConfigurationOptionsExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfigurationOptionsExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfigurationOptionsExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__RotateOptions(soap, &d->tt__VideoSourceConfigurationOptionsExtension::Rotate, &a->tt__VideoSourceConfigurationOptionsExtension::Rotate);
	soap_dup_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, &d->tt__VideoSourceConfigurationOptionsExtension::Extension, &a->tt__VideoSourceConfigurationOptionsExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfigurationOptionsExtension(tt__VideoSourceConfigurationOptionsExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__RotateOptions(&a->tt__VideoSourceConfigurationOptionsExtension::Rotate);
	soap_del_PointerTott__VideoSourceConfigurationOptionsExtension2(&a->tt__VideoSourceConfigurationOptionsExtension::Extension);
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptionsExtension *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationOptions::BoundsRange = NULL;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	this->tt__VideoSourceConfigurationOptions::Extension = NULL;
	this->tt__VideoSourceConfigurationOptions::MaximumNumberOfProfiles = NULL;
}

void tt__VideoSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRectangleRange(soap, &this->tt__VideoSourceConfigurationOptions::BoundsRange);
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &this->tt__VideoSourceConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles)
	{	soap_set_attr(soap, "MaximumNumberOfProfiles", soap_int2s(soap, *((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), type ? type : "tt:VideoSourceConfigurationOptions"))
		return soap->error;
	if (!a->tt__VideoSourceConfigurationOptions::BoundsRange)
	{	if (soap_element_empty(soap, "tt:BoundsRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->tt__VideoSourceConfigurationOptions::BoundsRange, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", -1, &a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationOptions::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MaximumNumberOfProfiles", 5, 0);
		if (t)
		{
			if (!(((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tt__VideoSourceConfigurationOptions*)a)->MaximumNumberOfProfiles))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundsRange1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BoundsRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &a->tt__VideoSourceConfigurationOptions::BoundsRange, "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", &a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &a->tt__VideoSourceConfigurationOptions::Extension, "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__VideoSourceConfigurationOptions::BoundsRange || a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_dup_tt__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *d, tt__VideoSourceConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntRectangleRange(soap, &d->tt__VideoSourceConfigurationOptions::BoundsRange, &a->tt__VideoSourceConfigurationOptions::BoundsRange);
	soap_dup_std__vectorTemplateOftt__ReferenceToken(soap, &d->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, &a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	soap_dup_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &d->tt__VideoSourceConfigurationOptions::Extension, &a->tt__VideoSourceConfigurationOptions::Extension);
	soap_dup_PointerToint(soap, &d->tt__VideoSourceConfigurationOptions::MaximumNumberOfProfiles, &a->tt__VideoSourceConfigurationOptions::MaximumNumberOfProfiles);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfigurationOptions(tt__VideoSourceConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntRectangleRange(&a->tt__VideoSourceConfigurationOptions::BoundsRange);
	soap_del_std__vectorTemplateOftt__ReferenceToken(&a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable);
	soap_del_PointerTott__VideoSourceConfigurationOptionsExtension(&a->tt__VideoSourceConfigurationOptions::Extension);
	soap_del_PointerToint(&a->tt__VideoSourceConfigurationOptions::MaximumNumberOfProfiles);
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationOptions *p;
	size_t k = sizeof(tt__VideoSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationOptions(soap, tag ? tag : "tt:VideoSourceConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LensDescription::Offset = NULL;
	soap_default_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_default_float(soap, &this->tt__LensDescription::XFactor);
	this->tt__LensDescription::FocalLength = NULL;
}

void tt__LensDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__LensOffset(soap, &this->tt__LensDescription::Offset);
	soap_serialize_std__vectorTemplateOfPointerTott__LensProjection(soap, &this->tt__LensDescription::Projection);
	soap_embedded(soap, &this->tt__LensDescription::XFactor, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensDescription(struct soap *soap, const char *tag, int id, const tt__LensDescription *a, const char *type)
{
	if (((tt__LensDescription*)a)->FocalLength)
	{	soap_set_attr(soap, "FocalLength", soap_float2s(soap, *((tt__LensDescription*)a)->FocalLength), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensDescription), type ? type : "tt:LensDescription"))
		return soap->error;
	if (!a->tt__LensDescription::Offset)
	{	if (soap_element_empty(soap, "tt:Offset", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__LensOffset(soap, "tt:Offset", -1, &a->tt__LensDescription::Offset, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", -1, &a->tt__LensDescription::Projection, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:XFactor", -1, &a->tt__LensDescription::XFactor, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_in_tt__LensDescription(struct soap *soap, const char *tag, tt__LensDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FocalLength", 5, 0);
		if (t)
		{
			if (!(((tt__LensDescription*)a)->FocalLength = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LensDescription*)a)->FocalLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Offset1 = 1;
	size_t soap_flag_XFactor1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Offset1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__LensOffset(soap, "tt:Offset", &a->tt__LensDescription::Offset, "tt:LensOffset"))
				{	soap_flag_Offset1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensProjection(soap, "tt:Projection", &a->tt__LensDescription::Projection, "tt:LensProjection"))
					continue;
			}
			if (soap_flag_XFactor1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:XFactor", &a->tt__LensDescription::XFactor, "xsd:float"))
				{	soap_flag_XFactor1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__LensDescription::Offset || a->tt__LensDescription::Projection.size() < 1 || soap_flag_XFactor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensDescription, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_dup_tt__LensDescription(struct soap *soap, tt__LensDescription *d, tt__LensDescription const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LensDescription*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LensDescription, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LensDescription(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__LensOffset(soap, &d->tt__LensDescription::Offset, &a->tt__LensDescription::Offset);
	soap_dup_std__vectorTemplateOfPointerTott__LensProjection(soap, &d->tt__LensDescription::Projection, &a->tt__LensDescription::Projection);
	d->tt__LensDescription::XFactor = a->tt__LensDescription::XFactor;
	soap_dup_PointerTofloat(soap, &d->tt__LensDescription::FocalLength, &a->tt__LensDescription::FocalLength);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LensDescription(tt__LensDescription const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__LensOffset(&a->tt__LensDescription::Offset);
	soap_del_std__vectorTemplateOfPointerTott__LensProjection(&a->tt__LensDescription::Projection);
	/* XFactor skipped */
	soap_del_PointerTofloat(&a->tt__LensDescription::FocalLength);
}

SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensDescription *p;
	size_t k = sizeof(tt__LensDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensDescription * SOAP_FMAC4 soap_get_tt__LensDescription(struct soap *soap, tt__LensDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensOffset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__LensOffset::x = NULL;
	this->tt__LensOffset::y = NULL;
}

void tt__LensOffset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensOffset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensOffset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensOffset(struct soap *soap, const char *tag, int id, const tt__LensOffset *a, const char *type)
{
	if (((tt__LensOffset*)a)->x)
	{	soap_set_attr(soap, "x", soap_float2s(soap, *((tt__LensOffset*)a)->x), 1);
	}
	if (((tt__LensOffset*)a)->y)
	{	soap_set_attr(soap, "y", soap_float2s(soap, *((tt__LensOffset*)a)->y), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:LensOffset");
}

void *tt__LensOffset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensOffset(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_in_tt__LensOffset(struct soap *soap, const char *tag, tt__LensOffset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__LensOffset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensOffset)
		return (tt__LensOffset *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "x", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->x = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->x))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "y", 5, 0);
		if (t)
		{
			if (!(((tt__LensOffset*)a)->y = (float *)soap_malloc(soap, sizeof(float))))
				return NULL;
			if (soap_s2float(soap, t, ((tt__LensOffset*)a)->y))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_dup_tt__LensOffset(struct soap *soap, tt__LensOffset *d, tt__LensOffset const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LensOffset*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LensOffset, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LensOffset(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTofloat(soap, &d->tt__LensOffset::x, &a->tt__LensOffset::x);
	soap_dup_PointerTofloat(soap, &d->tt__LensOffset::y, &a->tt__LensOffset::y);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LensOffset(tt__LensOffset const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTofloat(&a->tt__LensOffset::x);
	soap_del_PointerTofloat(&a->tt__LensOffset::y);
}

SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensOffset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensOffset *p;
	size_t k = sizeof(tt__LensOffset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensOffset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensOffset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensOffset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensOffset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensOffset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensOffset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensOffset(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensOffset * SOAP_FMAC4 soap_get_tt__LensOffset(struct soap *soap, tt__LensOffset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__LensProjection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__LensProjection::Angle);
	soap_default_float(soap, &this->tt__LensProjection::Radius);
	this->tt__LensProjection::Transmittance = NULL;
}

void tt__LensProjection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__LensProjection::Angle, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__LensProjection::Radius, SOAP_TYPE_float);
	soap_serialize_PointerTofloat(soap, &this->tt__LensProjection::Transmittance);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__LensProjection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__LensProjection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__LensProjection(struct soap *soap, const char *tag, int id, const tt__LensProjection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__LensProjection), type ? type : "tt:LensProjection"))
		return soap->error;
	if (soap_out_float(soap, "tt:Angle", -1, &a->tt__LensProjection::Angle, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Radius", -1, &a->tt__LensProjection::Radius, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tt:Transmittance", -1, &a->tt__LensProjection::Transmittance, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__LensProjection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__LensProjection(soap, tag, this, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_in_tt__LensProjection(struct soap *soap, const char *tag, tt__LensProjection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__LensProjection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__LensProjection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__LensProjection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Angle1 = 1;
	size_t soap_flag_Radius1 = 1;
	size_t soap_flag_Transmittance1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Angle1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Angle", &a->tt__LensProjection::Angle, "xsd:float"))
				{	soap_flag_Angle1--;
					continue;
				}
			}
			if (soap_flag_Radius1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Radius", &a->tt__LensProjection::Radius, "xsd:float"))
				{	soap_flag_Radius1--;
					continue;
				}
			}
			if (soap_flag_Transmittance1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tt:Transmittance", &a->tt__LensProjection::Transmittance, "xsd:float"))
				{	soap_flag_Transmittance1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Angle1 > 0 || soap_flag_Radius1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__LensProjection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__LensProjection, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_dup_tt__LensProjection(struct soap *soap, tt__LensProjection *d, tt__LensProjection const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__LensProjection*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__LensProjection, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__LensProjection(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__LensProjection::Angle = a->tt__LensProjection::Angle;
	d->tt__LensProjection::Radius = a->tt__LensProjection::Radius;
	soap_dup_PointerTofloat(soap, &d->tt__LensProjection::Transmittance, &a->tt__LensProjection::Transmittance);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__LensProjection(tt__LensProjection const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Angle skipped */
	/* Radius skipped */
	soap_del_PointerTofloat(&a->tt__LensProjection::Transmittance);
}

SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__LensProjection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__LensProjection *p;
	size_t k = sizeof(tt__LensProjection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__LensProjection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__LensProjection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__LensProjection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__LensProjection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__LensProjection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__LensProjection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__LensProjection(soap, this, tag, type);
}

SOAP_FMAC3 tt__LensProjection * SOAP_FMAC4 soap_get_tt__LensProjection(struct soap *soap, tt__LensProjection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__RotateExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__RotateExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap *soap, const char *tag, int id, const tt__RotateExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:RotateExtension");
}

void *tt__RotateExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__RotateExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__RotateExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__RotateExtension)
		return (tt__RotateExtension *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_dup_tt__RotateExtension(struct soap *soap, tt__RotateExtension *d, tt__RotateExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__RotateExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__RotateExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__RotateExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__RotateExtension(tt__RotateExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__RotateExtension *p;
	size_t k = sizeof(tt__RotateExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__RotateExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__RotateExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__RotateExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__RotateExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__RotateExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Rotate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RotateMode(soap, &this->tt__Rotate::Mode);
	this->tt__Rotate::Degree = NULL;
	this->tt__Rotate::Extension = NULL;
}

void tt__Rotate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__Rotate::Degree);
	soap_serialize_PointerTott__RotateExtension(soap, &this->tt__Rotate::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Rotate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rotate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap *soap, const char *tag, int id, const tt__Rotate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rotate), type ? type : "tt:Rotate"))
		return soap->error;
	if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, &a->tt__Rotate::Mode, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Degree", -1, &a->tt__Rotate::Degree, ""))
		return soap->error;
	if (soap_out_PointerTott__RotateExtension(soap, "tt:Extension", -1, &a->tt__Rotate::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Rotate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Rotate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap *soap, const char *tag, tt__Rotate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rotate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Rotate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Rotate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Degree1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RotateMode(soap, "tt:Mode", &a->tt__Rotate::Mode, "tt:RotateMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap_flag_Degree1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:Degree", &a->tt__Rotate::Degree, "xsd:int"))
				{	soap_flag_Degree1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RotateExtension(soap, "tt:Extension", &a->tt__Rotate::Extension, "tt:RotateExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_dup_tt__Rotate(struct soap *soap, tt__Rotate *d, tt__Rotate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Rotate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Rotate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Rotate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__Rotate::Mode = a->tt__Rotate::Mode;
	soap_dup_PointerToint(soap, &d->tt__Rotate::Degree, &a->tt__Rotate::Degree);
	soap_dup_PointerTott__RotateExtension(soap, &d->tt__Rotate::Extension, &a->tt__Rotate::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Rotate(tt__Rotate const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Mode skipped */
	soap_del_PointerToint(&a->tt__Rotate::Degree);
	soap_del_PointerTott__RotateExtension(&a->tt__Rotate::Extension);
}

SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rotate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Rotate *p;
	size_t k = sizeof(tt__Rotate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Rotate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Rotate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Rotate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Rotate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Rotate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Rotate(soap, tag ? tag : "tt:Rotate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rotate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rotate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap *soap, tt__Rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	this->tt__VideoSourceConfigurationExtension2::SceneOrientation = NULL;
}

void tt__VideoSourceConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LensDescription(soap, &this->tt__VideoSourceConfigurationExtension2::LensDescription);
	soap_serialize_PointerTott__SceneOrientation(soap, &this->tt__VideoSourceConfigurationExtension2::SceneOrientation);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2), type ? type : "tt:VideoSourceConfigurationExtension2"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", -1, &a->tt__VideoSourceConfigurationExtension2::LensDescription, ""))
		return soap->error;
	if (soap_out_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", -1, &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_SceneOrientation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LensDescription(soap, "tt:LensDescription", &a->tt__VideoSourceConfigurationExtension2::LensDescription, "tt:LensDescription"))
					continue;
			}
			if (soap_flag_SceneOrientation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SceneOrientation(soap, "tt:SceneOrientation", &a->tt__VideoSourceConfigurationExtension2::SceneOrientation, "tt:SceneOrientation"))
				{	soap_flag_SceneOrientation1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_dup_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *d, tt__VideoSourceConfigurationExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfigurationExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfigurationExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfPointerTott__LensDescription(soap, &d->tt__VideoSourceConfigurationExtension2::LensDescription, &a->tt__VideoSourceConfigurationExtension2::LensDescription);
	soap_dup_PointerTott__SceneOrientation(soap, &d->tt__VideoSourceConfigurationExtension2::SceneOrientation, &a->tt__VideoSourceConfigurationExtension2::SceneOrientation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfigurationExtension2(tt__VideoSourceConfigurationExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfPointerTott__LensDescription(&a->tt__VideoSourceConfigurationExtension2::LensDescription);
	soap_del_PointerTott__SceneOrientation(&a->tt__VideoSourceConfigurationExtension2::SceneOrientation);
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension2 *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Rotate(soap, &this->tt__VideoSourceConfigurationExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, &this->tt__VideoSourceConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension), type ? type : "tt:VideoSourceConfigurationExtension"))
		return soap->error;
	if (soap_out_PointerTott__Rotate(soap, "tt:Rotate", -1, &a->tt__VideoSourceConfigurationExtension::Rotate, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceConfigurationExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Rotate(soap, "tt:Rotate", &a->tt__VideoSourceConfigurationExtension::Rotate, "tt:Rotate"))
				{	soap_flag_Rotate1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", &a->tt__VideoSourceConfigurationExtension::Extension, "tt:VideoSourceConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_dup_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *d, tt__VideoSourceConfigurationExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfigurationExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfigurationExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__Rotate(soap, &d->tt__VideoSourceConfigurationExtension::Rotate, &a->tt__VideoSourceConfigurationExtension::Rotate);
	soap_dup_PointerTott__VideoSourceConfigurationExtension2(soap, &d->tt__VideoSourceConfigurationExtension::Extension, &a->tt__VideoSourceConfigurationExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfigurationExtension(tt__VideoSourceConfigurationExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__Rotate(&a->tt__VideoSourceConfigurationExtension::Rotate);
	soap_del_PointerTott__VideoSourceConfigurationExtension2(&a->tt__VideoSourceConfigurationExtension::Extension);
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfigurationExtension *p;
	size_t k = sizeof(tt__VideoSourceConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfigurationExtension(soap, tag ? tag : "tt:VideoSourceConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	this->tt__VideoSourceConfiguration::Bounds = NULL;
	this->tt__VideoSourceConfiguration::Extension = NULL;
	this->tt__VideoSourceConfiguration::ViewMode = NULL;
}

void tt__VideoSourceConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoSourceConfiguration::SourceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &this->tt__VideoSourceConfiguration::Bounds);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &this->tt__VideoSourceConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfiguration *a, const char *type)
{
	if (((tt__VideoSourceConfiguration*)a)->ViewMode)
	{	soap_set_attr(soap, "ViewMode", soap_std__string2s(soap, *((tt__VideoSourceConfiguration*)a)->ViewMode), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), type ? type : "tt:VideoSourceConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__VideoSourceConfiguration::SourceToken, ""))
		return soap->error;
	if (!a->tt__VideoSourceConfiguration::Bounds)
	{	if (soap_element_empty(soap, "tt:Bounds", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->tt__VideoSourceConfiguration::Bounds, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &a->tt__VideoSourceConfiguration::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "ViewMode", 1, 0);
		if (t)
		{
			if (!(((tt__VideoSourceConfiguration*)a)->ViewMode = soap_new_std__string(soap)))
				return NULL;
			if (soap_s2std__string(soap, t, ((tt__VideoSourceConfiguration*)a)->ViewMode))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_Bounds1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &a->tt__VideoSourceConfiguration::SourceToken, "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			}
			if (soap_flag_Bounds1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &a->tt__VideoSourceConfiguration::Bounds, "tt:IntRectangle"))
				{	soap_flag_Bounds1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &a->tt__VideoSourceConfiguration::Extension, "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0 || !a->tt__VideoSourceConfiguration::Bounds))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_dup_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *d, tt__VideoSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ConfigurationEntity(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__VideoSourceConfiguration::SourceToken, &a->tt__VideoSourceConfiguration::SourceToken);
	soap_dup_PointerTott__IntRectangle(soap, &d->tt__VideoSourceConfiguration::Bounds, &a->tt__VideoSourceConfiguration::Bounds);
	soap_dup_PointerTott__VideoSourceConfigurationExtension(soap, &d->tt__VideoSourceConfiguration::Extension, &a->tt__VideoSourceConfiguration::Extension);
	soap_dup_PointerTostd__string(soap, &d->tt__VideoSourceConfiguration::ViewMode, &a->tt__VideoSourceConfiguration::ViewMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceConfiguration(tt__VideoSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ConfigurationEntity(a);
	soap_del_tt__ReferenceToken(&a->tt__VideoSourceConfiguration::SourceToken);
	soap_del_PointerTott__IntRectangle(&a->tt__VideoSourceConfiguration::Bounds);
	soap_del_PointerTott__VideoSourceConfigurationExtension(&a->tt__VideoSourceConfiguration::Extension);
	soap_del_PointerTostd__string(&a->tt__VideoSourceConfiguration::ViewMode);
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceConfiguration *p;
	size_t k = sizeof(tt__VideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type ? type : "tt:ConfigurationEntity"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigurationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_dup_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *d, tt__ConfigurationEntity const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ConfigurationEntity*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ConfigurationEntity, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ConfigurationEntity(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__Name(soap, &d->tt__ConfigurationEntity::Name, &a->tt__ConfigurationEntity::Name);
	d->tt__ConfigurationEntity::UseCount = a->tt__ConfigurationEntity::UseCount;
	soap_dup_tt__ReferenceToken(soap, &d->tt__ConfigurationEntity::token, &a->tt__ConfigurationEntity::token);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ConfigurationEntity(tt__ConfigurationEntity const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__Name(&a->tt__ConfigurationEntity::Name);
	/* UseCount skipped */
	soap_del_tt__ReferenceToken(&a->tt__ConfigurationEntity::token);
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigurationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
		return soap_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
		return soap_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
		return soap_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
		return soap_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
		return soap_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
		return soap_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
		return soap_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
		return soap_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return soap_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	tt__ConfigurationEntity *p;
	size_t k = sizeof(tt__ConfigurationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigurationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigurationEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigurationEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigurationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__ProfileExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ProfileExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const tt__ProfileExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:ProfileExtension2");
}

void *tt__ProfileExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, tt__ProfileExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__ProfileExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(tt__ProfileExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileExtension2)
		return (tt__ProfileExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_dup_tt__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *d, tt__ProfileExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ProfileExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ProfileExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ProfileExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ProfileExtension2(tt__ProfileExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileExtension2 *p;
	size_t k = sizeof(tt__ProfileExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ProfileExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ProfileExtension::AudioOutputConfiguration = NULL;
	this->tt__ProfileExtension::AudioDecoderConfiguration = NULL;
	this->tt__ProfileExtension::Extension = NULL;
}

void tt__ProfileExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &this->tt__ProfileExtension::AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &this->tt__ProfileExtension::AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &this->tt__ProfileExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ProfileExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const tt__ProfileExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), type ? type : "tt:ProfileExtension"))
		return soap->error;
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &a->tt__ProfileExtension::AudioOutputConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &a->tt__ProfileExtension::AudioDecoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &a->tt__ProfileExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ProfileExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ProfileExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ProfileExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_AudioOutputConfiguration1 = 1;
	size_t soap_flag_AudioDecoderConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AudioOutputConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &a->tt__ProfileExtension::AudioOutputConfiguration, "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioDecoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &a->tt__ProfileExtension::AudioDecoderConfiguration, "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &a->tt__ProfileExtension::Extension, "tt:ProfileExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_dup_tt__ProfileExtension(struct soap *soap, tt__ProfileExtension *d, tt__ProfileExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__ProfileExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__ProfileExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__ProfileExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__AudioOutputConfiguration(soap, &d->tt__ProfileExtension::AudioOutputConfiguration, &a->tt__ProfileExtension::AudioOutputConfiguration);
	soap_dup_PointerTott__AudioDecoderConfiguration(soap, &d->tt__ProfileExtension::AudioDecoderConfiguration, &a->tt__ProfileExtension::AudioDecoderConfiguration);
	soap_dup_PointerTott__ProfileExtension2(soap, &d->tt__ProfileExtension::Extension, &a->tt__ProfileExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__ProfileExtension(tt__ProfileExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__AudioOutputConfiguration(&a->tt__ProfileExtension::AudioOutputConfiguration);
	soap_del_PointerTott__AudioDecoderConfiguration(&a->tt__ProfileExtension::AudioDecoderConfiguration);
	soap_del_PointerTott__ProfileExtension2(&a->tt__ProfileExtension::Extension);
}

SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ProfileExtension *p;
	size_t k = sizeof(tt__ProfileExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ProfileExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ProfileExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ProfileExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ProfileExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ProfileExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Profile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__Profile::Name);
	this->tt__Profile::VideoSourceConfiguration = NULL;
	this->tt__Profile::AudioSourceConfiguration = NULL;
	this->tt__Profile::VideoEncoderConfiguration = NULL;
	this->tt__Profile::AudioEncoderConfiguration = NULL;
	this->tt__Profile::VideoAnalyticsConfiguration = NULL;
	this->tt__Profile::PTZConfiguration = NULL;
	this->tt__Profile::MetadataConfiguration = NULL;
	this->tt__Profile::Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Profile::token);
	this->tt__Profile::fixed = NULL;
}

void tt__Profile::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__Name(soap, &this->tt__Profile::Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &this->tt__Profile::VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &this->tt__Profile::AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &this->tt__Profile::VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &this->tt__Profile::AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &this->tt__Profile::VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->tt__Profile::PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &this->tt__Profile::MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &this->tt__Profile::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Profile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Profile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const tt__Profile *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__Profile*)a)->token), 1);
	if (((tt__Profile*)a)->fixed)
	{	soap_set_attr(soap, "fixed", soap_bool2s(soap, *((tt__Profile*)a)->fixed), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), type ? type : "tt:Profile"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__Profile::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &a->tt__Profile::VideoSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &a->tt__Profile::AudioSourceConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &a->tt__Profile::VideoEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &a->tt__Profile::AudioEncoderConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &a->tt__Profile::VideoAnalyticsConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &a->tt__Profile::PTZConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &a->tt__Profile::MetadataConfiguration, ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &a->tt__Profile::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Profile::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Profile(soap, tag, this, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, tt__Profile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Profile*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Profile)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Profile *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__Profile*)a)->token))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "fixed", 5, 0);
		if (t)
		{
			if (!(((tt__Profile*)a)->fixed = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tt__Profile*)a)->fixed))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_VideoSourceConfiguration1 = 1;
	size_t soap_flag_AudioSourceConfiguration1 = 1;
	size_t soap_flag_VideoEncoderConfiguration1 = 1;
	size_t soap_flag_AudioEncoderConfiguration1 = 1;
	size_t soap_flag_VideoAnalyticsConfiguration1 = 1;
	size_t soap_flag_PTZConfiguration1 = 1;
	size_t soap_flag_MetadataConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__Profile::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_VideoSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &a->tt__Profile::VideoSourceConfiguration, "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &a->tt__Profile::AudioSourceConfiguration, "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration1--;
					continue;
				}
			}
			if (soap_flag_VideoEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &a->tt__Profile::VideoEncoderConfiguration, "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_AudioEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &a->tt__Profile::AudioEncoderConfiguration, "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration1--;
					continue;
				}
			}
			if (soap_flag_VideoAnalyticsConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &a->tt__Profile::VideoAnalyticsConfiguration, "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration1--;
					continue;
				}
			}
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &a->tt__Profile::PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			}
			if (soap_flag_MetadataConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &a->tt__Profile::MetadataConfiguration, "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &a->tt__Profile::Extension, "tt:ProfileExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_dup_tt__Profile(struct soap *soap, tt__Profile *d, tt__Profile const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__Profile*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__Profile, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__Profile(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__Name(soap, &d->tt__Profile::Name, &a->tt__Profile::Name);
	soap_dup_PointerTott__VideoSourceConfiguration(soap, &d->tt__Profile::VideoSourceConfiguration, &a->tt__Profile::VideoSourceConfiguration);
	soap_dup_PointerTott__AudioSourceConfiguration(soap, &d->tt__Profile::AudioSourceConfiguration, &a->tt__Profile::AudioSourceConfiguration);
	soap_dup_PointerTott__VideoEncoderConfiguration(soap, &d->tt__Profile::VideoEncoderConfiguration, &a->tt__Profile::VideoEncoderConfiguration);
	soap_dup_PointerTott__AudioEncoderConfiguration(soap, &d->tt__Profile::AudioEncoderConfiguration, &a->tt__Profile::AudioEncoderConfiguration);
	soap_dup_PointerTott__VideoAnalyticsConfiguration(soap, &d->tt__Profile::VideoAnalyticsConfiguration, &a->tt__Profile::VideoAnalyticsConfiguration);
	soap_dup_PointerTott__PTZConfiguration(soap, &d->tt__Profile::PTZConfiguration, &a->tt__Profile::PTZConfiguration);
	soap_dup_PointerTott__MetadataConfiguration(soap, &d->tt__Profile::MetadataConfiguration, &a->tt__Profile::MetadataConfiguration);
	soap_dup_PointerTott__ProfileExtension(soap, &d->tt__Profile::Extension, &a->tt__Profile::Extension);
	soap_dup_tt__ReferenceToken(soap, &d->tt__Profile::token, &a->tt__Profile::token);
	soap_dup_PointerTobool(soap, &d->tt__Profile::fixed, &a->tt__Profile::fixed);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__Profile(tt__Profile const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__Name(&a->tt__Profile::Name);
	soap_del_PointerTott__VideoSourceConfiguration(&a->tt__Profile::VideoSourceConfiguration);
	soap_del_PointerTott__AudioSourceConfiguration(&a->tt__Profile::AudioSourceConfiguration);
	soap_del_PointerTott__VideoEncoderConfiguration(&a->tt__Profile::VideoEncoderConfiguration);
	soap_del_PointerTott__AudioEncoderConfiguration(&a->tt__Profile::AudioEncoderConfiguration);
	soap_del_PointerTott__VideoAnalyticsConfiguration(&a->tt__Profile::VideoAnalyticsConfiguration);
	soap_del_PointerTott__PTZConfiguration(&a->tt__Profile::PTZConfiguration);
	soap_del_PointerTott__MetadataConfiguration(&a->tt__Profile::MetadataConfiguration);
	soap_del_PointerTott__ProfileExtension(&a->tt__Profile::Extension);
	soap_del_tt__ReferenceToken(&a->tt__Profile::token);
	soap_del_PointerTobool(&a->tt__Profile::fixed);
}

SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Profile *p;
	size_t k = sizeof(tt__Profile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Profile);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Profile, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Profile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Profile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Profile(soap, tag ? tag : "tt:Profile", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Profile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Profile(soap, this, tag, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__AudioSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_int(soap, &this->tt__AudioSource::Channels);
}

void tt__AudioSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__AudioSource::Channels, SOAP_TYPE_int);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__AudioSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const tt__AudioSource *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), type ? type : "tt:AudioSource"))
		return soap->error;
	if (soap_out_int(soap, "tt:Channels", -1, &a->tt__AudioSource::Channels, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__AudioSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, tt__AudioSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__AudioSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__AudioSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Channels1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Channels1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Channels", &a->tt__AudioSource::Channels, "xsd:int"))
				{	soap_flag_Channels1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Channels1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_dup_tt__AudioSource(struct soap *soap, tt__AudioSource *d, tt__AudioSource const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__AudioSource*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__AudioSource, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__AudioSource(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	d->tt__AudioSource::Channels = a->tt__AudioSource::Channels;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__AudioSource(tt__AudioSource const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	/* Channels skipped */
}

SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__AudioSource *p;
	size_t k = sizeof(tt__AudioSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__AudioSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__AudioSource);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__AudioSource, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__AudioSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__AudioSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__AudioSource(soap, tag ? tag : "tt:AudioSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
}

void tt__VideoSourceExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:VideoSourceExtension2");
}

void *tt__VideoSourceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceExtension2(struct soap *soap, const char *tag, tt__VideoSourceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__VideoSourceExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(tt__VideoSourceExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceExtension2)
		return (tt__VideoSourceExtension2 *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_dup_tt__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *d, tt__VideoSourceExtension2 const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceExtension2*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceExtension2, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceExtension2(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceExtension2(tt__VideoSourceExtension2 const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
}

SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceExtension2 *p;
	size_t k = sizeof(tt__VideoSourceExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSourceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceExtension::Imaging = NULL;
	this->tt__VideoSourceExtension::Extension = NULL;
}

void tt__VideoSourceExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__ImagingSettings20(soap, &this->tt__VideoSourceExtension::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension2(soap, &this->tt__VideoSourceExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), type ? type : "tt:VideoSourceExtension"))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings20(soap, "tt:Imaging", -1, &a->tt__VideoSourceExtension::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension2(soap, "tt:Extension", -1, &a->tt__VideoSourceExtension::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSourceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSourceExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSourceExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings20(soap, "tt:Imaging", &a->tt__VideoSourceExtension::Imaging, "tt:ImagingSettings20"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceExtension2(soap, "tt:Extension", &a->tt__VideoSourceExtension::Extension, "tt:VideoSourceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_dup_tt__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *d, tt__VideoSourceExtension const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSourceExtension*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSourceExtension, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSourceExtension(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__ImagingSettings20(soap, &d->tt__VideoSourceExtension::Imaging, &a->tt__VideoSourceExtension::Imaging);
	soap_dup_PointerTott__VideoSourceExtension2(soap, &d->tt__VideoSourceExtension::Extension, &a->tt__VideoSourceExtension::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSourceExtension(tt__VideoSourceExtension const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__ImagingSettings20(&a->tt__VideoSourceExtension::Imaging);
	soap_del_PointerTott__VideoSourceExtension2(&a->tt__VideoSourceExtension::Extension);
}

SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSourceExtension *p;
	size_t k = sizeof(tt__VideoSourceExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSourceExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSourceExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSourceExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSourceExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSourceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSourceExtension(soap, tag ? tag : "tt:VideoSourceExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__VideoSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	soap_default_float(soap, &this->tt__VideoSource::Framerate);
	this->tt__VideoSource::Resolution = NULL;
	this->tt__VideoSource::Imaging = NULL;
	this->tt__VideoSource::Extension = NULL;
}

void tt__VideoSource::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__VideoSource::Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoSource::Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &this->tt__VideoSource::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &this->tt__VideoSource::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__VideoSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const tt__VideoSource *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), type ? type : "tt:VideoSource"))
		return soap->error;
	if (soap_out_float(soap, "tt:Framerate", -1, &a->tt__VideoSource::Framerate, ""))
		return soap->error;
	if (!a->tt__VideoSource::Resolution)
	{	if (soap_element_empty(soap, "tt:Resolution", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoSource::Resolution, ""))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &a->tt__VideoSource::Imaging, ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &a->tt__VideoSource::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSource::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__VideoSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, tt__VideoSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSource*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__VideoSource)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__VideoSource *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Framerate1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Framerate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Framerate", &a->tt__VideoSource::Framerate, "xsd:float"))
				{	soap_flag_Framerate1--;
					continue;
				}
			}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &a->tt__VideoSource::Resolution, "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &a->tt__VideoSource::Imaging, "tt:ImagingSettings"))
				{	soap_flag_Imaging1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &a->tt__VideoSource::Extension, "tt:VideoSourceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Framerate1 > 0 || !a->tt__VideoSource::Resolution))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_dup_tt__VideoSource(struct soap *soap, tt__VideoSource *d, tt__VideoSource const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__VideoSource*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__VideoSource, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__VideoSource(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	d->tt__VideoSource::Framerate = a->tt__VideoSource::Framerate;
	soap_dup_PointerTott__VideoResolution(soap, &d->tt__VideoSource::Resolution, &a->tt__VideoSource::Resolution);
	soap_dup_PointerTott__ImagingSettings(soap, &d->tt__VideoSource::Imaging, &a->tt__VideoSource::Imaging);
	soap_dup_PointerTott__VideoSourceExtension(soap, &d->tt__VideoSource::Extension, &a->tt__VideoSource::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__VideoSource(tt__VideoSource const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	/* Framerate skipped */
	soap_del_PointerTott__VideoResolution(&a->tt__VideoSource::Resolution);
	soap_del_PointerTott__ImagingSettings(&a->tt__VideoSource::Imaging);
	soap_del_PointerTott__VideoSourceExtension(&a->tt__VideoSource::Extension);
}

SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__VideoSource *p;
	size_t k = sizeof(tt__VideoSource);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__VideoSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__VideoSource);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__VideoSource, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__VideoSource location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__VideoSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__VideoSource(soap, tag ? tag : "tt:VideoSource", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntItems::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__vectorTemplateOfint(soap, &this->tt__IntItems::Items);
}

void tt__IntItems::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfint(soap, &this->tt__IntItems::Items);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntItems::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntItems(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntItems(struct soap *soap, const char *tag, int id, const tt__IntItems *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntItems), type ? type : "tt:IntItems"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "tt:Items", -1, &a->tt__IntItems::Items, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntItems::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntItems(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntItems * SOAP_FMAC4 soap_in_tt__IntItems(struct soap *soap, const char *tag, tt__IntItems *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntItems*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntItems, sizeof(tt__IntItems), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntItems)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntItems *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfint(soap, "tt:Items", &a->tt__IntItems::Items, "xsd:int"))
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntItems *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntItems, SOAP_TYPE_tt__IntItems, sizeof(tt__IntItems), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntItems * SOAP_FMAC2 soap_dup_tt__IntItems(struct soap *soap, tt__IntItems *d, tt__IntItems const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IntItems*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IntItems, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IntItems(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__vectorTemplateOfint(soap, &d->tt__IntItems::Items, &a->tt__IntItems::Items);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IntItems(tt__IntItems const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__vectorTemplateOfint(&a->tt__IntItems::Items);
}

SOAP_FMAC1 tt__IntItems * SOAP_FMAC2 soap_instantiate_tt__IntItems(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntItems(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntItems *p;
	size_t k = sizeof(tt__IntItems);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntItems, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntItems);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntItems, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntItems location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntItems::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntItems(soap, tag ? tag : "tt:IntItems", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntItems::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntItems(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntItems * SOAP_FMAC4 soap_get_tt__IntItems(struct soap *soap, tt__IntItems *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Max);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type ? type : "tt:DurationRange"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->tt__DurationRange::Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->tt__DurationRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DurationRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DurationRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Min", &a->tt__DurationRange::Min, "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Max", &a->tt__DurationRange::Max, "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_dup_tt__DurationRange(struct soap *soap, tt__DurationRange *d, tt__DurationRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DurationRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DurationRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DurationRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__duration(soap, &d->tt__DurationRange::Min, &a->tt__DurationRange::Min);
	soap_dup_xsd__duration(soap, &d->tt__DurationRange::Max, &a->tt__DurationRange::Max);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DurationRange(tt__DurationRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__duration(&a->tt__DurationRange::Min);
	soap_del_xsd__duration(&a->tt__DurationRange::Max);
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DurationRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DurationRange *p;
	size_t k = sizeof(tt__DurationRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DurationRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DurationRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DurationRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DurationRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type ? type : "tt:FloatRange"))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->tt__FloatRange::Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->tt__FloatRange::Max, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FloatRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FloatRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Min", &a->tt__FloatRange::Min, "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Max", &a->tt__FloatRange::Max, "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_dup_tt__FloatRange(struct soap *soap, tt__FloatRange *d, tt__FloatRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__FloatRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__FloatRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__FloatRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__FloatRange::Min = a->tt__FloatRange::Min;
	d->tt__FloatRange::Max = a->tt__FloatRange::Max;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__FloatRange(tt__FloatRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* Min skipped */
	/* Max skipped */
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FloatRange *p;
	size_t k = sizeof(tt__FloatRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FloatRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FloatRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FloatRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FloatRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangleRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IntRectangleRange::XRange = NULL;
	this->tt__IntRectangleRange::YRange = NULL;
	this->tt__IntRectangleRange::WidthRange = NULL;
	this->tt__IntRectangleRange::HeightRange = NULL;
}

void tt__IntRectangleRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::XRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::YRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::HeightRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangleRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangleRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const tt__IntRectangleRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), type ? type : "tt:IntRectangleRange"))
		return soap->error;
	if (!a->tt__IntRectangleRange::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->tt__IntRectangleRange::XRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->tt__IntRectangleRange::YRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::WidthRange)
	{	if (soap_element_empty(soap, "tt:WidthRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->tt__IntRectangleRange::WidthRange, ""))
		return soap->error;
	if (!a->tt__IntRectangleRange::HeightRange)
	{	if (soap_element_empty(soap, "tt:HeightRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->tt__IntRectangleRange::HeightRange, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangleRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangleRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangleRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangleRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRectangleRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	size_t soap_flag_WidthRange1 = 1;
	size_t soap_flag_HeightRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &a->tt__IntRectangleRange::XRange, "tt:IntRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &a->tt__IntRectangleRange::YRange, "tt:IntRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap_flag_WidthRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &a->tt__IntRectangleRange::WidthRange, "tt:IntRange"))
				{	soap_flag_WidthRange1--;
					continue;
				}
			}
			if (soap_flag_HeightRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &a->tt__IntRectangleRange::HeightRange, "tt:IntRange"))
				{	soap_flag_HeightRange1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tt__IntRectangleRange::XRange || !a->tt__IntRectangleRange::YRange || !a->tt__IntRectangleRange::WidthRange || !a->tt__IntRectangleRange::HeightRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_dup_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *d, tt__IntRectangleRange const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IntRectangleRange*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IntRectangleRange, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IntRectangleRange(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__IntRange(soap, &d->tt__IntRectangleRange::XRange, &a->tt__IntRectangleRange::XRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__IntRectangleRange::YRange, &a->tt__IntRectangleRange::YRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__IntRectangleRange::WidthRange, &a->tt__IntRectangleRange::WidthRange);
	soap_dup_PointerTott__IntRange(soap, &d->tt__IntRectangleRange::HeightRange, &a->tt__IntRectangleRange::HeightRange);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IntRectangleRange(tt__IntRectangleRange const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__IntRange(&a->tt__IntRectangleRange::XRange);
	soap_del_PointerTott__IntRange(&a->tt__IntRectangleRange::YRange);
	soap_del_PointerTott__IntRange(&a->tt__IntRectangleRange::WidthRange);
	soap_del_PointerTott__IntRange(&a->tt__IntRectangleRange::HeightRange);
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangleRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangleRange *p;
	size_t k = sizeof(tt__IntRectangleRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangleRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangleRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangleRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangleRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangleRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangleRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangleRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRectangle::x);
	soap_default_int(soap, &this->tt__IntRectangle::y);
	soap_default_int(soap, &this->tt__IntRectangle::width);
	soap_default_int(soap, &this->tt__IntRectangle::height);
}

void tt__IntRectangle::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((tt__IntRectangle*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((tt__IntRectangle*)a)->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, ((tt__IntRectangle*)a)->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, ((tt__IntRectangle*)a)->height), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:IntRectangle");
}

void *tt__IntRectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IntRectangle*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRectangle)
		return (tt__IntRectangle *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2int(soap, soap_attr_value(soap, "x", 5, 3), &((tt__IntRectangle*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 5, 3), &((tt__IntRectangle*)a)->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 5, 3), &((tt__IntRectangle*)a)->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 5, 3), &((tt__IntRectangle*)a)->height))
		return NULL;
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_dup_tt__IntRectangle(struct soap *soap, tt__IntRectangle *d, tt__IntRectangle const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__IntRectangle*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__IntRectangle, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__IntRectangle(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->tt__IntRectangle::x = a->tt__IntRectangle::x;
	d->tt__IntRectangle::y = a->tt__IntRectangle::y;
	d->tt__IntRectangle::width = a->tt__IntRectangle::width;
	d->tt__IntRectangle::height = a->tt__IntRectangle::height;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__IntRectangle(tt__IntRectangle const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* x skipped */
	/* y skipped */
	/* width skipped */
	/* height skipped */
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangle(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRectangle *p;
	size_t k = sizeof(tt__IntRectangle);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRectangle, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRectangle);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRectangle, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRectangle location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRectangle(soap, tag ? tag : "tt:IntRectangle", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tt:DeviceEntity");
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DeviceEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceEntity)
		return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_dup_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *d, tt__DeviceEntity const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tt__DeviceEntity*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tt__DeviceEntity, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tt__DeviceEntity(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_tt__ReferenceToken(soap, &d->tt__DeviceEntity::token, &a->tt__DeviceEntity::token);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tt__DeviceEntity(tt__DeviceEntity const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_tt__ReferenceToken(&a->tt__DeviceEntity::token);
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tds:StorageConfiguration"))
		return soap_instantiate_tds__StorageConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSource"))
		return soap_instantiate_tt__VideoSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSource"))
		return soap_instantiate_tt__AudioSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutput"))
		return soap_instantiate_tt__AudioOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
		return soap_instantiate_tt__NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayOutput"))
		return soap_instantiate_tt__RelayOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfiguration"))
		return soap_instantiate_tt__OSDConfiguration(soap, n, NULL, NULL, size);
	tt__DeviceEntity *p;
	size_t k = sizeof(tt__DeviceEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_in__tds__DeleteGeoLocationResponse(struct soap *soap, const char *tag, _tds__DeleteGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocationResponse, SOAP_TYPE__tds__DeleteGeoLocationResponse, sizeof(_tds__DeleteGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_dup__tds__DeleteGeoLocationResponse(struct soap *soap, _tds__DeleteGeoLocationResponse *d, _tds__DeleteGeoLocationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteGeoLocationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteGeoLocationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteGeoLocationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__DeleteGeoLocationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteGeoLocationResponse(_tds__DeleteGeoLocationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocationResponse *p;
	size_t k = sizeof(_tds__DeleteGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocationResponse(soap, tag ? tag : "tds:DeleteGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocationResponse * SOAP_FMAC4 soap_get__tds__DeleteGeoLocationResponse(struct soap *soap, _tds__DeleteGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
}

void _tds__DeleteGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__DeleteGeoLocation::Location);
#endif
}

int _tds__DeleteGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, const _tds__DeleteGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__DeleteGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_in__tds__DeleteGeoLocation(struct soap *soap, const char *tag, _tds__DeleteGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__DeleteGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__DeleteGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteGeoLocation, SOAP_TYPE__tds__DeleteGeoLocation, sizeof(_tds__DeleteGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_dup__tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *d, _tds__DeleteGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__LocationEntity(soap, &d->_tds__DeleteGeoLocation::Location, &a->_tds__DeleteGeoLocation::Location);
	d->_tds__DeleteGeoLocation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteGeoLocation(_tds__DeleteGeoLocation const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__LocationEntity(&a->_tds__DeleteGeoLocation::Location);
}

SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteGeoLocation *p;
	size_t k = sizeof(_tds__DeleteGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteGeoLocation(soap, tag ? tag : "tds:DeleteGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteGeoLocation * SOAP_FMAC4 soap_get__tds__DeleteGeoLocation(struct soap *soap, _tds__DeleteGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__SetGeoLocationResponse(struct soap *soap, const char *tag, _tds__SetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocationResponse, SOAP_TYPE__tds__SetGeoLocationResponse, sizeof(_tds__SetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_dup__tds__SetGeoLocationResponse(struct soap *soap, _tds__SetGeoLocationResponse *d, _tds__SetGeoLocationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetGeoLocationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetGeoLocationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetGeoLocationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetGeoLocationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetGeoLocationResponse(_tds__SetGeoLocationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocationResponse *p;
	size_t k = sizeof(_tds__SetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocationResponse(soap, tag ? tag : "tds:SetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__SetGeoLocationResponse(struct soap *soap, _tds__SetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
}

void _tds__SetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__SetGeoLocation::Location);
#endif
}

int _tds__SetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__SetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetGeoLocation), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__SetGeoLocation::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_in__tds__SetGeoLocation(struct soap *soap, const char *tag, _tds__SetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__SetGeoLocation::Location, "tt:LocationEntity"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__SetGeoLocation::Location.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetGeoLocation, SOAP_TYPE__tds__SetGeoLocation, sizeof(_tds__SetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_dup__tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *d, _tds__SetGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__LocationEntity(soap, &d->_tds__SetGeoLocation::Location, &a->_tds__SetGeoLocation::Location);
	d->_tds__SetGeoLocation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetGeoLocation(_tds__SetGeoLocation const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__LocationEntity(&a->_tds__SetGeoLocation::Location);
}

SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetGeoLocation *p;
	size_t k = sizeof(_tds__SetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetGeoLocation(soap, tag ? tag : "tds:SetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetGeoLocation * SOAP_FMAC4 soap_get__tds__SetGeoLocation(struct soap *soap, _tds__SetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
}

void _tds__GetGeoLocationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__LocationEntity(soap, &this->_tds__GetGeoLocationResponse::Location);
#endif
}

int _tds__GetGeoLocationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Location");
	if (soap_out_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", -1, &a->_tds__GetGeoLocationResponse::Location, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_in__tds__GetGeoLocationResponse(struct soap *soap, const char *tag, _tds__GetGeoLocationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__LocationEntity(soap, "tds:Location", &a->_tds__GetGeoLocationResponse::Location, "tt:LocationEntity"))
					continue;
			}
			soap_check_result(soap, "tds:Location");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocationResponse, SOAP_TYPE__tds__GetGeoLocationResponse, sizeof(_tds__GetGeoLocationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_dup__tds__GetGeoLocationResponse(struct soap *soap, _tds__GetGeoLocationResponse *d, _tds__GetGeoLocationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetGeoLocationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetGeoLocationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetGeoLocationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__LocationEntity(soap, &d->_tds__GetGeoLocationResponse::Location, &a->_tds__GetGeoLocationResponse::Location);
	d->_tds__GetGeoLocationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetGeoLocationResponse(_tds__GetGeoLocationResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__LocationEntity(&a->_tds__GetGeoLocationResponse::Location);
}

SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocationResponse *p;
	size_t k = sizeof(_tds__GetGeoLocationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocationResponse(soap, tag ? tag : "tds:GetGeoLocationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocationResponse * SOAP_FMAC4 soap_get__tds__GetGeoLocationResponse(struct soap *soap, _tds__GetGeoLocationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetGeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetGeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetGeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetGeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetGeoLocation(struct soap *soap, const char *tag, int id, const _tds__GetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetGeoLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetGeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetGeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_in__tds__GetGeoLocation(struct soap *soap, const char *tag, _tds__GetGeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetGeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetGeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetGeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetGeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetGeoLocation, SOAP_TYPE__tds__GetGeoLocation, sizeof(_tds__GetGeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_dup__tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *d, _tds__GetGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetGeoLocation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetGeoLocation(_tds__GetGeoLocation const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetGeoLocation *p;
	size_t k = sizeof(_tds__GetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetGeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetGeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetGeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetGeoLocation(soap, tag ? tag : "tds:GetGeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetGeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetGeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetGeoLocation * SOAP_FMAC4 soap_get__tds__GetGeoLocation(struct soap *soap, _tds__GetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, sizeof(_tds__DeleteStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_dup__tds__DeleteStorageConfigurationResponse(struct soap *soap, _tds__DeleteStorageConfigurationResponse *d, _tds__DeleteStorageConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteStorageConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteStorageConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__DeleteStorageConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteStorageConfigurationResponse(_tds__DeleteStorageConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfigurationResponse(soap, tag ? tag : "tds:DeleteStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteStorageConfigurationResponse(struct soap *soap, _tds__DeleteStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
}

void _tds__DeleteStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__DeleteStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__DeleteStorageConfiguration::Token);
#endif
}

int _tds__DeleteStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__DeleteStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in__tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, _tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__DeleteStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteStorageConfiguration, SOAP_TYPE__tds__DeleteStorageConfiguration, sizeof(_tds__DeleteStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_dup__tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *d, _tds__DeleteStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__DeleteStorageConfiguration::Token, &a->_tds__DeleteStorageConfiguration::Token);
	d->_tds__DeleteStorageConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteStorageConfiguration(_tds__DeleteStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__DeleteStorageConfiguration::Token);
}

SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteStorageConfiguration *p;
	size_t k = sizeof(_tds__DeleteStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteStorageConfiguration(soap, tag ? tag : "tds:DeleteStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get__tds__DeleteStorageConfiguration(struct soap *soap, _tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__SetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfigurationResponse, SOAP_TYPE__tds__SetStorageConfigurationResponse, sizeof(_tds__SetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetStorageConfigurationResponse(struct soap *soap, _tds__SetStorageConfigurationResponse *d, _tds__SetStorageConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetStorageConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetStorageConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetStorageConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetStorageConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetStorageConfigurationResponse(_tds__SetStorageConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__SetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfigurationResponse(soap, tag ? tag : "tds:SetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetStorageConfigurationResponse(struct soap *soap, _tds__SetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__SetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__SetStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__SetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__SetStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__SetStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_in__tds__SetStorageConfiguration(struct soap *soap, const char *tag, _tds__SetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__SetStorageConfiguration::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__SetStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetStorageConfiguration, SOAP_TYPE__tds__SetStorageConfiguration, sizeof(_tds__SetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_dup__tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *d, _tds__SetStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTotds__StorageConfiguration(soap, &d->_tds__SetStorageConfiguration::StorageConfiguration, &a->_tds__SetStorageConfiguration::StorageConfiguration);
	d->_tds__SetStorageConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetStorageConfiguration(_tds__SetStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTotds__StorageConfiguration(&a->_tds__SetStorageConfiguration::StorageConfiguration);
}

SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetStorageConfiguration *p;
	size_t k = sizeof(_tds__SetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetStorageConfiguration(soap, tag ? tag : "tds:SetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetStorageConfiguration * SOAP_FMAC4 soap_get__tds__SetStorageConfiguration(struct soap *soap, _tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetStorageConfigurationResponse::StorageConfiguration = NULL;
}

void _tds__GetStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationResponse::StorageConfiguration);
#endif
}

int _tds__GetStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse), type))
		return soap->error;
	if (a->StorageConfiguration)
		soap_element_result(soap, "tds:StorageConfiguration");
	if (!a->_tds__GetStorageConfigurationResponse::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", -1, &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfiguration(soap, "tds:StorageConfiguration", &a->_tds__GetStorageConfigurationResponse::StorageConfiguration, "tds:StorageConfiguration"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:StorageConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetStorageConfigurationResponse::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationResponse, SOAP_TYPE__tds__GetStorageConfigurationResponse, sizeof(_tds__GetStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetStorageConfigurationResponse(struct soap *soap, _tds__GetStorageConfigurationResponse *d, _tds__GetStorageConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetStorageConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetStorageConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetStorageConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTotds__StorageConfiguration(soap, &d->_tds__GetStorageConfigurationResponse::StorageConfiguration, &a->_tds__GetStorageConfigurationResponse::StorageConfiguration);
	d->_tds__GetStorageConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetStorageConfigurationResponse(_tds__GetStorageConfigurationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTotds__StorageConfiguration(&a->_tds__GetStorageConfigurationResponse::StorageConfiguration);
}

SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationResponse(soap, tag ? tag : "tds:GetStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationResponse(struct soap *soap, _tds__GetStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
}

void _tds__GetStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetStorageConfiguration::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetStorageConfiguration::Token);
#endif
}

int _tds__GetStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__GetStorageConfiguration::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_in__tds__GetStorageConfiguration(struct soap *soap, const char *tag, _tds__GetStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__GetStorageConfiguration::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfiguration, SOAP_TYPE__tds__GetStorageConfiguration, sizeof(_tds__GetStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_dup__tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *d, _tds__GetStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__GetStorageConfiguration::Token, &a->_tds__GetStorageConfiguration::Token);
	d->_tds__GetStorageConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetStorageConfiguration(_tds__GetStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__GetStorageConfiguration::Token);
}

SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfiguration *p;
	size_t k = sizeof(_tds__GetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfiguration(soap, tag ? tag : "tds:GetStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfiguration * SOAP_FMAC4 soap_get__tds__GetStorageConfiguration(struct soap *soap, _tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
}

void _tds__CreateStorageConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__CreateStorageConfigurationResponse::Token, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__CreateStorageConfigurationResponse::Token);
#endif
}

int _tds__CreateStorageConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Token");
	if (soap_out_tt__ReferenceToken(soap, "tds:Token", -1, &a->_tds__CreateStorageConfigurationResponse::Token, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateStorageConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateStorageConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Token1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Token1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Token", &a->_tds__CreateStorageConfigurationResponse::Token, "tt:ReferenceToken"))
				{	soap_flag_Token1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Token");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Token1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfigurationResponse, SOAP_TYPE__tds__CreateStorageConfigurationResponse, sizeof(_tds__CreateStorageConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_dup__tds__CreateStorageConfigurationResponse(struct soap *soap, _tds__CreateStorageConfigurationResponse *d, _tds__CreateStorageConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateStorageConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateStorageConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateStorageConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__CreateStorageConfigurationResponse::Token, &a->_tds__CreateStorageConfigurationResponse::Token);
	d->_tds__CreateStorageConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateStorageConfigurationResponse(_tds__CreateStorageConfigurationResponse const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__CreateStorageConfigurationResponse::Token);
}

SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateStorageConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfigurationResponse(soap, tag ? tag : "tds:CreateStorageConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateStorageConfigurationResponse(struct soap *soap, _tds__CreateStorageConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateStorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateStorageConfiguration::StorageConfiguration = NULL;
}

void _tds__CreateStorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &this->_tds__CreateStorageConfiguration::StorageConfiguration);
#endif
}

int _tds__CreateStorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateStorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateStorageConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateStorageConfiguration::StorageConfiguration)
	{	if (soap_element_empty(soap, "tds:StorageConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", -1, &a->_tds__CreateStorageConfiguration::StorageConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateStorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateStorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in__tds__CreateStorageConfiguration(struct soap *soap, const char *tag, _tds__CreateStorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateStorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateStorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateStorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_StorageConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StorageConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:StorageConfiguration", &a->_tds__CreateStorageConfiguration::StorageConfiguration, "tds:StorageConfigurationData"))
				{	soap_flag_StorageConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__CreateStorageConfiguration::StorageConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateStorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateStorageConfiguration, SOAP_TYPE__tds__CreateStorageConfiguration, sizeof(_tds__CreateStorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_dup__tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *d, _tds__CreateStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTotds__StorageConfigurationData(soap, &d->_tds__CreateStorageConfiguration::StorageConfiguration, &a->_tds__CreateStorageConfiguration::StorageConfiguration);
	d->_tds__CreateStorageConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateStorageConfiguration(_tds__CreateStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTotds__StorageConfigurationData(&a->_tds__CreateStorageConfiguration::StorageConfiguration);
}

SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateStorageConfiguration *p;
	size_t k = sizeof(_tds__CreateStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateStorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateStorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateStorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateStorageConfiguration(soap, tag ? tag : "tds:CreateStorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateStorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateStorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get__tds__CreateStorageConfiguration(struct soap *soap, _tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
}

void _tds__GetStorageConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &this->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
#endif
}

int _tds__GetStorageConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:StorageConfigurations");
	if (soap_out_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", -1, &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetStorageConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetStorageConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, "tds:StorageConfigurations", &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations, "tds:StorageConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:StorageConfigurations");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurationsResponse, SOAP_TYPE__tds__GetStorageConfigurationsResponse, sizeof(_tds__GetStorageConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_dup__tds__GetStorageConfigurationsResponse(struct soap *soap, _tds__GetStorageConfigurationsResponse *d, _tds__GetStorageConfigurationsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetStorageConfigurationsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetStorageConfigurationsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetStorageConfigurationsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTotds__StorageConfiguration(soap, &d->_tds__GetStorageConfigurationsResponse::StorageConfigurations, &a->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
	d->_tds__GetStorageConfigurationsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetStorageConfigurationsResponse(_tds__GetStorageConfigurationsResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTotds__StorageConfiguration(&a->_tds__GetStorageConfigurationsResponse::StorageConfigurations);
}

SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetStorageConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurationsResponse(soap, tag ? tag : "tds:GetStorageConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetStorageConfigurationsResponse(struct soap *soap, _tds__GetStorageConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetStorageConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetStorageConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetStorageConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetStorageConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetStorageConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetStorageConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetStorageConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_in__tds__GetStorageConfigurations(struct soap *soap, const char *tag, _tds__GetStorageConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetStorageConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetStorageConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetStorageConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetStorageConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetStorageConfigurations, SOAP_TYPE__tds__GetStorageConfigurations, sizeof(_tds__GetStorageConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_dup__tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *d, _tds__GetStorageConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetStorageConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetStorageConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetStorageConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetStorageConfigurations::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetStorageConfigurations(_tds__GetStorageConfigurations const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetStorageConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetStorageConfigurations *p;
	size_t k = sizeof(_tds__GetStorageConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetStorageConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetStorageConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetStorageConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetStorageConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetStorageConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetStorageConfigurations(soap, tag ? tag : "tds:GetStorageConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetStorageConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetStorageConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetStorageConfigurations * SOAP_FMAC4 soap_get__tds__GetStorageConfigurations(struct soap *soap, _tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHashingAlgorithmResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetHashingAlgorithmResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetHashingAlgorithmResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHashingAlgorithmResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHashingAlgorithmResponse(struct soap *soap, const char *tag, int id, const _tds__SetHashingAlgorithmResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHashingAlgorithmResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHashingAlgorithmResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHashingAlgorithmResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithmResponse * SOAP_FMAC4 soap_in__tds__SetHashingAlgorithmResponse(struct soap *soap, const char *tag, _tds__SetHashingAlgorithmResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHashingAlgorithmResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHashingAlgorithmResponse, sizeof(_tds__SetHashingAlgorithmResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHashingAlgorithmResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHashingAlgorithmResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHashingAlgorithmResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHashingAlgorithmResponse, SOAP_TYPE__tds__SetHashingAlgorithmResponse, sizeof(_tds__SetHashingAlgorithmResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHashingAlgorithmResponse * SOAP_FMAC2 soap_dup__tds__SetHashingAlgorithmResponse(struct soap *soap, _tds__SetHashingAlgorithmResponse *d, _tds__SetHashingAlgorithmResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHashingAlgorithmResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHashingAlgorithmResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHashingAlgorithmResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetHashingAlgorithmResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHashingAlgorithmResponse(_tds__SetHashingAlgorithmResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetHashingAlgorithmResponse * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithmResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHashingAlgorithmResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHashingAlgorithmResponse *p;
	size_t k = sizeof(_tds__SetHashingAlgorithmResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHashingAlgorithmResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHashingAlgorithmResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHashingAlgorithmResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHashingAlgorithmResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHashingAlgorithmResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHashingAlgorithmResponse(soap, tag ? tag : "tds:SetHashingAlgorithmResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHashingAlgorithmResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHashingAlgorithmResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithmResponse * SOAP_FMAC4 soap_get__tds__SetHashingAlgorithmResponse(struct soap *soap, _tds__SetHashingAlgorithmResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHashingAlgorithmResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHashingAlgorithm::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__StringList(soap, &this->_tds__SetHashingAlgorithm::Algorithm);
}

void _tds__SetHashingAlgorithm::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHashingAlgorithm::Algorithm, SOAP_TYPE_tt__StringList);
	soap_serialize_tt__StringList(soap, &this->_tds__SetHashingAlgorithm::Algorithm);
#endif
}

int _tds__SetHashingAlgorithm::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHashingAlgorithm(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, const _tds__SetHashingAlgorithm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHashingAlgorithm), type))
		return soap->error;
	if (soap_out_tt__StringList(soap, "tds:Algorithm", -1, &a->_tds__SetHashingAlgorithm::Algorithm, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHashingAlgorithm::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHashingAlgorithm(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm * SOAP_FMAC4 soap_in__tds__SetHashingAlgorithm(struct soap *soap, const char *tag, _tds__SetHashingAlgorithm *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHashingAlgorithm*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHashingAlgorithm)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHashingAlgorithm *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Algorithm1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Algorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__StringList(soap, "tds:Algorithm", &a->_tds__SetHashingAlgorithm::Algorithm, "tt:StringList"))
				{	soap_flag_Algorithm1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Algorithm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHashingAlgorithm *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHashingAlgorithm, SOAP_TYPE__tds__SetHashingAlgorithm, sizeof(_tds__SetHashingAlgorithm), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHashingAlgorithm * SOAP_FMAC2 soap_dup__tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *d, _tds__SetHashingAlgorithm const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHashingAlgorithm*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHashingAlgorithm, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHashingAlgorithm(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__StringList(soap, &d->_tds__SetHashingAlgorithm::Algorithm, &a->_tds__SetHashingAlgorithm::Algorithm);
	d->_tds__SetHashingAlgorithm::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHashingAlgorithm(_tds__SetHashingAlgorithm const*a)
{
	if (!a)
		return;
	soap_del_tt__StringList(&a->_tds__SetHashingAlgorithm::Algorithm);
}

SOAP_FMAC1 _tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHashingAlgorithm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHashingAlgorithm *p;
	size_t k = sizeof(_tds__SetHashingAlgorithm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHashingAlgorithm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHashingAlgorithm);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHashingAlgorithm, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHashingAlgorithm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHashingAlgorithm::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHashingAlgorithm(soap, tag ? tag : "tds:SetHashingAlgorithm", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHashingAlgorithm::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHashingAlgorithm(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHashingAlgorithm * SOAP_FMAC4 soap_get__tds__SetHashingAlgorithm(struct soap *soap, _tds__SetHashingAlgorithm *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
}

void _tds__StartSystemRestoreResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
#endif
}

int _tds__StartSystemRestoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartSystemRestoreResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestoreResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestoreResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestoreResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartSystemRestoreResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartSystemRestoreResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_UploadUri1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_dup__tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *d, _tds__StartSystemRestoreResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__StartSystemRestoreResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__StartSystemRestoreResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__StartSystemRestoreResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyURI(soap, &d->_tds__StartSystemRestoreResponse::UploadUri, &a->_tds__StartSystemRestoreResponse::UploadUri);
	soap_dup_xsd__duration(soap, &d->_tds__StartSystemRestoreResponse::ExpectedDownTime, &a->_tds__StartSystemRestoreResponse::ExpectedDownTime);
	d->_tds__StartSystemRestoreResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__StartSystemRestoreResponse(_tds__StartSystemRestoreResponse const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyURI(&a->_tds__StartSystemRestoreResponse::UploadUri);
	soap_del_xsd__duration(&a->_tds__StartSystemRestoreResponse::ExpectedDownTime);
}

SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestoreResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestoreResponse *p;
	size_t k = sizeof(_tds__StartSystemRestoreResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestoreResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestoreResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestoreResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestoreResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag ? tag : "tds:StartSystemRestoreResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartSystemRestore::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartSystemRestore::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartSystemRestore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestore::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartSystemRestore(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestore*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartSystemRestore)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartSystemRestore *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_dup__tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *d, _tds__StartSystemRestore const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__StartSystemRestore*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__StartSystemRestore, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__StartSystemRestore(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__StartSystemRestore::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__StartSystemRestore(_tds__StartSystemRestore const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartSystemRestore *p;
	size_t k = sizeof(_tds__StartSystemRestore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartSystemRestore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartSystemRestore);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartSystemRestore, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartSystemRestore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartSystemRestore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartSystemRestore(soap, tag ? tag : "tds:StartSystemRestore", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestore(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgradeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
}

void _tds__StartFirmwareUpgradeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
#endif
}

int _tds__StartFirmwareUpgradeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:UploadUri");
	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadUri, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgradeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgradeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgradeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgradeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_UploadDelay1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->_tds__StartFirmwareUpgradeResponse::UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			}
			if (soap_flag_UploadDelay1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:UploadDelay", &a->_tds__StartFirmwareUpgradeResponse::UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay1--;
					continue;
				}
			}
			if (soap_flag_ExpectedDownTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_UploadUri1 > 0 || soap_flag_UploadDelay1 > 0 || soap_flag_ExpectedDownTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_dup__tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *d, _tds__StartFirmwareUpgradeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__StartFirmwareUpgradeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__StartFirmwareUpgradeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyURI(soap, &d->_tds__StartFirmwareUpgradeResponse::UploadUri, &a->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_dup_xsd__duration(soap, &d->_tds__StartFirmwareUpgradeResponse::UploadDelay, &a->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_dup_xsd__duration(soap, &d->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, &a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
	d->_tds__StartFirmwareUpgradeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__StartFirmwareUpgradeResponse(_tds__StartFirmwareUpgradeResponse const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyURI(&a->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_del_xsd__duration(&a->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_del_xsd__duration(&a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
}

SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgradeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgradeResponse *p;
	size_t k = sizeof(_tds__StartFirmwareUpgradeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgradeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgradeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgradeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgradeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag ? tag : "tds:StartFirmwareUpgradeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgradeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgradeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__StartFirmwareUpgrade::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__StartFirmwareUpgrade::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__StartFirmwareUpgrade::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgrade::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__StartFirmwareUpgrade(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgrade*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__StartFirmwareUpgrade)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__StartFirmwareUpgrade *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_dup__tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *d, _tds__StartFirmwareUpgrade const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__StartFirmwareUpgrade*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__StartFirmwareUpgrade, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__StartFirmwareUpgrade(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__StartFirmwareUpgrade::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__StartFirmwareUpgrade(_tds__StartFirmwareUpgrade const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgrade(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__StartFirmwareUpgrade *p;
	size_t k = sizeof(_tds__StartFirmwareUpgrade);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__StartFirmwareUpgrade);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__StartFirmwareUpgrade, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__StartFirmwareUpgrade location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__StartFirmwareUpgrade::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag ? tag : "tds:StartFirmwareUpgrade", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgrade::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgrade(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUrisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemUrisResponse::SystemLogUris = NULL;
	this->_tds__GetSystemUrisResponse::SupportInfoUri = NULL;
	this->_tds__GetSystemUrisResponse::SystemBackupUri = NULL;
	this->_tds__GetSystemUrisResponse::Extension = NULL;
}

void _tds__GetSystemUrisResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLogUriList(soap, &this->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_serialize_PointerToxsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &this->_tds__GetSystemUrisResponse::Extension);
#endif
}

int _tds__GetSystemUrisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->_tds__GetSystemUrisResponse::SystemLogUris, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", -1, &a->_tds__GetSystemUrisResponse::SupportInfoUri, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", -1, &a->_tds__GetSystemUrisResponse::SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->_tds__GetSystemUrisResponse::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUrisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUrisResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUrisResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUrisResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUrisResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemLogUris1 = 1;
	size_t soap_flag_SupportInfoUri1 = 1;
	size_t soap_flag_SystemBackupUri1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->_tds__GetSystemUrisResponse::SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris1--;
					continue;
				}
			}
			if (soap_flag_SupportInfoUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SupportInfoUri", &a->_tds__GetSystemUrisResponse::SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri1--;
					continue;
				}
			}
			if (soap_flag_SystemBackupUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:SystemBackupUri", &a->_tds__GetSystemUrisResponse::SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->_tds__GetSystemUrisResponse::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_dup__tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *d, _tds__GetSystemUrisResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemUrisResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemUrisResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemUrisResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__SystemLogUriList(soap, &d->_tds__GetSystemUrisResponse::SystemLogUris, &a->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_dup_PointerToxsd__anyURI(soap, &d->_tds__GetSystemUrisResponse::SupportInfoUri, &a->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_dup_PointerToxsd__anyURI(soap, &d->_tds__GetSystemUrisResponse::SystemBackupUri, &a->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_dup_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &d->_tds__GetSystemUrisResponse::Extension, &a->_tds__GetSystemUrisResponse::Extension);
	d->_tds__GetSystemUrisResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemUrisResponse(_tds__GetSystemUrisResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__SystemLogUriList(&a->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_del_PointerToxsd__anyURI(&a->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_del_PointerToxsd__anyURI(&a->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_del_PointerTo_tds__GetSystemUrisResponse_Extension(&a->_tds__GetSystemUrisResponse::Extension);
}

SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUrisResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUrisResponse *p;
	size_t k = sizeof(_tds__GetSystemUrisResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUrisResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUrisResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUrisResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUrisResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUrisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUrisResponse(soap, tag ? tag : "tds:GetSystemUrisResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUrisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUrisResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemUris::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemUris::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemUris::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUris(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUris::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemUris(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUris*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemUris)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemUris *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_dup__tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *d, _tds__GetSystemUris const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemUris*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemUris, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemUris(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetSystemUris::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemUris(_tds__GetSystemUris const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUris(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemUris *p;
	size_t k = sizeof(_tds__GetSystemUris);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemUris, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemUris);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemUris, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemUris location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemUris::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemUris(soap, tag ? tag : "tds:GetSystemUris", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUris::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUris(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11NetworksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
}

void _tds__ScanAvailableDot11NetworksResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &this->_tds__ScanAvailableDot11NetworksResponse::Networks);
#endif
}

int _tds__ScanAvailableDot11NetworksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Networks");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", -1, &a->_tds__ScanAvailableDot11NetworksResponse::Networks, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11NetworksResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11NetworksResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, "tds:Networks", &a->_tds__ScanAvailableDot11NetworksResponse::Networks, "tt:Dot11AvailableNetworks"))
					continue;
			}
			soap_check_result(soap, "tds:Networks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_dup__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *d, _tds__ScanAvailableDot11NetworksResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__ScanAvailableDot11NetworksResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__ScanAvailableDot11NetworksResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(soap, &d->_tds__ScanAvailableDot11NetworksResponse::Networks, &a->_tds__ScanAvailableDot11NetworksResponse::Networks);
	d->_tds__ScanAvailableDot11NetworksResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__ScanAvailableDot11NetworksResponse(_tds__ScanAvailableDot11NetworksResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks(&a->_tds__ScanAvailableDot11NetworksResponse::Networks);
}

SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11NetworksResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11NetworksResponse *p;
	size_t k = sizeof(_tds__ScanAvailableDot11NetworksResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11NetworksResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11NetworksResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11NetworksResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11NetworksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag ? tag : "tds:ScanAvailableDot11NetworksResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11NetworksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__ScanAvailableDot11Networks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
}

void _tds__ScanAvailableDot11Networks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
#endif
}

int _tds__ScanAvailableDot11Networks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__ScanAvailableDot11Networks::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11Networks::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__ScanAvailableDot11Networks(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11Networks*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__ScanAvailableDot11Networks)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__ScanAvailableDot11Networks *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__ScanAvailableDot11Networks::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_dup__tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *d, _tds__ScanAvailableDot11Networks const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__ScanAvailableDot11Networks*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__ScanAvailableDot11Networks(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__ScanAvailableDot11Networks::InterfaceToken, &a->_tds__ScanAvailableDot11Networks::InterfaceToken);
	d->_tds__ScanAvailableDot11Networks::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__ScanAvailableDot11Networks(_tds__ScanAvailableDot11Networks const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__ScanAvailableDot11Networks::InterfaceToken);
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11Networks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__ScanAvailableDot11Networks *p;
	size_t k = sizeof(_tds__ScanAvailableDot11Networks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__ScanAvailableDot11Networks);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__ScanAvailableDot11Networks, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__ScanAvailableDot11Networks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__ScanAvailableDot11Networks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag ? tag : "tds:ScanAvailableDot11Networks", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11Networks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11Networks(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11StatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11StatusResponse::Status = NULL;
}

void _tds__GetDot11StatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Status(soap, &this->_tds__GetDot11StatusResponse::Status);
#endif
}

int _tds__GetDot11StatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (!a->_tds__GetDot11StatusResponse::Status)
	{	if (soap_element_empty(soap, "tds:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->_tds__GetDot11StatusResponse::Status, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11StatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11StatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11StatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11StatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11StatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Status1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->_tds__GetDot11StatusResponse::Status, "tt:Dot11Status"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetDot11StatusResponse::Status))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_dup__tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *d, _tds__GetDot11StatusResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot11StatusResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot11StatusResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot11StatusResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Dot11Status(soap, &d->_tds__GetDot11StatusResponse::Status, &a->_tds__GetDot11StatusResponse::Status);
	d->_tds__GetDot11StatusResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot11StatusResponse(_tds__GetDot11StatusResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Dot11Status(&a->_tds__GetDot11StatusResponse::Status);
}

SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11StatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11StatusResponse *p;
	size_t k = sizeof(_tds__GetDot11StatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11StatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11StatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11StatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11StatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11StatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11StatusResponse(soap, tag ? tag : "tds:GetDot11StatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11StatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11StatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
}

void _tds__GetDot11Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot11Status::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
#endif
}

int _tds__GetDot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__GetDot11Status::InterfaceToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Status(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Status*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__GetDot11Status::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_dup__tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *d, _tds__GetDot11Status const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot11Status*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot11Status, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot11Status(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__GetDot11Status::InterfaceToken, &a->_tds__GetDot11Status::InterfaceToken);
	d->_tds__GetDot11Status::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot11Status(_tds__GetDot11Status const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__GetDot11Status::InterfaceToken);
}

SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Status *p;
	size_t k = sizeof(_tds__GetDot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Status);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Status(soap, tag ? tag : "tds:GetDot11Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Status(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11CapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11CapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetDot11CapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot11Capabilities(soap, &this->_tds__GetDot11CapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetDot11CapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetDot11CapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetDot11CapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11CapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11CapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11CapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11CapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->_tds__GetDot11CapabilitiesResponse::Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetDot11CapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_dup__tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *d, _tds__GetDot11CapabilitiesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot11CapabilitiesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot11CapabilitiesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Dot11Capabilities(soap, &d->_tds__GetDot11CapabilitiesResponse::Capabilities, &a->_tds__GetDot11CapabilitiesResponse::Capabilities);
	d->_tds__GetDot11CapabilitiesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot11CapabilitiesResponse(_tds__GetDot11CapabilitiesResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Dot11Capabilities(&a->_tds__GetDot11CapabilitiesResponse::Capabilities);
}

SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11CapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11CapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetDot11CapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11CapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11CapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11CapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11CapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag ? tag : "tds:GetDot11CapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11CapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11CapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDot11Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot11Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot11Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_dup__tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *d, _tds__GetDot11Capabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot11Capabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot11Capabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot11Capabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDot11Capabilities::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot11Capabilities(_tds__GetDot11Capabilities const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot11Capabilities *p;
	size_t k = sizeof(_tds__GetDot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot11Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot11Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot11Capabilities(soap, tag ? tag : "tds:GetDot11Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse = NULL;
}

void _tds__SendAuxiliaryCommandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
#endif
}

int _tds__SendAuxiliaryCommandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommandResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommandResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommandResponse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_dup__tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *d, _tds__SendAuxiliaryCommandResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SendAuxiliaryCommandResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SendAuxiliaryCommandResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__AuxiliaryData(soap, &d->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse, &a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
	d->_tds__SendAuxiliaryCommandResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SendAuxiliaryCommandResponse(_tds__SendAuxiliaryCommandResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__AuxiliaryData(&a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
}

SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommandResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommandResponse *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommandResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommandResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommandResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag ? tag : "tds:SendAuxiliaryCommandResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SendAuxiliaryCommand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
}

void _tds__SendAuxiliaryCommand::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand, SOAP_TYPE_tt__AuxiliaryData);
	soap_serialize_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
#endif
}

int _tds__SendAuxiliaryCommand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommand::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SendAuxiliaryCommand(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SendAuxiliaryCommand)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SendAuxiliaryCommand *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryCommand1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_AuxiliaryCommand1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_dup__tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *d, _tds__SendAuxiliaryCommand const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SendAuxiliaryCommand*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SendAuxiliaryCommand, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SendAuxiliaryCommand(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__AuxiliaryData(soap, &d->_tds__SendAuxiliaryCommand::AuxiliaryCommand, &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
	d->_tds__SendAuxiliaryCommand::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SendAuxiliaryCommand(_tds__SendAuxiliaryCommand const*a)
{
	if (!a)
		return;
	soap_del_tt__AuxiliaryData(&a->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SendAuxiliaryCommand *p;
	size_t k = sizeof(_tds__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SendAuxiliaryCommand);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SendAuxiliaryCommand, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SendAuxiliaryCommand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag ? tag : "tds:SendAuxiliaryCommand", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommand(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputStateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputStateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputStateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_dup__tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *d, _tds__SetRelayOutputStateResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRelayOutputStateResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRelayOutputStateResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetRelayOutputStateResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRelayOutputStateResponse(_tds__SetRelayOutputStateResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputStateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputStateResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputStateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputStateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputStateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputStateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputStateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag ? tag : "tds:SetRelayOutputStateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &this->_tds__SetRelayOutputState::LogicalState);
}

void _tds__SetRelayOutputState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputState::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
#endif
}

int _tds__SetRelayOutputState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputState::RelayOutputToken, ""))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->_tds__SetRelayOutputState::LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputState::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputState(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputState)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputState *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_LogicalState1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputState::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_LogicalState1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->_tds__SetRelayOutputState::LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RelayOutputToken1 > 0 || soap_flag_LogicalState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_dup__tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *d, _tds__SetRelayOutputState const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRelayOutputState*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRelayOutputState, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRelayOutputState(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__SetRelayOutputState::RelayOutputToken, &a->_tds__SetRelayOutputState::RelayOutputToken);
	d->_tds__SetRelayOutputState::LogicalState = a->_tds__SetRelayOutputState::LogicalState;
	d->_tds__SetRelayOutputState::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRelayOutputState(_tds__SetRelayOutputState const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__SetRelayOutputState::RelayOutputToken);
	/* LogicalState skipped */
}

SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputState *p;
	size_t k = sizeof(_tds__SetRelayOutputState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputState);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputState, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputState(soap, tag ? tag : "tds:SetRelayOutputState", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputState(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRelayOutputSettingsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRelayOutputSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettingsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettingsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettingsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_dup__tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *d, _tds__SetRelayOutputSettingsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRelayOutputSettingsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRelayOutputSettingsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetRelayOutputSettingsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRelayOutputSettingsResponse(_tds__SetRelayOutputSettingsResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettingsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettingsResponse *p;
	size_t k = sizeof(_tds__SetRelayOutputSettingsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettingsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettingsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettingsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag ? tag : "tds:SetRelayOutputSettingsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	this->_tds__SetRelayOutputSettings::Properties = NULL;
}

void _tds__SetRelayOutputSettings::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->_tds__SetRelayOutputSettings::Properties);
#endif
}

int _tds__SetRelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputSettings::RelayOutputToken, ""))
		return soap->error;
	if (!a->_tds__SetRelayOutputSettings::Properties)
	{	if (soap_element_empty(soap, "tds:Properties", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->_tds__SetRelayOutputSettings::Properties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettings*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRelayOutputSettings)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRelayOutputSettings *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->_tds__SetRelayOutputSettings::RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->_tds__SetRelayOutputSettings::Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RelayOutputToken1 > 0 || !a->_tds__SetRelayOutputSettings::Properties))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_dup__tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *d, _tds__SetRelayOutputSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRelayOutputSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRelayOutputSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRelayOutputSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__SetRelayOutputSettings::RelayOutputToken, &a->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_dup_PointerTott__RelayOutputSettings(soap, &d->_tds__SetRelayOutputSettings::Properties, &a->_tds__SetRelayOutputSettings::Properties);
	d->_tds__SetRelayOutputSettings::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRelayOutputSettings(_tds__SetRelayOutputSettings const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_del_PointerTott__RelayOutputSettings(&a->_tds__SetRelayOutputSettings::Properties);
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRelayOutputSettings *p;
	size_t k = sizeof(_tds__SetRelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRelayOutputSettings);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRelayOutputSettings, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRelayOutputSettings(soap, tag ? tag : "tds:SetRelayOutputSettings", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
}

void _tds__GetRelayOutputsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__RelayOutput(soap, &this->_tds__GetRelayOutputsResponse::RelayOutputs);
#endif
}

int _tds__GetRelayOutputsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RelayOutputs");
	if (soap_out_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", -1, &a->_tds__GetRelayOutputsResponse::RelayOutputs, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__RelayOutput(soap, "tds:RelayOutputs", &a->_tds__GetRelayOutputsResponse::RelayOutputs, "tt:RelayOutput"))
					continue;
			}
			soap_check_result(soap, "tds:RelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_dup__tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *d, _tds__GetRelayOutputsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRelayOutputsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRelayOutputsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRelayOutputsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__RelayOutput(soap, &d->_tds__GetRelayOutputsResponse::RelayOutputs, &a->_tds__GetRelayOutputsResponse::RelayOutputs);
	d->_tds__GetRelayOutputsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRelayOutputsResponse(_tds__GetRelayOutputsResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__RelayOutput(&a->_tds__GetRelayOutputsResponse::RelayOutputs);
}

SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputsResponse *p;
	size_t k = sizeof(_tds__GetRelayOutputsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag ? tag : "tds:GetRelayOutputsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRelayOutputs::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRelayOutputs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRelayOutputs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputs::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRelayOutputs(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputs*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRelayOutputs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRelayOutputs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_dup__tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *d, _tds__GetRelayOutputs const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRelayOutputs*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRelayOutputs, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRelayOutputs(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetRelayOutputs::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRelayOutputs(_tds__GetRelayOutputs const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRelayOutputs *p;
	size_t k = sizeof(_tds__GetRelayOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRelayOutputs);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRelayOutputs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRelayOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRelayOutputs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRelayOutputs(soap, tag ? tag : "tds:GetRelayOutputs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputs(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_dup__tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *d, _tds__DeleteDot1XConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteDot1XConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteDot1XConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__DeleteDot1XConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteDot1XConfigurationResponse(_tds__DeleteDot1XConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__DeleteDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag ? tag : "tds:DeleteDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__DeleteDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__DeleteDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_dup__tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *d, _tds__DeleteDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOftt__ReferenceToken(soap, &d->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, &a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
	d->_tds__DeleteDot1XConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteDot1XConfiguration(_tds__DeleteDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOftt__ReferenceToken(&a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken);
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteDot1XConfiguration *p;
	size_t k = sizeof(_tds__DeleteDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag ? tag : "tds:DeleteDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
}

void _tds__GetDot1XConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Dot1XConfiguration");
	if (soap_out_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
					continue;
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_dup__tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *d, _tds__GetDot1XConfigurationsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot1XConfigurationsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot1XConfigurationsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Dot1XConfiguration(soap, &d->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, &a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
	d->_tds__GetDot1XConfigurationsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot1XConfigurationsResponse(_tds__GetDot1XConfigurationsResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Dot1XConfiguration(&a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration);
}

SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationsResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag ? tag : "tds:GetDot1XConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDot1XConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDot1XConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_dup__tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *d, _tds__GetDot1XConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot1XConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot1XConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot1XConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDot1XConfigurations::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot1XConfigurations(_tds__GetDot1XConfigurations const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurations *p;
	size_t k = sizeof(_tds__GetDot1XConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurations(soap, tag ? tag : "tds:GetDot1XConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration = NULL;
}

void _tds__GetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
#endif
}

int _tds__GetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *d, _tds__GetDot1XConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot1XConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot1XConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Dot1XConfiguration(soap, &d->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
	d->_tds__GetDot1XConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot1XConfigurationResponse(_tds__GetDot1XConfigurationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Dot1XConfiguration(&a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
}

SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__GetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag ? tag : "tds:GetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
}

void _tds__GetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
#endif
}

int _tds__GetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Dot1XConfigurationToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_dup__tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *d, _tds__GetDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
	d->_tds__GetDot1XConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDot1XConfiguration(_tds__GetDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDot1XConfiguration *p;
	size_t k = sizeof(_tds__GetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDot1XConfiguration(soap, tag ? tag : "tds:GetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *d, _tds__SetDot1XConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDot1XConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDot1XConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDot1XConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDot1XConfigurationResponse(_tds__SetDot1XConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__SetDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag ? tag : "tds:SetDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__SetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__SetDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__SetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__SetDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__SetDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_dup__tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *d, _tds__SetDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Dot1XConfiguration(soap, &d->_tds__SetDot1XConfiguration::Dot1XConfiguration, &a->_tds__SetDot1XConfiguration::Dot1XConfiguration);
	d->_tds__SetDot1XConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDot1XConfiguration(_tds__SetDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Dot1XConfiguration(&a->_tds__SetDot1XConfiguration::Dot1XConfiguration);
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDot1XConfiguration *p;
	size_t k = sizeof(_tds__SetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDot1XConfiguration(soap, tag ? tag : "tds:SetDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__CreateDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__CreateDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_dup__tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *d, _tds__CreateDot1XConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateDot1XConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateDot1XConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__CreateDot1XConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateDot1XConfigurationResponse(_tds__CreateDot1XConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfigurationResponse *p;
	size_t k = sizeof(_tds__CreateDot1XConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag ? tag : "tds:CreateDot1XConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateDot1XConfiguration::Dot1XConfiguration = NULL;
}

void _tds__CreateDot1XConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
#endif
}

int _tds__CreateDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_element_empty(soap, "tds:Dot1XConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateDot1XConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateDot1XConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__CreateDot1XConfiguration::Dot1XConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_dup__tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *d, _tds__CreateDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Dot1XConfiguration(soap, &d->_tds__CreateDot1XConfiguration::Dot1XConfiguration, &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
	d->_tds__CreateDot1XConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateDot1XConfiguration(_tds__CreateDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Dot1XConfiguration(&a->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateDot1XConfiguration *p;
	size_t k = sizeof(_tds__CreateDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateDot1XConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateDot1XConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag ? tag : "tds:CreateDot1XConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_dup__tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *d, _tds__LoadCACertificatesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCACertificatesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCACertificatesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCACertificatesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__LoadCACertificatesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCACertificatesResponse(_tds__LoadCACertificatesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag ? tag : "tds:LoadCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
}

void _tds__LoadCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCACertificates::CACertificate);
#endif
}

int _tds__LoadCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__LoadCACertificates::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__LoadCACertificates::CACertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__LoadCACertificates::CACertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_dup__tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *d, _tds__LoadCACertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCACertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCACertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCACertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Certificate(soap, &d->_tds__LoadCACertificates::CACertificate, &a->_tds__LoadCACertificates::CACertificate);
	d->_tds__LoadCACertificates::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCACertificates(_tds__LoadCACertificates const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Certificate(&a->_tds__LoadCACertificates::CACertificate);
}

SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCACertificates *p;
	size_t k = sizeof(_tds__LoadCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCACertificates(soap, tag ? tag : "tds:LoadCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificateInformationResponse::CertificateInformation = NULL;
}

void _tds__GetCertificateInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__CertificateInformation(soap, &this->_tds__GetCertificateInformationResponse::CertificateInformation);
#endif
}

int _tds__GetCertificateInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (!a->_tds__GetCertificateInformationResponse::CertificateInformation)
	{	if (soap_element_empty(soap, "tds:CertificateInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->_tds__GetCertificateInformationResponse::CertificateInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->_tds__GetCertificateInformationResponse::CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetCertificateInformationResponse::CertificateInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_dup__tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *d, _tds__GetCertificateInformationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificateInformationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificateInformationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificateInformationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__CertificateInformation(soap, &d->_tds__GetCertificateInformationResponse::CertificateInformation, &a->_tds__GetCertificateInformationResponse::CertificateInformation);
	d->_tds__GetCertificateInformationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificateInformationResponse(_tds__GetCertificateInformationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__CertificateInformation(&a->_tds__GetCertificateInformationResponse::CertificateInformation);
}

SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformationResponse *p;
	size_t k = sizeof(_tds__GetCertificateInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag ? tag : "tds:GetCertificateInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
}

void _tds__GetCertificateInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetCertificateInformation::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
#endif
}

int _tds__GetCertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetCertificateInformation::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificateInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificateInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetCertificateInformation::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_dup__tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *d, _tds__GetCertificateInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificateInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificateInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificateInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__token(soap, &d->_tds__GetCertificateInformation::CertificateID, &a->_tds__GetCertificateInformation::CertificateID);
	d->_tds__GetCertificateInformation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificateInformation(_tds__GetCertificateInformation const*a)
{
	if (!a)
		return;
	soap_del_xsd__token(&a->_tds__GetCertificateInformation::CertificateID);
}

SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificateInformation *p;
	size_t k = sizeof(_tds__GetCertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificateInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificateInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificateInformation(soap, tag ? tag : "tds:GetCertificateInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKeyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKeyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_dup__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *d, _tds__LoadCertificateWithPrivateKeyResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCertificateWithPrivateKeyResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCertificateWithPrivateKeyResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__LoadCertificateWithPrivateKeyResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCertificateWithPrivateKeyResponse(_tds__LoadCertificateWithPrivateKeyResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKeyResponse *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKeyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKeyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKeyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKeyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag ? tag : "tds:LoadCertificateWithPrivateKeyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
}

void _tds__LoadCertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
#endif
}

int _tds__LoadCertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificateWithPrivateKey)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificateWithPrivateKey *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_dup__tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *d, _tds__LoadCertificateWithPrivateKey const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCertificateWithPrivateKey*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCertificateWithPrivateKey(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(soap, &d->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, &a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
	d->_tds__LoadCertificateWithPrivateKey::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCertificateWithPrivateKey(_tds__LoadCertificateWithPrivateKey const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey(&a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey);
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificateWithPrivateKey *p;
	size_t k = sizeof(_tds__LoadCertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificateWithPrivateKey);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificateWithPrivateKey, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "tds:LoadCertificateWithPrivateKey", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
}

void _tds__GetCACertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCACertificatesResponse::CACertificate);
#endif
}

int _tds__GetCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CACertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", -1, &a->_tds__GetCACertificatesResponse::CACertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:CACertificate", &a->_tds__GetCACertificatesResponse::CACertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:CACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_dup__tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *d, _tds__GetCACertificatesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCACertificatesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCACertificatesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCACertificatesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Certificate(soap, &d->_tds__GetCACertificatesResponse::CACertificate, &a->_tds__GetCACertificatesResponse::CACertificate);
	d->_tds__GetCACertificatesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCACertificatesResponse(_tds__GetCACertificatesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Certificate(&a->_tds__GetCACertificatesResponse::CACertificate);
}

SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificatesResponse *p;
	size_t k = sizeof(_tds__GetCACertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificatesResponse(soap, tag ? tag : "tds:GetCACertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCACertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const _tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCACertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCACertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_dup__tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *d, _tds__GetCACertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCACertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCACertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCACertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetCACertificates::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCACertificates(_tds__GetCACertificates const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCACertificates *p;
	size_t k = sizeof(_tds__GetCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCACertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCACertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCACertificates(soap, tag ? tag : "tds:GetCACertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_dup__tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *d, _tds__SetClientCertificateModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetClientCertificateModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetClientCertificateModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetClientCertificateModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetClientCertificateModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetClientCertificateModeResponse(_tds__SetClientCertificateModeResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__SetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag ? tag : "tds:SetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetClientCertificateMode::Enabled);
}

void _tds__SetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetClientCertificateMode::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetClientCertificateMode::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetClientCertificateMode::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_dup__tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *d, _tds__SetClientCertificateMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetClientCertificateMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetClientCertificateMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetClientCertificateMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetClientCertificateMode::Enabled = a->_tds__SetClientCertificateMode::Enabled;
	d->_tds__SetClientCertificateMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetClientCertificateMode(_tds__SetClientCertificateMode const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
}

SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetClientCertificateMode *p;
	size_t k = sizeof(_tds__SetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetClientCertificateMode(soap, tag ? tag : "tds:SetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetClientCertificateModeResponse::Enabled);
}

void _tds__GetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetClientCertificateModeResponse::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__GetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetClientCertificateModeResponse::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetClientCertificateModeResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_dup__tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *d, _tds__GetClientCertificateModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetClientCertificateModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetClientCertificateModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetClientCertificateModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetClientCertificateModeResponse::Enabled = a->_tds__GetClientCertificateModeResponse::Enabled;
	d->_tds__GetClientCertificateModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetClientCertificateModeResponse(_tds__GetClientCertificateModeResponse const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
}

SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateModeResponse *p;
	size_t k = sizeof(_tds__GetClientCertificateModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag ? tag : "tds:GetClientCertificateModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetClientCertificateMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetClientCertificateMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetClientCertificateMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_dup__tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *d, _tds__GetClientCertificateMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetClientCertificateMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetClientCertificateMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetClientCertificateMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetClientCertificateMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetClientCertificateMode(_tds__GetClientCertificateMode const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetClientCertificateMode *p;
	size_t k = sizeof(_tds__GetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetClientCertificateMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetClientCertificateMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetClientCertificateMode(soap, tag ? tag : "tds:GetClientCertificateMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__LoadCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__LoadCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_dup__tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *d, _tds__LoadCertificatesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCertificatesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCertificatesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCertificatesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__LoadCertificatesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCertificatesResponse(_tds__LoadCertificatesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificatesResponse *p;
	size_t k = sizeof(_tds__LoadCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificatesResponse(soap, tag ? tag : "tds:LoadCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__LoadCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
}

void _tds__LoadCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__LoadCertificates::NVTCertificate);
#endif
}

int _tds__LoadCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", -1, &a->_tds__LoadCertificates::NVTCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__LoadCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__LoadCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__LoadCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NVTCertificate", &a->_tds__LoadCertificates::NVTCertificate, "tt:Certificate"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__LoadCertificates::NVTCertificate.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_dup__tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *d, _tds__LoadCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__LoadCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__LoadCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__LoadCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Certificate(soap, &d->_tds__LoadCertificates::NVTCertificate, &a->_tds__LoadCertificates::NVTCertificate);
	d->_tds__LoadCertificates::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__LoadCertificates(_tds__LoadCertificates const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Certificate(&a->_tds__LoadCertificates::NVTCertificate);
}

SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__LoadCertificates *p;
	size_t k = sizeof(_tds__LoadCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__LoadCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__LoadCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__LoadCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__LoadCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__LoadCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__LoadCertificates(soap, tag ? tag : "tds:LoadCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10RequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPkcs10RequestResponse::Pkcs10Request = NULL;
}

void _tds__GetPkcs10RequestResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10RequestResponse::Pkcs10Request);
#endif
}

int _tds__GetPkcs10RequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (!a->_tds__GetPkcs10RequestResponse::Pkcs10Request)
	{	if (soap_element_empty(soap, "tds:Pkcs10Request", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10RequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10RequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10RequestResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10RequestResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10RequestResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Pkcs10Request1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetPkcs10RequestResponse::Pkcs10Request))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_dup__tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *d, _tds__GetPkcs10RequestResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPkcs10RequestResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPkcs10RequestResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPkcs10RequestResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__BinaryData(soap, &d->_tds__GetPkcs10RequestResponse::Pkcs10Request, &a->_tds__GetPkcs10RequestResponse::Pkcs10Request);
	d->_tds__GetPkcs10RequestResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPkcs10RequestResponse(_tds__GetPkcs10RequestResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__BinaryData(&a->_tds__GetPkcs10RequestResponse::Pkcs10Request);
}

SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10RequestResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10RequestResponse *p;
	size_t k = sizeof(_tds__GetPkcs10RequestResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10RequestResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10RequestResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10RequestResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10RequestResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10RequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag ? tag : "tds:GetPkcs10RequestResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10RequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10RequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPkcs10Request::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	this->_tds__GetPkcs10Request::Subject = NULL;
	this->_tds__GetPkcs10Request::Attributes = NULL;
}

void _tds__GetPkcs10Request::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetPkcs10Request::CertificateID, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__GetPkcs10Request::Subject);
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10Request::Attributes);
#endif
}

int _tds__GetPkcs10Request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10Request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetPkcs10Request::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__GetPkcs10Request::Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->_tds__GetPkcs10Request::Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10Request::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPkcs10Request(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10Request*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPkcs10Request)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPkcs10Request *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_Attributes1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:CertificateID", &a->_tds__GetPkcs10Request::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__GetPkcs10Request::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_Attributes1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->_tds__GetPkcs10Request::Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_CertificateID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_dup__tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *d, _tds__GetPkcs10Request const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPkcs10Request*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPkcs10Request, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPkcs10Request(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__token(soap, &d->_tds__GetPkcs10Request::CertificateID, &a->_tds__GetPkcs10Request::CertificateID);
	soap_dup_PointerTostd__string(soap, &d->_tds__GetPkcs10Request::Subject, &a->_tds__GetPkcs10Request::Subject);
	soap_dup_PointerTott__BinaryData(soap, &d->_tds__GetPkcs10Request::Attributes, &a->_tds__GetPkcs10Request::Attributes);
	d->_tds__GetPkcs10Request::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPkcs10Request(_tds__GetPkcs10Request const*a)
{
	if (!a)
		return;
	soap_del_xsd__token(&a->_tds__GetPkcs10Request::CertificateID);
	soap_del_PointerTostd__string(&a->_tds__GetPkcs10Request::Subject);
	soap_del_PointerTott__BinaryData(&a->_tds__GetPkcs10Request::Attributes);
}

SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10Request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPkcs10Request *p;
	size_t k = sizeof(_tds__GetPkcs10Request);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPkcs10Request);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPkcs10Request, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPkcs10Request location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPkcs10Request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPkcs10Request(soap, tag ? tag : "tds:GetPkcs10Request", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10Request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10Request(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_dup__tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *d, _tds__DeleteCertificatesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteCertificatesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteCertificatesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteCertificatesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__DeleteCertificatesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteCertificatesResponse(_tds__DeleteCertificatesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificatesResponse *p;
	size_t k = sizeof(_tds__DeleteCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag ? tag : "tds:DeleteCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
}

void _tds__DeleteCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__DeleteCertificates::CertificateID);
#endif
}

int _tds__DeleteCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", -1, &a->_tds__DeleteCertificates::CertificateID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:CertificateID", &a->_tds__DeleteCertificates::CertificateID, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__DeleteCertificates::CertificateID.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_dup__tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *d, _tds__DeleteCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfxsd__token(soap, &d->_tds__DeleteCertificates::CertificateID, &a->_tds__DeleteCertificates::CertificateID);
	d->_tds__DeleteCertificates::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteCertificates(_tds__DeleteCertificates const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfxsd__token(&a->_tds__DeleteCertificates::CertificateID);
}

SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteCertificates *p;
	size_t k = sizeof(_tds__DeleteCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteCertificates(soap, tag ? tag : "tds:DeleteCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_dup__tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *d, _tds__SetCertificatesStatusResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetCertificatesStatusResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetCertificatesStatusResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetCertificatesStatusResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetCertificatesStatusResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetCertificatesStatusResponse(_tds__SetCertificatesStatusResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__SetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag ? tag : "tds:SetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
}

void _tds__SetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__SetCertificatesStatus::CertificateStatus);
#endif
}

int _tds__SetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__SetCertificatesStatus::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__SetCertificatesStatus::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_dup__tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *d, _tds__SetCertificatesStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetCertificatesStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetCertificatesStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetCertificatesStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &d->_tds__SetCertificatesStatus::CertificateStatus, &a->_tds__SetCertificatesStatus::CertificateStatus);
	d->_tds__SetCertificatesStatus::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetCertificatesStatus(_tds__SetCertificatesStatus const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__CertificateStatus(&a->_tds__SetCertificatesStatus::CertificateStatus);
}

SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetCertificatesStatus *p;
	size_t k = sizeof(_tds__SetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetCertificatesStatus(soap, tag ? tag : "tds:SetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
}

void _tds__GetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &this->_tds__GetCertificatesStatusResponse::CertificateStatus);
#endif
}

int _tds__GetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:CertificateStatus");
	if (soap_out_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, &a->_tds__GetCertificatesStatusResponse::CertificateStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__CertificateStatus(soap, "tds:CertificateStatus", &a->_tds__GetCertificatesStatusResponse::CertificateStatus, "tt:CertificateStatus"))
					continue;
			}
			soap_check_result(soap, "tds:CertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_dup__tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *d, _tds__GetCertificatesStatusResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificatesStatusResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificatesStatusResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificatesStatusResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__CertificateStatus(soap, &d->_tds__GetCertificatesStatusResponse::CertificateStatus, &a->_tds__GetCertificatesStatusResponse::CertificateStatus);
	d->_tds__GetCertificatesStatusResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificatesStatusResponse(_tds__GetCertificatesStatusResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__CertificateStatus(&a->_tds__GetCertificatesStatusResponse::CertificateStatus);
}

SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatusResponse *p;
	size_t k = sizeof(_tds__GetCertificatesStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag ? tag : "tds:GetCertificatesStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificatesStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_dup__tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *d, _tds__GetCertificatesStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificatesStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificatesStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificatesStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetCertificatesStatus::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificatesStatus(_tds__GetCertificatesStatus const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesStatus *p;
	size_t k = sizeof(_tds__GetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesStatus(soap, tag ? tag : "tds:GetCertificatesStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
}

void _tds__GetCertificatesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Certificate(soap, &this->_tds__GetCertificatesResponse::NvtCertificate);
#endif
}

int _tds__GetCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NvtCertificate");
	if (soap_out_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__GetCertificatesResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, _tds__GetCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificatesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificatesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__GetCertificatesResponse::NvtCertificate, "tt:Certificate"))
					continue;
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_dup__tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *d, _tds__GetCertificatesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificatesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificatesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificatesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Certificate(soap, &d->_tds__GetCertificatesResponse::NvtCertificate, &a->_tds__GetCertificatesResponse::NvtCertificate);
	d->_tds__GetCertificatesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificatesResponse(_tds__GetCertificatesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Certificate(&a->_tds__GetCertificatesResponse::NvtCertificate);
}

SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificatesResponse *p;
	size_t k = sizeof(_tds__GetCertificatesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificatesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificatesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificatesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificatesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificatesResponse(soap, tag ? tag : "tds:GetCertificatesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetCertificates::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const _tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificates*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCertificates)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCertificates *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_dup__tds__GetCertificates(struct soap *soap, _tds__GetCertificates *d, _tds__GetCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetCertificates::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCertificates(_tds__GetCertificates const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCertificates *p;
	size_t k = sizeof(_tds__GetCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCertificates);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCertificates, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCertificates(soap, tag ? tag : "tds:GetCertificates", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificateResponse::NvtCertificate = NULL;
}

void _tds__CreateCertificateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Certificate(soap, &this->_tds__CreateCertificateResponse::NvtCertificate);
#endif
}

int _tds__CreateCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const _tds__CreateCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (!a->_tds__CreateCertificateResponse::NvtCertificate)
	{	if (soap_element_empty(soap, "tds:NvtCertificate", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__CreateCertificateResponse::NvtCertificate, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, _tds__CreateCertificateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificateResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificateResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificateResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NvtCertificate1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->_tds__CreateCertificateResponse::NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__CreateCertificateResponse::NvtCertificate))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_dup__tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *d, _tds__CreateCertificateResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateCertificateResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateCertificateResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateCertificateResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Certificate(soap, &d->_tds__CreateCertificateResponse::NvtCertificate, &a->_tds__CreateCertificateResponse::NvtCertificate);
	d->_tds__CreateCertificateResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateCertificateResponse(_tds__CreateCertificateResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Certificate(&a->_tds__CreateCertificateResponse::NvtCertificate);
}

SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificateResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificateResponse *p;
	size_t k = sizeof(_tds__CreateCertificateResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificateResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificateResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificateResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificateResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificateResponse(soap, tag ? tag : "tds:CreateCertificateResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificate::CertificateID = NULL;
	this->_tds__CreateCertificate::Subject = NULL;
	this->_tds__CreateCertificate::ValidNotBefore = NULL;
	this->_tds__CreateCertificate::ValidNotAfter = NULL;
}

void _tds__CreateCertificate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__token(soap, &this->_tds__CreateCertificate::CertificateID);
	soap_serialize_PointerTostd__string(soap, &this->_tds__CreateCertificate::Subject);
	soap_serialize_PointerTodateTime(soap, &this->_tds__CreateCertificate::ValidNotBefore);
	soap_serialize_PointerTodateTime(soap, &this->_tds__CreateCertificate::ValidNotAfter);
#endif
}

int _tds__CreateCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const _tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_PointerToxsd__token(soap, "tds:CertificateID", -1, &a->_tds__CreateCertificate::CertificateID, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Subject", -1, &a->_tds__CreateCertificate::Subject, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotBefore", -1, &a->_tds__CreateCertificate::ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerTodateTime(soap, "tds:ValidNotAfter", -1, &a->_tds__CreateCertificate::ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateCertificate(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificate*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateCertificate)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateCertificate *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__token(soap, "tds:CertificateID", &a->_tds__CreateCertificate::CertificateID, "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Subject", &a->_tds__CreateCertificate::Subject, "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			}
			if (soap_flag_ValidNotBefore1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotBefore", &a->_tds__CreateCertificate::ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			}
			if (soap_flag_ValidNotAfter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTodateTime(soap, "tds:ValidNotAfter", &a->_tds__CreateCertificate::ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_dup__tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *d, _tds__CreateCertificate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateCertificate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateCertificate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateCertificate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerToxsd__token(soap, &d->_tds__CreateCertificate::CertificateID, &a->_tds__CreateCertificate::CertificateID);
	soap_dup_PointerTostd__string(soap, &d->_tds__CreateCertificate::Subject, &a->_tds__CreateCertificate::Subject);
	soap_dup_PointerTodateTime(soap, &d->_tds__CreateCertificate::ValidNotBefore, &a->_tds__CreateCertificate::ValidNotBefore);
	soap_dup_PointerTodateTime(soap, &d->_tds__CreateCertificate::ValidNotAfter, &a->_tds__CreateCertificate::ValidNotAfter);
	d->_tds__CreateCertificate::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateCertificate(_tds__CreateCertificate const*a)
{
	if (!a)
		return;
	soap_del_PointerToxsd__token(&a->_tds__CreateCertificate::CertificateID);
	soap_del_PointerTostd__string(&a->_tds__CreateCertificate::Subject);
	soap_del_PointerTodateTime(&a->_tds__CreateCertificate::ValidNotBefore);
	soap_del_PointerTodateTime(&a->_tds__CreateCertificate::ValidNotAfter);
}

SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateCertificate *p;
	size_t k = sizeof(_tds__CreateCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateCertificate);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateCertificate, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateCertificate(soap, tag ? tag : "tds:CreateCertificate", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificate(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_dup__tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *d, _tds__SetAccessPolicyResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetAccessPolicyResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetAccessPolicyResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetAccessPolicyResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetAccessPolicyResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetAccessPolicyResponse(_tds__SetAccessPolicyResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__SetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag ? tag : "tds:SetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetAccessPolicy::PolicyFile = NULL;
}

void _tds__SetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__SetAccessPolicy::PolicyFile);
#endif
}

int _tds__SetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (!a->_tds__SetAccessPolicy::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__SetAccessPolicy::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__SetAccessPolicy::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__SetAccessPolicy::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_dup__tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *d, _tds__SetAccessPolicy const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetAccessPolicy*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetAccessPolicy, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetAccessPolicy(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__BinaryData(soap, &d->_tds__SetAccessPolicy::PolicyFile, &a->_tds__SetAccessPolicy::PolicyFile);
	d->_tds__SetAccessPolicy::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetAccessPolicy(_tds__SetAccessPolicy const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__BinaryData(&a->_tds__SetAccessPolicy::PolicyFile);
}

SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAccessPolicy *p;
	size_t k = sizeof(_tds__SetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAccessPolicy(soap, tag ? tag : "tds:SetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAccessPolicyResponse::PolicyFile = NULL;
}

void _tds__GetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetAccessPolicyResponse::PolicyFile);
#endif
}

int _tds__GetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (!a->_tds__GetAccessPolicyResponse::PolicyFile)
	{	if (soap_element_empty(soap, "tds:PolicyFile", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__GetAccessPolicyResponse::PolicyFile, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicyResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicyResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->_tds__GetAccessPolicyResponse::PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetAccessPolicyResponse::PolicyFile))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_dup__tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *d, _tds__GetAccessPolicyResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAccessPolicyResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAccessPolicyResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAccessPolicyResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__BinaryData(soap, &d->_tds__GetAccessPolicyResponse::PolicyFile, &a->_tds__GetAccessPolicyResponse::PolicyFile);
	d->_tds__GetAccessPolicyResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAccessPolicyResponse(_tds__GetAccessPolicyResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__BinaryData(&a->_tds__GetAccessPolicyResponse::PolicyFile);
}

SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicyResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicyResponse *p;
	size_t k = sizeof(_tds__GetAccessPolicyResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicyResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicyResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicyResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicyResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicyResponse(soap, tag ? tag : "tds:GetAccessPolicyResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAccessPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicy*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAccessPolicy)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAccessPolicy *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_dup__tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *d, _tds__GetAccessPolicy const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAccessPolicy*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAccessPolicy, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAccessPolicy(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetAccessPolicy::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAccessPolicy(_tds__GetAccessPolicy const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAccessPolicy *p;
	size_t k = sizeof(_tds__GetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAccessPolicy);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAccessPolicy, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAccessPolicy(soap, tag ? tag : "tds:GetAccessPolicy", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__RemoveIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__RemoveIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_dup__tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *d, _tds__RemoveIPAddressFilterResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RemoveIPAddressFilterResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RemoveIPAddressFilterResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__RemoveIPAddressFilterResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RemoveIPAddressFilterResponse(_tds__RemoveIPAddressFilterResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilterResponse(soap, tag ? tag : "tds:RemoveIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__RemoveIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__RemoveIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__RemoveIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__RemoveIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__RemoveIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__RemoveIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__RemoveIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__RemoveIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_dup__tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *d, _tds__RemoveIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RemoveIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RemoveIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RemoveIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IPAddressFilter(soap, &d->_tds__RemoveIPAddressFilter::IPAddressFilter, &a->_tds__RemoveIPAddressFilter::IPAddressFilter);
	d->_tds__RemoveIPAddressFilter::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RemoveIPAddressFilter(_tds__RemoveIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IPAddressFilter(&a->_tds__RemoveIPAddressFilter::IPAddressFilter);
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveIPAddressFilter *p;
	size_t k = sizeof(_tds__RemoveIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveIPAddressFilter(soap, tag ? tag : "tds:RemoveIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__AddIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__AddIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_dup__tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *d, _tds__AddIPAddressFilterResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__AddIPAddressFilterResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__AddIPAddressFilterResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__AddIPAddressFilterResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__AddIPAddressFilterResponse(_tds__AddIPAddressFilterResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__AddIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilterResponse(soap, tag ? tag : "tds:AddIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__AddIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__AddIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__AddIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__AddIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__AddIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__AddIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__AddIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__AddIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_dup__tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *d, _tds__AddIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__AddIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__AddIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__AddIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IPAddressFilter(soap, &d->_tds__AddIPAddressFilter::IPAddressFilter, &a->_tds__AddIPAddressFilter::IPAddressFilter);
	d->_tds__AddIPAddressFilter::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__AddIPAddressFilter(_tds__AddIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IPAddressFilter(&a->_tds__AddIPAddressFilter::IPAddressFilter);
}

SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddIPAddressFilter *p;
	size_t k = sizeof(_tds__AddIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddIPAddressFilter(soap, tag ? tag : "tds:AddIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_dup__tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *d, _tds__SetIPAddressFilterResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetIPAddressFilterResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetIPAddressFilterResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetIPAddressFilterResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetIPAddressFilterResponse(_tds__SetIPAddressFilterResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__SetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilterResponse(soap, tag ? tag : "tds:SetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetIPAddressFilter::IPAddressFilter = NULL;
}

void _tds__SetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__SetIPAddressFilter::IPAddressFilter);
#endif
}

int _tds__SetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (!a->_tds__SetIPAddressFilter::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__SetIPAddressFilter::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__SetIPAddressFilter::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__SetIPAddressFilter::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_dup__tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *d, _tds__SetIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IPAddressFilter(soap, &d->_tds__SetIPAddressFilter::IPAddressFilter, &a->_tds__SetIPAddressFilter::IPAddressFilter);
	d->_tds__SetIPAddressFilter::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetIPAddressFilter(_tds__SetIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IPAddressFilter(&a->_tds__SetIPAddressFilter::IPAddressFilter);
}

SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetIPAddressFilter *p;
	size_t k = sizeof(_tds__SetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetIPAddressFilter(soap, tag ? tag : "tds:SetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetIPAddressFilterResponse::IPAddressFilter = NULL;
}

void _tds__GetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__GetIPAddressFilterResponse::IPAddressFilter);
#endif
}

int _tds__GetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (!a->_tds__GetIPAddressFilterResponse::IPAddressFilter)
	{	if (soap_element_empty(soap, "tds:IPAddressFilter", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilterResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilterResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetIPAddressFilterResponse::IPAddressFilter))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_dup__tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *d, _tds__GetIPAddressFilterResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetIPAddressFilterResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetIPAddressFilterResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IPAddressFilter(soap, &d->_tds__GetIPAddressFilterResponse::IPAddressFilter, &a->_tds__GetIPAddressFilterResponse::IPAddressFilter);
	d->_tds__GetIPAddressFilterResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetIPAddressFilterResponse(_tds__GetIPAddressFilterResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IPAddressFilter(&a->_tds__GetIPAddressFilterResponse::IPAddressFilter);
}

SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilterResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilterResponse *p;
	size_t k = sizeof(_tds__GetIPAddressFilterResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilterResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilterResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilterResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilterResponse(soap, tag ? tag : "tds:GetIPAddressFilterResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetIPAddressFilter::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetIPAddressFilter)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetIPAddressFilter *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_dup__tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *d, _tds__GetIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetIPAddressFilter::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetIPAddressFilter(_tds__GetIPAddressFilter const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetIPAddressFilter *p;
	size_t k = sizeof(_tds__GetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetIPAddressFilter);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetIPAddressFilter, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetIPAddressFilter(soap, tag ? tag : "tds:GetIPAddressFilter", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *d, _tds__SetZeroConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetZeroConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetZeroConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetZeroConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetZeroConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetZeroConfigurationResponse(_tds__SetZeroConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__SetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfigurationResponse(soap, tag ? tag : "tds:SetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->_tds__SetZeroConfiguration::Enabled);
}

void _tds__SetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::Enabled, SOAP_TYPE_bool);
#endif
}

int _tds__SetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetZeroConfiguration::InterfaceToken, ""))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetZeroConfiguration::Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetZeroConfiguration::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetZeroConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_dup__tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *d, _tds__SetZeroConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetZeroConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetZeroConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetZeroConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__SetZeroConfiguration::InterfaceToken, &a->_tds__SetZeroConfiguration::InterfaceToken);
	d->_tds__SetZeroConfiguration::Enabled = a->_tds__SetZeroConfiguration::Enabled;
	d->_tds__SetZeroConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetZeroConfiguration(_tds__SetZeroConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__SetZeroConfiguration::InterfaceToken);
	/* Enabled skipped */
}

SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetZeroConfiguration *p;
	size_t k = sizeof(_tds__SetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetZeroConfiguration(soap, tag ? tag : "tds:SetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetZeroConfigurationResponse::ZeroConfiguration = NULL;
}

void _tds__GetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &this->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
#endif
}

int _tds__GetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration)
	{	if (soap_element_empty(soap, "tds:ZeroConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ZeroConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetZeroConfigurationResponse::ZeroConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *d, _tds__GetZeroConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetZeroConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetZeroConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetZeroConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__NetworkZeroConfiguration(soap, &d->_tds__GetZeroConfigurationResponse::ZeroConfiguration, &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
	d->_tds__GetZeroConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetZeroConfigurationResponse(_tds__GetZeroConfigurationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__NetworkZeroConfiguration(&a->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
}

SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfigurationResponse *p;
	size_t k = sizeof(_tds__GetZeroConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfigurationResponse(soap, tag ? tag : "tds:GetZeroConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetZeroConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetZeroConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetZeroConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_dup__tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *d, _tds__GetZeroConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetZeroConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetZeroConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetZeroConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetZeroConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetZeroConfiguration(_tds__GetZeroConfiguration const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetZeroConfiguration *p;
	size_t k = sizeof(_tds__GetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetZeroConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetZeroConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetZeroConfiguration(soap, tag ? tag : "tds:GetZeroConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_dup__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *d, _tds__SetNetworkDefaultGatewayResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkDefaultGatewayResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkDefaultGatewayResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetNetworkDefaultGatewayResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkDefaultGatewayResponse(_tds__SetNetworkDefaultGatewayResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:SetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_default_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
}

void _tds__SetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__IPv4Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_serialize_std__vectorTemplateOftt__IPv6Address(soap, &this->_tds__SetNetworkDefaultGateway::IPv6Address);
#endif
}

int _tds__SetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv4Address, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", -1, &a->_tds__SetNetworkDefaultGateway::IPv6Address, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv4Address(soap, "tds:IPv4Address", &a->_tds__SetNetworkDefaultGateway::IPv4Address, "tt:IPv4Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__IPv6Address(soap, "tds:IPv6Address", &a->_tds__SetNetworkDefaultGateway::IPv6Address, "tt:IPv6Address"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_dup__tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *d, _tds__SetNetworkDefaultGateway const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkDefaultGateway*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkDefaultGateway(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOftt__IPv4Address(soap, &d->_tds__SetNetworkDefaultGateway::IPv4Address, &a->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_dup_std__vectorTemplateOftt__IPv6Address(soap, &d->_tds__SetNetworkDefaultGateway::IPv6Address, &a->_tds__SetNetworkDefaultGateway::IPv6Address);
	d->_tds__SetNetworkDefaultGateway::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkDefaultGateway(_tds__SetNetworkDefaultGateway const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOftt__IPv4Address(&a->_tds__SetNetworkDefaultGateway::IPv4Address);
	soap_del_std__vectorTemplateOftt__IPv6Address(&a->_tds__SetNetworkDefaultGateway::IPv6Address);
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__SetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkDefaultGateway(soap, tag ? tag : "tds:SetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway = NULL;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NetworkGateway(soap, &this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
#endif
}

int _tds__GetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway)
	{	if (soap_element_empty(soap, "tds:NetworkGateway", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGatewayResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NetworkGateway1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_dup__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *d, _tds__GetNetworkDefaultGatewayResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkDefaultGatewayResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkDefaultGatewayResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__NetworkGateway(soap, &d->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
	d->_tds__GetNetworkDefaultGatewayResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkDefaultGatewayResponse(_tds__GetNetworkDefaultGatewayResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__NetworkGateway(&a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
}

SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGatewayResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGatewayResponse *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGatewayResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGatewayResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGatewayResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGatewayResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag ? tag : "tds:GetNetworkDefaultGatewayResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGateway*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkDefaultGateway)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_dup__tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *d, _tds__GetNetworkDefaultGateway const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkDefaultGateway*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkDefaultGateway(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetNetworkDefaultGateway::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkDefaultGateway(_tds__GetNetworkDefaultGateway const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkDefaultGateway *p;
	size_t k = sizeof(_tds__GetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkDefaultGateway);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkDefaultGateway, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkDefaultGateway(soap, tag ? tag : "tds:GetNetworkDefaultGateway", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
