/* soapC_nnn.cpp
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.127 2023-10-20 00:49:00 GMT")


SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, tt__ImagingCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingCapabilities *)soap_instantiate_tt__ImagingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(tt__ImagingCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities * *d, tt__ImagingCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingCapabilities **)soap_malloc(soap, sizeof(tt__ImagingCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingCapabilities(tt__ImagingCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag ? tag : "tt:ImagingCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EventCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, tt__EventCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventCapabilities *)soap_instantiate_tt__EventCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(tt__EventCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EventCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities * *d, tt__EventCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__EventCapabilities **)soap_malloc(soap, sizeof(tt__EventCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__EventCapabilities(tt__EventCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__EventCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EventCapabilities(soap, tag ? tag : "tt:EventCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DeviceCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, tt__DeviceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DeviceCapabilities *)soap_instantiate_tt__DeviceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(tt__DeviceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities * *d, tt__DeviceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DeviceCapabilities **)soap_malloc(soap, sizeof(tt__DeviceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DeviceCapabilities(tt__DeviceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DeviceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag ? tag : "tt:DeviceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AnalyticsCapabilities ? type : NULL);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, tt__AnalyticsCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsCapabilities *)soap_instantiate_tt__AnalyticsCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(tt__AnalyticsCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AnalyticsCapabilities * * SOAP_FMAC2 soap_dup_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities * *d, tt__AnalyticsCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(tt__AnalyticsCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AnalyticsCapabilities(tt__AnalyticsCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AnalyticsCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag ? tag : "tt:AnalyticsCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, tt__Dot11AvailableNetworksExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11AvailableNetworksExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, tt__Dot11AvailableNetworksExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11AvailableNetworksExtension **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworksExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11AvailableNetworksExtension *)soap_instantiate_tt__Dot11AvailableNetworksExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11AvailableNetworksExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(tt__Dot11AvailableNetworksExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * * SOAP_FMAC2 soap_dup_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension * *d, tt__Dot11AvailableNetworksExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11AvailableNetworksExtension **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworksExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11AvailableNetworksExtension(tt__Dot11AvailableNetworksExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11AvailableNetworksExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, tag ? tag : "tt:Dot11AvailableNetworksExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, tt__Dot11AvailableNetworksExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SignalStrength(struct soap *soap, tt__Dot11SignalStrength *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SignalStrength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, int id, tt__Dot11SignalStrength *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SignalStrength, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SignalStrength(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__Dot11SignalStrength ** SOAP_FMAC4 soap_in_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, tt__Dot11SignalStrength **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11SignalStrength **)soap_malloc(soap, sizeof(tt__Dot11SignalStrength *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SignalStrength(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__Dot11SignalStrength **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(tt__Dot11SignalStrength), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SignalStrength * * SOAP_FMAC2 soap_dup_PointerTott__Dot11SignalStrength(struct soap *soap, tt__Dot11SignalStrength * *d, tt__Dot11SignalStrength *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11SignalStrength **)soap_malloc(soap, sizeof(tt__Dot11SignalStrength *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__Dot11SignalStrength *)soap_malloc(soap, sizeof(tt__Dot11SignalStrength))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11SignalStrength(tt__Dot11SignalStrength *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SignalStrength(struct soap *soap, tt__Dot11SignalStrength *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SignalStrength(soap, tag ? tag : "tt:Dot11SignalStrength", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11SignalStrength ** SOAP_FMAC4 soap_get_PointerTott__Dot11SignalStrength(struct soap *soap, tt__Dot11SignalStrength **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSetExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, tt__Dot11PSKSetExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSetExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11PSKSetExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, tt__Dot11PSKSetExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(tt__Dot11PSKSetExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11PSKSetExtension *)soap_instantiate_tt__Dot11PSKSetExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(tt__Dot11PSKSetExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSetExtension * * SOAP_FMAC2 soap_dup_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension * *d, tt__Dot11PSKSetExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(tt__Dot11PSKSetExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11PSKSetExtension(tt__Dot11PSKSetExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11PSKSetExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, tag ? tag : "tt:Dot11PSKSetExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSetExtension(struct soap *soap, tt__Dot11PSKSetExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase))
		soap_serialize_tt__Dot11PSKPassphrase(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKPassphrase, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKPassphrase(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKPassphrase(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKPassphrase(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKPassphrase, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__Dot11PSKPassphrase(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11PSKPassphrase(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKPassphrase(soap, tag ? tag : "tt:Dot11PSKPassphrase", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKPassphrase(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_tt__Dot11PSK(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSK(struct soap *soap, const char *tag, int id, xsd__hexBinary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, *a ? (*a)->__ptr : NULL, *a ? (*a)->__size : 0, type, SOAP_TYPE_tt__Dot11PSK, NULL);
	if (!*a || id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSK(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__hexBinary ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSK(struct soap *soap, const char *tag, xsd__hexBinary **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__hexBinary **)soap_malloc(soap, sizeof(xsd__hexBinary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSK(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSK, sizeof(xsd__hexBinary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * * SOAP_FMAC2 soap_dup_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary * *d, xsd__hexBinary *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (xsd__hexBinary **)soap_malloc(soap, sizeof(xsd__hexBinary *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_tt__Dot11PSK(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11PSK(xsd__hexBinary *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_tt__Dot11PSK(*a);
		SOAP_DELETE(NULL, *a, xsd__hexBinary);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSK(soap, tag ? tag : "tt:Dot11PSK", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 xsd__hexBinary ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSK(struct soap *soap, xsd__hexBinary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, tt__Dot11SecurityConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11SecurityConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, tt__Dot11SecurityConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11SecurityConfigurationExtension *)soap_instantiate_tt__Dot11SecurityConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(tt__Dot11SecurityConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension * *d, tt__Dot11SecurityConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11SecurityConfigurationExtension(tt__Dot11SecurityConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11SecurityConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag ? tag : "tt:Dot11SecurityConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, tt__Dot11SecurityConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__ReferenceToken(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__ReferenceToken(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ReferenceToken(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSet))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, int id, tt__Dot11PSKSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSet, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11PSKSet ? type : NULL);
}

SOAP_FMAC3 tt__Dot11PSKSet ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, tt__Dot11PSKSet **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11PSKSet **)soap_malloc(soap, sizeof(tt__Dot11PSKSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11PSKSet *)soap_instantiate_tt__Dot11PSKSet(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(tt__Dot11PSKSet), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11PSKSet * * SOAP_FMAC2 soap_dup_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet * *d, tt__Dot11PSKSet *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11PSKSet **)soap_malloc(soap, sizeof(tt__Dot11PSKSet *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11PSKSet(tt__Dot11PSKSet *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11PSKSet);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11PSKSet(soap, tag ? tag : "tt:Dot11PSKSet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11PSKSet ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSet(struct soap *soap, tt__Dot11PSKSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Cipher(struct soap *soap, tt__Dot11Cipher *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Cipher);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, int id, tt__Dot11Cipher *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Cipher, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Cipher(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__Dot11Cipher ** SOAP_FMAC4 soap_in_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, tt__Dot11Cipher **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Cipher **)soap_malloc(soap, sizeof(tt__Dot11Cipher *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Cipher(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(tt__Dot11Cipher), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Cipher * * SOAP_FMAC2 soap_dup_PointerTott__Dot11Cipher(struct soap *soap, tt__Dot11Cipher * *d, tt__Dot11Cipher *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11Cipher **)soap_malloc(soap, sizeof(tt__Dot11Cipher *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__Dot11Cipher *)soap_malloc(soap, sizeof(tt__Dot11Cipher))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11Cipher(tt__Dot11Cipher *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Cipher(struct soap *soap, tt__Dot11Cipher *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Cipher(soap, tag ? tag : "tt:Dot11Cipher", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Cipher ** SOAP_FMAC4 soap_get_PointerTott__Dot11Cipher(struct soap *soap, tt__Dot11Cipher **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, tt__Dot11SecurityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11SecurityConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, tt__Dot11SecurityConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11SecurityConfiguration *)soap_instantiate_tt__Dot11SecurityConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(tt__Dot11SecurityConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11SecurityConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration * *d, tt__Dot11SecurityConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(tt__Dot11SecurityConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11SecurityConfiguration(tt__Dot11SecurityConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11SecurityConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag ? tag : "tt:Dot11SecurityConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfiguration(struct soap *soap, tt__Dot11SecurityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddressFilterExtension ? type : NULL);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, tt__IPAddressFilterExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddressFilterExtension *)soap_instantiate_tt__IPAddressFilterExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(tt__IPAddressFilterExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilterExtension * * SOAP_FMAC2 soap_dup_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension * *d, tt__IPAddressFilterExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(tt__IPAddressFilterExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPAddressFilterExtension(tt__IPAddressFilterExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPAddressFilterExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag ? tag : "tt:IPAddressFilterExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfigurationExtension2 *)soap_instantiate_tt__NetworkZeroConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(tt__NetworkZeroConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 * *d, tt__NetworkZeroConfigurationExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkZeroConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkZeroConfigurationExtension2(tt__NetworkZeroConfigurationExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkZeroConfigurationExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, tt__NetworkZeroConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfigurationExtension ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkZeroConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfigurationExtension *)soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(tt__NetworkZeroConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension * *d, tt__NetworkZeroConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkZeroConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkZeroConfigurationExtension(tt__NetworkZeroConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkZeroConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag ? tag : "tt:NetworkZeroConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, tt__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, tt__IPv6DHCPConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, tt__IPv6DHCPConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(tt__IPv6DHCPConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6DHCPConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__IPv6DHCPConfiguration(struct soap *soap, tt__IPv6DHCPConfiguration * *d, tt__IPv6DHCPConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(tt__IPv6DHCPConfiguration *))))
		return NULL; /* ERROR */
	if (*a && (*d = (tt__IPv6DHCPConfiguration *)soap_malloc(soap, sizeof(tt__IPv6DHCPConfiguration))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6DHCPConfiguration(tt__IPv6DHCPConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag ? tag : "tt:IPv6DHCPConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfigurationExtension2 *)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(tt__NetworkInterfaceSetConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 * *d, tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceSetConfigurationExtension2(tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceSetConfigurationExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfigurationExtension *)soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(tt__NetworkInterfaceSetConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension * *d, tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceSetConfigurationExtension(tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceSetConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag ? tag : "tt:NetworkInterfaceSetConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(tt__IPv6NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration * *d, tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterfaceSetConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6NetworkInterfaceSetConfiguration(tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv6NetworkInterfaceSetConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv6NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterfaceSetConfiguration *)soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(tt__IPv4NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration * *d, tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterfaceSetConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv4NetworkInterfaceSetConfiguration(tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv4NetworkInterfaceSetConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:IPv4NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DynamicDNSInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, tt__DynamicDNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DynamicDNSInformationExtension *)soap_instantiate_tt__DynamicDNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(tt__DynamicDNSInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformationExtension * * SOAP_FMAC2 soap_dup_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension * *d, tt__DynamicDNSInformationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(tt__DynamicDNSInformationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DynamicDNSInformationExtension(tt__DynamicDNSInformationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DynamicDNSInformationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag ? tag : "tt:DynamicDNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NTPInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, tt__NTPInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NTPInformationExtension **)soap_malloc(soap, sizeof(tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NTPInformationExtension *)soap_instantiate_tt__NTPInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(tt__NTPInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformationExtension * * SOAP_FMAC2 soap_dup_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension * *d, tt__NTPInformationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NTPInformationExtension **)soap_malloc(soap, sizeof(tt__NTPInformationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NTPInformationExtension(tt__NTPInformationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NTPInformationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag ? tag : "tt:NTPInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DNSInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, tt__DNSInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DNSInformationExtension **)soap_malloc(soap, sizeof(tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DNSInformationExtension *)soap_instantiate_tt__DNSInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(tt__DNSInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformationExtension * * SOAP_FMAC2 soap_dup_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension * *d, tt__DNSInformationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DNSInformationExtension **)soap_malloc(soap, sizeof(tt__DNSInformationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DNSInformationExtension(tt__DNSInformationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DNSInformationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag ? tag : "tt:DNSInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__HostnameInformationExtension ? type : NULL);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, tt__HostnameInformationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__HostnameInformationExtension *)soap_instantiate_tt__HostnameInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(tt__HostnameInformationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformationExtension * * SOAP_FMAC2 soap_dup_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension * *d, tt__HostnameInformationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(tt__HostnameInformationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__HostnameInformationExtension(tt__HostnameInformationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__HostnameInformationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag ? tag : "tt:HostnameInformationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkHostExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, tt__NetworkHostExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHostExtension **)soap_malloc(soap, sizeof(tt__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHostExtension *)soap_instantiate_tt__NetworkHostExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(tt__NetworkHostExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHostExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension * *d, tt__NetworkHostExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkHostExtension **)soap_malloc(soap, sizeof(tt__NetworkHostExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkHostExtension(tt__NetworkHostExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkHostExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag ? tag : "tt:NetworkHostExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__IPv6Address(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__IPv6Address(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6Address(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Address(soap, tag ? tag : "tt:IPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__IPv4Address(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__IPv4Address(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv4Address(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Address(soap, tag ? tag : "tt:IPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkProtocolExtension ? type : NULL);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, tt__NetworkProtocolExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkProtocolExtension *)soap_instantiate_tt__NetworkProtocolExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(tt__NetworkProtocolExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocolExtension * * SOAP_FMAC2 soap_dup_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension * *d, tt__NetworkProtocolExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(tt__NetworkProtocolExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkProtocolExtension(tt__NetworkProtocolExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkProtocolExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag ? tag : "tt:NetworkProtocolExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6ConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, tt__IPv6ConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6ConfigurationExtension *)soap_instantiate_tt__IPv6ConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(tt__IPv6ConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6ConfigurationExtension * * SOAP_FMAC2 soap_dup_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension * *d, tt__IPv6ConfigurationExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(tt__IPv6ConfigurationExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6ConfigurationExtension(tt__IPv6ConfigurationExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv6ConfigurationExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag ? tag : "tt:IPv6ConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PrefixedIPv6Address ? type : NULL);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, tt__PrefixedIPv6Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv6Address *)soap_instantiate_tt__PrefixedIPv6Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(tt__PrefixedIPv6Address), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv6Address * * SOAP_FMAC2 soap_dup_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address * *d, tt__PrefixedIPv6Address *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv6Address *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PrefixedIPv6Address(tt__PrefixedIPv6Address *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PrefixedIPv6Address);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag ? tag : "tt:PrefixedIPv6Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PrefixedIPv4Address ? type : NULL);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, tt__PrefixedIPv4Address **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PrefixedIPv4Address *)soap_instantiate_tt__PrefixedIPv4Address(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(tt__PrefixedIPv4Address), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PrefixedIPv4Address * * SOAP_FMAC2 soap_dup_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address * *d, tt__PrefixedIPv4Address *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(tt__PrefixedIPv4Address *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PrefixedIPv4Address(tt__PrefixedIPv4Address *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PrefixedIPv4Address);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag ? tag : "tt:PrefixedIPv4Address", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv4Configuration ? type : NULL);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, tt__IPv4Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4Configuration **)soap_malloc(soap, sizeof(tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4Configuration *)soap_instantiate_tt__IPv4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(tt__IPv4Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv4Configuration * * SOAP_FMAC2 soap_dup_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration * *d, tt__IPv4Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv4Configuration **)soap_malloc(soap, sizeof(tt__IPv4Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv4Configuration(tt__IPv4Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv4Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv4Configuration(soap, tag ? tag : "tt:IPv4Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPv6Configuration ? type : NULL);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, tt__IPv6Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6Configuration **)soap_malloc(soap, sizeof(tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6Configuration *)soap_instantiate_tt__IPv6Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(tt__IPv6Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPv6Configuration * * SOAP_FMAC2 soap_dup_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration * *d, tt__IPv6Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPv6Configuration **)soap_malloc(soap, sizeof(tt__IPv6Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPv6Configuration(tt__IPv6Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPv6Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPv6Configuration(soap, tag ? tag : "tt:IPv6Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceConnectionSetting ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceConnectionSetting *)soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(tt__NetworkInterfaceConnectionSetting), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting * *d, tt__NetworkInterfaceConnectionSetting *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(tt__NetworkInterfaceConnectionSetting *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceConnectionSetting(tt__NetworkInterfaceConnectionSetting *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceConnectionSetting);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag ? tag : "tt:NetworkInterfaceConnectionSetting", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension2 *)soap_instantiate_tt__NetworkInterfaceExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(tt__NetworkInterfaceExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 * *d, tt__NetworkInterfaceExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceExtension2(tt__NetworkInterfaceExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag ? tag : "tt:NetworkInterfaceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension2(struct soap *soap, tt__NetworkInterfaceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, tt__Dot11Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, tt__Dot11Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Configuration **)soap_malloc(soap, sizeof(tt__Dot11Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Configuration *)soap_instantiate_tt__Dot11Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(tt__Dot11Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Configuration * * SOAP_FMAC2 soap_dup_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration * *d, tt__Dot11Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11Configuration **)soap_malloc(soap, sizeof(tt__Dot11Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11Configuration(tt__Dot11Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Configuration(soap, tag ? tag : "tt:Dot11Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot11Configuration(struct soap *soap, tt__Dot11Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot3Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, tt__Dot3Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot3Configuration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot3Configuration ? type : NULL);
}

SOAP_FMAC3 tt__Dot3Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, tt__Dot3Configuration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot3Configuration **)soap_malloc(soap, sizeof(tt__Dot3Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot3Configuration *)soap_instantiate_tt__Dot3Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(tt__Dot3Configuration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot3Configuration * * SOAP_FMAC2 soap_dup_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration * *d, tt__Dot3Configuration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot3Configuration **)soap_malloc(soap, sizeof(tt__Dot3Configuration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot3Configuration(tt__Dot3Configuration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot3Configuration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot3Configuration(soap, tag ? tag : "tt:Dot3Configuration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot3Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot3Configuration(struct soap *soap, tt__Dot3Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transport(struct soap *soap, tt__Transport *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transport))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transport(struct soap *soap, const char *tag, int id, tt__Transport *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transport, &mark);
	if (id < 0)
		return soap->error;
	(void)(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Transport ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 tt__Transport ** SOAP_FMAC4 soap_in_PointerTott__Transport(struct soap *soap, const char *tag, tt__Transport **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Transport **)soap_malloc(soap, sizeof(tt__Transport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Transport *)soap_instantiate_tt__Transport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(tt__Transport), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Transport * * SOAP_FMAC2 soap_dup_PointerTott__Transport(struct soap *soap, tt__Transport * *d, tt__Transport *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Transport **)soap_malloc(soap, sizeof(tt__Transport *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Transport(tt__Transport *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Transport);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transport(struct soap *soap, tt__Transport *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Transport(soap, tag ? tag : "tt:Transport", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Transport ** SOAP_FMAC4 soap_get_PointerTott__Transport(struct soap *soap, tt__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__AudioDecoderConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__AudioDecoderConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioDecoderConfigurationOptionsExtension *)soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(tt__AudioDecoderConfigurationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension * *d, tt__AudioDecoderConfigurationOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__AudioDecoderConfigurationOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioDecoderConfigurationOptionsExtension(tt__AudioDecoderConfigurationOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioDecoderConfigurationOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag ? tag : "tt:AudioDecoderConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, tt__AudioDecoderConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G726DecOptions(struct soap *soap, tt__G726DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G726DecOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G726DecOptions(struct soap *soap, const char *tag, int id, tt__G726DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G726DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__G726DecOptions ? type : NULL);
}

SOAP_FMAC3 tt__G726DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G726DecOptions(struct soap *soap, const char *tag, tt__G726DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__G726DecOptions **)soap_malloc(soap, sizeof(tt__G726DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__G726DecOptions *)soap_instantiate_tt__G726DecOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__G726DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G726DecOptions, sizeof(tt__G726DecOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G726DecOptions * * SOAP_FMAC2 soap_dup_PointerTott__G726DecOptions(struct soap *soap, tt__G726DecOptions * *d, tt__G726DecOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__G726DecOptions **)soap_malloc(soap, sizeof(tt__G726DecOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__G726DecOptions(tt__G726DecOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__G726DecOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G726DecOptions(struct soap *soap, tt__G726DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__G726DecOptions(soap, tag ? tag : "tt:G726DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__G726DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G726DecOptions(struct soap *soap, tt__G726DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G711DecOptions(struct soap *soap, tt__G711DecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G711DecOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G711DecOptions(struct soap *soap, const char *tag, int id, tt__G711DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G711DecOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__G711DecOptions ? type : NULL);
}

SOAP_FMAC3 tt__G711DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G711DecOptions(struct soap *soap, const char *tag, tt__G711DecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__G711DecOptions **)soap_malloc(soap, sizeof(tt__G711DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__G711DecOptions *)soap_instantiate_tt__G711DecOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__G711DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G711DecOptions, sizeof(tt__G711DecOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__G711DecOptions * * SOAP_FMAC2 soap_dup_PointerTott__G711DecOptions(struct soap *soap, tt__G711DecOptions * *d, tt__G711DecOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__G711DecOptions **)soap_malloc(soap, sizeof(tt__G711DecOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__G711DecOptions(tt__G711DecOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__G711DecOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G711DecOptions(struct soap *soap, tt__G711DecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__G711DecOptions(soap, tag ? tag : "tt:G711DecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__G711DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G711DecOptions(struct soap *soap, tt__G711DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AACDecOptions(struct soap *soap, tt__AACDecOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AACDecOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AACDecOptions(struct soap *soap, const char *tag, int id, tt__AACDecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AACDecOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AACDecOptions ? type : NULL);
}

SOAP_FMAC3 tt__AACDecOptions ** SOAP_FMAC4 soap_in_PointerTott__AACDecOptions(struct soap *soap, const char *tag, tt__AACDecOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AACDecOptions **)soap_malloc(soap, sizeof(tt__AACDecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AACDecOptions *)soap_instantiate_tt__AACDecOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AACDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AACDecOptions, sizeof(tt__AACDecOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AACDecOptions * * SOAP_FMAC2 soap_dup_PointerTott__AACDecOptions(struct soap *soap, tt__AACDecOptions * *d, tt__AACDecOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AACDecOptions **)soap_malloc(soap, sizeof(tt__AACDecOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AACDecOptions(tt__AACDecOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AACDecOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AACDecOptions(struct soap *soap, tt__AACDecOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AACDecOptions(soap, tag ? tag : "tt:AACDecOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AACDecOptions ** SOAP_FMAC4 soap_get_PointerTott__AACDecOptions(struct soap *soap, tt__AACDecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, tt__PTZStatusFilterOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZStatusFilterOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, tt__PTZStatusFilterOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStatusFilterOptionsExtension **)soap_malloc(soap, sizeof(tt__PTZStatusFilterOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStatusFilterOptionsExtension *)soap_instantiate_tt__PTZStatusFilterOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZStatusFilterOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(tt__PTZStatusFilterOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension * *d, tt__PTZStatusFilterOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZStatusFilterOptionsExtension **)soap_malloc(soap, sizeof(tt__PTZStatusFilterOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZStatusFilterOptionsExtension(tt__PTZStatusFilterOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZStatusFilterOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, tag ? tag : "tt:PTZStatusFilterOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, tt__PTZStatusFilterOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationOptionsExtension2 *)soap_instantiate_tt__MetadataConfigurationOptionsExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2, sizeof(tt__MetadataConfigurationOptionsExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 * *d, tt__MetadataConfigurationOptionsExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MetadataConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptionsExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MetadataConfigurationOptionsExtension2(tt__MetadataConfigurationOptionsExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MetadataConfigurationOptionsExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension2(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptionsExtension2(struct soap *soap, tt__MetadataConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfigurationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationOptionsExtension *)soap_instantiate_tt__MetadataConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptionsExtension, sizeof(tt__MetadataConfigurationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension * *d, tt__MetadataConfigurationOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MetadataConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MetadataConfigurationOptionsExtension(tt__MetadataConfigurationOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MetadataConfigurationOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfigurationOptionsExtension(soap, tag ? tag : "tt:MetadataConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptionsExtension(struct soap *soap, tt__MetadataConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, tt__PTZStatusFilterOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZStatusFilterOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, tt__PTZStatusFilterOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(tt__PTZStatusFilterOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStatusFilterOptions *)soap_instantiate_tt__PTZStatusFilterOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(tt__PTZStatusFilterOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatusFilterOptions * * SOAP_FMAC2 soap_dup_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions * *d, tt__PTZStatusFilterOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(tt__PTZStatusFilterOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZStatusFilterOptions(tt__PTZStatusFilterOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZStatusFilterOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, tag ? tag : "tt:PTZStatusFilterOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptions(struct soap *soap, tt__PTZStatusFilterOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy ? type : NULL);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, _tt__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tt__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tt__EventSubscription_SubscriptionPolicy *)soap_instantiate__tt__EventSubscription_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(_tt__EventSubscription_SubscriptionPolicy), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * * SOAP_FMAC2 soap_dup_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy * *d, _tt__EventSubscription_SubscriptionPolicy *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(_tt__EventSubscription_SubscriptionPolicy *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tt__EventSubscription_SubscriptionPolicy(_tt__EventSubscription_SubscriptionPolicy *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tt__EventSubscription_SubscriptionPolicy);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag ? tag : "tt:EventSubscription-SubscriptionPolicy", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, _tt__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_wsnt__FilterType ? type : NULL);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, wsnt__FilterType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__FilterType **)soap_malloc(soap, sizeof(wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__FilterType *)soap_instantiate_wsnt__FilterType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(wsnt__FilterType), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 wsnt__FilterType * * SOAP_FMAC2 soap_dup_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType * *d, wsnt__FilterType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (wsnt__FilterType **)soap_malloc(soap, sizeof(wsnt__FilterType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsnt__FilterType(wsnt__FilterType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, wsnt__FilterType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsnt__FilterType(soap, tag ? tag : "wsnt:FilterType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOption))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfigurationOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOption, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioEncoderConfigurationOption ? type : NULL);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfigurationOption *)soap_instantiate_tt__AudioEncoderConfigurationOption(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * * SOAP_FMAC2 soap_dup_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption * *d, tt__AudioEncoderConfigurationOption *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(tt__AudioEncoderConfigurationOption *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioEncoderConfigurationOption(tt__AudioEncoderConfigurationOption *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioEncoderConfigurationOption);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag ? tag : "tt:AudioEncoderConfigurationOption", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, tt__AudioSourceOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioSourceOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(tt__AudioSourceOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceOptionsExtension *)soap_instantiate_tt__AudioSourceOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension * *d, tt__AudioSourceOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(tt__AudioSourceOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioSourceOptionsExtension(tt__AudioSourceOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioSourceOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, tag ? tag : "tt:AudioSourceOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoResolution ? type : NULL);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoResolution **)soap_malloc(soap, sizeof(tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoResolution *)soap_instantiate_tt__VideoResolution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoResolution * * SOAP_FMAC2 soap_dup_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution * *d, tt__VideoResolution *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoResolution **)soap_malloc(soap, sizeof(tt__VideoResolution *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoResolution(tt__VideoResolution *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoResolution);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoResolution(soap, tag ? tag : "tt:VideoResolution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoEncoderOptionsExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(tt__VideoEncoderOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderOptionsExtension2 *)soap_instantiate_tt__VideoEncoderOptionsExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(tt__VideoEncoderOptionsExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 * *d, tt__VideoEncoderOptionsExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(tt__VideoEncoderOptionsExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoEncoderOptionsExtension2(tt__VideoEncoderOptionsExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoEncoderOptionsExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag ? tag : "tt:VideoEncoderOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, tt__H264Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__H264Options2 ? type : NULL);
}

SOAP_FMAC3 tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, tt__H264Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Options2 **)soap_malloc(soap, sizeof(tt__H264Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Options2 *)soap_instantiate_tt__H264Options2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options2 * * SOAP_FMAC2 soap_dup_PointerTott__H264Options2(struct soap *soap, tt__H264Options2 * *d, tt__H264Options2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__H264Options2 **)soap_malloc(soap, sizeof(tt__H264Options2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__H264Options2(tt__H264Options2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__H264Options2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, tt__H264Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options2(soap, tag ? tag : "tt:H264Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Mpeg4Options2 ? type : NULL);
}

SOAP_FMAC3 tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, tt__Mpeg4Options2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(tt__Mpeg4Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Options2 *)soap_instantiate_tt__Mpeg4Options2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options2 * * SOAP_FMAC2 soap_dup_PointerTott__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 * *d, tt__Mpeg4Options2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(tt__Mpeg4Options2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Mpeg4Options2(tt__Mpeg4Options2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Mpeg4Options2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag ? tag : "tt:Mpeg4Options2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, tt__JpegOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__JpegOptions2 ? type : NULL);
}

SOAP_FMAC3 tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, tt__JpegOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__JpegOptions2 **)soap_malloc(soap, sizeof(tt__JpegOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__JpegOptions2 *)soap_instantiate_tt__JpegOptions2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions2 * * SOAP_FMAC2 soap_dup_PointerTott__JpegOptions2(struct soap *soap, tt__JpegOptions2 * *d, tt__JpegOptions2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__JpegOptions2 **)soap_malloc(soap, sizeof(tt__JpegOptions2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__JpegOptions2(tt__JpegOptions2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__JpegOptions2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions2(soap, tag ? tag : "tt:JpegOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoEncoderOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderOptionsExtension *)soap_instantiate_tt__VideoEncoderOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension * *d, tt__VideoEncoderOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoEncoderOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoEncoderOptionsExtension(tt__VideoEncoderOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoEncoderOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag ? tag : "tt:VideoEncoderOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, tt__H264Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__H264Options ? type : NULL);
}

SOAP_FMAC3 tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, tt__H264Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Options **)soap_malloc(soap, sizeof(tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Options *)soap_instantiate_tt__H264Options(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__H264Options * * SOAP_FMAC2 soap_dup_PointerTott__H264Options(struct soap *soap, tt__H264Options * *d, tt__H264Options *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__H264Options **)soap_malloc(soap, sizeof(tt__H264Options *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__H264Options(tt__H264Options *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__H264Options);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, tt__H264Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__H264Options(soap, tag ? tag : "tt:H264Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Mpeg4Options ? type : NULL);
}

SOAP_FMAC3 tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Options **)soap_malloc(soap, sizeof(tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Options *)soap_instantiate_tt__Mpeg4Options(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Mpeg4Options * * SOAP_FMAC2 soap_dup_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options * *d, tt__Mpeg4Options *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Mpeg4Options **)soap_malloc(soap, sizeof(tt__Mpeg4Options *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Mpeg4Options(tt__Mpeg4Options *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Mpeg4Options);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Mpeg4Options(soap, tag ? tag : "tt:Mpeg4Options", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__JpegOptions ? type : NULL);
}

SOAP_FMAC3 tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__JpegOptions **)soap_malloc(soap, sizeof(tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__JpegOptions *)soap_instantiate_tt__JpegOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__JpegOptions * * SOAP_FMAC2 soap_dup_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions * *d, tt__JpegOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__JpegOptions **)soap_malloc(soap, sizeof(tt__JpegOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__JpegOptions(tt__JpegOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__JpegOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__JpegOptions(soap, tag ? tag : "tt:JpegOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, int id, tt__RotateOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RotateOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__RotateOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, tt__RotateOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RotateOptionsExtension **)soap_malloc(soap, sizeof(tt__RotateOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RotateOptionsExtension *)soap_instantiate_tt__RotateOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RotateOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(tt__RotateOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension * *d, tt__RotateOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RotateOptionsExtension **)soap_malloc(soap, sizeof(tt__RotateOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RotateOptionsExtension(tt__RotateOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RotateOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptionsExtension(soap, tag ? tag : "tt:RotateOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RotateOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntItems(struct soap *soap, tt__IntItems *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntItems))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntItems(struct soap *soap, const char *tag, int id, tt__IntItems *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntItems, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntItems ? type : NULL);
}

SOAP_FMAC3 tt__IntItems ** SOAP_FMAC4 soap_in_PointerTott__IntItems(struct soap *soap, const char *tag, tt__IntItems **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntItems **)soap_malloc(soap, sizeof(tt__IntItems *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntItems *)soap_instantiate_tt__IntItems(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntItems **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntItems, sizeof(tt__IntItems), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntItems * * SOAP_FMAC2 soap_dup_PointerTott__IntItems(struct soap *soap, tt__IntItems * *d, tt__IntItems *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IntItems **)soap_malloc(soap, sizeof(tt__IntItems *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IntItems(tt__IntItems *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IntItems);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntItems(struct soap *soap, tt__IntItems *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntItems(soap, tag ? tag : "tt:IntItems", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntItems ** SOAP_FMAC4 soap_get_PointerTott__IntItems(struct soap *soap, tt__IntItems **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntItems(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationOptionsExtension2 *)soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 * *d, tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptionsExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfigurationOptionsExtension2(tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfigurationOptionsExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptions(struct soap *soap, tt__RotateOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptions(struct soap *soap, const char *tag, int id, tt__RotateOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RotateOptions ? type : NULL);
}

SOAP_FMAC3 tt__RotateOptions ** SOAP_FMAC4 soap_in_PointerTott__RotateOptions(struct soap *soap, const char *tag, tt__RotateOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RotateOptions **)soap_malloc(soap, sizeof(tt__RotateOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RotateOptions *)soap_instantiate_tt__RotateOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RotateOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateOptions * * SOAP_FMAC2 soap_dup_PointerTott__RotateOptions(struct soap *soap, tt__RotateOptions * *d, tt__RotateOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RotateOptions **)soap_malloc(soap, sizeof(tt__RotateOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RotateOptions(tt__RotateOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RotateOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptions(struct soap *soap, tt__RotateOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateOptions(soap, tag ? tag : "tt:RotateOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RotateOptions ** SOAP_FMAC4 soap_get_PointerTott__RotateOptions(struct soap *soap, tt__RotateOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationOptionsExtension *)soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension * *d, tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptionsExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfigurationOptionsExtension(tt__VideoSourceConfigurationOptionsExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfigurationOptionsExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag ? tag : "tt:VideoSourceConfigurationOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangleRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, int id, tt__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangleRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRectangleRange ? type : NULL);
}

SOAP_FMAC3 tt__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangleRange **)soap_malloc(soap, sizeof(tt__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangleRange *)soap_instantiate_tt__IntRectangleRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRectangleRange * * SOAP_FMAC2 soap_dup_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange * *d, tt__IntRectangleRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IntRectangleRange **)soap_malloc(soap, sizeof(tt__IntRectangleRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IntRectangleRange(tt__IntRectangleRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IntRectangleRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRectangleRange(soap, tag ? tag : "tt:IntRectangleRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTott__IntRectangleRange(struct soap *soap, tt__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensProjection(struct soap *soap, tt__LensProjection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensProjection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensProjection(struct soap *soap, const char *tag, int id, tt__LensProjection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensProjection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensProjection ? type : NULL);
}

SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_in_PointerTott__LensProjection(struct soap *soap, const char *tag, tt__LensProjection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensProjection **)soap_malloc(soap, sizeof(tt__LensProjection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensProjection *)soap_instantiate_tt__LensProjection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensProjection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensProjection, sizeof(tt__LensProjection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensProjection * * SOAP_FMAC2 soap_dup_PointerTott__LensProjection(struct soap *soap, tt__LensProjection * *d, tt__LensProjection *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LensProjection **)soap_malloc(soap, sizeof(tt__LensProjection *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LensProjection(tt__LensProjection *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LensProjection);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensProjection(struct soap *soap, tt__LensProjection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensProjection(soap, tag ? tag : "tt:LensProjection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensProjection ** SOAP_FMAC4 soap_get_PointerTott__LensProjection(struct soap *soap, tt__LensProjection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensProjection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensOffset(struct soap *soap, tt__LensOffset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensOffset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensOffset(struct soap *soap, const char *tag, int id, tt__LensOffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensOffset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensOffset ? type : NULL);
}

SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_in_PointerTott__LensOffset(struct soap *soap, const char *tag, tt__LensOffset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensOffset **)soap_malloc(soap, sizeof(tt__LensOffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensOffset *)soap_instantiate_tt__LensOffset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensOffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensOffset, sizeof(tt__LensOffset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensOffset * * SOAP_FMAC2 soap_dup_PointerTott__LensOffset(struct soap *soap, tt__LensOffset * *d, tt__LensOffset *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LensOffset **)soap_malloc(soap, sizeof(tt__LensOffset *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LensOffset(tt__LensOffset *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LensOffset);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensOffset(struct soap *soap, tt__LensOffset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensOffset(soap, tag ? tag : "tt:LensOffset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensOffset ** SOAP_FMAC4 soap_get_PointerTott__LensOffset(struct soap *soap, tt__LensOffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensOffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 float * * SOAP_FMAC2 soap_dup_PointerTofloat(struct soap *soap, float * *d, float *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (float **)soap_malloc(soap, sizeof(float *))))
		return NULL; /* ERROR */
	if (*a && (*d = (float *)soap_malloc(soap, sizeof(float))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTofloat(float *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap *soap, const char *tag, int id, tt__RotateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RotateExtension ? type : NULL);
}

SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RotateExtension **)soap_malloc(soap, sizeof(tt__RotateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RotateExtension *)soap_instantiate_tt__RotateExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RotateExtension * * SOAP_FMAC2 soap_dup_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension * *d, tt__RotateExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RotateExtension **)soap_malloc(soap, sizeof(tt__RotateExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RotateExtension(tt__RotateExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RotateExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RotateExtension(soap, tag ? tag : "tt:RotateExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap *soap, tt__RotateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SceneOrientation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SceneOrientation(struct soap *soap, const char *tag, int id, tt__SceneOrientation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SceneOrientation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SceneOrientation ? type : NULL);
}

SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_in_PointerTott__SceneOrientation(struct soap *soap, const char *tag, tt__SceneOrientation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SceneOrientation **)soap_malloc(soap, sizeof(tt__SceneOrientation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SceneOrientation *)soap_instantiate_tt__SceneOrientation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SceneOrientation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SceneOrientation, sizeof(tt__SceneOrientation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SceneOrientation * * SOAP_FMAC2 soap_dup_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation * *d, tt__SceneOrientation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SceneOrientation **)soap_malloc(soap, sizeof(tt__SceneOrientation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SceneOrientation(tt__SceneOrientation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SceneOrientation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SceneOrientation(soap, tag ? tag : "tt:SceneOrientation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SceneOrientation ** SOAP_FMAC4 soap_get_PointerTott__SceneOrientation(struct soap *soap, tt__SceneOrientation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SceneOrientation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LensDescription(struct soap *soap, tt__LensDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LensDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LensDescription(struct soap *soap, const char *tag, int id, tt__LensDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LensDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LensDescription ? type : NULL);
}

SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_in_PointerTott__LensDescription(struct soap *soap, const char *tag, tt__LensDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LensDescription **)soap_malloc(soap, sizeof(tt__LensDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LensDescription *)soap_instantiate_tt__LensDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LensDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LensDescription, sizeof(tt__LensDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LensDescription * * SOAP_FMAC2 soap_dup_PointerTott__LensDescription(struct soap *soap, tt__LensDescription * *d, tt__LensDescription *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LensDescription **)soap_malloc(soap, sizeof(tt__LensDescription *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LensDescription(tt__LensDescription *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LensDescription);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LensDescription(struct soap *soap, tt__LensDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LensDescription(soap, tag ? tag : "tt:LensDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LensDescription ** SOAP_FMAC4 soap_get_PointerTott__LensDescription(struct soap *soap, tt__LensDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LensDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension2 *)soap_instantiate_tt__VideoSourceConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 * *d, tt__VideoSourceConfigurationExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfigurationExtension2(tt__VideoSourceConfigurationExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfigurationExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag ? tag : "tt:VideoSourceConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap *soap, tt__Rotate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rotate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap *soap, const char *tag, int id, tt__Rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rotate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Rotate ? type : NULL);
}

SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap *soap, const char *tag, tt__Rotate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Rotate **)soap_malloc(soap, sizeof(tt__Rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Rotate *)soap_instantiate_tt__Rotate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Rotate * * SOAP_FMAC2 soap_dup_PointerTott__Rotate(struct soap *soap, tt__Rotate * *d, tt__Rotate *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Rotate **)soap_malloc(soap, sizeof(tt__Rotate *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Rotate(tt__Rotate *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Rotate);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap *soap, tt__Rotate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Rotate(soap, tag ? tag : "tt:Rotate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap *soap, tt__Rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, int id, tt__ProfileExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ProfileExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__ProfileExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, tt__ProfileExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileExtension2 **)soap_malloc(soap, sizeof(tt__ProfileExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileExtension2 *)soap_instantiate_tt__ProfileExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(tt__ProfileExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 * *d, tt__ProfileExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ProfileExtension2 **)soap_malloc(soap, sizeof(tt__ProfileExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ProfileExtension2(tt__ProfileExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ProfileExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension2(soap, tag ? tag : "tt:ProfileExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, tt__AudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioDecoderConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, tt__AudioDecoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(tt__AudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioDecoderConfiguration *)soap_instantiate_tt__AudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioDecoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration * *d, tt__AudioDecoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(tt__AudioDecoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioDecoderConfiguration(tt__AudioDecoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioDecoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag ? tag : "tt:AudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, tt__AudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioOutputConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, tt__AudioOutputConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(tt__AudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioOutputConfiguration *)soap_instantiate_tt__AudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioOutputConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration * *d, tt__AudioOutputConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(tt__AudioOutputConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioOutputConfiguration(tt__AudioOutputConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioOutputConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag ? tag : "tt:AudioOutputConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ProfileExtension ? type : NULL);
}

SOAP_FMAC3 tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ProfileExtension **)soap_malloc(soap, sizeof(tt__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ProfileExtension *)soap_instantiate_tt__ProfileExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ProfileExtension * * SOAP_FMAC2 soap_dup_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension * *d, tt__ProfileExtension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ProfileExtension **)soap_malloc(soap, sizeof(tt__ProfileExtension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ProfileExtension(tt__ProfileExtension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ProfileExtension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ProfileExtension(soap, tag ? tag : "tt:ProfileExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__MetadataConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfiguration **)soap_malloc(soap, sizeof(tt__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfiguration *)soap_instantiate_tt__MetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__MetadataConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration * *d, tt__MetadataConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__MetadataConfiguration **)soap_malloc(soap, sizeof(tt__MetadataConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__MetadataConfiguration(tt__MetadataConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__MetadataConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag ? tag : "tt:MetadataConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfiguration **)soap_malloc(soap, sizeof(tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfiguration *)soap_instantiate_tt__PTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration * *d, tt__PTZConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__PTZConfiguration **)soap_malloc(soap, sizeof(tt__PTZConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__PTZConfiguration(tt__PTZConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__PTZConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoAnalyticsConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(tt__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAnalyticsConfiguration *)soap_instantiate_tt__VideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoAnalyticsConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration * *d, tt__VideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(tt__VideoAnalyticsConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoAnalyticsConfiguration(tt__VideoAnalyticsConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoAnalyticsConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag ? tag : "tt:VideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(tt__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioEncoderConfiguration *)soap_instantiate_tt__AudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration * *d, tt__AudioEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(tt__AudioEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioEncoderConfiguration(tt__AudioEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag ? tag : "tt:AudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoEncoderConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderConfiguration *)soap_instantiate_tt__VideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration * *d, tt__VideoEncoderConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(tt__VideoEncoderConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoEncoderConfiguration(tt__VideoEncoderConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoEncoderConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag ? tag : "tt:VideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AudioSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(tt__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceConfiguration *)soap_instantiate_tt__AudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration * *d, tt__AudioSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(tt__AudioSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AudioSourceConfiguration(tt__AudioSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AudioSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag ? tag : "tt:AudioSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(tt__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfiguration *)soap_instantiate_tt__VideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration * *d, tt__VideoSourceConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(tt__VideoSourceConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceConfiguration(tt__VideoSourceConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag ? tag : "tt:VideoSourceConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, int id, tt__VideoSourceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__VideoSourceExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, tt__VideoSourceExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceExtension2 *)soap_instantiate_tt__VideoSourceExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__VideoSourceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(tt__VideoSourceExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__VideoSourceExtension2 * * SOAP_FMAC2 soap_dup_PointerTott__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 * *d, tt__VideoSourceExtension2 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__VideoSourceExtension2 **)soap_malloc(soap, sizeof(tt__VideoSourceExtension2 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__VideoSourceExtension2(tt__VideoSourceExtension2 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__VideoSourceExtension2);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__VideoSourceExtension2(soap, tag ? tag : "tt:VideoSourceExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ImagingSettings20 ? type : NULL);
}

SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, tt__ImagingSettings20 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings20 **)soap_malloc(soap, sizeof(tt__ImagingSettings20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings20 *)soap_instantiate_tt__ImagingSettings20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(tt__ImagingSettings20), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ImagingSettings20 * * SOAP_FMAC2 soap_dup_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 * *d, tt__ImagingSettings20 *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__ImagingSettings20 **)soap_malloc(soap, sizeof(tt__ImagingSettings20 *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__ImagingSettings20(tt__ImagingSettings20 *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__ImagingSettings20);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ImagingSettings20(soap, tag ? tag : "tt:ImagingSettings20", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LocationEntity))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LocationEntity(struct soap *soap, const char *tag, int id, tt__LocationEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LocationEntity, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__LocationEntity ? type : NULL);
}

SOAP_FMAC3 tt__LocationEntity ** SOAP_FMAC4 soap_in_PointerTott__LocationEntity(struct soap *soap, const char *tag, tt__LocationEntity **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__LocationEntity **)soap_malloc(soap, sizeof(tt__LocationEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__LocationEntity *)soap_instantiate_tt__LocationEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__LocationEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LocationEntity, sizeof(tt__LocationEntity), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__LocationEntity * * SOAP_FMAC2 soap_dup_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity * *d, tt__LocationEntity *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__LocationEntity **)soap_malloc(soap, sizeof(tt__LocationEntity *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__LocationEntity(tt__LocationEntity *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__LocationEntity);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__LocationEntity(soap, tag ? tag : "tt:LocationEntity", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__LocationEntity ** SOAP_FMAC4 soap_get_PointerTott__LocationEntity(struct soap *soap, tt__LocationEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LocationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfigurationData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, int id, tds__StorageConfigurationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfigurationData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__StorageConfigurationData ? type : NULL);
}

SOAP_FMAC3 tds__StorageConfigurationData ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfigurationData(struct soap *soap, const char *tag, tds__StorageConfigurationData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__StorageConfigurationData **)soap_malloc(soap, sizeof(tds__StorageConfigurationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__StorageConfigurationData *)soap_instantiate_tds__StorageConfigurationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__StorageConfigurationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfigurationData * * SOAP_FMAC2 soap_dup_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData * *d, tds__StorageConfigurationData *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__StorageConfigurationData **)soap_malloc(soap, sizeof(tds__StorageConfigurationData *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__StorageConfigurationData(tds__StorageConfigurationData *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__StorageConfigurationData);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__StorageConfigurationData ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__StorageConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, int id, tds__StorageConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__StorageConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__StorageConfiguration ? type : NULL);
}

SOAP_FMAC3 tds__StorageConfiguration ** SOAP_FMAC4 soap_in_PointerTotds__StorageConfiguration(struct soap *soap, const char *tag, tds__StorageConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__StorageConfiguration **)soap_malloc(soap, sizeof(tds__StorageConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__StorageConfiguration *)soap_instantiate_tds__StorageConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__StorageConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfiguration * * SOAP_FMAC2 soap_dup_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration * *d, tds__StorageConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__StorageConfiguration **)soap_malloc(soap, sizeof(tds__StorageConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__StorageConfiguration(tds__StorageConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__StorageConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__StorageConfiguration ** SOAP_FMAC4 soap_get_PointerTotds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__GetSystemUrisResponse_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(_tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUrisResponse_Extension *)soap_instantiate__tds__GetSystemUrisResponse_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(_tds__GetSystemUrisResponse_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * * SOAP_FMAC2 soap_dup_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension * *d, _tds__GetSystemUrisResponse_Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(_tds__GetSystemUrisResponse_Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__GetSystemUrisResponse_Extension(_tds__GetSystemUrisResponse_Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__GetSystemUrisResponse_Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag ? tag : "tds:GetSystemUrisResponse-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLogUriList ? type : NULL);
}

SOAP_FMAC3 tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, tt__SystemLogUriList **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLogUriList **)soap_malloc(soap, sizeof(tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLogUriList *)soap_instantiate_tt__SystemLogUriList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(tt__SystemLogUriList), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLogUriList * * SOAP_FMAC2 soap_dup_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList * *d, tt__SystemLogUriList *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemLogUriList **)soap_malloc(soap, sizeof(tt__SystemLogUriList *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemLogUriList(tt__SystemLogUriList *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemLogUriList);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLogUriList(soap, tag ? tag : "tt:SystemLogUriList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11AvailableNetworks ? type : NULL);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, tt__Dot11AvailableNetworks **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11AvailableNetworks *)soap_instantiate_tt__Dot11AvailableNetworks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(tt__Dot11AvailableNetworks), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11AvailableNetworks * * SOAP_FMAC2 soap_dup_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks * *d, tt__Dot11AvailableNetworks *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(tt__Dot11AvailableNetworks *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11AvailableNetworks(tt__Dot11AvailableNetworks *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11AvailableNetworks);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag ? tag : "tt:Dot11AvailableNetworks", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Status ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, tt__Dot11Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Status **)soap_malloc(soap, sizeof(tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Status *)soap_instantiate_tt__Dot11Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(tt__Dot11Status), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Status * * SOAP_FMAC2 soap_dup_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status * *d, tt__Dot11Status *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11Status **)soap_malloc(soap, sizeof(tt__Dot11Status *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11Status(tt__Dot11Status *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11Status);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Status(soap, tag ? tag : "tt:Dot11Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot11Capabilities ? type : NULL);
}

SOAP_FMAC3 tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, tt__Dot11Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot11Capabilities **)soap_malloc(soap, sizeof(tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot11Capabilities *)soap_instantiate_tt__Dot11Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(tt__Dot11Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot11Capabilities * * SOAP_FMAC2 soap_dup_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities * *d, tt__Dot11Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot11Capabilities **)soap_malloc(soap, sizeof(tt__Dot11Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot11Capabilities(tt__Dot11Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot11Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag ? tag : "tt:Dot11Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AuxiliaryData(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData))
		soap_serialize_tt__AuxiliaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AuxiliaryData, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AuxiliaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__AuxiliaryData(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__AuxiliaryData(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AuxiliaryData(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AuxiliaryData(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__AuxiliaryData(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelayOutputSettings ? type : NULL);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, tt__RelayOutputSettings **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelayOutputSettings **)soap_malloc(soap, sizeof(tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelayOutputSettings *)soap_instantiate_tt__RelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(tt__RelayOutputSettings), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutputSettings * * SOAP_FMAC2 soap_dup_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings * *d, tt__RelayOutputSettings *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RelayOutputSettings **)soap_malloc(soap, sizeof(tt__RelayOutputSettings *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RelayOutputSettings(tt__RelayOutputSettings *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RelayOutputSettings);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag ? tag : "tt:RelayOutputSettings", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RelayOutput ? type : NULL);
}

SOAP_FMAC3 tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, tt__RelayOutput **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RelayOutput **)soap_malloc(soap, sizeof(tt__RelayOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RelayOutput *)soap_instantiate_tt__RelayOutput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(tt__RelayOutput), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RelayOutput * * SOAP_FMAC2 soap_dup_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput * *d, tt__RelayOutput *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RelayOutput **)soap_malloc(soap, sizeof(tt__RelayOutput *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RelayOutput(tt__RelayOutput *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RelayOutput);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RelayOutput(soap, tag ? tag : "tt:RelayOutput", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, tt__Dot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Dot1XConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__Dot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, tt__Dot1XConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(tt__Dot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Dot1XConfiguration *)soap_instantiate_tt__Dot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(tt__Dot1XConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Dot1XConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration * *d, tt__Dot1XConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(tt__Dot1XConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Dot1XConfiguration(tt__Dot1XConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Dot1XConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Dot1XConfiguration(soap, tag ? tag : "tt:Dot1XConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Dot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfiguration(struct soap *soap, tt__Dot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformation(struct soap *soap, const char *tag, int id, tt__CertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateInformation ? type : NULL);
}

SOAP_FMAC3 tt__CertificateInformation ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformation(struct soap *soap, const char *tag, tt__CertificateInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateInformation **)soap_malloc(soap, sizeof(tt__CertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateInformation *)soap_instantiate_tt__CertificateInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(tt__CertificateInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateInformation * * SOAP_FMAC2 soap_dup_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation * *d, tt__CertificateInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CertificateInformation **)soap_malloc(soap, sizeof(tt__CertificateInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CertificateInformation(tt__CertificateInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CertificateInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateInformation(soap, tag ? tag : "tt:CertificateInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateInformation ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformation(struct soap *soap, tt__CertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateWithPrivateKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, tt__CertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateWithPrivateKey, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateWithPrivateKey ? type : NULL);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, tt__CertificateWithPrivateKey **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(tt__CertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateWithPrivateKey *)soap_instantiate_tt__CertificateWithPrivateKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(tt__CertificateWithPrivateKey), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateWithPrivateKey * * SOAP_FMAC2 soap_dup_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey * *d, tt__CertificateWithPrivateKey *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(tt__CertificateWithPrivateKey *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CertificateWithPrivateKey(tt__CertificateWithPrivateKey *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CertificateWithPrivateKey);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag ? tag : "tt:CertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTott__CertificateWithPrivateKey(struct soap *soap, tt__CertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, tt__CertificateStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__CertificateStatus ? type : NULL);
}

SOAP_FMAC3 tt__CertificateStatus ** SOAP_FMAC4 soap_in_PointerTott__CertificateStatus(struct soap *soap, const char *tag, tt__CertificateStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__CertificateStatus **)soap_malloc(soap, sizeof(tt__CertificateStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__CertificateStatus *)soap_instantiate_tt__CertificateStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(tt__CertificateStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__CertificateStatus * * SOAP_FMAC2 soap_dup_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus * *d, tt__CertificateStatus *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__CertificateStatus **)soap_malloc(soap, sizeof(tt__CertificateStatus *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__CertificateStatus(tt__CertificateStatus *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__CertificateStatus);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__CertificateStatus(soap, tag ? tag : "tt:CertificateStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__CertificateStatus ** SOAP_FMAC4 soap_get_PointerTott__CertificateStatus(struct soap *soap, tt__CertificateStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Certificate(struct soap *soap, tt__Certificate *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Certificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Certificate(struct soap *soap, const char *tag, int id, tt__Certificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Certificate, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Certificate ? type : NULL);
}

SOAP_FMAC3 tt__Certificate ** SOAP_FMAC4 soap_in_PointerTott__Certificate(struct soap *soap, const char *tag, tt__Certificate **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Certificate **)soap_malloc(soap, sizeof(tt__Certificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Certificate *)soap_instantiate_tt__Certificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(tt__Certificate), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Certificate * * SOAP_FMAC2 soap_dup_PointerTott__Certificate(struct soap *soap, tt__Certificate * *d, tt__Certificate *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Certificate **)soap_malloc(soap, sizeof(tt__Certificate *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Certificate(tt__Certificate *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Certificate);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Certificate(struct soap *soap, tt__Certificate *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Certificate(soap, tag ? tag : "tt:Certificate", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Certificate ** SOAP_FMAC4 soap_get_PointerTott__Certificate(struct soap *soap, tt__Certificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodateTime(struct soap *soap, time_t *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_dateTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodateTime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_dateTime, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_dateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTodateTime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_dateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_dateTime, sizeof(time_t), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 time_t * * SOAP_FMAC2 soap_dup_PointerTodateTime(struct soap *soap, time_t * *d, time_t *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (time_t **)soap_malloc(soap, sizeof(time_t *))))
		return NULL; /* ERROR */
	if (*a && (*d = (time_t *)soap_malloc(soap, sizeof(time_t))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTodateTime(time_t *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodateTime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTodateTime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__token(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__token(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__token(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BinaryData ? type : NULL);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, tt__BinaryData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BinaryData **)soap_malloc(soap, sizeof(tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BinaryData *)soap_instantiate_tt__BinaryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(tt__BinaryData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BinaryData * * SOAP_FMAC2 soap_dup_PointerTott__BinaryData(struct soap *soap, tt__BinaryData * *d, tt__BinaryData *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__BinaryData **)soap_malloc(soap, sizeof(tt__BinaryData *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__BinaryData(tt__BinaryData *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__BinaryData);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, tt__BinaryData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BinaryData(soap, tag ? tag : "tt:BinaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddressFilter ? type : NULL);
}

SOAP_FMAC3 tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, tt__IPAddressFilter **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddressFilter **)soap_malloc(soap, sizeof(tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddressFilter *)soap_instantiate_tt__IPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(tt__IPAddressFilter), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddressFilter * * SOAP_FMAC2 soap_dup_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter * *d, tt__IPAddressFilter *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPAddressFilter **)soap_malloc(soap, sizeof(tt__IPAddressFilter *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPAddressFilter(tt__IPAddressFilter *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPAddressFilter);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddressFilter(soap, tag ? tag : "tt:IPAddressFilter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, tt__NetworkZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkZeroConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, tt__NetworkZeroConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(tt__NetworkZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkZeroConfiguration *)soap_instantiate_tt__NetworkZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(tt__NetworkZeroConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkZeroConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration * *d, tt__NetworkZeroConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(tt__NetworkZeroConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkZeroConfiguration(tt__NetworkZeroConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkZeroConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag ? tag : "tt:NetworkZeroConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfiguration(struct soap *soap, tt__NetworkZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkGateway ? type : NULL);
}

SOAP_FMAC3 tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, tt__NetworkGateway **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkGateway **)soap_malloc(soap, sizeof(tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkGateway *)soap_instantiate_tt__NetworkGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(tt__NetworkGateway), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkGateway * * SOAP_FMAC2 soap_dup_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway * *d, tt__NetworkGateway *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkGateway **)soap_malloc(soap, sizeof(tt__NetworkGateway *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkGateway(tt__NetworkGateway *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkGateway);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkGateway(soap, tag ? tag : "tt:NetworkGateway", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, tt__NetworkProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocol, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkProtocol ? type : NULL);
}

SOAP_FMAC3 tt__NetworkProtocol ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, tt__NetworkProtocol **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkProtocol **)soap_malloc(soap, sizeof(tt__NetworkProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkProtocol *)soap_instantiate_tt__NetworkProtocol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(tt__NetworkProtocol), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkProtocol * * SOAP_FMAC2 soap_dup_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol * *d, tt__NetworkProtocol *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkProtocol **)soap_malloc(soap, sizeof(tt__NetworkProtocol *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkProtocol(tt__NetworkProtocol *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkProtocol);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkProtocol(soap, tag ? tag : "tt:NetworkProtocol", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkProtocol ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocol(struct soap *soap, tt__NetworkProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterfaceSetConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceSetConfiguration *)soap_instantiate_tt__NetworkInterfaceSetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(tt__NetworkInterfaceSetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration * *d, tt__NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(tt__NetworkInterfaceSetConfiguration *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterfaceSetConfiguration(tt__NetworkInterfaceSetConfiguration *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterfaceSetConfiguration);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag ? tag : "tt:NetworkInterfaceSetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, tt__NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterface, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkInterface ? type : NULL);
}

SOAP_FMAC3 tt__NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterface(struct soap *soap, const char *tag, tt__NetworkInterface **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterface **)soap_malloc(soap, sizeof(tt__NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterface *)soap_instantiate_tt__NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(tt__NetworkInterface), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkInterface * * SOAP_FMAC2 soap_dup_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface * *d, tt__NetworkInterface *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkInterface **)soap_malloc(soap, sizeof(tt__NetworkInterface *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkInterface(tt__NetworkInterface *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkInterface);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkInterface(soap, tag ? tag : "tt:NetworkInterface", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterface(struct soap *soap, tt__NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__duration(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__duration(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__duration(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSName(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSName))
		soap_serialize_tt__DNSName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSName, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__DNSName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSName, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__DNSName(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__DNSName(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DNSName(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSName(soap, tag ? tag : "tt:DNSName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__DNSName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DynamicDNSInformation ? type : NULL);
}

SOAP_FMAC3 tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, tt__DynamicDNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DynamicDNSInformation *)soap_instantiate_tt__DynamicDNSInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(tt__DynamicDNSInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DynamicDNSInformation * * SOAP_FMAC2 soap_dup_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation * *d, tt__DynamicDNSInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(tt__DynamicDNSInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DynamicDNSInformation(tt__DynamicDNSInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DynamicDNSInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag ? tag : "tt:DynamicDNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NTPInformation ? type : NULL);
}

SOAP_FMAC3 tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, tt__NTPInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NTPInformation **)soap_malloc(soap, sizeof(tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NTPInformation *)soap_instantiate_tt__NTPInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(tt__NTPInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NTPInformation * * SOAP_FMAC2 soap_dup_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation * *d, tt__NTPInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NTPInformation **)soap_malloc(soap, sizeof(tt__NTPInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NTPInformation(tt__NTPInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NTPInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NTPInformation(soap, tag ? tag : "tt:NTPInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IPAddress ? type : NULL);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, tt__IPAddress **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPAddress **)soap_malloc(soap, sizeof(tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPAddress *)soap_instantiate_tt__IPAddress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(tt__IPAddress), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IPAddress * * SOAP_FMAC2 soap_dup_PointerTott__IPAddress(struct soap *soap, tt__IPAddress * *d, tt__IPAddress *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IPAddress **)soap_malloc(soap, sizeof(tt__IPAddress *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IPAddress(tt__IPAddress *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IPAddress);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, tt__IPAddress *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IPAddress(soap, tag ? tag : "tt:IPAddress", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DNSInformation ? type : NULL);
}

SOAP_FMAC3 tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, tt__DNSInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DNSInformation **)soap_malloc(soap, sizeof(tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DNSInformation *)soap_instantiate_tt__DNSInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(tt__DNSInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DNSInformation * * SOAP_FMAC2 soap_dup_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation * *d, tt__DNSInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DNSInformation **)soap_malloc(soap, sizeof(tt__DNSInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DNSInformation(tt__DNSInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DNSInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DNSInformation(soap, tag ? tag : "tt:DNSInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__HostnameInformation ? type : NULL);
}

SOAP_FMAC3 tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, tt__HostnameInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__HostnameInformation **)soap_malloc(soap, sizeof(tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__HostnameInformation *)soap_instantiate_tt__HostnameInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(tt__HostnameInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__HostnameInformation * * SOAP_FMAC2 soap_dup_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation * *d, tt__HostnameInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__HostnameInformation **)soap_malloc(soap, sizeof(tt__HostnameInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__HostnameInformation(tt__HostnameInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__HostnameInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__HostnameInformation(soap, tag ? tag : "tt:HostnameInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, tt__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Capabilities ? type : NULL);
}

SOAP_FMAC3 tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, tt__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Capabilities **)soap_malloc(soap, sizeof(tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Capabilities *)soap_instantiate_tt__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(tt__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Capabilities * * SOAP_FMAC2 soap_dup_PointerTott__Capabilities(struct soap *soap, tt__Capabilities * *d, tt__Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Capabilities **)soap_malloc(soap, sizeof(tt__Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Capabilities(tt__Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, tt__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Capabilities(soap, tag ? tag : "tt:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRange ? type : NULL);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRange *)soap_instantiate_tt__IntRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * * SOAP_FMAC2 soap_dup_PointerTott__IntRange(struct soap *soap, tt__IntRange * *d, tt__IntRange *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IntRange(tt__IntRange *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__IntRange);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, tt__User *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__User ? type : NULL);
}

SOAP_FMAC3 tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, tt__User **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__User **)soap_malloc(soap, sizeof(tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__User *)soap_instantiate_tt__User(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(tt__User), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__User * * SOAP_FMAC2 soap_dup_PointerTott__User(struct soap *soap, tt__User * *d, tt__User *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__User **)soap_malloc(soap, sizeof(tt__User *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__User(tt__User *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__User);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, tt__User *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__User(soap, tag ? tag : "tt:User", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RemoteUser(struct soap *soap, const char *tag, int id, tt__RemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RemoteUser, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__RemoteUser ? type : NULL);
}

SOAP_FMAC3 tt__RemoteUser ** SOAP_FMAC4 soap_in_PointerTott__RemoteUser(struct soap *soap, const char *tag, tt__RemoteUser **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RemoteUser **)soap_malloc(soap, sizeof(tt__RemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RemoteUser *)soap_instantiate_tt__RemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(tt__RemoteUser), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__RemoteUser * * SOAP_FMAC2 soap_dup_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser * *d, tt__RemoteUser *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__RemoteUser **)soap_malloc(soap, sizeof(tt__RemoteUser *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__RemoteUser(tt__RemoteUser *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__RemoteUser);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__RemoteUser(soap, tag ? tag : "tt:RemoteUser", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RemoteUser ** SOAP_FMAC4 soap_get_PointerTott__RemoteUser(struct soap *soap, tt__RemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__NetworkHost ? type : NULL);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, tt__NetworkHost **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkHost **)soap_malloc(soap, sizeof(tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkHost *)soap_instantiate_tt__NetworkHost(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(tt__NetworkHost), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__NetworkHost * * SOAP_FMAC2 soap_dup_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost * *d, tt__NetworkHost *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__NetworkHost **)soap_malloc(soap, sizeof(tt__NetworkHost *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__NetworkHost(tt__NetworkHost *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__NetworkHost);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__NetworkHost(soap, tag ? tag : "tt:NetworkHost", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Scope(struct soap *soap, tt__Scope *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Scope))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Scope(struct soap *soap, const char *tag, int id, tt__Scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Scope, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Scope ? type : NULL);
}

SOAP_FMAC3 tt__Scope ** SOAP_FMAC4 soap_in_PointerTott__Scope(struct soap *soap, const char *tag, tt__Scope **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Scope **)soap_malloc(soap, sizeof(tt__Scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Scope *)soap_instantiate_tt__Scope(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(tt__Scope), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Scope * * SOAP_FMAC2 soap_dup_PointerTott__Scope(struct soap *soap, tt__Scope * *d, tt__Scope *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__Scope **)soap_malloc(soap, sizeof(tt__Scope *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__Scope(tt__Scope *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__Scope);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Scope(struct soap *soap, tt__Scope *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Scope(soap, tag ? tag : "tt:Scope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Scope ** SOAP_FMAC4 soap_get_PointerTott__Scope(struct soap *soap, tt__Scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLog(struct soap *soap, tt__SystemLog *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLog(struct soap *soap, const char *tag, int id, tt__SystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLog, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemLog ? type : NULL);
}

SOAP_FMAC3 tt__SystemLog ** SOAP_FMAC4 soap_in_PointerTott__SystemLog(struct soap *soap, const char *tag, tt__SystemLog **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemLog **)soap_malloc(soap, sizeof(tt__SystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemLog *)soap_instantiate_tt__SystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(tt__SystemLog), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemLog * * SOAP_FMAC2 soap_dup_PointerTott__SystemLog(struct soap *soap, tt__SystemLog * *d, tt__SystemLog *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemLog **)soap_malloc(soap, sizeof(tt__SystemLog *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemLog(tt__SystemLog *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemLog);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLog(struct soap *soap, tt__SystemLog *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemLog(soap, tag ? tag : "tt:SystemLog", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemLog ** SOAP_FMAC4 soap_get_PointerTott__SystemLog(struct soap *soap, tt__SystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportInformation(struct soap *soap, const char *tag, int id, tt__SupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportInformation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SupportInformation ? type : NULL);
}

SOAP_FMAC3 tt__SupportInformation ** SOAP_FMAC4 soap_in_PointerTott__SupportInformation(struct soap *soap, const char *tag, tt__SupportInformation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SupportInformation **)soap_malloc(soap, sizeof(tt__SupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SupportInformation *)soap_instantiate_tt__SupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(tt__SupportInformation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SupportInformation * * SOAP_FMAC2 soap_dup_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation * *d, tt__SupportInformation *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SupportInformation **)soap_malloc(soap, sizeof(tt__SupportInformation *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SupportInformation(tt__SupportInformation *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SupportInformation);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SupportInformation(soap, tag ? tag : "tt:SupportInformation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SupportInformation ** SOAP_FMAC4 soap_get_PointerTott__SupportInformation(struct soap *soap, tt__SupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BackupFile(struct soap *soap, tt__BackupFile *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BackupFile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BackupFile(struct soap *soap, const char *tag, int id, tt__BackupFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BackupFile, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__BackupFile ? type : NULL);
}

SOAP_FMAC3 tt__BackupFile ** SOAP_FMAC4 soap_in_PointerTott__BackupFile(struct soap *soap, const char *tag, tt__BackupFile **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__BackupFile **)soap_malloc(soap, sizeof(tt__BackupFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__BackupFile *)soap_instantiate_tt__BackupFile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(tt__BackupFile), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__BackupFile * * SOAP_FMAC2 soap_dup_PointerTott__BackupFile(struct soap *soap, tt__BackupFile * *d, tt__BackupFile *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__BackupFile **)soap_malloc(soap, sizeof(tt__BackupFile *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__BackupFile(tt__BackupFile *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__BackupFile);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BackupFile(struct soap *soap, tt__BackupFile *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__BackupFile(soap, tag ? tag : "tt:BackupFile", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__BackupFile ** SOAP_FMAC4 soap_get_PointerTott__BackupFile(struct soap *soap, tt__BackupFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__AttachmentData ? type : NULL);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, tt__AttachmentData **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AttachmentData **)soap_malloc(soap, sizeof(tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AttachmentData *)soap_instantiate_tt__AttachmentData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(tt__AttachmentData), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__AttachmentData * * SOAP_FMAC2 soap_dup_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData * *d, tt__AttachmentData *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__AttachmentData **)soap_malloc(soap, sizeof(tt__AttachmentData *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__AttachmentData(tt__AttachmentData *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__AttachmentData);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__AttachmentData(soap, tag ? tag : "tt:AttachmentData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__SystemDateTime ? type : NULL);
}

SOAP_FMAC3 tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, tt__SystemDateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SystemDateTime **)soap_malloc(soap, sizeof(tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SystemDateTime *)soap_instantiate_tt__SystemDateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(tt__SystemDateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__SystemDateTime * * SOAP_FMAC2 soap_dup_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime * *d, tt__SystemDateTime *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__SystemDateTime **)soap_malloc(soap, sizeof(tt__SystemDateTime *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__SystemDateTime(tt__SystemDateTime *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__SystemDateTime);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__SystemDateTime(soap, tag ? tag : "tt:SystemDateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DateTime ? type : NULL);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, tt__DateTime **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DateTime **)soap_malloc(soap, sizeof(tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DateTime *)soap_instantiate_tt__DateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(tt__DateTime), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DateTime * * SOAP_FMAC2 soap_dup_PointerTott__DateTime(struct soap *soap, tt__DateTime * *d, tt__DateTime *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__DateTime **)soap_malloc(soap, sizeof(tt__DateTime *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__DateTime(tt__DateTime *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__DateTime);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, tt__DateTime *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DateTime(soap, tag ? tag : "tt:DateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__TimeZone ? type : NULL);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, tt__TimeZone **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TimeZone **)soap_malloc(soap, sizeof(tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TimeZone *)soap_instantiate_tt__TimeZone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(tt__TimeZone), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__TimeZone * * SOAP_FMAC2 soap_dup_PointerTott__TimeZone(struct soap *soap, tt__TimeZone * *d, tt__TimeZone *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__TimeZone **)soap_malloc(soap, sizeof(tt__TimeZone *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__TimeZone(tt__TimeZone *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__TimeZone);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, tt__TimeZone *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__TimeZone(soap, tag ? tag : "tt:TimeZone", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__DeviceServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, tds__DeviceServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__DeviceServiceCapabilities *)soap_instantiate_tds__DeviceServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__DeviceServiceCapabilities * * SOAP_FMAC2 soap_dup_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities * *d, tds__DeviceServiceCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(tds__DeviceServiceCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__DeviceServiceCapabilities(tds__DeviceServiceCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__DeviceServiceCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, tds__Service *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__Service ? type : NULL);
}

SOAP_FMAC3 tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, tds__Service **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__Service **)soap_malloc(soap, sizeof(tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__Service *)soap_instantiate_tds__Service(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(tds__Service), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__Service * * SOAP_FMAC2 soap_dup_PointerTotds__Service(struct soap *soap, tds__Service * *d, tds__Service *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__Service **)soap_malloc(soap, sizeof(tds__Service *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__Service(tds__Service *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__Service);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, tds__Service *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__Service(soap, tag ? tag : "tds:Service", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StorageConfigurationData_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, int id, _tds__StorageConfigurationData_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StorageConfigurationData_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__StorageConfigurationData_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, const char *tag, _tds__StorageConfigurationData_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StorageConfigurationData_Extension **)soap_malloc(soap, sizeof(_tds__StorageConfigurationData_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StorageConfigurationData_Extension *)soap_instantiate__tds__StorageConfigurationData_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__StorageConfigurationData_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StorageConfigurationData_Extension, sizeof(_tds__StorageConfigurationData_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__StorageConfigurationData_Extension * * SOAP_FMAC2 soap_dup_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension * *d, _tds__StorageConfigurationData_Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__StorageConfigurationData_Extension **)soap_malloc(soap, sizeof(_tds__StorageConfigurationData_Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__StorageConfigurationData_Extension(_tds__StorageConfigurationData_Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__StorageConfigurationData_Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, tag ? tag : "tds:StorageConfigurationData-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StorageConfigurationData_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__StorageConfigurationData_Extension(struct soap *soap, _tds__StorageConfigurationData_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__UserCredential))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__UserCredential(struct soap *soap, const char *tag, int id, tds__UserCredential *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__UserCredential, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__UserCredential ? type : NULL);
}

SOAP_FMAC3 tds__UserCredential ** SOAP_FMAC4 soap_in_PointerTotds__UserCredential(struct soap *soap, const char *tag, tds__UserCredential **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__UserCredential **)soap_malloc(soap, sizeof(tds__UserCredential *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__UserCredential *)soap_instantiate_tds__UserCredential(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__UserCredential **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__UserCredential * * SOAP_FMAC2 soap_dup_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential * *d, tds__UserCredential *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__UserCredential **)soap_malloc(soap, sizeof(tds__UserCredential *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__UserCredential(tds__UserCredential *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__UserCredential);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__UserCredential ** SOAP_FMAC4 soap_get_PointerTotds__UserCredential(struct soap *soap, tds__UserCredential **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerToxsd__anyURI(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_xsd__anyURI(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToxsd__anyURI(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UserCredential_Extension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, int id, _tds__UserCredential_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UserCredential_Extension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__UserCredential_Extension ? type : NULL);
}

SOAP_FMAC3 _tds__UserCredential_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__UserCredential_Extension(struct soap *soap, const char *tag, _tds__UserCredential_Extension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UserCredential_Extension **)soap_malloc(soap, sizeof(_tds__UserCredential_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UserCredential_Extension *)soap_instantiate__tds__UserCredential_Extension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__UserCredential_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UserCredential_Extension, sizeof(_tds__UserCredential_Extension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UserCredential_Extension * * SOAP_FMAC2 soap_dup_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension * *d, _tds__UserCredential_Extension *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__UserCredential_Extension **)soap_malloc(soap, sizeof(_tds__UserCredential_Extension *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__UserCredential_Extension(_tds__UserCredential_Extension *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__UserCredential_Extension);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, tag ? tag : "tds:UserCredential-Extension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UserCredential_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__UserCredential_Extension(struct soap *soap, _tds__UserCredential_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UserCredential_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTostd__string(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_std__string(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTostd__string(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringAttrList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList))
		soap_serialize_tt__StringAttrList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringAttrList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringAttrList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringAttrList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringAttrList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringAttrList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringAttrList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__StringAttrList(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__StringAttrList(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__StringAttrList(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringAttrList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringAttrList(soap, tag ? tag : "tt:StringAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringAttrList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringList))
		soap_serialize_tt__StringList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__StringList(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__StringList(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__StringList(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntList))
		soap_serialize_tt__IntList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IntList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 std::string * * SOAP_FMAC2 soap_dup_PointerTott__IntList(struct soap *soap, std::string * *d, std::string *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (std::string **)soap_malloc(soap, sizeof(std::string *))))
		return NULL; /* ERROR */
	if (*a && (*d = soap_new_tt__IntList(soap)))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__IntList(std::string *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_DELETE(NULL, *a, std::string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntList(soap, tag ? tag : "tt:IntList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IntList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 bool * * SOAP_FMAC2 soap_dup_PointerTobool(struct soap *soap, bool * *d, bool *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (bool **)soap_malloc(soap, sizeof(bool *))))
		return NULL; /* ERROR */
	if (*a && (*d = (bool *)soap_malloc(soap, sizeof(bool))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTobool(bool *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__MiscCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, int id, tds__MiscCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__MiscCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__MiscCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__MiscCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, tds__MiscCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__MiscCapabilities **)soap_malloc(soap, sizeof(tds__MiscCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__MiscCapabilities *)soap_instantiate_tds__MiscCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(tds__MiscCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__MiscCapabilities * * SOAP_FMAC2 soap_dup_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities * *d, tds__MiscCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__MiscCapabilities **)soap_malloc(soap, sizeof(tds__MiscCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__MiscCapabilities(tds__MiscCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__MiscCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__MiscCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SystemCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, int id, tds__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SystemCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__SystemCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, tds__SystemCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__SystemCapabilities **)soap_malloc(soap, sizeof(tds__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__SystemCapabilities *)soap_instantiate_tds__SystemCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(tds__SystemCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__SystemCapabilities * * SOAP_FMAC2 soap_dup_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities * *d, tds__SystemCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__SystemCapabilities **)soap_malloc(soap, sizeof(tds__SystemCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__SystemCapabilities(tds__SystemCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__SystemCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SecurityCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, int id, tds__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SecurityCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__SecurityCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, tds__SecurityCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__SecurityCapabilities **)soap_malloc(soap, sizeof(tds__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__SecurityCapabilities *)soap_instantiate_tds__SecurityCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(tds__SecurityCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__SecurityCapabilities * * SOAP_FMAC2 soap_dup_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities * *d, tds__SecurityCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__SecurityCapabilities **)soap_malloc(soap, sizeof(tds__SecurityCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__SecurityCapabilities(tds__SecurityCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__SecurityCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__NetworkCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, int id, tds__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__NetworkCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tds__NetworkCapabilities ? type : NULL);
}

SOAP_FMAC3 tds__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, tds__NetworkCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tds__NetworkCapabilities **)soap_malloc(soap, sizeof(tds__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tds__NetworkCapabilities *)soap_instantiate_tds__NetworkCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(tds__NetworkCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__NetworkCapabilities * * SOAP_FMAC2 soap_dup_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities * *d, tds__NetworkCapabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tds__NetworkCapabilities **)soap_malloc(soap, sizeof(tds__NetworkCapabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTotds__NetworkCapabilities(tds__NetworkCapabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tds__NetworkCapabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tds__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__OnvifVersion ? type : NULL);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, tt__OnvifVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__OnvifVersion **)soap_malloc(soap, sizeof(tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__OnvifVersion *)soap_instantiate_tt__OnvifVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(tt__OnvifVersion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__OnvifVersion * * SOAP_FMAC2 soap_dup_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion * *d, tt__OnvifVersion *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (tt__OnvifVersion **)soap_malloc(soap, sizeof(tt__OnvifVersion *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTott__OnvifVersion(tt__OnvifVersion *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, tt__OnvifVersion);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__OnvifVersion(soap, tag ? tag : "tt:OnvifVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tds__Service_Capabilities ? type : NULL);
}

SOAP_FMAC3 _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, _tds__Service_Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__Service_Capabilities **)soap_malloc(soap, sizeof(_tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__Service_Capabilities *)soap_instantiate__tds__Service_Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(_tds__Service_Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__Service_Capabilities * * SOAP_FMAC2 soap_dup_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities * *d, _tds__Service_Capabilities *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_tds__Service_Capabilities **)soap_malloc(soap, sizeof(_tds__Service_Capabilities *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_tds__Service_Capabilities(_tds__Service_Capabilities *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _tds__Service_Capabilities);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag ? tag : "tds:Service-Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header * *d, struct SOAP_ENV__Header *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Header(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToSOAP_ENV__Header(struct SOAP_ENV__Header *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_SOAP_ENV__Header(*a);
		SOAP_DELETE(NULL, *a, struct SOAP_ENV__Header);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 unsigned char * * SOAP_FMAC2 soap_dup_PointerTounsignedByte(struct soap *soap, unsigned char * *d, unsigned char *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
		return NULL; /* ERROR */
	if (*a && (*d = (unsigned char *)soap_malloc(soap, sizeof(unsigned char))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTounsignedByte(unsigned char *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchesType))
		soap_serialize_wsdd__ResolveMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveMatchesType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType * *d, struct wsdd__ResolveMatchesType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ResolveMatchesType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ResolveMatchesType(struct wsdd__ResolveMatchesType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ResolveMatchesType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ResolveMatchesType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveType))
		soap_serialize_wsdd__ResolveType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType * *d, struct wsdd__ResolveType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ResolveType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ResolveType(struct wsdd__ResolveType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ResolveType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ResolveType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchesType))
		soap_serialize_wsdd__ProbeMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeMatchesType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType * *d, struct wsdd__ProbeMatchesType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ProbeMatchesType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ProbeMatchesType(struct wsdd__ProbeMatchesType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ProbeMatchesType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ProbeMatchesType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeType))
		soap_serialize_wsdd__ProbeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType * *d, struct wsdd__ProbeType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ProbeType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ProbeType(struct wsdd__ProbeType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ProbeType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ProbeType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ByeType))
		soap_serialize_wsdd__ByeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ByeType(struct soap *soap, const char *tag, int id, struct wsdd__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ByeType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ByeType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType * *d, struct wsdd__ByeType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ByeType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ByeType(struct wsdd__ByeType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ByeType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ByeType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__HelloType))
		soap_serialize_wsdd__HelloType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__HelloType(struct soap *soap, const char *tag, int id, struct wsdd__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__HelloType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_in_PointerTowsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__HelloType * * SOAP_FMAC2 soap_dup_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType * *d, struct wsdd__HelloType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__HelloType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__HelloType(struct wsdd__HelloType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__HelloType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__HelloType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_get_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__AppSequenceType))
		soap_serialize_wsdd__AppSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, int id, struct wsdd__AppSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__AppSequenceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__AppSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_in_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__AppSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__AppSequenceType * * SOAP_FMAC2 soap_dup_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType * *d, struct wsdd__AppSequenceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__AppSequenceType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__AppSequenceType(struct wsdd__AppSequenceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__AppSequenceType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__AppSequenceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_get_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Id(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Id(soap, tag ? tag : "wsdd:Id", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__SigType))
		soap_serialize_wsdd__SigType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__SigType(struct soap *soap, const char *tag, int id, struct wsdd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__SigType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_in_PointerTowsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__SigType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__SigType * * SOAP_FMAC2 soap_dup_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType * *d, struct wsdd__SigType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__SigType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__SigType(struct wsdd__SigType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__SigType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__SigType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_get_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchType))
		soap_serialize_wsdd__ResolveMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveMatchType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType * *d, struct wsdd__ResolveMatchType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ResolveMatchType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ResolveMatchType(struct wsdd__ResolveMatchType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ResolveMatchType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ResolveMatchType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchType))
		soap_serialize_wsdd__ProbeMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeMatchType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType * *d, struct wsdd__ProbeMatchType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ProbeMatchType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ProbeMatchType(struct wsdd__ProbeMatchType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ProbeMatchType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ProbeMatchType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 unsigned int * * SOAP_FMAC2 soap_dup_PointerTounsignedInt(struct soap *soap, unsigned int * *d, unsigned int *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
		return NULL; /* ERROR */
	if (*a && (*d = (unsigned int *)soap_malloc(soap, sizeof(unsigned int))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTounsignedInt(unsigned int *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ScopesType))
		soap_serialize_wsdd__ScopesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, int id, struct wsdd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ScopesType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ScopesType * * SOAP_FMAC2 soap_dup_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType * *d, struct wsdd__ScopesType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsdd__ScopesType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsdd__ScopesType(struct wsdd__ScopesType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsdd__ScopesType(*a);
		SOAP_DELETE(NULL, *a, struct wsdd__ScopesType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__FaultCodeOpenType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__FaultCodeOpenType(soap, tag ? tag : "wsdd:FaultCodeOpenType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__UriListType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsdd__UriListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__UriListType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsdd__UriListType(soap, tag ? tag : "wsdd:UriListType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason * *d, struct SOAP_ENV__Reason *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Reason(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToSOAP_ENV__Reason(struct SOAP_ENV__Reason *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_SOAP_ENV__Reason(*a);
		SOAP_DELETE(NULL, *a, struct SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code * *d, struct SOAP_ENV__Code *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Code(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToSOAP_ENV__Code(struct SOAP_ENV__Code *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_SOAP_ENV__Code(*a);
		SOAP_DELETE(NULL, *a, struct SOAP_ENV__Code);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * * SOAP_FMAC2 soap_dup_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail * *d, struct SOAP_ENV__Detail *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_SOAP_ENV__Detail(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToSOAP_ENV__Detail(struct SOAP_ENV__Detail *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_SOAP_ENV__Detail(*a);
		SOAP_DELETE(NULL, *a, struct SOAP_ENV__Detail);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * * SOAP_FMAC2 soap_dup_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType * *d, struct chan__ChannelInstanceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_chan__ChannelInstanceType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTochan__ChannelInstanceType(struct chan__ChannelInstanceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_chan__ChannelInstanceType(*a);
		SOAP_DELETE(NULL, *a, struct chan__ChannelInstanceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * * SOAP_FMAC2 soap_dup_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType * *d, struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup__wsa5__FaultTo(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsa5__FaultTo(struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del__wsa5__FaultTo(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__EndpointReferenceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * * SOAP_FMAC2 soap_dup_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType * *d, struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup__wsa5__ReplyTo(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsa5__ReplyTo(struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del__wsa5__ReplyTo(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__EndpointReferenceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * * SOAP_FMAC2 soap_dup_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType * *d, struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup__wsa5__From(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsa5__From(struct wsa5__EndpointReferenceType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del__wsa5__From(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__EndpointReferenceType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * * SOAP_FMAC2 soap_dup_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType * *d, struct wsa5__RelatesToType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup__wsa5__RelatesTo(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_wsa5__RelatesTo(struct wsa5__RelatesToType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del__wsa5__RelatesTo(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__RelatesToType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 int * * SOAP_FMAC2 soap_dup_PointerToint(struct soap *soap, int * *d, int *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (int **)soap_malloc(soap, sizeof(int *))))
		return NULL; /* ERROR */
	if (*a && (*d = (int *)soap_malloc(soap, sizeof(int))))
		**d = **a;
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerToint(int *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * * SOAP_FMAC2 soap_dup_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType * *d, struct wsa5__MetadataType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsa5__MetadataType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsa5__MetadataType(struct wsa5__MetadataType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsa5__MetadataType(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__MetadataType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * * SOAP_FMAC2 soap_dup_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType * *d, struct wsa5__ReferenceParametersType *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
		return NULL; /* ERROR */
	if (*a)
		*d = soap_dup_wsa5__ReferenceParametersType(soap, NULL, *a);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTowsa5__ReferenceParametersType(struct wsa5__ReferenceParametersType *const*a)
{
	if (!a)
		return;
	if (*a)
	{	soap_del_wsa5__ReferenceParametersType(*a);
		SOAP_DELETE(NULL, *a, struct wsa5__ReferenceParametersType);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_dup_string(struct soap *soap, char * *d, char *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (char **)soap_malloc(soap, sizeof(char *))))
		return NULL; /* ERROR */
	*d = NULL;
	if (*a)
	{	struct soap_plist *pp = NULL;
		if (!(*d = (char *)soap_mark_lookup(soap, (const void*)*a, SOAP_TYPE_string, &pp, NULL)))
			soap_mark_dup(soap, *d = soap_strdup(soap, *a), pp);
	}
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_string(char *const*a)
{
	if (!a)
		return;
	if (*a)
		SOAP_FREE(NULL, *a);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const std::vector<_wstop__TopicNamespaceType_Topic> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, const std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wstop__TopicNamespaceType_Topic> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, std::vector<_wstop__TopicNamespaceType_Topic> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wstop__TopicNamespaceType_Topic));
		}
		else
		{	a->emplace_back();
		}
		_wstop__TopicNamespaceType_Topic *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wstop__TopicNamespaceType_Topic, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wstop__TopicNamespaceType_Topic(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, std::vector<_wstop__TopicNamespaceType_Topic>  *d, std::vector<_wstop__TopicNamespaceType_Topic> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<_wstop__TopicNamespaceType_Topic> ::iterator j = d->begin();
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup__wstop__TopicNamespaceType_Topic(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(std::vector<_wstop__TopicNamespaceType_Topic> const*a)
{
	if (!a)
		return;
	for (std::vector<_wstop__TopicNamespaceType_Topic> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del__wstop__TopicNamespaceType_Topic(&*i);
}

SOAP_FMAC1 std::vector<_wstop__TopicNamespaceType_Topic>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wstop__TopicNamespaceType_Topic> *p;
	size_t k = sizeof(std::vector<_wstop__TopicNamespaceType_Topic> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wstop__TopicNamespaceType_Topic> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wstop__TopicNamespaceType_Topic> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wstop__TopicNamespaceType_Topic>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const std::vector<wstop__TopicType *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTowstop__TopicType(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, const std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTowstop__TopicType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<wstop__TopicType *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, const char *tag, std::vector<wstop__TopicType *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
			return NULL;
		a->emplace_back();
		wstop__TopicType * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_wstop__TopicType, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, sizeof(wstop__TopicType), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTowstop__TopicType(soap, tag, NULL, "wstop:TopicType"))
				break;
		}
		else
		{	if (!soap_in_PointerTowstop__TopicType(soap, tag, n, "wstop:TopicType"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, std::vector<wstop__TopicType *>  *d, std::vector<wstop__TopicType *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTowstop__TopicType(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<wstop__TopicType *> ::iterator j = d->begin();
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTowstop__TopicType(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTowstop__TopicType(std::vector<wstop__TopicType *> const*a)
{
	if (!a)
		return;
	for (std::vector<wstop__TopicType *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTowstop__TopicType(&*i);
}

SOAP_FMAC1 std::vector<wstop__TopicType *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTowstop__TopicType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<wstop__TopicType *> *p;
	size_t k = sizeof(std::vector<wstop__TopicType *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<wstop__TopicType *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<wstop__TopicType *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<wstop__TopicType *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		std::string soap_tmp(soap_QName2s(soap, (*i).c_str()));
		if (soap_out_xsd__QName(soap, tag, id, &soap_tmp, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(std::string));
		}
		else
		{	a->emplace_back();
		}
		std::string *n = &a->back();
		soap_default_xsd__QName(soap, n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_xsd__QName(soap, tag, NULL, "xsd:QName"))
				break;
		}
		else
		{	if (!soap_in_xsd__QName(soap, tag, n, "xsd:QName"))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string>  *d, std::vector<std::string> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfxsd__QName(soap)))
		return NULL; /* ERROR */
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfxsd__QName(std::vector<std::string> const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, std::vector<tt__OSDConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const std::vector<tt__OSDConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__OSDConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__OSDConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__OSDConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__OSDConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, const char *tag, std::vector<tt__OSDConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__OSDConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__OSDConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__OSDConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration, sizeof(tt__OSDConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__OSDConfiguration(soap, tag, NULL, "tt:OSDConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__OSDConfiguration(soap, tag, n, "tt:OSDConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__OSDConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, std::vector<tt__OSDConfiguration *>  *d, std::vector<tt__OSDConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__OSDConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__OSDConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__OSDConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__OSDConfiguration(std::vector<tt__OSDConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__OSDConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__OSDConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__OSDConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__OSDConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__OSDConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__OSDConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__OSDConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__OSDConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__OSDConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__OSDConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, std::vector<trt__VideoSourceMode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const std::vector<trt__VideoSourceMode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotrt__VideoSourceMode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, int id, const std::vector<trt__VideoSourceMode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotrt__VideoSourceMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<trt__VideoSourceMode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, const char *tag, std::vector<trt__VideoSourceMode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotrt__VideoSourceMode(soap)))
			return NULL;
		a->emplace_back();
		trt__VideoSourceMode * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_trt__VideoSourceMode, SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode, sizeof(trt__VideoSourceMode), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotrt__VideoSourceMode(soap, tag, NULL, "trt:VideoSourceMode"))
				break;
		}
		else
		{	if (!soap_in_PointerTotrt__VideoSourceMode(soap, tag, n, "trt:VideoSourceMode"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<trt__VideoSourceMode *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, std::vector<trt__VideoSourceMode *>  *d, std::vector<trt__VideoSourceMode *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTotrt__VideoSourceMode(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<trt__VideoSourceMode *> ::iterator j = d->begin();
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTotrt__VideoSourceMode(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTotrt__VideoSourceMode(std::vector<trt__VideoSourceMode *> const*a)
{
	if (!a)
		return;
	for (std::vector<trt__VideoSourceMode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTotrt__VideoSourceMode(&*i);
}

SOAP_FMAC1 std::vector<trt__VideoSourceMode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotrt__VideoSourceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotrt__VideoSourceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<trt__VideoSourceMode *> *p;
	size_t k = sizeof(std::vector<trt__VideoSourceMode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<trt__VideoSourceMode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<trt__VideoSourceMode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<trt__VideoSourceMode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, std::vector<tt__AudioDecoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const std::vector<tt__AudioDecoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioDecoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioDecoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioDecoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioDecoderConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioDecoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, NULL, "tt:AudioDecoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, n, "tt:AudioDecoderConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioDecoderConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, std::vector<tt__AudioDecoderConfiguration *>  *d, std::vector<tt__AudioDecoderConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioDecoderConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioDecoderConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(std::vector<tt__AudioDecoderConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioDecoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioDecoderConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioDecoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioDecoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioDecoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioDecoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioDecoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioDecoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, std::vector<tt__AudioOutputConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const std::vector<tt__AudioOutputConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioOutputConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioOutputConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioOutputConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioOutputConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioOutputConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioOutputConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioOutputConfiguration(soap, tag, NULL, "tt:AudioOutputConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioOutputConfiguration(soap, tag, n, "tt:AudioOutputConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioOutputConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, std::vector<tt__AudioOutputConfiguration *>  *d, std::vector<tt__AudioOutputConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioOutputConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioOutputConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(std::vector<tt__AudioOutputConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioOutputConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioOutputConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioOutputConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioOutputConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioOutputConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioOutputConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioOutputConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioOutputConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, std::vector<tt__MetadataConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const std::vector<tt__MetadataConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__MetadataConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__MetadataConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__MetadataConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__MetadataConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, std::vector<tt__MetadataConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__MetadataConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__MetadataConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__MetadataConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration, sizeof(tt__MetadataConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__MetadataConfiguration(soap, tag, NULL, "tt:MetadataConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__MetadataConfiguration(soap, tag, n, "tt:MetadataConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__MetadataConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, std::vector<tt__MetadataConfiguration *>  *d, std::vector<tt__MetadataConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__MetadataConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__MetadataConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__MetadataConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__MetadataConfiguration(std::vector<tt__MetadataConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__MetadataConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__MetadataConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__MetadataConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__MetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__MetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__MetadataConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__MetadataConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__MetadataConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__MetadataConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__MetadataConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, std::vector<tt__VideoAnalyticsConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const std::vector<tt__VideoAnalyticsConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__VideoAnalyticsConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__VideoAnalyticsConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, std::vector<tt__VideoAnalyticsConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__VideoAnalyticsConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__VideoAnalyticsConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, NULL, "tt:VideoAnalyticsConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, n, "tt:VideoAnalyticsConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__VideoAnalyticsConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, std::vector<tt__VideoAnalyticsConfiguration *>  *d, std::vector<tt__VideoAnalyticsConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__VideoAnalyticsConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__VideoAnalyticsConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(std::vector<tt__VideoAnalyticsConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__VideoAnalyticsConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__VideoAnalyticsConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__VideoAnalyticsConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__VideoAnalyticsConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__VideoAnalyticsConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__VideoAnalyticsConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__VideoAnalyticsConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__VideoAnalyticsConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, std::vector<tt__AudioSourceConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const std::vector<tt__AudioSourceConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioSourceConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioSourceConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioSourceConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioSourceConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioSourceConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioSourceConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioSourceConfiguration(soap, tag, NULL, "tt:AudioSourceConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioSourceConfiguration(soap, tag, n, "tt:AudioSourceConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioSourceConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, std::vector<tt__AudioSourceConfiguration *>  *d, std::vector<tt__AudioSourceConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioSourceConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioSourceConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(std::vector<tt__AudioSourceConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioSourceConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioSourceConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioSourceConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioSourceConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioSourceConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioSourceConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioSourceConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioSourceConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, std::vector<tt__AudioEncoderConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const std::vector<tt__AudioEncoderConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioEncoderConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioEncoderConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, std::vector<tt__AudioEncoderConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioEncoderConfiguration * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioEncoderConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, NULL, "tt:AudioEncoderConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, n, "tt:AudioEncoderConfiguration"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfiguration *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, std::vector<tt__AudioEncoderConfiguration *>  *d, std::vector<tt__AudioEncoderConfiguration *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioEncoderConfiguration *> ::iterator j = d->begin();
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioEncoderConfiguration(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(std::vector<tt__AudioEncoderConfiguration *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioEncoderConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioEncoderConfiguration(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioEncoderConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioEncoderConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__AudioEncoderConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioEncoderConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioEncoderConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioEncoderConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, std::vector<tt__Profile *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const std::vector<tt__Profile *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Profile(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, int id, const std::vector<tt__Profile *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Profile(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Profile *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, const char *tag, std::vector<tt__Profile *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Profile(soap)))
			return NULL;
		a->emplace_back();
		tt__Profile * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__Profile, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, sizeof(tt__Profile), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Profile(soap, tag, NULL, "tt:Profile"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Profile(soap, tag, n, "tt:Profile"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Profile *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, std::vector<tt__Profile *>  *d, std::vector<tt__Profile *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__Profile(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__Profile *> ::iterator j = d->begin();
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__Profile(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__Profile(std::vector<tt__Profile *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__Profile *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__Profile(&*i);
}

SOAP_FMAC1 std::vector<tt__Profile *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Profile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Profile *> *p;
	size_t k = sizeof(std::vector<tt__Profile *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Profile *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Profile *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Profile *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, std::vector<tt__AudioOutput *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const std::vector<tt__AudioOutput *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioOutput(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioOutput(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioOutput *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, const char *tag, std::vector<tt__AudioOutput *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioOutput(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioOutput * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioOutput, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, sizeof(tt__AudioOutput), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioOutput(soap, tag, NULL, "tt:AudioOutput"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioOutput(soap, tag, n, "tt:AudioOutput"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioOutput *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, std::vector<tt__AudioOutput *>  *d, std::vector<tt__AudioOutput *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioOutput(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioOutput *> ::iterator j = d->begin();
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioOutput(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioOutput(std::vector<tt__AudioOutput *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioOutput *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioOutput(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioOutput *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioOutput(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioOutput *> *p;
	size_t k = sizeof(std::vector<tt__AudioOutput *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioOutput *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioOutput *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioOutput *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, std::vector<tt__AudioSource *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const std::vector<tt__AudioSource *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__AudioSource(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, int id, const std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__AudioSource(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__AudioSource *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, const char *tag, std::vector<tt__AudioSource *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__AudioSource(soap)))
			return NULL;
		a->emplace_back();
		tt__AudioSource * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_tt__AudioSource, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, sizeof(tt__AudioSource), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__AudioSource(soap, tag, NULL, "tt:AudioSource"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__AudioSource(soap, tag, n, "tt:AudioSource"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__AudioSource *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, std::vector<tt__AudioSource *>  *d, std::vector<tt__AudioSource *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTott__AudioSource(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<tt__AudioSource *> ::iterator j = d->begin();
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTott__AudioSource(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTott__AudioSource(std::vector<tt__AudioSource *> const*a)
{
	if (!a)
		return;
	for (std::vector<tt__AudioSource *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTott__AudioSource(&*i);
}

SOAP_FMAC1 std::vector<tt__AudioSource *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__AudioSource(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__AudioSource *> *p;
	size_t k = sizeof(std::vector<tt__AudioSource *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__AudioSource *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__AudioSource *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__AudioSource *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const std::vector<timg__ImagingPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTotimg__ImagingPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, int id, const std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTotimg__ImagingPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<timg__ImagingPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, const char *tag, std::vector<timg__ImagingPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
			return NULL;
		a->emplace_back();
		timg__ImagingPreset * *n = &a->back();
		*n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE_timg__ImagingPreset, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, sizeof(timg__ImagingPreset), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, NULL, "timg:ImagingPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTotimg__ImagingPreset(soap, tag, n, "timg:ImagingPreset"))
			{	a->pop_back();
				break;
			}
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, std::vector<timg__ImagingPreset *>  *d, std::vector<timg__ImagingPreset *> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOfPointerTotimg__ImagingPreset(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<timg__ImagingPreset *> ::iterator j = d->begin();
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup_PointerTotimg__ImagingPreset(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOfPointerTotimg__ImagingPreset(std::vector<timg__ImagingPreset *> const*a)
{
	if (!a)
		return;
	for (std::vector<timg__ImagingPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del_PointerTotimg__ImagingPreset(&*i);
}

SOAP_FMAC1 std::vector<timg__ImagingPreset *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTotimg__ImagingPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<timg__ImagingPreset *> *p;
	size_t k = sizeof(std::vector<timg__ImagingPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<timg__ImagingPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<timg__ImagingPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<timg__ImagingPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const std::vector<_wsrfbf__BaseFaultType_Description> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		(*i).soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, const std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if ((*i).soap_out(soap, tag, id, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_wsrfbf__BaseFaultType_Description> * SOAP_FMAC4 soap_in_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, std::vector<_wsrfbf__BaseFaultType_Description> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
			return NULL;
		if (!a->empty() && a->size() == a->capacity())
		{	const void *p = &a->front();
			a->emplace_back();
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Vector capacity increased to %lu to fit %lu items: updating pointers\n", a->capacity(), a->size()));
			soap_update_pointers(soap, (const char*)&a->front(), (const char*)p, (a->size() - 1) * sizeof(_wsrfbf__BaseFaultType_Description));
		}
		else
		{	a->emplace_back();
		}
		_wsrfbf__BaseFaultType_Description *n = &a->back();
		n->soap_default(soap);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size() - 1, SOAP_TYPE__wsrfbf__BaseFaultType_Description, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, NULL, ""))
				break;
		}
		else
		{	if (!soap_in__wsrfbf__BaseFaultType_Description(soap, tag, n, ""))
			{	a->pop_back();
				break;
			}
		}
		soap_end_shaky(soap, soap_shaky);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_dup_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, std::vector<_wsrfbf__BaseFaultType_Description>  *d, std::vector<_wsrfbf__BaseFaultType_Description> const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = soap_new_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(soap)))
		return NULL; /* ERROR */
	d->resize(a->size());
	std::vector<_wsrfbf__BaseFaultType_Description> ::iterator j = d->begin();
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i, ++j)
	{	soap_dup__wsrfbf__BaseFaultType_Description(soap, &*j, &*i);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(std::vector<_wsrfbf__BaseFaultType_Description> const*a)
{
	if (!a)
		return;
	for (std::vector<_wsrfbf__BaseFaultType_Description> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_del__wsrfbf__BaseFaultType_Description(&*i);
}

SOAP_FMAC1 std::vector<_wsrfbf__BaseFaultType_Description>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<_wsrfbf__BaseFaultType_Description> *p;
	size_t k = sizeof(std::vector<_wsrfbf__BaseFaultType_Description> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<_wsrfbf__BaseFaultType_Description> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<_wsrfbf__BaseFaultType_Description> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<_wsrfbf__BaseFaultType_Description>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
