/* soapC_nnn.cpp
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC_nnn.cpp ver 2.8.127 2023-11-30 23:29:18 GMT")


void _tds__SetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_dup__tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *d, _tds__SetNetworkProtocolsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkProtocolsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkProtocolsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetNetworkProtocolsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkProtocolsResponse(_tds__SetNetworkProtocolsResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__SetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocolsResponse(soap, tag ? tag : "tds:SetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
}

void _tds__SetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__SetNetworkProtocols::NetworkProtocols);
#endif
}

int _tds__SetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__SetNetworkProtocols::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__SetNetworkProtocols::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__SetNetworkProtocols::NetworkProtocols.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_dup__tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *d, _tds__SetNetworkProtocols const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkProtocols*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkProtocols, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkProtocols(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &d->_tds__SetNetworkProtocols::NetworkProtocols, &a->_tds__SetNetworkProtocols::NetworkProtocols);
	d->_tds__SetNetworkProtocols::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkProtocols(_tds__SetNetworkProtocols const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__NetworkProtocol(&a->_tds__SetNetworkProtocols::NetworkProtocols);
}

SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkProtocols *p;
	size_t k = sizeof(_tds__SetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkProtocols(soap, tag ? tag : "tds:SetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
}

void _tds__GetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &this->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
#endif
}

int _tds__GetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkProtocols");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocolsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocolsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, "tt:NetworkProtocol"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_dup__tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *d, _tds__GetNetworkProtocolsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkProtocolsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkProtocolsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkProtocol(soap, &d->_tds__GetNetworkProtocolsResponse::NetworkProtocols, &a->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
	d->_tds__GetNetworkProtocolsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkProtocolsResponse(_tds__GetNetworkProtocolsResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__NetworkProtocol(&a->_tds__GetNetworkProtocolsResponse::NetworkProtocols);
}

SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocolsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocolsResponse *p;
	size_t k = sizeof(_tds__GetNetworkProtocolsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocolsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocolsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocolsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocolsResponse(soap, tag ? tag : "tds:GetNetworkProtocolsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkProtocols::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocols*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkProtocols)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkProtocols *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_dup__tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *d, _tds__GetNetworkProtocols const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkProtocols*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkProtocols, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkProtocols(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetNetworkProtocols::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkProtocols(_tds__GetNetworkProtocols const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkProtocols *p;
	size_t k = sizeof(_tds__GetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkProtocols);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkProtocols, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkProtocols(soap, tag ? tag : "tds:GetNetworkProtocols", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded);
}

void _tds__SetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetNetworkInterfacesResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_dup__tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *d, _tds__SetNetworkInterfacesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkInterfacesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkInterfacesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetNetworkInterfacesResponse::RebootNeeded = a->_tds__SetNetworkInterfacesResponse::RebootNeeded;
	d->_tds__SetNetworkInterfacesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkInterfacesResponse(_tds__SetNetworkInterfacesResponse const*a)
{
	if (!a)
		return;
	/* RebootNeeded skipped */
}

SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__SetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfacesResponse(soap, tag ? tag : "tds:SetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	this->_tds__SetNetworkInterfaces::NetworkInterface = NULL;
}

void _tds__SetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &this->_tds__SetNetworkInterfaces::NetworkInterface);
#endif
}

int _tds__SetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetNetworkInterfaces::InterfaceToken, ""))
		return soap->error;
	if (!a->_tds__SetNetworkInterfaces::NetworkInterface)
	{	if (soap_element_empty(soap, "tds:NetworkInterface", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->_tds__SetNetworkInterfaces::NetworkInterface, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_NetworkInterface1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->_tds__SetNetworkInterfaces::InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			}
			if (soap_flag_NetworkInterface1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &a->_tds__SetNetworkInterfaces::NetworkInterface, "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_InterfaceToken1 > 0 || !a->_tds__SetNetworkInterfaces::NetworkInterface))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_dup__tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *d, _tds__SetNetworkInterfaces const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNetworkInterfaces*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNetworkInterfaces, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNetworkInterfaces(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__ReferenceToken(soap, &d->_tds__SetNetworkInterfaces::InterfaceToken, &a->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_dup_PointerTott__NetworkInterfaceSetConfiguration(soap, &d->_tds__SetNetworkInterfaces::NetworkInterface, &a->_tds__SetNetworkInterfaces::NetworkInterface);
	d->_tds__SetNetworkInterfaces::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNetworkInterfaces(_tds__SetNetworkInterfaces const*a)
{
	if (!a)
		return;
	soap_del_tt__ReferenceToken(&a->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_del_PointerTott__NetworkInterfaceSetConfiguration(&a->_tds__SetNetworkInterfaces::NetworkInterface);
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNetworkInterfaces *p;
	size_t k = sizeof(_tds__SetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNetworkInterfaces(soap, tag ? tag : "tds:SetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
}

void _tds__GetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
#endif
}

int _tds__GetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:NetworkInterfaces");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", -1, &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfacesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfacesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, "tt:NetworkInterface"))
					continue;
			}
			soap_check_result(soap, "tds:NetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_dup__tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *d, _tds__GetNetworkInterfacesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkInterfacesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkInterfacesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkInterface(soap, &d->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, &a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
	d->_tds__GetNetworkInterfacesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkInterfacesResponse(_tds__GetNetworkInterfacesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__NetworkInterface(&a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces);
}

SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfacesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfacesResponse *p;
	size_t k = sizeof(_tds__GetNetworkInterfacesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfacesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfacesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfacesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfacesResponse(soap, tag ? tag : "tds:GetNetworkInterfacesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNetworkInterfaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNetworkInterfaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_dup__tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *d, _tds__GetNetworkInterfaces const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNetworkInterfaces*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNetworkInterfaces, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNetworkInterfaces(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetNetworkInterfaces::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNetworkInterfaces(_tds__GetNetworkInterfaces const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNetworkInterfaces *p;
	size_t k = sizeof(_tds__GetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNetworkInterfaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNetworkInterfaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNetworkInterfaces(soap, tag ? tag : "tds:GetNetworkInterfaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_dup__tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *d, _tds__SetDynamicDNSResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDynamicDNSResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDynamicDNSResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDynamicDNSResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDynamicDNSResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDynamicDNSResponse(_tds__SetDynamicDNSResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__SetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNSResponse(soap, tag ? tag : "tds:SetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->_tds__SetDynamicDNS::Type);
	this->_tds__SetDynamicDNS::Name = NULL;
	this->_tds__SetDynamicDNS::TTL = NULL;
}

void _tds__SetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSName(soap, &this->_tds__SetDynamicDNS::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->_tds__SetDynamicDNS::TTL);
#endif
}

int _tds__SetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &a->_tds__SetDynamicDNS::Type, ""))
		return soap->error;
	if (soap_out_PointerTott__DNSName(soap, "tds:Name", -1, &a->_tds__SetDynamicDNS::Name, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tds:TTL", -1, &a->_tds__SetDynamicDNS::TTL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &a->_tds__SetDynamicDNS::Type, "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__DNSName(soap, "tds:Name", &a->_tds__SetDynamicDNS::Name, "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_TTL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tds:TTL", &a->_tds__SetDynamicDNS::TTL, "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_dup__tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *d, _tds__SetDynamicDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDynamicDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDynamicDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDynamicDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDynamicDNS::Type = a->_tds__SetDynamicDNS::Type;
	soap_dup_PointerTott__DNSName(soap, &d->_tds__SetDynamicDNS::Name, &a->_tds__SetDynamicDNS::Name);
	soap_dup_PointerToxsd__duration(soap, &d->_tds__SetDynamicDNS::TTL, &a->_tds__SetDynamicDNS::TTL);
	d->_tds__SetDynamicDNS::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDynamicDNS(_tds__SetDynamicDNS const*a)
{
	if (!a)
		return;
	/* Type skipped */
	soap_del_PointerTott__DNSName(&a->_tds__SetDynamicDNS::Name);
	soap_del_PointerToxsd__duration(&a->_tds__SetDynamicDNS::TTL);
}

SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDynamicDNS *p;
	size_t k = sizeof(_tds__SetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDynamicDNS(soap, tag ? tag : "tds:SetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDynamicDNSResponse::DynamicDNSInformation = NULL;
}

void _tds__GetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &this->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
#endif
}

int _tds__GetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation)
	{	if (soap_element_empty(soap, "tds:DynamicDNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DynamicDNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetDynamicDNSResponse::DynamicDNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_dup__tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *d, _tds__GetDynamicDNSResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDynamicDNSResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDynamicDNSResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDynamicDNSResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__DynamicDNSInformation(soap, &d->_tds__GetDynamicDNSResponse::DynamicDNSInformation, &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
	d->_tds__GetDynamicDNSResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDynamicDNSResponse(_tds__GetDynamicDNSResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__DynamicDNSInformation(&a->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
}

SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNSResponse *p;
	size_t k = sizeof(_tds__GetDynamicDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNSResponse(soap, tag ? tag : "tds:GetDynamicDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDynamicDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDynamicDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDynamicDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_dup__tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *d, _tds__GetDynamicDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDynamicDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDynamicDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDynamicDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDynamicDNS::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDynamicDNS(_tds__GetDynamicDNS const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDynamicDNS *p;
	size_t k = sizeof(_tds__GetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDynamicDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDynamicDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDynamicDNS(soap, tag ? tag : "tds:GetDynamicDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__SetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, _tds__SetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_dup__tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *d, _tds__SetNTPResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNTPResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNTPResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNTPResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetNTPResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNTPResponse(_tds__SetNTPResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTPResponse *p;
	size_t k = sizeof(_tds__SetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTPResponse(soap, tag ? tag : "tds:SetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNTP::FromDHCP);
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
}

void _tds__SetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetNTP::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetNTP::NTPManual);
#endif
}

int _tds__SetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const _tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetNTP::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", -1, &a->_tds__SetNTP::NTPManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetNTP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:NTPManual", &a->_tds__SetNTP::NTPManual, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_dup__tds__SetNTP(struct soap *soap, _tds__SetNTP *d, _tds__SetNTP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetNTP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetNTP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetNTP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetNTP::FromDHCP = a->_tds__SetNTP::FromDHCP;
	soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(soap, &d->_tds__SetNTP::NTPManual, &a->_tds__SetNTP::NTPManual);
	d->_tds__SetNTP::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetNTP(_tds__SetNTP const*a)
{
	if (!a)
		return;
	/* FromDHCP skipped */
	soap_del_std__vectorTemplateOfPointerTott__NetworkHost(&a->_tds__SetNTP::NTPManual);
}

SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetNTP *p;
	size_t k = sizeof(_tds__SetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetNTP(soap, tag ? tag : "tds:SetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNTPResponse::NTPInformation = NULL;
}

void _tds__GetNTPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__NTPInformation(soap, &this->_tds__GetNTPResponse::NTPInformation);
#endif
}

int _tds__GetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__GetNTPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (!a->_tds__GetNTPResponse::NTPInformation)
	{	if (soap_element_empty(soap, "tds:NTPInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->_tds__GetNTPResponse::NTPInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, _tds__GetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NTPInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &a->_tds__GetNTPResponse::NTPInformation, "tt:NTPInformation"))
				{	soap_flag_NTPInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetNTPResponse::NTPInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_dup__tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *d, _tds__GetNTPResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNTPResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNTPResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNTPResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__NTPInformation(soap, &d->_tds__GetNTPResponse::NTPInformation, &a->_tds__GetNTPResponse::NTPInformation);
	d->_tds__GetNTPResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNTPResponse(_tds__GetNTPResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__NTPInformation(&a->_tds__GetNTPResponse::NTPInformation);
}

SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTPResponse *p;
	size_t k = sizeof(_tds__GetNTPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTPResponse(soap, tag ? tag : "tds:GetNTPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetNTP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const _tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetNTP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetNTP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_dup__tds__GetNTP(struct soap *soap, _tds__GetNTP *d, _tds__GetNTP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetNTP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetNTP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetNTP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetNTP::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetNTP(_tds__GetNTP const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetNTP *p;
	size_t k = sizeof(_tds__GetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetNTP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetNTP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetNTP(soap, tag ? tag : "tds:GetNTP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, _tds__SetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_dup__tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *d, _tds__SetDNSResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDNSResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDNSResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDNSResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDNSResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDNSResponse(_tds__SetDNSResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNSResponse *p;
	size_t k = sizeof(_tds__SetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNSResponse(soap, tag ? tag : "tds:SetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetDNS::FromDHCP);
	soap_default_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_default_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
}

void _tds__SetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetDNS::FromDHCP, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOfxsd__token(soap, &this->_tds__SetDNS::SearchDomain);
	soap_serialize_std__vectorTemplateOfPointerTott__IPAddress(soap, &this->_tds__SetDNS::DNSManual);
#endif
}

int _tds__SetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const _tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetDNS::FromDHCP, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", -1, &a->_tds__SetDNS::SearchDomain, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", -1, &a->_tds__SetDNS::DNSManual, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetDNS::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__token(soap, "tds:SearchDomain", &a->_tds__SetDNS::SearchDomain, "xsd:token"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__IPAddress(soap, "tds:DNSManual", &a->_tds__SetDNS::DNSManual, "tt:IPAddress"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_dup__tds__SetDNS(struct soap *soap, _tds__SetDNS *d, _tds__SetDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDNS::FromDHCP = a->_tds__SetDNS::FromDHCP;
	soap_dup_std__vectorTemplateOfxsd__token(soap, &d->_tds__SetDNS::SearchDomain, &a->_tds__SetDNS::SearchDomain);
	soap_dup_std__vectorTemplateOfPointerTott__IPAddress(soap, &d->_tds__SetDNS::DNSManual, &a->_tds__SetDNS::DNSManual);
	d->_tds__SetDNS::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDNS(_tds__SetDNS const*a)
{
	if (!a)
		return;
	/* FromDHCP skipped */
	soap_del_std__vectorTemplateOfxsd__token(&a->_tds__SetDNS::SearchDomain);
	soap_del_std__vectorTemplateOfPointerTott__IPAddress(&a->_tds__SetDNS::DNSManual);
}

SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDNS *p;
	size_t k = sizeof(_tds__SetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDNS(soap, tag ? tag : "tds:SetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDNSResponse::DNSInformation = NULL;
}

void _tds__GetDNSResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__DNSInformation(soap, &this->_tds__GetDNSResponse::DNSInformation);
#endif
}

int _tds__GetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDNSResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (!a->_tds__GetDNSResponse::DNSInformation)
	{	if (soap_element_empty(soap, "tds:DNSInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->_tds__GetDNSResponse::DNSInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, _tds__GetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNSResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNSResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNSResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DNSInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &a->_tds__GetDNSResponse::DNSInformation, "tt:DNSInformation"))
				{	soap_flag_DNSInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetDNSResponse::DNSInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_dup__tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *d, _tds__GetDNSResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDNSResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDNSResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDNSResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__DNSInformation(soap, &d->_tds__GetDNSResponse::DNSInformation, &a->_tds__GetDNSResponse::DNSInformation);
	d->_tds__GetDNSResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDNSResponse(_tds__GetDNSResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__DNSInformation(&a->_tds__GetDNSResponse::DNSInformation);
}

SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNSResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNSResponse *p;
	size_t k = sizeof(_tds__GetDNSResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNSResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNSResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNSResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNSResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNSResponse(soap, tag ? tag : "tds:GetDNSResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDNS::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const _tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNS*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDNS)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDNS *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_dup__tds__GetDNS(struct soap *soap, _tds__GetDNS *d, _tds__GetDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDNS::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDNS(_tds__GetDNS const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDNS *p;
	size_t k = sizeof(_tds__GetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDNS);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDNS, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDNS(soap, tag ? tag : "tds:GetDNS", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded);
}

void _tds__SetHostnameFromDHCPResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCPResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCPResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCPResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:RebootNeeded", &a->_tds__SetHostnameFromDHCPResponse::RebootNeeded, "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RebootNeeded1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_dup__tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *d, _tds__SetHostnameFromDHCPResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHostnameFromDHCPResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHostnameFromDHCPResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetHostnameFromDHCPResponse::RebootNeeded = a->_tds__SetHostnameFromDHCPResponse::RebootNeeded;
	d->_tds__SetHostnameFromDHCPResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHostnameFromDHCPResponse(_tds__SetHostnameFromDHCPResponse const*a)
{
	if (!a)
		return;
	/* RebootNeeded skipped */
}

SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCPResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCPResponse *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCPResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCPResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCPResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCPResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCPResponse(soap, tag ? tag : "tds:SetHostnameFromDHCPResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameFromDHCP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP);
}

void _tds__SetHostnameFromDHCP::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP, SOAP_TYPE_bool);
#endif
}

int _tds__SetHostnameFromDHCP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &a->_tds__SetHostnameFromDHCP::FromDHCP, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCP::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameFromDHCP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCP*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameFromDHCP)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameFromDHCP *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:FromDHCP", &a->_tds__SetHostnameFromDHCP::FromDHCP, "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FromDHCP1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_dup__tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *d, _tds__SetHostnameFromDHCP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHostnameFromDHCP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHostnameFromDHCP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHostnameFromDHCP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetHostnameFromDHCP::FromDHCP = a->_tds__SetHostnameFromDHCP::FromDHCP;
	d->_tds__SetHostnameFromDHCP::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHostnameFromDHCP(_tds__SetHostnameFromDHCP const*a)
{
	if (!a)
		return;
	/* FromDHCP skipped */
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameFromDHCP *p;
	size_t k = sizeof(_tds__SetHostnameFromDHCP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameFromDHCP);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameFromDHCP, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameFromDHCP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameFromDHCP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameFromDHCP(soap, tag ? tag : "tds:SetHostnameFromDHCP", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, _tds__SetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_dup__tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *d, _tds__SetHostnameResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHostnameResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHostnameResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHostnameResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetHostnameResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHostnameResponse(_tds__SetHostnameResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostnameResponse *p;
	size_t k = sizeof(_tds__SetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostnameResponse(soap, tag ? tag : "tds:SetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__SetHostname::Name);
}

void _tds__SetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetHostname::Name, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->_tds__SetHostname::Name);
#endif
}

int _tds__SetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const _tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:Name", -1, &a->_tds__SetHostname::Name, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Name1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__token(soap, "tds:Name", &a->_tds__SetHostname::Name, "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_dup__tds__SetHostname(struct soap *soap, _tds__SetHostname *d, _tds__SetHostname const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetHostname*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetHostname, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetHostname(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__token(soap, &d->_tds__SetHostname::Name, &a->_tds__SetHostname::Name);
	d->_tds__SetHostname::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetHostname(_tds__SetHostname const*a)
{
	if (!a)
		return;
	soap_del_xsd__token(&a->_tds__SetHostname::Name);
}

SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetHostname *p;
	size_t k = sizeof(_tds__SetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetHostname(soap, tag ? tag : "tds:SetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetHostnameResponse::HostnameInformation = NULL;
}

void _tds__GetHostnameResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__HostnameInformation(soap, &this->_tds__GetHostnameResponse::HostnameInformation);
#endif
}

int _tds__GetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__GetHostnameResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (!a->_tds__GetHostnameResponse::HostnameInformation)
	{	if (soap_element_empty(soap, "tds:HostnameInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->_tds__GetHostnameResponse::HostnameInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, _tds__GetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostnameResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostnameResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostnameResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HostnameInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &a->_tds__GetHostnameResponse::HostnameInformation, "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetHostnameResponse::HostnameInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_dup__tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *d, _tds__GetHostnameResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetHostnameResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetHostnameResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetHostnameResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__HostnameInformation(soap, &d->_tds__GetHostnameResponse::HostnameInformation, &a->_tds__GetHostnameResponse::HostnameInformation);
	d->_tds__GetHostnameResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetHostnameResponse(_tds__GetHostnameResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__HostnameInformation(&a->_tds__GetHostnameResponse::HostnameInformation);
}

SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostnameResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostnameResponse *p;
	size_t k = sizeof(_tds__GetHostnameResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostnameResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostnameResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostnameResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostnameResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostnameResponse(soap, tag ? tag : "tds:GetHostnameResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetHostname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const _tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostname*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetHostname)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetHostname *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_dup__tds__GetHostname(struct soap *soap, _tds__GetHostname *d, _tds__GetHostname const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetHostname*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetHostname, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetHostname(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetHostname::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetHostname(_tds__GetHostname const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetHostname *p;
	size_t k = sizeof(_tds__GetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetHostname);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetHostname, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetHostname(soap, tag ? tag : "tds:GetHostname", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Capabilities(soap, &this->_tds__GetCapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &a->_tds__GetCapabilitiesResponse::Capabilities, "tt:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_dup__tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *d, _tds__GetCapabilitiesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCapabilitiesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCapabilitiesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCapabilitiesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__Capabilities(soap, &d->_tds__GetCapabilitiesResponse::Capabilities, &a->_tds__GetCapabilitiesResponse::Capabilities);
	d->_tds__GetCapabilitiesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCapabilitiesResponse(_tds__GetCapabilitiesResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__Capabilities(&a->_tds__GetCapabilitiesResponse::Capabilities);
}

SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilitiesResponse(soap, tag ? tag : "tds:GetCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
}

void _tds__GetCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__CapabilityCategory(soap, &this->_tds__GetCapabilities::Category);
#endif
}

int _tds__GetCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", -1, &a->_tds__GetCapabilities::Category, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__CapabilityCategory(soap, "tds:Category", &a->_tds__GetCapabilities::Category, "tt:CapabilityCategory"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_dup__tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *d, _tds__GetCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOftt__CapabilityCategory(soap, &d->_tds__GetCapabilities::Category, &a->_tds__GetCapabilities::Category);
	d->_tds__GetCapabilities::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetCapabilities(_tds__GetCapabilities const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOftt__CapabilityCategory(&a->_tds__GetCapabilities::Category);
}

SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetCapabilities *p;
	size_t k = sizeof(_tds__GetCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetCapabilities(soap, tag ? tag : "tds:GetCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAuthFailureWarningConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetAuthFailureWarningConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetAuthFailureWarningConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAuthFailureWarningConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAuthFailureWarningConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, sizeof(_tds__SetAuthFailureWarningConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAuthFailureWarningConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, sizeof(_tds__SetAuthFailureWarningConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__SetAuthFailureWarningConfigurationResponse *d, _tds__SetAuthFailureWarningConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetAuthFailureWarningConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetAuthFailureWarningConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetAuthFailureWarningConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetAuthFailureWarningConfigurationResponse(_tds__SetAuthFailureWarningConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAuthFailureWarningConfigurationResponse *p;
	size_t k = sizeof(_tds__SetAuthFailureWarningConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAuthFailureWarningConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAuthFailureWarningConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAuthFailureWarningConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAuthFailureWarningConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAuthFailureWarningConfigurationResponse(soap, tag ? tag : "tds:SetAuthFailureWarningConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAuthFailureWarningConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAuthFailureWarningConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__SetAuthFailureWarningConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAuthFailureWarningConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetAuthFailureWarningConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetAuthFailureWarningConfiguration::Enabled);
	soap_default_int(soap, &this->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod);
	soap_default_int(soap, &this->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures);
}

void _tds__SetAuthFailureWarningConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, SOAP_TYPE_int);
	soap_embedded(soap, &this->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, SOAP_TYPE_int);
#endif
}

int _tds__SetAuthFailureWarningConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAuthFailureWarningConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetAuthFailureWarningConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MonitorPeriod", -1, &a->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MaxAuthFailures", -1, &a->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAuthFailureWarningConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetAuthFailureWarningConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in__tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAuthFailureWarningConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetAuthFailureWarningConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetAuthFailureWarningConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_MonitorPeriod1 = 1;
	size_t soap_flag_MaxAuthFailures1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetAuthFailureWarningConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_MonitorPeriod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MonitorPeriod", &a->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod, "xsd:int"))
				{	soap_flag_MonitorPeriod1--;
					continue;
				}
			}
			if (soap_flag_MaxAuthFailures1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MaxAuthFailures", &a->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures, "xsd:int"))
				{	soap_flag_MaxAuthFailures1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0 || soap_flag_MonitorPeriod1 > 0 || soap_flag_MaxAuthFailures1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetAuthFailureWarningConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, sizeof(_tds__SetAuthFailureWarningConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_dup__tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *d, _tds__SetAuthFailureWarningConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetAuthFailureWarningConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetAuthFailureWarningConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetAuthFailureWarningConfiguration::Enabled = a->_tds__SetAuthFailureWarningConfiguration::Enabled;
	d->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod = a->_tds__SetAuthFailureWarningConfiguration::MonitorPeriod;
	d->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures = a->_tds__SetAuthFailureWarningConfiguration::MaxAuthFailures;
	d->_tds__SetAuthFailureWarningConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetAuthFailureWarningConfiguration(_tds__SetAuthFailureWarningConfiguration const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
	/* MonitorPeriod skipped */
	/* MaxAuthFailures skipped */
}

SOAP_FMAC1 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(_tds__SetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetAuthFailureWarningConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetAuthFailureWarningConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetAuthFailureWarningConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:SetAuthFailureWarningConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAuthFailureWarningConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAuthFailureWarningConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get__tds__SetAuthFailureWarningConfiguration(struct soap *soap, _tds__SetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::Enabled);
	soap_default_int(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod);
	soap_default_int(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures);
}

void _tds__GetAuthFailureWarningConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, SOAP_TYPE_int);
	soap_embedded(soap, &this->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, SOAP_TYPE_int);
#endif
}

int _tds__GetAuthFailureWarningConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MonitorPeriod", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:MaxAuthFailures", -1, &a->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, sizeof(_tds__GetAuthFailureWarningConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_MonitorPeriod1 = 1;
	size_t soap_flag_MaxAuthFailures1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetAuthFailureWarningConfigurationResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_MonitorPeriod1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MonitorPeriod", &a->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod, "xsd:int"))
				{	soap_flag_MonitorPeriod1--;
					continue;
				}
			}
			if (soap_flag_MaxAuthFailures1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:MaxAuthFailures", &a->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures, "xsd:int"))
				{	soap_flag_MaxAuthFailures1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0 || soap_flag_MonitorPeriod1 > 0 || soap_flag_MaxAuthFailures1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, sizeof(_tds__GetAuthFailureWarningConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__GetAuthFailureWarningConfigurationResponse *d, _tds__GetAuthFailureWarningConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAuthFailureWarningConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAuthFailureWarningConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetAuthFailureWarningConfigurationResponse::Enabled = a->_tds__GetAuthFailureWarningConfigurationResponse::Enabled;
	d->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod = a->_tds__GetAuthFailureWarningConfigurationResponse::MonitorPeriod;
	d->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures = a->_tds__GetAuthFailureWarningConfigurationResponse::MaxAuthFailures;
	d->_tds__GetAuthFailureWarningConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAuthFailureWarningConfigurationResponse(_tds__GetAuthFailureWarningConfigurationResponse const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
	/* MonitorPeriod skipped */
	/* MaxAuthFailures skipped */
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningConfigurationResponse *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningConfigurationResponse(soap, tag ? tag : "tds:GetAuthFailureWarningConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningConfigurationResponse(struct soap *soap, _tds__GetAuthFailureWarningConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAuthFailureWarningConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAuthFailureWarningConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, sizeof(_tds__GetAuthFailureWarningConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_dup__tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *d, _tds__GetAuthFailureWarningConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAuthFailureWarningConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAuthFailureWarningConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetAuthFailureWarningConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAuthFailureWarningConfiguration(_tds__GetAuthFailureWarningConfiguration const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "tds:GetAuthFailureWarningConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningConfiguration(struct soap *soap, _tds__GetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange = NULL;
	this->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange = NULL;
}

void _tds__GetAuthFailureWarningOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange);
#endif
}

int _tds__GetAuthFailureWarningOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse), type))
		return soap->error;
	if (a->MonitorPeriodRange)
		soap_element_result(soap, "tds:MonitorPeriodRange");
	if (!a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange)
	{	if (soap_element_empty(soap, "tds:MonitorPeriodRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tds:MonitorPeriodRange", -1, &a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange, ""))
		return soap->error;
	if (!a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange)
	{	if (soap_element_empty(soap, "tds:AuthFailureRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__IntRange(soap, "tds:AuthFailureRange", -1, &a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, sizeof(_tds__GetAuthFailureWarningOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MonitorPeriodRange1 = 1;
	size_t soap_flag_AuthFailureRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MonitorPeriodRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:MonitorPeriodRange", &a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange, "tt:IntRange"))
				{	soap_flag_MonitorPeriodRange1--;
					continue;
				}
			}
			if (soap_flag_AuthFailureRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:AuthFailureRange", &a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange, "tt:IntRange"))
				{	soap_flag_AuthFailureRange1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MonitorPeriodRange");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange || !a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, sizeof(_tds__GetAuthFailureWarningOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC2 soap_dup__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, _tds__GetAuthFailureWarningOptionsResponse *d, _tds__GetAuthFailureWarningOptionsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAuthFailureWarningOptionsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAuthFailureWarningOptionsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange, &a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange, &a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange);
	d->_tds__GetAuthFailureWarningOptionsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAuthFailureWarningOptionsResponse(_tds__GetAuthFailureWarningOptionsResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IntRange(&a->_tds__GetAuthFailureWarningOptionsResponse::MonitorPeriodRange);
	soap_del_PointerTott__IntRange(&a->_tds__GetAuthFailureWarningOptionsResponse::AuthFailureRange);
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningOptionsResponse *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningOptionsResponse(soap, tag ? tag : "tds:GetAuthFailureWarningOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningOptionsResponse(struct soap *soap, _tds__GetAuthFailureWarningOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetAuthFailureWarningOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetAuthFailureWarningOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetAuthFailureWarningOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAuthFailureWarningOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, const _tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAuthFailureWarningOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetAuthFailureWarningOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_in__tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, _tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAuthFailureWarningOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetAuthFailureWarningOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetAuthFailureWarningOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAuthFailureWarningOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAuthFailureWarningOptions, SOAP_TYPE__tds__GetAuthFailureWarningOptions, sizeof(_tds__GetAuthFailureWarningOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_dup__tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *d, _tds__GetAuthFailureWarningOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetAuthFailureWarningOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetAuthFailureWarningOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetAuthFailureWarningOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetAuthFailureWarningOptions::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetAuthFailureWarningOptions(_tds__GetAuthFailureWarningOptions const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAuthFailureWarningOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetAuthFailureWarningOptions *p;
	size_t k = sizeof(_tds__GetAuthFailureWarningOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetAuthFailureWarningOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetAuthFailureWarningOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetAuthFailureWarningOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetAuthFailureWarningOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetAuthFailureWarningOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetAuthFailureWarningOptions(soap, tag ? tag : "tds:GetAuthFailureWarningOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAuthFailureWarningOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAuthFailureWarningOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_get__tds__GetAuthFailureWarningOptions(struct soap *soap, _tds__GetAuthFailureWarningOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordHistoryConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetPasswordHistoryConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetPasswordHistoryConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordHistoryConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordHistoryConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordHistoryConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordHistoryConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, sizeof(_tds__SetPasswordHistoryConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordHistoryConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordHistoryConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, sizeof(_tds__SetPasswordHistoryConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__SetPasswordHistoryConfigurationResponse *d, _tds__SetPasswordHistoryConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetPasswordHistoryConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetPasswordHistoryConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetPasswordHistoryConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetPasswordHistoryConfigurationResponse(_tds__SetPasswordHistoryConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordHistoryConfigurationResponse *p;
	size_t k = sizeof(_tds__SetPasswordHistoryConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordHistoryConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordHistoryConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordHistoryConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordHistoryConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordHistoryConfigurationResponse(soap, tag ? tag : "tds:SetPasswordHistoryConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordHistoryConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordHistoryConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__SetPasswordHistoryConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordHistoryConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordHistoryConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetPasswordHistoryConfiguration::Enabled);
	soap_default_int(soap, &this->_tds__SetPasswordHistoryConfiguration::Length);
}

void _tds__SetPasswordHistoryConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetPasswordHistoryConfiguration::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__SetPasswordHistoryConfiguration::Length, SOAP_TYPE_int);
#endif
}

int _tds__SetPasswordHistoryConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordHistoryConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__SetPasswordHistoryConfiguration::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:Length", -1, &a->_tds__SetPasswordHistoryConfiguration::Length, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordHistoryConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordHistoryConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in__tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordHistoryConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordHistoryConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordHistoryConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Length1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__SetPasswordHistoryConfiguration::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Length1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:Length", &a->_tds__SetPasswordHistoryConfiguration::Length, "xsd:int"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0 || soap_flag_Length1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetPasswordHistoryConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, sizeof(_tds__SetPasswordHistoryConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_dup__tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *d, _tds__SetPasswordHistoryConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetPasswordHistoryConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetPasswordHistoryConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetPasswordHistoryConfiguration::Enabled = a->_tds__SetPasswordHistoryConfiguration::Enabled;
	d->_tds__SetPasswordHistoryConfiguration::Length = a->_tds__SetPasswordHistoryConfiguration::Length;
	d->_tds__SetPasswordHistoryConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetPasswordHistoryConfiguration(_tds__SetPasswordHistoryConfiguration const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
	/* Length skipped */
}

SOAP_FMAC1 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordHistoryConfiguration *p;
	size_t k = sizeof(_tds__SetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordHistoryConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordHistoryConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordHistoryConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "tds:SetPasswordHistoryConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordHistoryConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordHistoryConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get__tds__SetPasswordHistoryConfiguration(struct soap *soap, _tds__SetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordHistoryConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Enabled);
	soap_default_int(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Length);
}

void _tds__GetPasswordHistoryConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Enabled, SOAP_TYPE_bool);
	soap_embedded(soap, &this->_tds__GetPasswordHistoryConfigurationResponse::Length, SOAP_TYPE_int);
#endif
}

int _tds__GetPasswordHistoryConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordHistoryConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &a->_tds__GetPasswordHistoryConfigurationResponse::Enabled, ""))
		return soap->error;
	if (soap_out_int(soap, "tds:Length", -1, &a->_tds__GetPasswordHistoryConfigurationResponse::Length, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordHistoryConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordHistoryConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordHistoryConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, sizeof(_tds__GetPasswordHistoryConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordHistoryConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Enabled1 = 1;
	size_t soap_flag_Length1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:Enabled", &a->_tds__GetPasswordHistoryConfigurationResponse::Enabled, "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			}
			if (soap_flag_Length1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tds:Length", &a->_tds__GetPasswordHistoryConfigurationResponse::Length, "xsd:int"))
				{	soap_flag_Length1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Enabled1 > 0 || soap_flag_Length1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetPasswordHistoryConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, sizeof(_tds__GetPasswordHistoryConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__GetPasswordHistoryConfigurationResponse *d, _tds__GetPasswordHistoryConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordHistoryConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordHistoryConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetPasswordHistoryConfigurationResponse::Enabled = a->_tds__GetPasswordHistoryConfigurationResponse::Enabled;
	d->_tds__GetPasswordHistoryConfigurationResponse::Length = a->_tds__GetPasswordHistoryConfigurationResponse::Length;
	d->_tds__GetPasswordHistoryConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordHistoryConfigurationResponse(_tds__GetPasswordHistoryConfigurationResponse const*a)
{
	if (!a)
		return;
	/* Enabled skipped */
	/* Length skipped */
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordHistoryConfigurationResponse *p;
	size_t k = sizeof(_tds__GetPasswordHistoryConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordHistoryConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordHistoryConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordHistoryConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordHistoryConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordHistoryConfigurationResponse(soap, tag ? tag : "tds:GetPasswordHistoryConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordHistoryConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordHistoryConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetPasswordHistoryConfigurationResponse(struct soap *soap, _tds__GetPasswordHistoryConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordHistoryConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordHistoryConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordHistoryConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordHistoryConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordHistoryConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordHistoryConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordHistoryConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in__tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordHistoryConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordHistoryConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordHistoryConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordHistoryConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, sizeof(_tds__GetPasswordHistoryConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_dup__tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *d, _tds__GetPasswordHistoryConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordHistoryConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordHistoryConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetPasswordHistoryConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordHistoryConfiguration(_tds__GetPasswordHistoryConfiguration const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordHistoryConfiguration *p;
	size_t k = sizeof(_tds__GetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordHistoryConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordHistoryConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordHistoryConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "tds:GetPasswordHistoryConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordHistoryConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordHistoryConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get__tds__GetPasswordHistoryConfiguration(struct soap *soap, _tds__GetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordComplexityConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetPasswordComplexityConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetPasswordComplexityConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordComplexityConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordComplexityConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordComplexityConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordComplexityConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, sizeof(_tds__SetPasswordComplexityConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordComplexityConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordComplexityConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, sizeof(_tds__SetPasswordComplexityConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_dup__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__SetPasswordComplexityConfigurationResponse *d, _tds__SetPasswordComplexityConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetPasswordComplexityConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetPasswordComplexityConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetPasswordComplexityConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetPasswordComplexityConfigurationResponse(_tds__SetPasswordComplexityConfigurationResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordComplexityConfigurationResponse *p;
	size_t k = sizeof(_tds__SetPasswordComplexityConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordComplexityConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordComplexityConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordComplexityConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordComplexityConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordComplexityConfigurationResponse(soap, tag ? tag : "tds:SetPasswordComplexityConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordComplexityConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordComplexityConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__SetPasswordComplexityConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordComplexityConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetPasswordComplexityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetPasswordComplexityConfiguration::MinLen = NULL;
	this->_tds__SetPasswordComplexityConfiguration::Uppercase = NULL;
	this->_tds__SetPasswordComplexityConfiguration::Number = NULL;
	this->_tds__SetPasswordComplexityConfiguration::SpecialChars = NULL;
	this->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence = NULL;
	this->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked = NULL;
}

void _tds__SetPasswordComplexityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::MinLen);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::Uppercase);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::Number);
	soap_serialize_PointerToint(soap, &this->_tds__SetPasswordComplexityConfiguration::SpecialChars);
	soap_serialize_PointerTobool(soap, &this->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence);
	soap_serialize_PointerTobool(soap, &this->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked);
#endif
}

int _tds__SetPasswordComplexityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetPasswordComplexityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:MinLen", -1, &a->_tds__SetPasswordComplexityConfiguration::MinLen, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Uppercase", -1, &a->_tds__SetPasswordComplexityConfiguration::Uppercase, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Number", -1, &a->_tds__SetPasswordComplexityConfiguration::Number, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:SpecialChars", -1, &a->_tds__SetPasswordComplexityConfiguration::SpecialChars, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrence", -1, &a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLocked", -1, &a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetPasswordComplexityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetPasswordComplexityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in__tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetPasswordComplexityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetPasswordComplexityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetPasswordComplexityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLen1 = 1;
	size_t soap_flag_Uppercase1 = 1;
	size_t soap_flag_Number1 = 1;
	size_t soap_flag_SpecialChars1 = 1;
	size_t soap_flag_BlockUsernameOccurrence1 = 1;
	size_t soap_flag_PolicyConfigurationLocked1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:MinLen", &a->_tds__SetPasswordComplexityConfiguration::MinLen, "xsd:int"))
				{	soap_flag_MinLen1--;
					continue;
				}
			}
			if (soap_flag_Uppercase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Uppercase", &a->_tds__SetPasswordComplexityConfiguration::Uppercase, "xsd:int"))
				{	soap_flag_Uppercase1--;
					continue;
				}
			}
			if (soap_flag_Number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Number", &a->_tds__SetPasswordComplexityConfiguration::Number, "xsd:int"))
				{	soap_flag_Number1--;
					continue;
				}
			}
			if (soap_flag_SpecialChars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:SpecialChars", &a->_tds__SetPasswordComplexityConfiguration::SpecialChars, "xsd:int"))
				{	soap_flag_SpecialChars1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrence", &a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrence1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLocked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLocked", &a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLocked1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetPasswordComplexityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, sizeof(_tds__SetPasswordComplexityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_dup__tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *d, _tds__SetPasswordComplexityConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetPasswordComplexityConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetPasswordComplexityConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerToint(soap, &d->_tds__SetPasswordComplexityConfiguration::MinLen, &a->_tds__SetPasswordComplexityConfiguration::MinLen);
	soap_dup_PointerToint(soap, &d->_tds__SetPasswordComplexityConfiguration::Uppercase, &a->_tds__SetPasswordComplexityConfiguration::Uppercase);
	soap_dup_PointerToint(soap, &d->_tds__SetPasswordComplexityConfiguration::Number, &a->_tds__SetPasswordComplexityConfiguration::Number);
	soap_dup_PointerToint(soap, &d->_tds__SetPasswordComplexityConfiguration::SpecialChars, &a->_tds__SetPasswordComplexityConfiguration::SpecialChars);
	soap_dup_PointerTobool(soap, &d->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence, &a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence);
	soap_dup_PointerTobool(soap, &d->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked, &a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked);
	d->_tds__SetPasswordComplexityConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetPasswordComplexityConfiguration(_tds__SetPasswordComplexityConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerToint(&a->_tds__SetPasswordComplexityConfiguration::MinLen);
	soap_del_PointerToint(&a->_tds__SetPasswordComplexityConfiguration::Uppercase);
	soap_del_PointerToint(&a->_tds__SetPasswordComplexityConfiguration::Number);
	soap_del_PointerToint(&a->_tds__SetPasswordComplexityConfiguration::SpecialChars);
	soap_del_PointerTobool(&a->_tds__SetPasswordComplexityConfiguration::BlockUsernameOccurrence);
	soap_del_PointerTobool(&a->_tds__SetPasswordComplexityConfiguration::PolicyConfigurationLocked);
}

SOAP_FMAC1 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetPasswordComplexityConfiguration *p;
	size_t k = sizeof(_tds__SetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetPasswordComplexityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetPasswordComplexityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetPasswordComplexityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "tds:SetPasswordComplexityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetPasswordComplexityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetPasswordComplexityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get__tds__SetPasswordComplexityConfiguration(struct soap *soap, _tds__SetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPasswordComplexityConfigurationResponse::MinLen = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::Uppercase = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::Number = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence = NULL;
	this->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked = NULL;
}

void _tds__GetPasswordComplexityConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::MinLen);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::Uppercase);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::Number);
	soap_serialize_PointerToint(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked);
#endif
}

int _tds__GetPasswordComplexityConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse), type))
		return soap->error;
	if (a->MinLen)
		soap_element_result(soap, "tds:MinLen");
	if (soap_out_PointerToint(soap, "tds:MinLen", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::MinLen, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Uppercase", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:Number", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::Number, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tds:SpecialChars", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrence", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLocked", -1, &a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, sizeof(_tds__GetPasswordComplexityConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLen1 = 1;
	size_t soap_flag_Uppercase1 = 1;
	size_t soap_flag_Number1 = 1;
	size_t soap_flag_SpecialChars1 = 1;
	size_t soap_flag_BlockUsernameOccurrence1 = 1;
	size_t soap_flag_PolicyConfigurationLocked1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLen1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:MinLen", &a->_tds__GetPasswordComplexityConfigurationResponse::MinLen, "xsd:int"))
				{	soap_flag_MinLen1--;
					continue;
				}
			}
			if (soap_flag_Uppercase1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Uppercase", &a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase, "xsd:int"))
				{	soap_flag_Uppercase1--;
					continue;
				}
			}
			if (soap_flag_Number1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:Number", &a->_tds__GetPasswordComplexityConfigurationResponse::Number, "xsd:int"))
				{	soap_flag_Number1--;
					continue;
				}
			}
			if (soap_flag_SpecialChars1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tds:SpecialChars", &a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars, "xsd:int"))
				{	soap_flag_SpecialChars1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrence", &a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrence1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLocked1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLocked", &a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLocked1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MinLen");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, sizeof(_tds__GetPasswordComplexityConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_dup__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__GetPasswordComplexityConfigurationResponse *d, _tds__GetPasswordComplexityConfigurationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordComplexityConfigurationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordComplexityConfigurationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerToint(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::MinLen, &a->_tds__GetPasswordComplexityConfigurationResponse::MinLen);
	soap_dup_PointerToint(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::Uppercase, &a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase);
	soap_dup_PointerToint(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::Number, &a->_tds__GetPasswordComplexityConfigurationResponse::Number);
	soap_dup_PointerToint(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars, &a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars);
	soap_dup_PointerTobool(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence, &a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence);
	soap_dup_PointerTobool(soap, &d->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked, &a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked);
	d->_tds__GetPasswordComplexityConfigurationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordComplexityConfigurationResponse(_tds__GetPasswordComplexityConfigurationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerToint(&a->_tds__GetPasswordComplexityConfigurationResponse::MinLen);
	soap_del_PointerToint(&a->_tds__GetPasswordComplexityConfigurationResponse::Uppercase);
	soap_del_PointerToint(&a->_tds__GetPasswordComplexityConfigurationResponse::Number);
	soap_del_PointerToint(&a->_tds__GetPasswordComplexityConfigurationResponse::SpecialChars);
	soap_del_PointerTobool(&a->_tds__GetPasswordComplexityConfigurationResponse::BlockUsernameOccurrence);
	soap_del_PointerTobool(&a->_tds__GetPasswordComplexityConfigurationResponse::PolicyConfigurationLocked);
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityConfigurationResponse *p;
	size_t k = sizeof(_tds__GetPasswordComplexityConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityConfigurationResponse(soap, tag ? tag : "tds:GetPasswordComplexityConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityConfigurationResponse(struct soap *soap, _tds__GetPasswordComplexityConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordComplexityConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordComplexityConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, _tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, sizeof(_tds__GetPasswordComplexityConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_dup__tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *d, _tds__GetPasswordComplexityConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordComplexityConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordComplexityConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetPasswordComplexityConfiguration::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordComplexityConfiguration(_tds__GetPasswordComplexityConfiguration const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityConfiguration *p;
	size_t k = sizeof(_tds__GetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "tds:GetPasswordComplexityConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityConfiguration(struct soap *soap, _tds__GetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPasswordComplexityOptionsResponse::MinLenRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::NumberRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported = NULL;
	this->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported = NULL;
}

void _tds__GetPasswordComplexityOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::MinLenRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::NumberRange);
	soap_serialize_PointerTott__IntRange(soap, &this->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported);
	soap_serialize_PointerTobool(soap, &this->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported);
#endif
}

int _tds__GetPasswordComplexityOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse), type))
		return soap->error;
	if (a->MinLenRange)
		soap_element_result(soap, "tds:MinLenRange");
	if (soap_out_PointerTott__IntRange(soap, "tds:MinLenRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:UppercaseRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:NumberRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::NumberRange, ""))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tds:SpecialCharsRange", -1, &a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:BlockUsernameOccurrenceSupported", -1, &a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tds:PolicyConfigurationLockSupported", -1, &a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, sizeof(_tds__GetPasswordComplexityOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MinLenRange1 = 1;
	size_t soap_flag_UppercaseRange1 = 1;
	size_t soap_flag_NumberRange1 = 1;
	size_t soap_flag_SpecialCharsRange1 = 1;
	size_t soap_flag_BlockUsernameOccurrenceSupported1 = 1;
	size_t soap_flag_PolicyConfigurationLockSupported1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MinLenRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:MinLenRange", &a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange, "tt:IntRange"))
				{	soap_flag_MinLenRange1--;
					continue;
				}
			}
			if (soap_flag_UppercaseRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:UppercaseRange", &a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange, "tt:IntRange"))
				{	soap_flag_UppercaseRange1--;
					continue;
				}
			}
			if (soap_flag_NumberRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:NumberRange", &a->_tds__GetPasswordComplexityOptionsResponse::NumberRange, "tt:IntRange"))
				{	soap_flag_NumberRange1--;
					continue;
				}
			}
			if (soap_flag_SpecialCharsRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tds:SpecialCharsRange", &a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange, "tt:IntRange"))
				{	soap_flag_SpecialCharsRange1--;
					continue;
				}
			}
			if (soap_flag_BlockUsernameOccurrenceSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:BlockUsernameOccurrenceSupported", &a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported, "xsd:boolean"))
				{	soap_flag_BlockUsernameOccurrenceSupported1--;
					continue;
				}
			}
			if (soap_flag_PolicyConfigurationLockSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tds:PolicyConfigurationLockSupported", &a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported, "xsd:boolean"))
				{	soap_flag_PolicyConfigurationLockSupported1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:MinLenRange");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, sizeof(_tds__GetPasswordComplexityOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC2 soap_dup__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, _tds__GetPasswordComplexityOptionsResponse *d, _tds__GetPasswordComplexityOptionsResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordComplexityOptionsResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordComplexityOptionsResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetPasswordComplexityOptionsResponse::MinLenRange, &a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange, &a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetPasswordComplexityOptionsResponse::NumberRange, &a->_tds__GetPasswordComplexityOptionsResponse::NumberRange);
	soap_dup_PointerTott__IntRange(soap, &d->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange, &a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange);
	soap_dup_PointerTobool(soap, &d->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported, &a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported);
	soap_dup_PointerTobool(soap, &d->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported, &a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported);
	d->_tds__GetPasswordComplexityOptionsResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordComplexityOptionsResponse(_tds__GetPasswordComplexityOptionsResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__IntRange(&a->_tds__GetPasswordComplexityOptionsResponse::MinLenRange);
	soap_del_PointerTott__IntRange(&a->_tds__GetPasswordComplexityOptionsResponse::UppercaseRange);
	soap_del_PointerTott__IntRange(&a->_tds__GetPasswordComplexityOptionsResponse::NumberRange);
	soap_del_PointerTott__IntRange(&a->_tds__GetPasswordComplexityOptionsResponse::SpecialCharsRange);
	soap_del_PointerTobool(&a->_tds__GetPasswordComplexityOptionsResponse::BlockUsernameOccurrenceSupported);
	soap_del_PointerTobool(&a->_tds__GetPasswordComplexityOptionsResponse::PolicyConfigurationLockSupported);
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityOptionsResponse *p;
	size_t k = sizeof(_tds__GetPasswordComplexityOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityOptionsResponse(soap, tag ? tag : "tds:GetPasswordComplexityOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityOptionsResponse(struct soap *soap, _tds__GetPasswordComplexityOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetPasswordComplexityOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetPasswordComplexityOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetPasswordComplexityOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPasswordComplexityOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, const _tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPasswordComplexityOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPasswordComplexityOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetPasswordComplexityOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_in__tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, _tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPasswordComplexityOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetPasswordComplexityOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetPasswordComplexityOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPasswordComplexityOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPasswordComplexityOptions, SOAP_TYPE__tds__GetPasswordComplexityOptions, sizeof(_tds__GetPasswordComplexityOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_dup__tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *d, _tds__GetPasswordComplexityOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetPasswordComplexityOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetPasswordComplexityOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetPasswordComplexityOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetPasswordComplexityOptions::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetPasswordComplexityOptions(_tds__GetPasswordComplexityOptions const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPasswordComplexityOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetPasswordComplexityOptions *p;
	size_t k = sizeof(_tds__GetPasswordComplexityOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetPasswordComplexityOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetPasswordComplexityOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetPasswordComplexityOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetPasswordComplexityOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetPasswordComplexityOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetPasswordComplexityOptions(soap, tag ? tag : "tds:GetPasswordComplexityOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPasswordComplexityOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPasswordComplexityOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_get__tds__GetPasswordComplexityOptions(struct soap *soap, _tds__GetPasswordComplexityOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetWsdlUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
}

void _tds__GetWsdlUrlResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
#endif
}

int _tds__GetWsdlUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:WsdlUrl");
	if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, &a->_tds__GetWsdlUrlResponse::WsdlUrl, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetWsdlUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrlResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetWsdlUrlResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetWsdlUrlResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_WsdlUrl1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", &a->_tds__GetWsdlUrlResponse::WsdlUrl, "xsd:anyURI"))
				{	soap_flag_WsdlUrl1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_WsdlUrl1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_dup__tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *d, _tds__GetWsdlUrlResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetWsdlUrlResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetWsdlUrlResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetWsdlUrlResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyURI(soap, &d->_tds__GetWsdlUrlResponse::WsdlUrl, &a->_tds__GetWsdlUrlResponse::WsdlUrl);
	d->_tds__GetWsdlUrlResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetWsdlUrlResponse(_tds__GetWsdlUrlResponse const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyURI(&a->_tds__GetWsdlUrlResponse::WsdlUrl);
}

SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrlResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetWsdlUrlResponse *p;
	size_t k = sizeof(_tds__GetWsdlUrlResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetWsdlUrlResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetWsdlUrlResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetWsdlUrlResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetWsdlUrlResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetWsdlUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetWsdlUrlResponse(soap, tag ? tag : "tds:GetWsdlUrlResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetWsdlUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetWsdlUrl::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetWsdlUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetWsdlUrl(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrl*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetWsdlUrl)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetWsdlUrl *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_dup__tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *d, _tds__GetWsdlUrl const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetWsdlUrl*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetWsdlUrl, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetWsdlUrl(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetWsdlUrl::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetWsdlUrl(_tds__GetWsdlUrl const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetWsdlUrl *p;
	size_t k = sizeof(_tds__GetWsdlUrl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetWsdlUrl);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetWsdlUrl, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetWsdlUrl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetWsdlUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetWsdlUrl(soap, tag ? tag : "tds:GetWsdlUrl", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrl(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const _tds__SetUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, _tds__SetUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_dup__tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *d, _tds__SetUserResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetUserResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetUserResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetUserResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetUserResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetUserResponse(_tds__SetUserResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetUserResponse *p;
	size_t k = sizeof(_tds__SetUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetUserResponse(soap, tag ? tag : "tds:SetUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__SetUser::User);
}

void _tds__SetUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__SetUser::User);
#endif
}

int _tds__SetUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const _tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__SetUser::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__SetUser::User, "tt:User"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__SetUser::User.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_dup__tds__SetUser(struct soap *soap, _tds__SetUser *d, _tds__SetUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__User(soap, &d->_tds__SetUser::User, &a->_tds__SetUser::User);
	d->_tds__SetUser::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetUser(_tds__SetUser const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__User(&a->_tds__SetUser::User);
}

SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetUser *p;
	size_t k = sizeof(_tds__SetUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetUser(soap, tag ? tag : "tds:SetUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__DeleteUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__DeleteUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, _tds__DeleteUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_dup__tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *d, _tds__DeleteUsersResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteUsersResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteUsersResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteUsersResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__DeleteUsersResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteUsersResponse(_tds__DeleteUsersResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteUsersResponse *p;
	size_t k = sizeof(_tds__DeleteUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteUsersResponse(soap, tag ? tag : "tds:DeleteUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__DeleteUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->_tds__DeleteUsers::Username);
}

void _tds__DeleteUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->_tds__DeleteUsers::Username);
#endif
}

int _tds__DeleteUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const _tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "tds:Username", -1, &a->_tds__DeleteUsers::Username, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__DeleteUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__DeleteUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__DeleteUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfstd__string(soap, "tds:Username", &a->_tds__DeleteUsers::Username, "xsd:string"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__DeleteUsers::Username.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_dup__tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *d, _tds__DeleteUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__DeleteUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__DeleteUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__DeleteUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfstd__string(soap, &d->_tds__DeleteUsers::Username, &a->_tds__DeleteUsers::Username);
	d->_tds__DeleteUsers::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__DeleteUsers(_tds__DeleteUsers const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfstd__string(&a->_tds__DeleteUsers::Username);
}

SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__DeleteUsers *p;
	size_t k = sizeof(_tds__DeleteUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__DeleteUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__DeleteUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__DeleteUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__DeleteUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__DeleteUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__DeleteUsers(soap, tag ? tag : "tds:DeleteUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__CreateUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__CreateUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const _tds__CreateUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, _tds__CreateUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_dup__tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *d, _tds__CreateUsersResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateUsersResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateUsersResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateUsersResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__CreateUsersResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateUsersResponse(_tds__CreateUsersResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateUsersResponse *p;
	size_t k = sizeof(_tds__CreateUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateUsersResponse(soap, tag ? tag : "tds:CreateUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__CreateUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__CreateUsers::User);
}

void _tds__CreateUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__CreateUsers::User);
#endif
}

int _tds__CreateUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const _tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__CreateUsers::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__CreateUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateUsers * SOAP_FMAC4 soap_in__tds__CreateUsers(struct soap *soap, const char *tag, _tds__CreateUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__CreateUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__CreateUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__CreateUsers::User, "tt:User"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__CreateUsers::User.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__CreateUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsers, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_dup__tds__CreateUsers(struct soap *soap, _tds__CreateUsers *d, _tds__CreateUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__CreateUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__CreateUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__CreateUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__User(soap, &d->_tds__CreateUsers::User, &a->_tds__CreateUsers::User);
	d->_tds__CreateUsers::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__CreateUsers(_tds__CreateUsers const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__User(&a->_tds__CreateUsers::User);
}

SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__CreateUsers *p;
	size_t k = sizeof(_tds__CreateUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__CreateUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__CreateUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__CreateUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__CreateUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__CreateUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__CreateUsers(soap, tag ? tag : "tds:CreateUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateUsers * SOAP_FMAC4 soap_get__tds__CreateUsers(struct soap *soap, _tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__GetUsersResponse::User);
}

void _tds__GetUsersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__User(soap, &this->_tds__GetUsersResponse::User);
#endif
}

int _tds__GetUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsersResponse(struct soap *soap, const char *tag, int id, const _tds__GetUsersResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsersResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:User");
	if (soap_out_std__vectorTemplateOfPointerTott__User(soap, "tds:User", -1, &a->_tds__GetUsersResponse::User, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetUsersResponse * SOAP_FMAC4 soap_in__tds__GetUsersResponse(struct soap *soap, const char *tag, _tds__GetUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetUsersResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsersResponse, sizeof(_tds__GetUsersResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetUsersResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetUsersResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__User(soap, "tds:User", &a->_tds__GetUsersResponse::User, "tt:User"))
					continue;
			}
			soap_check_result(soap, "tds:User");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsersResponse, SOAP_TYPE__tds__GetUsersResponse, sizeof(_tds__GetUsersResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_dup__tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse *d, _tds__GetUsersResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetUsersResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetUsersResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetUsersResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__User(soap, &d->_tds__GetUsersResponse::User, &a->_tds__GetUsersResponse::User);
	d->_tds__GetUsersResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetUsersResponse(_tds__GetUsersResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__User(&a->_tds__GetUsersResponse::User);
}

SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetUsersResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetUsersResponse *p;
	size_t k = sizeof(_tds__GetUsersResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetUsersResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetUsersResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetUsersResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetUsersResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetUsersResponse(soap, tag ? tag : "tds:GetUsersResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetUsersResponse * SOAP_FMAC4 soap_get__tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetUsers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetUsers(struct soap *soap, const char *tag, int id, const _tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetUsers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetUsers * SOAP_FMAC4 soap_in__tds__GetUsers(struct soap *soap, const char *tag, _tds__GetUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetUsers*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetUsers)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetUsers *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetUsers, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_dup__tds__GetUsers(struct soap *soap, _tds__GetUsers *d, _tds__GetUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetUsers::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetUsers(_tds__GetUsers const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetUsers *p;
	size_t k = sizeof(_tds__GetUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetUsers);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetUsers, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetUsers(soap, tag ? tag : "tds:GetUsers", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetUsers * SOAP_FMAC4 soap_get__tds__GetUsers(struct soap *soap, _tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRemoteUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, const _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUserResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__SetRemoteUserResponse(struct soap *soap, const char *tag, _tds__SetRemoteUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(_tds__SetRemoteUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUserResponse, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(_tds__SetRemoteUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_dup__tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse *d, _tds__SetRemoteUserResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRemoteUserResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRemoteUserResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRemoteUserResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetRemoteUserResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRemoteUserResponse(_tds__SetRemoteUserResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteUserResponse *p;
	size_t k = sizeof(_tds__SetRemoteUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteUserResponse(soap, tag ? tag : "tds:SetRemoteUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetRemoteUser::RemoteUser = NULL;
}

void _tds__SetRemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &this->_tds__SetRemoteUser::RemoteUser);
#endif
}

int _tds__SetRemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const _tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteUser), type))
		return soap->error;
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->_tds__SetRemoteUser::RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteUser * SOAP_FMAC4 soap_in__tds__SetRemoteUser(struct soap *soap, const char *tag, _tds__SetRemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->_tds__SetRemoteUser::RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteUser, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_dup__tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *d, _tds__SetRemoteUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRemoteUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRemoteUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRemoteUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__RemoteUser(soap, &d->_tds__SetRemoteUser::RemoteUser, &a->_tds__SetRemoteUser::RemoteUser);
	d->_tds__SetRemoteUser::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRemoteUser(_tds__SetRemoteUser const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__RemoteUser(&a->_tds__SetRemoteUser::RemoteUser);
}

SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteUser *p;
	size_t k = sizeof(_tds__SetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteUser(soap, tag ? tag : "tds:SetRemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteUser * SOAP_FMAC4 soap_get__tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetRemoteUserResponse::RemoteUser = NULL;
}

void _tds__GetRemoteUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__RemoteUser(soap, &this->_tds__GetRemoteUserResponse::RemoteUser);
#endif
}

int _tds__GetRemoteUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, const _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUserResponse), type))
		return soap->error;
	if (a->RemoteUser)
		soap_element_result(soap, "tds:RemoteUser");
	if (soap_out_PointerTott__RemoteUser(soap, "tds:RemoteUser", -1, &a->_tds__GetRemoteUserResponse::RemoteUser, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_in__tds__GetRemoteUserResponse(struct soap *soap, const char *tag, _tds__GetRemoteUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteUserResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(_tds__GetRemoteUserResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteUserResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteUserResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteUser1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteUser1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__RemoteUser(soap, "tds:RemoteUser", &a->_tds__GetRemoteUserResponse::RemoteUser, "tt:RemoteUser"))
				{	soap_flag_RemoteUser1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteUser");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUserResponse, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(_tds__GetRemoteUserResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_dup__tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse *d, _tds__GetRemoteUserResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRemoteUserResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRemoteUserResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRemoteUserResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__RemoteUser(soap, &d->_tds__GetRemoteUserResponse::RemoteUser, &a->_tds__GetRemoteUserResponse::RemoteUser);
	d->_tds__GetRemoteUserResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRemoteUserResponse(_tds__GetRemoteUserResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__RemoteUser(&a->_tds__GetRemoteUserResponse::RemoteUser);
}

SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteUserResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteUserResponse *p;
	size_t k = sizeof(_tds__GetRemoteUserResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteUserResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteUserResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteUserResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteUserResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteUserResponse(soap, tag ? tag : "tds:GetRemoteUserResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse * SOAP_FMAC4 soap_get__tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteUser::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRemoteUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const _tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteUser), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteUser::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteUser * SOAP_FMAC4 soap_in__tds__GetRemoteUser(struct soap *soap, const char *tag, _tds__GetRemoteUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteUser*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteUser)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteUser *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteUser, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_dup__tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *d, _tds__GetRemoteUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRemoteUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRemoteUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRemoteUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetRemoteUser::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRemoteUser(_tds__GetRemoteUser const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteUser *p;
	size_t k = sizeof(_tds__GetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteUser);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteUser, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteUser(soap, tag ? tag : "tds:GetRemoteUser", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteUser * SOAP_FMAC4 soap_get__tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetEndpointReferenceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__GetEndpointReferenceResponse::GUID);
}

void _tds__GetEndpointReferenceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetEndpointReferenceResponse::GUID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetEndpointReferenceResponse::GUID);
#endif
}

int _tds__GetEndpointReferenceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetEndpointReferenceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, const _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:GUID");
	if (soap_out_std__string(soap, "tds:GUID", -1, &a->_tds__GetEndpointReferenceResponse::GUID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetEndpointReferenceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetEndpointReferenceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_in__tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, _tds__GetEndpointReferenceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetEndpointReferenceResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(_tds__GetEndpointReferenceResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetEndpointReferenceResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetEndpointReferenceResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GUID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:GUID", &a->_tds__GetEndpointReferenceResponse::GUID, "xsd:string"))
				{	soap_flag_GUID1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:GUID");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_GUID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetEndpointReferenceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReferenceResponse, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(_tds__GetEndpointReferenceResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_dup__tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse *d, _tds__GetEndpointReferenceResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetEndpointReferenceResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetEndpointReferenceResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetEndpointReferenceResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__string(soap, &d->_tds__GetEndpointReferenceResponse::GUID, &a->_tds__GetEndpointReferenceResponse::GUID);
	d->_tds__GetEndpointReferenceResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetEndpointReferenceResponse(_tds__GetEndpointReferenceResponse const*a)
{
	if (!a)
		return;
	soap_del_std__string(&a->_tds__GetEndpointReferenceResponse::GUID);
}

SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetEndpointReferenceResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetEndpointReferenceResponse *p;
	size_t k = sizeof(_tds__GetEndpointReferenceResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetEndpointReferenceResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetEndpointReferenceResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetEndpointReferenceResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetEndpointReferenceResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetEndpointReferenceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetEndpointReferenceResponse(soap, tag ? tag : "tds:GetEndpointReferenceResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetEndpointReferenceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetEndpointReferenceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse * SOAP_FMAC4 soap_get__tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetEndpointReference::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetEndpointReference::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetEndpointReference::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetEndpointReference(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const _tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetEndpointReference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetEndpointReference::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetEndpointReference(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetEndpointReference * SOAP_FMAC4 soap_in__tds__GetEndpointReference(struct soap *soap, const char *tag, _tds__GetEndpointReference *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetEndpointReference*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetEndpointReference)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetEndpointReference *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetEndpointReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetEndpointReference, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_dup__tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *d, _tds__GetEndpointReference const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetEndpointReference*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetEndpointReference, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetEndpointReference(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetEndpointReference::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetEndpointReference(_tds__GetEndpointReference const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetEndpointReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetEndpointReference *p;
	size_t k = sizeof(_tds__GetEndpointReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetEndpointReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetEndpointReference);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetEndpointReference, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetEndpointReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetEndpointReference::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetEndpointReference(soap, tag ? tag : "tds:GetEndpointReference", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetEndpointReference::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetEndpointReference(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetEndpointReference * SOAP_FMAC4 soap_get__tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDPAddressesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDPAddressesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDPAddressesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDPAddressesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, const _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddressesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDPAddressesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDPAddressesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__SetDPAddressesResponse(struct soap *soap, const char *tag, _tds__SetDPAddressesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(_tds__SetDPAddressesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDPAddressesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDPAddressesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddressesResponse, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(_tds__SetDPAddressesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_dup__tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse *d, _tds__SetDPAddressesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDPAddressesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDPAddressesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDPAddressesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDPAddressesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDPAddressesResponse(_tds__SetDPAddressesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDPAddressesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDPAddressesResponse *p;
	size_t k = sizeof(_tds__SetDPAddressesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDPAddressesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDPAddressesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDPAddressesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDPAddressesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDPAddressesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDPAddressesResponse(soap, tag ? tag : "tds:SetDPAddressesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDPAddressesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDPAddressesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDPAddresses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetDPAddresses::DPAddress);
}

void _tds__SetDPAddresses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__SetDPAddresses::DPAddress);
#endif
}

int _tds__SetDPAddresses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDPAddresses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const _tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDPAddresses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", -1, &a->_tds__SetDPAddresses::DPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDPAddresses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDPAddresses(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDPAddresses * SOAP_FMAC4 soap_in__tds__SetDPAddresses(struct soap *soap, const char *tag, _tds__SetDPAddresses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDPAddresses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDPAddresses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", &a->_tds__SetDPAddresses::DPAddress, "tt:NetworkHost"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDPAddresses, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_dup__tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *d, _tds__SetDPAddresses const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDPAddresses*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDPAddresses, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDPAddresses(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(soap, &d->_tds__SetDPAddresses::DPAddress, &a->_tds__SetDPAddresses::DPAddress);
	d->_tds__SetDPAddresses::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDPAddresses(_tds__SetDPAddresses const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__NetworkHost(&a->_tds__SetDPAddresses::DPAddress);
}

SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDPAddresses *p;
	size_t k = sizeof(_tds__SetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDPAddresses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDPAddresses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDPAddresses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDPAddresses(soap, tag ? tag : "tds:SetDPAddresses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDPAddresses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDPAddresses(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDPAddresses * SOAP_FMAC4 soap_get__tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDPAddressesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__GetDPAddressesResponse::DPAddress);
}

void _tds__GetDPAddressesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__NetworkHost(soap, &this->_tds__GetDPAddressesResponse::DPAddress);
#endif
}

int _tds__GetDPAddressesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDPAddressesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddressesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DPAddress");
	if (soap_out_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", -1, &a->_tds__GetDPAddressesResponse::DPAddress, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDPAddressesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDPAddressesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_in__tds__GetDPAddressesResponse(struct soap *soap, const char *tag, _tds__GetDPAddressesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDPAddressesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(_tds__GetDPAddressesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDPAddressesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDPAddressesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__NetworkHost(soap, "tds:DPAddress", &a->_tds__GetDPAddressesResponse::DPAddress, "tt:NetworkHost"))
					continue;
			}
			soap_check_result(soap, "tds:DPAddress");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDPAddressesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddressesResponse, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(_tds__GetDPAddressesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_dup__tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse *d, _tds__GetDPAddressesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDPAddressesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDPAddressesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDPAddressesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__NetworkHost(soap, &d->_tds__GetDPAddressesResponse::DPAddress, &a->_tds__GetDPAddressesResponse::DPAddress);
	d->_tds__GetDPAddressesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDPAddressesResponse(_tds__GetDPAddressesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__NetworkHost(&a->_tds__GetDPAddressesResponse::DPAddress);
}

SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDPAddressesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDPAddressesResponse *p;
	size_t k = sizeof(_tds__GetDPAddressesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDPAddressesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDPAddressesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDPAddressesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDPAddressesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDPAddressesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDPAddressesResponse(soap, tag ? tag : "tds:GetDPAddressesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDPAddressesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDPAddressesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse * SOAP_FMAC4 soap_get__tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDPAddresses::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDPAddresses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDPAddresses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDPAddresses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const _tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDPAddresses), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDPAddresses::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDPAddresses(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDPAddresses * SOAP_FMAC4 soap_in__tds__GetDPAddresses(struct soap *soap, const char *tag, _tds__GetDPAddresses *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDPAddresses*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDPAddresses)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDPAddresses *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDPAddresses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDPAddresses, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_dup__tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *d, _tds__GetDPAddresses const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDPAddresses*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDPAddresses, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDPAddresses(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDPAddresses::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDPAddresses(_tds__GetDPAddresses const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDPAddresses *p;
	size_t k = sizeof(_tds__GetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDPAddresses);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDPAddresses, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDPAddresses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDPAddresses(soap, tag ? tag : "tds:GetDPAddresses", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDPAddresses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDPAddresses(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDPAddresses * SOAP_FMAC4 soap_get__tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetRemoteDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(_tds__SetRemoteDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(_tds__SetRemoteDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_dup__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse *d, _tds__SetRemoteDiscoveryModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRemoteDiscoveryModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRemoteDiscoveryModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetRemoteDiscoveryModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRemoteDiscoveryModeResponse(_tds__SetRemoteDiscoveryModeResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__SetRemoteDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:SetRemoteDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetRemoteDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode);
}

void _tds__SetRemoteDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetRemoteDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRemoteDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRemoteDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetRemoteDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetRemoteDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetRemoteDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteDiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RemoteDiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRemoteDiscoveryMode, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_dup__tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *d, _tds__SetRemoteDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetRemoteDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetRemoteDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode = a->_tds__SetRemoteDiscoveryMode::RemoteDiscoveryMode;
	d->_tds__SetRemoteDiscoveryMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetRemoteDiscoveryMode(_tds__SetRemoteDiscoveryMode const*a)
{
	if (!a)
		return;
	/* RemoteDiscoveryMode skipped */
}

SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetRemoteDiscoveryMode *p;
	size_t k = sizeof(_tds__SetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetRemoteDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetRemoteDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetRemoteDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetRemoteDiscoveryMode(soap, tag ? tag : "tds:SetRemoteDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRemoteDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRemoteDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode);
}

void _tds__GetRemoteDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RemoteDiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", -1, &a->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(_tds__GetRemoteDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RemoteDiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RemoteDiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:RemoteDiscoveryMode", &a->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_RemoteDiscoveryMode1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:RemoteDiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_RemoteDiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetRemoteDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(_tds__GetRemoteDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_dup__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse *d, _tds__GetRemoteDiscoveryModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRemoteDiscoveryModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRemoteDiscoveryModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode = a->_tds__GetRemoteDiscoveryModeResponse::RemoteDiscoveryMode;
	d->_tds__GetRemoteDiscoveryModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRemoteDiscoveryModeResponse(_tds__GetRemoteDiscoveryModeResponse const*a)
{
	if (!a)
		return;
	/* RemoteDiscoveryMode skipped */
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__GetRemoteDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag ? tag : "tds:GetRemoteDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetRemoteDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetRemoteDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetRemoteDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRemoteDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRemoteDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetRemoteDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetRemoteDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetRemoteDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRemoteDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRemoteDiscoveryMode, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_dup__tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *d, _tds__GetRemoteDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetRemoteDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetRemoteDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetRemoteDiscoveryMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetRemoteDiscoveryMode(_tds__GetRemoteDiscoveryMode const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetRemoteDiscoveryMode *p;
	size_t k = sizeof(_tds__GetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetRemoteDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetRemoteDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetRemoteDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetRemoteDiscoveryMode(soap, tag ? tag : "tds:GetRemoteDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRemoteDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRemoteDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(_tds__SetDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryModeResponse, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(_tds__SetDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_dup__tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse *d, _tds__SetDiscoveryModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDiscoveryModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDiscoveryModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDiscoveryModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDiscoveryModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDiscoveryModeResponse(_tds__SetDiscoveryModeResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__SetDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDiscoveryModeResponse(soap, tag ? tag : "tds:SetDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__SetDiscoveryMode::DiscoveryMode);
}

void _tds__SetDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDiscoveryMode), type))
		return soap->error;
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->_tds__SetDiscoveryMode::DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDiscoveryMode * SOAP_FMAC4 soap_in__tds__SetDiscoveryMode(struct soap *soap, const char *tag, _tds__SetDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->_tds__SetDiscoveryMode::DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDiscoveryMode, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_dup__tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *d, _tds__SetDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetDiscoveryMode::DiscoveryMode = a->_tds__SetDiscoveryMode::DiscoveryMode;
	d->_tds__SetDiscoveryMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetDiscoveryMode(_tds__SetDiscoveryMode const*a)
{
	if (!a)
		return;
	/* DiscoveryMode skipped */
}

SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetDiscoveryMode *p;
	size_t k = sizeof(_tds__SetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetDiscoveryMode(soap, tag ? tag : "tds:SetDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDiscoveryMode * SOAP_FMAC4 soap_get__tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDiscoveryModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DiscoveryMode(soap, &this->_tds__GetDiscoveryModeResponse::DiscoveryMode);
}

void _tds__GetDiscoveryModeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDiscoveryModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDiscoveryModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:DiscoveryMode");
	if (soap_out_tt__DiscoveryMode(soap, "tds:DiscoveryMode", -1, &a->_tds__GetDiscoveryModeResponse::DiscoveryMode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDiscoveryModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDiscoveryModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_in__tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetDiscoveryModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDiscoveryModeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(_tds__GetDiscoveryModeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDiscoveryModeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDiscoveryModeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiscoveryMode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiscoveryMode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__DiscoveryMode(soap, "tds:DiscoveryMode", &a->_tds__GetDiscoveryModeResponse::DiscoveryMode, "tt:DiscoveryMode"))
				{	soap_flag_DiscoveryMode1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:DiscoveryMode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DiscoveryMode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDiscoveryModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryModeResponse, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(_tds__GetDiscoveryModeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_dup__tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse *d, _tds__GetDiscoveryModeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDiscoveryModeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDiscoveryModeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDiscoveryModeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDiscoveryModeResponse::DiscoveryMode = a->_tds__GetDiscoveryModeResponse::DiscoveryMode;
	d->_tds__GetDiscoveryModeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDiscoveryModeResponse(_tds__GetDiscoveryModeResponse const*a)
{
	if (!a)
		return;
	/* DiscoveryMode skipped */
}

SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDiscoveryModeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDiscoveryModeResponse *p;
	size_t k = sizeof(_tds__GetDiscoveryModeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDiscoveryModeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDiscoveryModeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDiscoveryModeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDiscoveryModeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDiscoveryModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDiscoveryModeResponse(soap, tag ? tag : "tds:GetDiscoveryModeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDiscoveryModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDiscoveryModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse * SOAP_FMAC4 soap_get__tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDiscoveryMode::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDiscoveryMode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDiscoveryMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDiscoveryMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const _tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDiscoveryMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDiscoveryMode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDiscoveryMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDiscoveryMode * SOAP_FMAC4 soap_in__tds__GetDiscoveryMode(struct soap *soap, const char *tag, _tds__GetDiscoveryMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDiscoveryMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDiscoveryMode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDiscoveryMode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDiscoveryMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDiscoveryMode, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_dup__tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *d, _tds__GetDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDiscoveryMode::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDiscoveryMode(_tds__GetDiscoveryMode const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDiscoveryMode *p;
	size_t k = sizeof(_tds__GetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDiscoveryMode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDiscoveryMode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDiscoveryMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDiscoveryMode(soap, tag ? tag : "tds:GetDiscoveryMode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDiscoveryMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDiscoveryMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDiscoveryMode * SOAP_FMAC4 soap_get__tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopesResponse::ScopeItem);
}

void _tds__RemoveScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopesResponse::ScopeItem);
#endif
}

int _tds__RemoveScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:ScopeItem");
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__RemoveScopesResponse::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveScopesResponse * SOAP_FMAC4 soap_in__tds__RemoveScopesResponse(struct soap *soap, const char *tag, _tds__RemoveScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(_tds__RemoveScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__RemoveScopesResponse::ScopeItem, "xsd:anyURI"))
					continue;
			}
			soap_check_result(soap, "tds:ScopeItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopesResponse, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(_tds__RemoveScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_dup__tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse *d, _tds__RemoveScopesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RemoveScopesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RemoveScopesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RemoveScopesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->_tds__RemoveScopesResponse::ScopeItem, &a->_tds__RemoveScopesResponse::ScopeItem);
	d->_tds__RemoveScopesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RemoveScopesResponse(_tds__RemoveScopesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->_tds__RemoveScopesResponse::ScopeItem);
}

SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveScopesResponse *p;
	size_t k = sizeof(_tds__RemoveScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveScopesResponse(soap, tag ? tag : "tds:RemoveScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveScopesResponse * SOAP_FMAC4 soap_get__tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RemoveScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopes::ScopeItem);
}

void _tds__RemoveScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__RemoveScopes::ScopeItem);
#endif
}

int _tds__RemoveScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveScopes(struct soap *soap, const char *tag, int id, const _tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__RemoveScopes::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RemoveScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveScopes * SOAP_FMAC4 soap_in__tds__RemoveScopes(struct soap *soap, const char *tag, _tds__RemoveScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RemoveScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RemoveScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__RemoveScopes::ScopeItem, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__RemoveScopes::ScopeItem.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RemoveScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveScopes, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_dup__tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *d, _tds__RemoveScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RemoveScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RemoveScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RemoveScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->_tds__RemoveScopes::ScopeItem, &a->_tds__RemoveScopes::ScopeItem);
	d->_tds__RemoveScopes::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RemoveScopes(_tds__RemoveScopes const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->_tds__RemoveScopes::ScopeItem);
}

SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RemoveScopes *p;
	size_t k = sizeof(_tds__RemoveScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RemoveScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RemoveScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RemoveScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RemoveScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RemoveScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RemoveScopes(soap, tag ? tag : "tds:RemoveScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveScopes * SOAP_FMAC4 soap_get__tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__AddScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__AddScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopesResponse(struct soap *soap, const char *tag, int id, const _tds__AddScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddScopesResponse * SOAP_FMAC4 soap_in__tds__AddScopesResponse(struct soap *soap, const char *tag, _tds__AddScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopesResponse, sizeof(_tds__AddScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopesResponse, SOAP_TYPE__tds__AddScopesResponse, sizeof(_tds__AddScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_dup__tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse *d, _tds__AddScopesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__AddScopesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__AddScopesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__AddScopesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__AddScopesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__AddScopesResponse(_tds__AddScopesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddScopesResponse *p;
	size_t k = sizeof(_tds__AddScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddScopesResponse(soap, tag ? tag : "tds:AddScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddScopesResponse * SOAP_FMAC4 soap_get__tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__AddScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__AddScopes::ScopeItem);
}

void _tds__AddScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__AddScopes::ScopeItem);
#endif
}

int _tds__AddScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddScopes(struct soap *soap, const char *tag, int id, const _tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", -1, &a->_tds__AddScopes::ScopeItem, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__AddScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__AddScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddScopes * SOAP_FMAC4 soap_in__tds__AddScopes(struct soap *soap, const char *tag, _tds__AddScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__AddScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__AddScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:ScopeItem", &a->_tds__AddScopes::ScopeItem, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__AddScopes::ScopeItem.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__AddScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddScopes, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_dup__tds__AddScopes(struct soap *soap, _tds__AddScopes *d, _tds__AddScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__AddScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__AddScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__AddScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->_tds__AddScopes::ScopeItem, &a->_tds__AddScopes::ScopeItem);
	d->_tds__AddScopes::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__AddScopes(_tds__AddScopes const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->_tds__AddScopes::ScopeItem);
}

SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__AddScopes *p;
	size_t k = sizeof(_tds__AddScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__AddScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__AddScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__AddScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__AddScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__AddScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__AddScopes(soap, tag ? tag : "tds:AddScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddScopes * SOAP_FMAC4 soap_get__tds__AddScopes(struct soap *soap, _tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopesResponse(struct soap *soap, const char *tag, int id, const _tds__SetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetScopesResponse * SOAP_FMAC4 soap_in__tds__SetScopesResponse(struct soap *soap, const char *tag, _tds__SetScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopesResponse, sizeof(_tds__SetScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopesResponse, SOAP_TYPE__tds__SetScopesResponse, sizeof(_tds__SetScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_dup__tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse *d, _tds__SetScopesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetScopesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetScopesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetScopesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetScopesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetScopesResponse(_tds__SetScopesResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetScopesResponse *p;
	size_t k = sizeof(_tds__SetScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetScopesResponse(soap, tag ? tag : "tds:SetScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetScopesResponse * SOAP_FMAC4 soap_get__tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__SetScopes::Scopes);
}

void _tds__SetScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfxsd__anyURI(soap, &this->_tds__SetScopes::Scopes);
#endif
}

int _tds__SetScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetScopes(struct soap *soap, const char *tag, int id, const _tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetScopes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfxsd__anyURI(soap, "tds:Scopes", -1, &a->_tds__SetScopes::Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetScopes * SOAP_FMAC4 soap_in__tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfxsd__anyURI(soap, "tds:Scopes", &a->_tds__SetScopes::Scopes, "xsd:anyURI"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__SetScopes::Scopes.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetScopes, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_dup__tds__SetScopes(struct soap *soap, _tds__SetScopes *d, _tds__SetScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfxsd__anyURI(soap, &d->_tds__SetScopes::Scopes, &a->_tds__SetScopes::Scopes);
	d->_tds__SetScopes::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetScopes(_tds__SetScopes const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfxsd__anyURI(&a->_tds__SetScopes::Scopes);
}

SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetScopes *p;
	size_t k = sizeof(_tds__SetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetScopes(soap, tag ? tag : "tds:SetScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetScopes * SOAP_FMAC4 soap_get__tds__SetScopes(struct soap *soap, _tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetScopesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Scope(soap, &this->_tds__GetScopesResponse::Scopes);
}

void _tds__GetScopesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Scope(soap, &this->_tds__GetScopesResponse::Scopes);
#endif
}

int _tds__GetScopesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetScopesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopesResponse(struct soap *soap, const char *tag, int id, const _tds__GetScopesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Scopes");
	if (soap_out_std__vectorTemplateOfPointerTott__Scope(soap, "tds:Scopes", -1, &a->_tds__GetScopesResponse::Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetScopesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetScopesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetScopesResponse * SOAP_FMAC4 soap_in__tds__GetScopesResponse(struct soap *soap, const char *tag, _tds__GetScopesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetScopesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopesResponse, sizeof(_tds__GetScopesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetScopesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetScopesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Scope(soap, "tds:Scopes", &a->_tds__GetScopesResponse::Scopes, "tt:Scope"))
					continue;
			}
			soap_check_result(soap, "tds:Scopes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__GetScopesResponse::Scopes.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetScopesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopesResponse, SOAP_TYPE__tds__GetScopesResponse, sizeof(_tds__GetScopesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_dup__tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse *d, _tds__GetScopesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetScopesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetScopesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetScopesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__Scope(soap, &d->_tds__GetScopesResponse::Scopes, &a->_tds__GetScopesResponse::Scopes);
	d->_tds__GetScopesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetScopesResponse(_tds__GetScopesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__Scope(&a->_tds__GetScopesResponse::Scopes);
}

SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetScopesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetScopesResponse *p;
	size_t k = sizeof(_tds__GetScopesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetScopesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetScopesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetScopesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetScopesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetScopesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetScopesResponse(soap, tag ? tag : "tds:GetScopesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetScopesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetScopesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetScopesResponse * SOAP_FMAC4 soap_get__tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetScopes::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetScopes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetScopes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetScopes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetScopes(struct soap *soap, const char *tag, int id, const _tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetScopes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetScopes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetScopes(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetScopes * SOAP_FMAC4 soap_in__tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetScopes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetScopes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetScopes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetScopes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetScopes, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_dup__tds__GetScopes(struct soap *soap, _tds__GetScopes *d, _tds__GetScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetScopes::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetScopes(_tds__GetScopes const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetScopes *p;
	size_t k = sizeof(_tds__GetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetScopes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetScopes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetScopes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetScopes(soap, tag ? tag : "tds:GetScopes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetScopes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetScopes(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetScopes * SOAP_FMAC4 soap_get__tds__GetScopes(struct soap *soap, _tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemLogResponse::SystemLog = NULL;
}

void _tds__GetSystemLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemLog(soap, &this->_tds__GetSystemLogResponse::SystemLog);
#endif
}

int _tds__GetSystemLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemLogResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLogResponse), type))
		return soap->error;
	if (a->SystemLog)
		soap_element_result(soap, "tds:SystemLog");
	if (!a->_tds__GetSystemLogResponse::SystemLog)
	{	if (soap_element_empty(soap, "tds:SystemLog", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemLog(soap, "tds:SystemLog", -1, &a->_tds__GetSystemLogResponse::SystemLog, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemLogResponse * SOAP_FMAC4 soap_in__tds__GetSystemLogResponse(struct soap *soap, const char *tag, _tds__GetSystemLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemLogResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(_tds__GetSystemLogResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemLogResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemLogResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemLog1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLog1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemLog(soap, "tds:SystemLog", &a->_tds__GetSystemLogResponse::SystemLog, "tt:SystemLog"))
				{	soap_flag_SystemLog1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemLog");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetSystemLogResponse::SystemLog))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLogResponse, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(_tds__GetSystemLogResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_dup__tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse *d, _tds__GetSystemLogResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemLogResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemLogResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemLogResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__SystemLog(soap, &d->_tds__GetSystemLogResponse::SystemLog, &a->_tds__GetSystemLogResponse::SystemLog);
	d->_tds__GetSystemLogResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemLogResponse(_tds__GetSystemLogResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__SystemLog(&a->_tds__GetSystemLogResponse::SystemLog);
}

SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemLogResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemLogResponse *p;
	size_t k = sizeof(_tds__GetSystemLogResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemLogResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemLogResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemLogResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemLogResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemLogResponse(soap, tag ? tag : "tds:GetSystemLogResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemLogResponse * SOAP_FMAC4 soap_get__tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SystemLogType(soap, &this->_tds__GetSystemLog::LogType);
}

void _tds__GetSystemLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemLog(struct soap *soap, const char *tag, int id, const _tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemLog), type))
		return soap->error;
	if (soap_out_tt__SystemLogType(soap, "tds:LogType", -1, &a->_tds__GetSystemLog::LogType, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemLog::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemLog(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemLog * SOAP_FMAC4 soap_in__tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemLog*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemLog)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemLog *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_LogType1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LogType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SystemLogType(soap, "tds:LogType", &a->_tds__GetSystemLog::LogType, "tt:SystemLogType"))
				{	soap_flag_LogType1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_LogType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemLog, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_dup__tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *d, _tds__GetSystemLog const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemLog*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemLog, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemLog(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetSystemLog::LogType = a->_tds__GetSystemLog::LogType;
	d->_tds__GetSystemLog::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemLog(_tds__GetSystemLog const*a)
{
	if (!a)
		return;
	/* LogType skipped */
}

SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemLog *p;
	size_t k = sizeof(_tds__GetSystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemLog);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemLog, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemLog(soap, tag ? tag : "tds:GetSystemLog", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemLog(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemLog * SOAP_FMAC4 soap_get__tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemSupportInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemSupportInformationResponse::SupportInformation = NULL;
}

void _tds__GetSystemSupportInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SupportInformation(soap, &this->_tds__GetSystemSupportInformationResponse::SupportInformation);
#endif
}

int _tds__GetSystemSupportInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemSupportInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse), type))
		return soap->error;
	if (a->SupportInformation)
		soap_element_result(soap, "tds:SupportInformation");
	if (!a->_tds__GetSystemSupportInformationResponse::SupportInformation)
	{	if (soap_element_empty(soap, "tds:SupportInformation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SupportInformation(soap, "tds:SupportInformation", -1, &a->_tds__GetSystemSupportInformationResponse::SupportInformation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemSupportInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemSupportInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, _tds__GetSystemSupportInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemSupportInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(_tds__GetSystemSupportInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemSupportInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemSupportInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SupportInformation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportInformation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SupportInformation(soap, "tds:SupportInformation", &a->_tds__GetSystemSupportInformationResponse::SupportInformation, "tt:SupportInformation"))
				{	soap_flag_SupportInformation1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SupportInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetSystemSupportInformationResponse::SupportInformation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemSupportInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformationResponse, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(_tds__GetSystemSupportInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_dup__tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse *d, _tds__GetSystemSupportInformationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemSupportInformationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemSupportInformationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__SupportInformation(soap, &d->_tds__GetSystemSupportInformationResponse::SupportInformation, &a->_tds__GetSystemSupportInformationResponse::SupportInformation);
	d->_tds__GetSystemSupportInformationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemSupportInformationResponse(_tds__GetSystemSupportInformationResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__SupportInformation(&a->_tds__GetSystemSupportInformationResponse::SupportInformation);
}

SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemSupportInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemSupportInformationResponse *p;
	size_t k = sizeof(_tds__GetSystemSupportInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemSupportInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemSupportInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemSupportInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemSupportInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemSupportInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemSupportInformationResponse(soap, tag ? tag : "tds:GetSystemSupportInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemSupportInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemSupportInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemSupportInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemSupportInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemSupportInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemSupportInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemSupportInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemSupportInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemSupportInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in__tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemSupportInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemSupportInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemSupportInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemSupportInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemSupportInformation, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_dup__tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *d, _tds__GetSystemSupportInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemSupportInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemSupportInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemSupportInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetSystemSupportInformation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemSupportInformation(_tds__GetSystemSupportInformation const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemSupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemSupportInformation *p;
	size_t k = sizeof(_tds__GetSystemSupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemSupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemSupportInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemSupportInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemSupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemSupportInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemSupportInformation(soap, tag ? tag : "tds:GetSystemSupportInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemSupportInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemSupportInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get__tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemBackupResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__GetSystemBackupResponse::BackupFiles);
}

void _tds__GetSystemBackupResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__GetSystemBackupResponse::BackupFiles);
#endif
}

int _tds__GetSystemBackupResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemBackupResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackupResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:BackupFiles");
	if (soap_out_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", -1, &a->_tds__GetSystemBackupResponse::BackupFiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemBackupResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemBackupResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_in__tds__GetSystemBackupResponse(struct soap *soap, const char *tag, _tds__GetSystemBackupResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemBackupResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(_tds__GetSystemBackupResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemBackupResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemBackupResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", &a->_tds__GetSystemBackupResponse::BackupFiles, "tt:BackupFile"))
					continue;
			}
			soap_check_result(soap, "tds:BackupFiles");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__GetSystemBackupResponse::BackupFiles.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemBackupResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackupResponse, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(_tds__GetSystemBackupResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_dup__tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse *d, _tds__GetSystemBackupResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemBackupResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemBackupResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemBackupResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__BackupFile(soap, &d->_tds__GetSystemBackupResponse::BackupFiles, &a->_tds__GetSystemBackupResponse::BackupFiles);
	d->_tds__GetSystemBackupResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemBackupResponse(_tds__GetSystemBackupResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__BackupFile(&a->_tds__GetSystemBackupResponse::BackupFiles);
}

SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemBackupResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemBackupResponse *p;
	size_t k = sizeof(_tds__GetSystemBackupResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemBackupResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemBackupResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemBackupResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemBackupResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemBackupResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemBackupResponse(soap, tag ? tag : "tds:GetSystemBackupResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemBackupResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemBackupResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse * SOAP_FMAC4 soap_get__tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemBackup::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemBackup::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemBackup::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemBackup(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const _tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemBackup), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemBackup::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemBackup(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemBackup * SOAP_FMAC4 soap_in__tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemBackup*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemBackup)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemBackup *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemBackup *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemBackup, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_dup__tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *d, _tds__GetSystemBackup const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemBackup*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemBackup, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemBackup(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetSystemBackup::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemBackup(_tds__GetSystemBackup const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemBackup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemBackup *p;
	size_t k = sizeof(_tds__GetSystemBackup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemBackup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemBackup);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemBackup, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemBackup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemBackup::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemBackup(soap, tag ? tag : "tds:GetSystemBackup", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemBackup::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemBackup(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemBackup * SOAP_FMAC4 soap_get__tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RestoreSystemResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__RestoreSystemResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__RestoreSystemResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RestoreSystemResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, const _tds__RestoreSystemResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystemResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RestoreSystemResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RestoreSystemResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RestoreSystemResponse * SOAP_FMAC4 soap_in__tds__RestoreSystemResponse(struct soap *soap, const char *tag, _tds__RestoreSystemResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RestoreSystemResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(_tds__RestoreSystemResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RestoreSystemResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RestoreSystemResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RestoreSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystemResponse, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(_tds__RestoreSystemResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_dup__tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse *d, _tds__RestoreSystemResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RestoreSystemResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RestoreSystemResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RestoreSystemResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__RestoreSystemResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RestoreSystemResponse(_tds__RestoreSystemResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RestoreSystemResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RestoreSystemResponse *p;
	size_t k = sizeof(_tds__RestoreSystemResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RestoreSystemResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RestoreSystemResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RestoreSystemResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RestoreSystemResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RestoreSystemResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RestoreSystemResponse(soap, tag ? tag : "tds:RestoreSystemResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RestoreSystemResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RestoreSystemResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RestoreSystemResponse * SOAP_FMAC4 soap_get__tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__RestoreSystem::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__RestoreSystem::BackupFiles);
}

void _tds__RestoreSystem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__BackupFile(soap, &this->_tds__RestoreSystem::BackupFiles);
#endif
}

int _tds__RestoreSystem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RestoreSystem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RestoreSystem(struct soap *soap, const char *tag, int id, const _tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RestoreSystem), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", -1, &a->_tds__RestoreSystem::BackupFiles, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__RestoreSystem::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__RestoreSystem(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RestoreSystem * SOAP_FMAC4 soap_in__tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RestoreSystem*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__RestoreSystem)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__RestoreSystem *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__BackupFile(soap, "tds:BackupFiles", &a->_tds__RestoreSystem::BackupFiles, "tt:BackupFile"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__RestoreSystem::BackupFiles.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__RestoreSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RestoreSystem, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_dup__tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *d, _tds__RestoreSystem const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__RestoreSystem*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__RestoreSystem, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__RestoreSystem(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTott__BackupFile(soap, &d->_tds__RestoreSystem::BackupFiles, &a->_tds__RestoreSystem::BackupFiles);
	d->_tds__RestoreSystem::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__RestoreSystem(_tds__RestoreSystem const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTott__BackupFile(&a->_tds__RestoreSystem::BackupFiles);
}

SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RestoreSystem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__RestoreSystem *p;
	size_t k = sizeof(_tds__RestoreSystem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__RestoreSystem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__RestoreSystem);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__RestoreSystem, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__RestoreSystem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__RestoreSystem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__RestoreSystem(soap, tag ? tag : "tds:RestoreSystem", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RestoreSystem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RestoreSystem(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RestoreSystem * SOAP_FMAC4 soap_get__tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SystemRebootResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__SystemRebootResponse::Message);
}

void _tds__SystemRebootResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SystemRebootResponse::Message, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__SystemRebootResponse::Message);
#endif
}

int _tds__SystemRebootResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SystemRebootResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, const _tds__SystemRebootResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemRebootResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Message");
	if (soap_out_std__string(soap, "tds:Message", -1, &a->_tds__SystemRebootResponse::Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SystemRebootResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SystemRebootResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SystemRebootResponse * SOAP_FMAC4 soap_in__tds__SystemRebootResponse(struct soap *soap, const char *tag, _tds__SystemRebootResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SystemRebootResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(_tds__SystemRebootResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SystemRebootResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SystemRebootResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Message", &a->_tds__SystemRebootResponse::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Message1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SystemRebootResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemRebootResponse, SOAP_TYPE__tds__SystemRebootResponse, sizeof(_tds__SystemRebootResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_dup__tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse *d, _tds__SystemRebootResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SystemRebootResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SystemRebootResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SystemRebootResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__string(soap, &d->_tds__SystemRebootResponse::Message, &a->_tds__SystemRebootResponse::Message);
	d->_tds__SystemRebootResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SystemRebootResponse(_tds__SystemRebootResponse const*a)
{
	if (!a)
		return;
	soap_del_std__string(&a->_tds__SystemRebootResponse::Message);
}

SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SystemRebootResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SystemRebootResponse *p;
	size_t k = sizeof(_tds__SystemRebootResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SystemRebootResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SystemRebootResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SystemRebootResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SystemRebootResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SystemRebootResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SystemRebootResponse(soap, tag ? tag : "tds:SystemRebootResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SystemRebootResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SystemRebootResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SystemRebootResponse * SOAP_FMAC4 soap_get__tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SystemReboot::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SystemReboot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SystemReboot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SystemReboot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SystemReboot(struct soap *soap, const char *tag, int id, const _tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SystemReboot), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SystemReboot::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SystemReboot(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SystemReboot * SOAP_FMAC4 soap_in__tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SystemReboot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SystemReboot)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SystemReboot *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SystemReboot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SystemReboot, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_dup__tds__SystemReboot(struct soap *soap, _tds__SystemReboot *d, _tds__SystemReboot const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SystemReboot*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SystemReboot, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SystemReboot(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SystemReboot::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SystemReboot(_tds__SystemReboot const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SystemReboot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SystemReboot *p;
	size_t k = sizeof(_tds__SystemReboot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SystemReboot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SystemReboot);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SystemReboot, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SystemReboot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SystemReboot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SystemReboot(soap, tag ? tag : "tds:SystemReboot", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SystemReboot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SystemReboot(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SystemReboot * SOAP_FMAC4 soap_get__tds__SystemReboot(struct soap *soap, _tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__UpgradeSystemFirmwareResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__UpgradeSystemFirmwareResponse::Message = NULL;
}

void _tds__UpgradeSystemFirmwareResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_tds__UpgradeSystemFirmwareResponse::Message);
#endif
}

int _tds__UpgradeSystemFirmwareResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, const _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse), type))
		return soap->error;
	if (a->Message)
		soap_element_result(soap, "tds:Message");
	if (soap_out_PointerTostd__string(soap, "tds:Message", -1, &a->_tds__UpgradeSystemFirmwareResponse::Message, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__UpgradeSystemFirmwareResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmwareResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__UpgradeSystemFirmwareResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(_tds__UpgradeSystemFirmwareResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__UpgradeSystemFirmwareResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__UpgradeSystemFirmwareResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Message1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Message", &a->_tds__UpgradeSystemFirmwareResponse::Message, "xsd:string"))
				{	soap_flag_Message1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Message");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__UpgradeSystemFirmwareResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(_tds__UpgradeSystemFirmwareResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_dup__tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse *d, _tds__UpgradeSystemFirmwareResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__UpgradeSystemFirmwareResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__UpgradeSystemFirmwareResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTostd__string(soap, &d->_tds__UpgradeSystemFirmwareResponse::Message, &a->_tds__UpgradeSystemFirmwareResponse::Message);
	d->_tds__UpgradeSystemFirmwareResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__UpgradeSystemFirmwareResponse(_tds__UpgradeSystemFirmwareResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTostd__string(&a->_tds__UpgradeSystemFirmwareResponse::Message);
}

SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__UpgradeSystemFirmwareResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__UpgradeSystemFirmwareResponse *p;
	size_t k = sizeof(_tds__UpgradeSystemFirmwareResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__UpgradeSystemFirmwareResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__UpgradeSystemFirmwareResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__UpgradeSystemFirmwareResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__UpgradeSystemFirmwareResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag ? tag : "tds:UpgradeSystemFirmwareResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__UpgradeSystemFirmwareResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__UpgradeSystemFirmwareResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__UpgradeSystemFirmware::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__UpgradeSystemFirmware::Firmware = NULL;
}

void _tds__UpgradeSystemFirmware::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__AttachmentData(soap, &this->_tds__UpgradeSystemFirmware::Firmware);
#endif
}

int _tds__UpgradeSystemFirmware::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__UpgradeSystemFirmware(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__UpgradeSystemFirmware), type))
		return soap->error;
	if (!a->_tds__UpgradeSystemFirmware::Firmware)
	{	if (soap_element_empty(soap, "tds:Firmware", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__AttachmentData(soap, "tds:Firmware", -1, &a->_tds__UpgradeSystemFirmware::Firmware, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__UpgradeSystemFirmware::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__UpgradeSystemFirmware(soap, tag, this, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in__tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__UpgradeSystemFirmware*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__UpgradeSystemFirmware)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__UpgradeSystemFirmware *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Firmware1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Firmware1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__AttachmentData(soap, "tds:Firmware", &a->_tds__UpgradeSystemFirmware::Firmware, "tt:AttachmentData"))
				{	soap_flag_Firmware1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__UpgradeSystemFirmware::Firmware))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__UpgradeSystemFirmware *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__UpgradeSystemFirmware, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_dup__tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *d, _tds__UpgradeSystemFirmware const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__UpgradeSystemFirmware*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__UpgradeSystemFirmware, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__UpgradeSystemFirmware(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__AttachmentData(soap, &d->_tds__UpgradeSystemFirmware::Firmware, &a->_tds__UpgradeSystemFirmware::Firmware);
	d->_tds__UpgradeSystemFirmware::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__UpgradeSystemFirmware(_tds__UpgradeSystemFirmware const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__AttachmentData(&a->_tds__UpgradeSystemFirmware::Firmware);
}

SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__UpgradeSystemFirmware(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__UpgradeSystemFirmware *p;
	size_t k = sizeof(_tds__UpgradeSystemFirmware);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__UpgradeSystemFirmware, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__UpgradeSystemFirmware);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__UpgradeSystemFirmware, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__UpgradeSystemFirmware location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__UpgradeSystemFirmware::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__UpgradeSystemFirmware(soap, tag ? tag : "tds:UpgradeSystemFirmware", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__UpgradeSystemFirmware::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__UpgradeSystemFirmware(soap, this, tag, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get__tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemFactoryDefaultResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetSystemFactoryDefaultResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemFactoryDefaultResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, const _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemFactoryDefaultResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefaultResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemFactoryDefaultResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(_tds__SetSystemFactoryDefaultResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemFactoryDefaultResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemFactoryDefaultResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetSystemFactoryDefaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(_tds__SetSystemFactoryDefaultResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_dup__tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse *d, _tds__SetSystemFactoryDefaultResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetSystemFactoryDefaultResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetSystemFactoryDefaultResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetSystemFactoryDefaultResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetSystemFactoryDefaultResponse(_tds__SetSystemFactoryDefaultResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemFactoryDefaultResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemFactoryDefaultResponse *p;
	size_t k = sizeof(_tds__SetSystemFactoryDefaultResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemFactoryDefaultResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemFactoryDefaultResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemFactoryDefaultResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemFactoryDefaultResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag ? tag : "tds:SetSystemFactoryDefaultResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemFactoryDefaultResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemFactoryDefaultResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemFactoryDefault::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__FactoryDefaultType(soap, &this->_tds__SetSystemFactoryDefault::FactoryDefault);
}

void _tds__SetSystemFactoryDefault::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemFactoryDefault::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemFactoryDefault), type))
		return soap->error;
	if (soap_out_tt__FactoryDefaultType(soap, "tds:FactoryDefault", -1, &a->_tds__SetSystemFactoryDefault::FactoryDefault, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemFactoryDefault::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemFactoryDefault(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in__tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemFactoryDefault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemFactoryDefault)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemFactoryDefault *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_FactoryDefault1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FactoryDefault1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__FactoryDefaultType(soap, "tds:FactoryDefault", &a->_tds__SetSystemFactoryDefault::FactoryDefault, "tt:FactoryDefaultType"))
				{	soap_flag_FactoryDefault1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_FactoryDefault1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetSystemFactoryDefault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemFactoryDefault, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_dup__tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *d, _tds__SetSystemFactoryDefault const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetSystemFactoryDefault*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetSystemFactoryDefault, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetSystemFactoryDefault(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetSystemFactoryDefault::FactoryDefault = a->_tds__SetSystemFactoryDefault::FactoryDefault;
	d->_tds__SetSystemFactoryDefault::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetSystemFactoryDefault(_tds__SetSystemFactoryDefault const*a)
{
	if (!a)
		return;
	/* FactoryDefault skipped */
}

SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemFactoryDefault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemFactoryDefault *p;
	size_t k = sizeof(_tds__SetSystemFactoryDefault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemFactoryDefault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemFactoryDefault);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemFactoryDefault, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemFactoryDefault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemFactoryDefault::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemFactoryDefault(soap, tag ? tag : "tds:SetSystemFactoryDefault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemFactoryDefault::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemFactoryDefault(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get__tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemDateAndTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime = NULL;
}

void _tds__GetSystemDateAndTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__SystemDateTime(soap, &this->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime);
#endif
}

int _tds__GetSystemDateAndTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse), type))
		return soap->error;
	if (a->SystemDateAndTime)
		soap_element_result(soap, "tds:SystemDateAndTime");
	if (!a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime)
	{	if (soap_element_empty(soap, "tds:SystemDateAndTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", -1, &a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemDateAndTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__GetSystemDateAndTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(_tds__GetSystemDateAndTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemDateAndTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemDateAndTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SystemDateAndTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemDateAndTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__SystemDateTime(soap, "tds:SystemDateAndTime", &a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime, "tt:SystemDateTime"))
				{	soap_flag_SystemDateAndTime1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:SystemDateAndTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(_tds__GetSystemDateAndTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_dup__tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse *d, _tds__GetSystemDateAndTimeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemDateAndTimeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemDateAndTimeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTott__SystemDateTime(soap, &d->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime, &a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime);
	d->_tds__GetSystemDateAndTimeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemDateAndTimeResponse(_tds__GetSystemDateAndTimeResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTott__SystemDateTime(&a->_tds__GetSystemDateAndTimeResponse::SystemDateAndTime);
}

SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemDateAndTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemDateAndTimeResponse *p;
	size_t k = sizeof(_tds__GetSystemDateAndTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemDateAndTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemDateAndTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemDateAndTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemDateAndTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemDateAndTimeResponse(soap, tag ? tag : "tds:GetSystemDateAndTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemDateAndTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemDateAndTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetSystemDateAndTime::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetSystemDateAndTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetSystemDateAndTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemDateAndTime), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemDateAndTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetSystemDateAndTime(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetSystemDateAndTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetSystemDateAndTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemDateAndTime, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_dup__tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *d, _tds__GetSystemDateAndTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetSystemDateAndTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetSystemDateAndTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetSystemDateAndTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetSystemDateAndTime::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetSystemDateAndTime(_tds__GetSystemDateAndTime const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetSystemDateAndTime *p;
	size_t k = sizeof(_tds__GetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetSystemDateAndTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetSystemDateAndTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetSystemDateAndTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetSystemDateAndTime(soap, tag ? tag : "tds:GetSystemDateAndTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemDateAndTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemDateAndTime(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemDateAndTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__SetSystemDateAndTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__SetSystemDateAndTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, const _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemDateAndTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__SetSystemDateAndTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemDateAndTimeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(_tds__SetSystemDateAndTimeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemDateAndTimeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemDateAndTimeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetSystemDateAndTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(_tds__SetSystemDateAndTimeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_dup__tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse *d, _tds__SetSystemDateAndTimeResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetSystemDateAndTimeResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetSystemDateAndTimeResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetSystemDateAndTimeResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetSystemDateAndTimeResponse(_tds__SetSystemDateAndTimeResponse const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemDateAndTimeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemDateAndTimeResponse *p;
	size_t k = sizeof(_tds__SetSystemDateAndTimeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemDateAndTimeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemDateAndTimeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemDateAndTimeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemDateAndTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemDateAndTimeResponse(soap, tag ? tag : "tds:SetSystemDateAndTimeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemDateAndTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemDateAndTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__SetSystemDateAndTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__SetDateTimeType(soap, &this->_tds__SetSystemDateAndTime::DateTimeType);
	soap_default_bool(soap, &this->_tds__SetSystemDateAndTime::DaylightSavings);
	this->_tds__SetSystemDateAndTime::TimeZone = NULL;
	this->_tds__SetSystemDateAndTime::UTCDateTime = NULL;
}

void _tds__SetSystemDateAndTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__SetSystemDateAndTime::DaylightSavings, SOAP_TYPE_bool);
	soap_serialize_PointerTott__TimeZone(soap, &this->_tds__SetSystemDateAndTime::TimeZone);
	soap_serialize_PointerTott__DateTime(soap, &this->_tds__SetSystemDateAndTime::UTCDateTime);
#endif
}

int _tds__SetSystemDateAndTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetSystemDateAndTime), type))
		return soap->error;
	if (soap_out_tt__SetDateTimeType(soap, "tds:DateTimeType", -1, &a->_tds__SetSystemDateAndTime::DateTimeType, ""))
		return soap->error;
	if (soap_out_bool(soap, "tds:DaylightSavings", -1, &a->_tds__SetSystemDateAndTime::DaylightSavings, ""))
		return soap->error;
	if (soap_out_PointerTott__TimeZone(soap, "tds:TimeZone", -1, &a->_tds__SetSystemDateAndTime::TimeZone, ""))
		return soap->error;
	if (soap_out_PointerTott__DateTime(soap, "tds:UTCDateTime", -1, &a->_tds__SetSystemDateAndTime::UTCDateTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__SetSystemDateAndTime::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__SetSystemDateAndTime(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in__tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetSystemDateAndTime*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__SetSystemDateAndTime)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__SetSystemDateAndTime *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DateTimeType1 = 1;
	size_t soap_flag_DaylightSavings1 = 1;
	size_t soap_flag_TimeZone1 = 1;
	size_t soap_flag_UTCDateTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DateTimeType1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__SetDateTimeType(soap, "tds:DateTimeType", &a->_tds__SetSystemDateAndTime::DateTimeType, "tt:SetDateTimeType"))
				{	soap_flag_DateTimeType1--;
					continue;
				}
			}
			if (soap_flag_DaylightSavings1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:DaylightSavings", &a->_tds__SetSystemDateAndTime::DaylightSavings, "xsd:boolean"))
				{	soap_flag_DaylightSavings1--;
					continue;
				}
			}
			if (soap_flag_TimeZone1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__TimeZone(soap, "tds:TimeZone", &a->_tds__SetSystemDateAndTime::TimeZone, "tt:TimeZone"))
				{	soap_flag_TimeZone1--;
					continue;
				}
			}
			if (soap_flag_UTCDateTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DateTime(soap, "tds:UTCDateTime", &a->_tds__SetSystemDateAndTime::UTCDateTime, "tt:DateTime"))
				{	soap_flag_UTCDateTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_DateTimeType1 > 0 || soap_flag_DaylightSavings1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__SetSystemDateAndTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetSystemDateAndTime, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_dup__tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *d, _tds__SetSystemDateAndTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__SetSystemDateAndTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__SetSystemDateAndTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__SetSystemDateAndTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__SetSystemDateAndTime::DateTimeType = a->_tds__SetSystemDateAndTime::DateTimeType;
	d->_tds__SetSystemDateAndTime::DaylightSavings = a->_tds__SetSystemDateAndTime::DaylightSavings;
	soap_dup_PointerTott__TimeZone(soap, &d->_tds__SetSystemDateAndTime::TimeZone, &a->_tds__SetSystemDateAndTime::TimeZone);
	soap_dup_PointerTott__DateTime(soap, &d->_tds__SetSystemDateAndTime::UTCDateTime, &a->_tds__SetSystemDateAndTime::UTCDateTime);
	d->_tds__SetSystemDateAndTime::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__SetSystemDateAndTime(_tds__SetSystemDateAndTime const*a)
{
	if (!a)
		return;
	/* DateTimeType skipped */
	/* DaylightSavings skipped */
	soap_del_PointerTott__TimeZone(&a->_tds__SetSystemDateAndTime::TimeZone);
	soap_del_PointerTott__DateTime(&a->_tds__SetSystemDateAndTime::UTCDateTime);
}

SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__SetSystemDateAndTime *p;
	size_t k = sizeof(_tds__SetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__SetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__SetSystemDateAndTime);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__SetSystemDateAndTime, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__SetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__SetSystemDateAndTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__SetSystemDateAndTime(soap, tag ? tag : "tds:SetSystemDateAndTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetSystemDateAndTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetSystemDateAndTime(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get__tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDeviceInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::Model);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_default_std__string(soap, &this->_tds__GetDeviceInformationResponse::HardwareId);
}

void _tds__GetDeviceInformationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::Model, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::Model);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_embedded(soap, &this->_tds__GetDeviceInformationResponse::HardwareId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_tds__GetDeviceInformationResponse::HardwareId);
#endif
}

int _tds__GetDeviceInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformationResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Manufacturer");
	if (soap_out_std__string(soap, "tds:Manufacturer", -1, &a->_tds__GetDeviceInformationResponse::Manufacturer, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:Model", -1, &a->_tds__GetDeviceInformationResponse::Model, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:FirmwareVersion", -1, &a->_tds__GetDeviceInformationResponse::FirmwareVersion, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:SerialNumber", -1, &a->_tds__GetDeviceInformationResponse::SerialNumber, ""))
		return soap->error;
	if (soap_out_std__string(soap, "tds:HardwareId", -1, &a->_tds__GetDeviceInformationResponse::HardwareId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDeviceInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDeviceInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_in__tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, _tds__GetDeviceInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDeviceInformationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(_tds__GetDeviceInformationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDeviceInformationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDeviceInformationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Manufacturer1 = 1;
	size_t soap_flag_Model1 = 1;
	size_t soap_flag_FirmwareVersion1 = 1;
	size_t soap_flag_SerialNumber1 = 1;
	size_t soap_flag_HardwareId1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Manufacturer1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Manufacturer", &a->_tds__GetDeviceInformationResponse::Manufacturer, "xsd:string"))
				{	soap_flag_Manufacturer1--;
					continue;
				}
			}
			if (soap_flag_Model1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:Model", &a->_tds__GetDeviceInformationResponse::Model, "xsd:string"))
				{	soap_flag_Model1--;
					continue;
				}
			}
			if (soap_flag_FirmwareVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:FirmwareVersion", &a->_tds__GetDeviceInformationResponse::FirmwareVersion, "xsd:string"))
				{	soap_flag_FirmwareVersion1--;
					continue;
				}
			}
			if (soap_flag_SerialNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:SerialNumber", &a->_tds__GetDeviceInformationResponse::SerialNumber, "xsd:string"))
				{	soap_flag_SerialNumber1--;
					continue;
				}
			}
			if (soap_flag_HardwareId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:HardwareId", &a->_tds__GetDeviceInformationResponse::HardwareId, "xsd:string"))
				{	soap_flag_HardwareId1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Manufacturer");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Manufacturer1 > 0 || soap_flag_Model1 > 0 || soap_flag_FirmwareVersion1 > 0 || soap_flag_SerialNumber1 > 0 || soap_flag_HardwareId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetDeviceInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformationResponse, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(_tds__GetDeviceInformationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_dup__tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse *d, _tds__GetDeviceInformationResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDeviceInformationResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDeviceInformationResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDeviceInformationResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__string(soap, &d->_tds__GetDeviceInformationResponse::Manufacturer, &a->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_dup_std__string(soap, &d->_tds__GetDeviceInformationResponse::Model, &a->_tds__GetDeviceInformationResponse::Model);
	soap_dup_std__string(soap, &d->_tds__GetDeviceInformationResponse::FirmwareVersion, &a->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_dup_std__string(soap, &d->_tds__GetDeviceInformationResponse::SerialNumber, &a->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_dup_std__string(soap, &d->_tds__GetDeviceInformationResponse::HardwareId, &a->_tds__GetDeviceInformationResponse::HardwareId);
	d->_tds__GetDeviceInformationResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDeviceInformationResponse(_tds__GetDeviceInformationResponse const*a)
{
	if (!a)
		return;
	soap_del_std__string(&a->_tds__GetDeviceInformationResponse::Manufacturer);
	soap_del_std__string(&a->_tds__GetDeviceInformationResponse::Model);
	soap_del_std__string(&a->_tds__GetDeviceInformationResponse::FirmwareVersion);
	soap_del_std__string(&a->_tds__GetDeviceInformationResponse::SerialNumber);
	soap_del_std__string(&a->_tds__GetDeviceInformationResponse::HardwareId);
}

SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDeviceInformationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDeviceInformationResponse *p;
	size_t k = sizeof(_tds__GetDeviceInformationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDeviceInformationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDeviceInformationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDeviceInformationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDeviceInformationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDeviceInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDeviceInformationResponse(soap, tag ? tag : "tds:GetDeviceInformationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDeviceInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDeviceInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse * SOAP_FMAC4 soap_get__tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetDeviceInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetDeviceInformation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetDeviceInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDeviceInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const _tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDeviceInformation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDeviceInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetDeviceInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDeviceInformation * SOAP_FMAC4 soap_in__tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDeviceInformation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetDeviceInformation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetDeviceInformation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDeviceInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDeviceInformation, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_dup__tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *d, _tds__GetDeviceInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetDeviceInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetDeviceInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetDeviceInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetDeviceInformation::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetDeviceInformation(_tds__GetDeviceInformation const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDeviceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetDeviceInformation *p;
	size_t k = sizeof(_tds__GetDeviceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetDeviceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetDeviceInformation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetDeviceInformation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetDeviceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetDeviceInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetDeviceInformation(soap, tag ? tag : "tds:GetDeviceInformation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDeviceInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDeviceInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDeviceInformation * SOAP_FMAC4 soap_get__tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetServiceCapabilitiesResponse::Capabilities = NULL;
}

void _tds__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__DeviceServiceCapabilities(soap, &this->_tds__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _tds__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (!a->_tds__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tds:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", -1, &a->_tds__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(_tds__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__DeviceServiceCapabilities(soap, "tds:Capabilities", &a->_tds__GetServiceCapabilitiesResponse::Capabilities, "tds:DeviceServiceCapabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->_tds__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(_tds__GetServiceCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_dup__tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse *d, _tds__GetServiceCapabilitiesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetServiceCapabilitiesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetServiceCapabilitiesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTotds__DeviceServiceCapabilities(soap, &d->_tds__GetServiceCapabilitiesResponse::Capabilities, &a->_tds__GetServiceCapabilitiesResponse::Capabilities);
	d->_tds__GetServiceCapabilitiesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetServiceCapabilitiesResponse(_tds__GetServiceCapabilitiesResponse const*a)
{
	if (!a)
		return;
	soap_del_PointerTotds__DeviceServiceCapabilities(&a->_tds__GetServiceCapabilitiesResponse::Capabilities);
}

SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_tds__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServiceCapabilitiesResponse(soap, tag ? tag : "tds:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tds__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tds__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilities * SOAP_FMAC4 soap_in__tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServiceCapabilities, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_dup__tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *d, _tds__GetServiceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetServiceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetServiceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetServiceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetServiceCapabilities::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetServiceCapabilities(_tds__GetServiceCapabilities const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServiceCapabilities *p;
	size_t k = sizeof(_tds__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServiceCapabilities(soap, tag ? tag : "tds:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilities * SOAP_FMAC4 soap_get__tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServicesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTotds__Service(soap, &this->_tds__GetServicesResponse::Service);
}

void _tds__GetServicesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTotds__Service(soap, &this->_tds__GetServicesResponse::Service);
#endif
}

int _tds__GetServicesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServicesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServicesResponse(struct soap *soap, const char *tag, int id, const _tds__GetServicesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServicesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Service");
	if (soap_out_std__vectorTemplateOfPointerTotds__Service(soap, "tds:Service", -1, &a->_tds__GetServicesResponse::Service, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServicesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServicesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServicesResponse * SOAP_FMAC4 soap_in__tds__GetServicesResponse(struct soap *soap, const char *tag, _tds__GetServicesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServicesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServicesResponse, sizeof(_tds__GetServicesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServicesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServicesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTotds__Service(soap, "tds:Service", &a->_tds__GetServicesResponse::Service, "tds:Service"))
					continue;
			}
			soap_check_result(soap, "tds:Service");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((a->_tds__GetServicesResponse::Service.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServicesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServicesResponse, SOAP_TYPE__tds__GetServicesResponse, sizeof(_tds__GetServicesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_dup__tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse *d, _tds__GetServicesResponse const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetServicesResponse*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetServicesResponse, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetServicesResponse(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_std__vectorTemplateOfPointerTotds__Service(soap, &d->_tds__GetServicesResponse::Service, &a->_tds__GetServicesResponse::Service);
	d->_tds__GetServicesResponse::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetServicesResponse(_tds__GetServicesResponse const*a)
{
	if (!a)
		return;
	soap_del_std__vectorTemplateOfPointerTotds__Service(&a->_tds__GetServicesResponse::Service);
}

SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServicesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServicesResponse *p;
	size_t k = sizeof(_tds__GetServicesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServicesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServicesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServicesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServicesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServicesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServicesResponse(soap, tag ? tag : "tds:GetServicesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServicesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServicesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServicesResponse * SOAP_FMAC4 soap_get__tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tds__GetServices::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetServices::IncludeCapability);
}

void _tds__GetServices::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tds__GetServices::IncludeCapability, SOAP_TYPE_bool);
#endif
}

int _tds__GetServices::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetServices(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetServices(struct soap *soap, const char *tag, int id, const _tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetServices), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:IncludeCapability", -1, &a->_tds__GetServices::IncludeCapability, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tds__GetServices::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tds__GetServices(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetServices * SOAP_FMAC4 soap_in__tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetServices*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tds__GetServices)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tds__GetServices *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_IncludeCapability1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IncludeCapability1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tds:IncludeCapability", &a->_tds__GetServices::IncludeCapability, "xsd:boolean"))
				{	soap_flag_IncludeCapability1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_IncludeCapability1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tds__GetServices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetServices, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_dup__tds__GetServices(struct soap *soap, _tds__GetServices *d, _tds__GetServices const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (_tds__GetServices*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__tds__GetServices, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__tds__GetServices(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->_tds__GetServices::IncludeCapability = a->_tds__GetServices::IncludeCapability;
	d->_tds__GetServices::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__tds__GetServices(_tds__GetServices const*a)
{
	if (!a)
		return;
	/* IncludeCapability skipped */
}

SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetServices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tds__GetServices *p;
	size_t k = sizeof(_tds__GetServices);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tds__GetServices, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tds__GetServices);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tds__GetServices, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tds__GetServices location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tds__GetServices::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tds__GetServices(soap, tag ? tag : "tds:GetServices", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetServices::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetServices(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetServices * SOAP_FMAC4 soap_get__tds__GetServices(struct soap *soap, _tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__StorageConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tds__StorageConfiguration::Data = NULL;
}

void tds__StorageConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__StorageConfigurationData(soap, &this->tds__StorageConfiguration::Data);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tds__StorageConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__StorageConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfiguration(struct soap *soap, const char *tag, int id, const tds__StorageConfiguration *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfiguration), type ? type : "tds:StorageConfiguration"))
		return soap->error;
	if (!a->tds__StorageConfiguration::Data)
	{	if (soap_element_empty(soap, "tds:Data", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__StorageConfigurationData(soap, "tds:Data", -1, &a->tds__StorageConfiguration::Data, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__StorageConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__StorageConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tds__StorageConfiguration * SOAP_FMAC4 soap_in_tds__StorageConfiguration(struct soap *soap, const char *tag, tds__StorageConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__StorageConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__StorageConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__StorageConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 3), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Data1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Data1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__StorageConfigurationData(soap, "tds:Data", &a->tds__StorageConfiguration::Data, "tds:StorageConfigurationData"))
				{	soap_flag_Data1--;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item3--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tds__StorageConfiguration::Data))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__StorageConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfiguration, SOAP_TYPE_tds__StorageConfiguration, sizeof(tds__StorageConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_dup_tds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *d, tds__StorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__StorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__StorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__StorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_tt__DeviceEntity(soap, d, a);
	soap_dup_PointerTotds__StorageConfigurationData(soap, &d->tds__StorageConfiguration::Data, &a->tds__StorageConfiguration::Data);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__StorageConfiguration(tds__StorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_tt__DeviceEntity(a);
	soap_del_PointerTotds__StorageConfigurationData(&a->tds__StorageConfiguration::Data);
}

SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__StorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__StorageConfiguration *p;
	size_t k = sizeof(tds__StorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__StorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__StorageConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__StorageConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__StorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__StorageConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__StorageConfiguration(soap, tag ? tag : "tds:StorageConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__StorageConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__StorageConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tds__StorageConfiguration * SOAP_FMAC4 soap_get_tds__StorageConfiguration(struct soap *soap, tds__StorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__StorageConfigurationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__StorageConfigurationData::LocalPath = NULL;
	this->tds__StorageConfigurationData::StorageUri = NULL;
	this->tds__StorageConfigurationData::User = NULL;
	this->tds__StorageConfigurationData::Extension = NULL;
	soap_default_std__string(soap, &this->tds__StorageConfigurationData::type);
	this->tds__StorageConfigurationData::Region = NULL;
}

void tds__StorageConfigurationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToxsd__anyURI(soap, &this->tds__StorageConfigurationData::LocalPath);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tds__StorageConfigurationData::StorageUri);
	soap_serialize_PointerTotds__UserCredential(soap, &this->tds__StorageConfigurationData::User);
	soap_serialize_PointerTo_tds__StorageConfigurationData_Extension(soap, &this->tds__StorageConfigurationData::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__StorageConfigurationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__StorageConfigurationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__StorageConfigurationData(struct soap *soap, const char *tag, int id, const tds__StorageConfigurationData *a, const char *type)
{
	soap_set_attr(soap, "type", soap_std__string2s(soap, ((tds__StorageConfigurationData*)a)->type), 1);
	if (((tds__StorageConfigurationData*)a)->Region)
	{	soap_set_attr(soap, "Region", soap_std__string2s(soap, *((tds__StorageConfigurationData*)a)->Region), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__StorageConfigurationData), type ? type : "tds:StorageConfigurationData"))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:LocalPath", -1, &a->tds__StorageConfigurationData::LocalPath, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tds:StorageUri", -1, &a->tds__StorageConfigurationData::StorageUri, ""))
		return soap->error;
	if (soap_out_PointerTotds__UserCredential(soap, "tds:User", -1, &a->tds__StorageConfigurationData::User, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", -1, &a->tds__StorageConfigurationData::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__StorageConfigurationData::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__StorageConfigurationData(soap, tag, this, type);
}

SOAP_FMAC3 tds__StorageConfigurationData * SOAP_FMAC4 soap_in_tds__StorageConfigurationData(struct soap *soap, const char *tag, tds__StorageConfigurationData *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__StorageConfigurationData*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__StorageConfigurationData)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__StorageConfigurationData *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2std__string(soap, soap_attr_value(soap, "type", 1, 3), &((tds__StorageConfigurationData*)a)->type))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "Region", 1, 0);
		if (t)
		{
			if (!(((tds__StorageConfigurationData*)a)->Region = soap_new_std__string(soap)))
				return NULL;
			if (soap_s2std__string(soap, t, ((tds__StorageConfigurationData*)a)->Region))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_LocalPath1 = 1;
	size_t soap_flag_StorageUri1 = 1;
	size_t soap_flag_User1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LocalPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:LocalPath", &a->tds__StorageConfigurationData::LocalPath, "xsd:anyURI"))
				{	soap_flag_LocalPath1--;
					continue;
				}
			}
			if (soap_flag_StorageUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tds:StorageUri", &a->tds__StorageConfigurationData::StorageUri, "xsd:anyURI"))
				{	soap_flag_StorageUri1--;
					continue;
				}
			}
			if (soap_flag_User1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__UserCredential(soap, "tds:User", &a->tds__StorageConfigurationData::User, "tds:UserCredential"))
				{	soap_flag_User1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StorageConfigurationData_Extension(soap, "tds:Extension", &a->tds__StorageConfigurationData::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tds__StorageConfigurationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__StorageConfigurationData, SOAP_TYPE_tds__StorageConfigurationData, sizeof(tds__StorageConfigurationData), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_dup_tds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *d, tds__StorageConfigurationData const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__StorageConfigurationData*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__StorageConfigurationData, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__StorageConfigurationData(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerToxsd__anyURI(soap, &d->tds__StorageConfigurationData::LocalPath, &a->tds__StorageConfigurationData::LocalPath);
	soap_dup_PointerToxsd__anyURI(soap, &d->tds__StorageConfigurationData::StorageUri, &a->tds__StorageConfigurationData::StorageUri);
	soap_dup_PointerTotds__UserCredential(soap, &d->tds__StorageConfigurationData::User, &a->tds__StorageConfigurationData::User);
	soap_dup_PointerTo_tds__StorageConfigurationData_Extension(soap, &d->tds__StorageConfigurationData::Extension, &a->tds__StorageConfigurationData::Extension);
	soap_dup_std__string(soap, &d->tds__StorageConfigurationData::type, &a->tds__StorageConfigurationData::type);
	soap_dup_PointerTostd__string(soap, &d->tds__StorageConfigurationData::Region, &a->tds__StorageConfigurationData::Region);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__StorageConfigurationData(tds__StorageConfigurationData const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerToxsd__anyURI(&a->tds__StorageConfigurationData::LocalPath);
	soap_del_PointerToxsd__anyURI(&a->tds__StorageConfigurationData::StorageUri);
	soap_del_PointerTotds__UserCredential(&a->tds__StorageConfigurationData::User);
	soap_del_PointerTo_tds__StorageConfigurationData_Extension(&a->tds__StorageConfigurationData::Extension);
	soap_del_std__string(&a->tds__StorageConfigurationData::type);
	soap_del_PointerTostd__string(&a->tds__StorageConfigurationData::Region);
}

SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__StorageConfigurationData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__StorageConfigurationData *p;
	size_t k = sizeof(tds__StorageConfigurationData);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__StorageConfigurationData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__StorageConfigurationData);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__StorageConfigurationData, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__StorageConfigurationData location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__StorageConfigurationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__StorageConfigurationData(soap, tag ? tag : "tds:StorageConfigurationData", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__StorageConfigurationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__StorageConfigurationData(soap, this, tag, type);
}

SOAP_FMAC3 tds__StorageConfigurationData * SOAP_FMAC4 soap_get_tds__StorageConfigurationData(struct soap *soap, tds__StorageConfigurationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__StorageConfigurationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__UserCredential::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->tds__UserCredential::UserName);
	this->tds__UserCredential::Password = NULL;
	this->tds__UserCredential::Extension = NULL;
}

void tds__UserCredential::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tds__UserCredential::UserName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->tds__UserCredential::UserName);
	soap_serialize_PointerTostd__string(soap, &this->tds__UserCredential::Password);
	soap_serialize_PointerTo_tds__UserCredential_Extension(soap, &this->tds__UserCredential::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__UserCredential::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__UserCredential(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__UserCredential(struct soap *soap, const char *tag, int id, const tds__UserCredential *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__UserCredential), type ? type : "tds:UserCredential"))
		return soap->error;
	if (soap_out_std__string(soap, "tds:UserName", -1, &a->tds__UserCredential::UserName, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tds:Password", -1, &a->tds__UserCredential::Password, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", -1, &a->tds__UserCredential::Extension, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__UserCredential::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__UserCredential(soap, tag, this, type);
}

SOAP_FMAC3 tds__UserCredential * SOAP_FMAC4 soap_in_tds__UserCredential(struct soap *soap, const char *tag, tds__UserCredential *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__UserCredential*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__UserCredential)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__UserCredential *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_UserName1 = 1;
	size_t soap_flag_Password1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UserName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_std__string(soap, "tds:UserName", &a->tds__UserCredential::UserName, "xsd:string"))
				{	soap_flag_UserName1--;
					continue;
				}
			}
			if (soap_flag_Password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tds:Password", &a->tds__UserCredential::Password, "xsd:string"))
				{	soap_flag_Password1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UserCredential_Extension(soap, "tds:Extension", &a->tds__UserCredential::Extension, ""))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_UserName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__UserCredential *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__UserCredential, SOAP_TYPE_tds__UserCredential, sizeof(tds__UserCredential), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_dup_tds__UserCredential(struct soap *soap, tds__UserCredential *d, tds__UserCredential const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__UserCredential*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__UserCredential, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__UserCredential(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->tds__UserCredential::UserName, &a->tds__UserCredential::UserName);
	soap_dup_PointerTostd__string(soap, &d->tds__UserCredential::Password, &a->tds__UserCredential::Password);
	soap_dup_PointerTo_tds__UserCredential_Extension(soap, &d->tds__UserCredential::Extension, &a->tds__UserCredential::Extension);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__UserCredential(tds__UserCredential const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->tds__UserCredential::UserName);
	soap_del_PointerTostd__string(&a->tds__UserCredential::Password);
	soap_del_PointerTo_tds__UserCredential_Extension(&a->tds__UserCredential::Extension);
}

SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__UserCredential(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__UserCredential *p;
	size_t k = sizeof(tds__UserCredential);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__UserCredential, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__UserCredential);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__UserCredential, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__UserCredential location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__UserCredential::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__UserCredential(soap, tag ? tag : "tds:UserCredential", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__UserCredential::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__UserCredential(soap, this, tag, type);
}

SOAP_FMAC3 tds__UserCredential * SOAP_FMAC4 soap_get_tds__UserCredential(struct soap *soap, tds__UserCredential *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__UserCredential(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__MiscCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__MiscCapabilities::AuxiliaryCommands = NULL;
}

void tds__MiscCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__MiscCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__MiscCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__MiscCapabilities(struct soap *soap, const char *tag, int id, const tds__MiscCapabilities *a, const char *type)
{
	if (((tds__MiscCapabilities*)a)->AuxiliaryCommands)
	{	soap_set_attr(soap, "AuxiliaryCommands", soap_tt__StringAttrList2s(soap, *((tds__MiscCapabilities*)a)->AuxiliaryCommands), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tds:MiscCapabilities");
}

void *tds__MiscCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__MiscCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__MiscCapabilities * SOAP_FMAC4 soap_in_tds__MiscCapabilities(struct soap *soap, const char *tag, tds__MiscCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__MiscCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__MiscCapabilities, sizeof(tds__MiscCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__MiscCapabilities)
		return (tds__MiscCapabilities *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "AuxiliaryCommands", 1, 0);
		if (t)
		{
			if (!(((tds__MiscCapabilities*)a)->AuxiliaryCommands = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__MiscCapabilities*)a)->AuxiliaryCommands))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_dup_tds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *d, tds__MiscCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__MiscCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__MiscCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__MiscCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTott__StringAttrList(soap, &d->tds__MiscCapabilities::AuxiliaryCommands, &a->tds__MiscCapabilities::AuxiliaryCommands);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__MiscCapabilities(tds__MiscCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTott__StringAttrList(&a->tds__MiscCapabilities::AuxiliaryCommands);
}

SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__MiscCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__MiscCapabilities *p;
	size_t k = sizeof(tds__MiscCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__MiscCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__MiscCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__MiscCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__MiscCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__MiscCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__MiscCapabilities(soap, tag ? tag : "tds:MiscCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__MiscCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__MiscCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__MiscCapabilities * SOAP_FMAC4 soap_get_tds__MiscCapabilities(struct soap *soap, tds__MiscCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__SystemCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__SystemCapabilities::DiscoveryResolve = NULL;
	this->tds__SystemCapabilities::DiscoveryBye = NULL;
	this->tds__SystemCapabilities::RemoteDiscovery = NULL;
	this->tds__SystemCapabilities::SystemBackup = NULL;
	this->tds__SystemCapabilities::SystemLogging = NULL;
	this->tds__SystemCapabilities::FirmwareUpgrade = NULL;
	this->tds__SystemCapabilities::HttpFirmwareUpgrade = NULL;
	this->tds__SystemCapabilities::HttpSystemBackup = NULL;
	this->tds__SystemCapabilities::HttpSystemLogging = NULL;
	this->tds__SystemCapabilities::HttpSupportInformation = NULL;
	this->tds__SystemCapabilities::StorageConfiguration = NULL;
	this->tds__SystemCapabilities::MaxStorageConfigurations = NULL;
	this->tds__SystemCapabilities::GeoLocationEntries = NULL;
	this->tds__SystemCapabilities::AutoGeo = NULL;
	this->tds__SystemCapabilities::StorageTypesSupported = NULL;
	this->tds__SystemCapabilities::DiscoveryNotSupported = NULL;
	this->tds__SystemCapabilities::NetworkConfigNotSupported = NULL;
	this->tds__SystemCapabilities::UserConfigNotSupported = NULL;
	this->tds__SystemCapabilities::Addons = NULL;
}

void tds__SystemCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__SystemCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__SystemCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SystemCapabilities(struct soap *soap, const char *tag, int id, const tds__SystemCapabilities *a, const char *type)
{
	if (((tds__SystemCapabilities*)a)->DiscoveryResolve)
	{	soap_set_attr(soap, "DiscoveryResolve", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryResolve), 1);
	}
	if (((tds__SystemCapabilities*)a)->DiscoveryBye)
	{	soap_set_attr(soap, "DiscoveryBye", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryBye), 1);
	}
	if (((tds__SystemCapabilities*)a)->RemoteDiscovery)
	{	soap_set_attr(soap, "RemoteDiscovery", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->RemoteDiscovery), 1);
	}
	if (((tds__SystemCapabilities*)a)->SystemBackup)
	{	soap_set_attr(soap, "SystemBackup", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->SystemBackup), 1);
	}
	if (((tds__SystemCapabilities*)a)->SystemLogging)
	{	soap_set_attr(soap, "SystemLogging", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->SystemLogging), 1);
	}
	if (((tds__SystemCapabilities*)a)->FirmwareUpgrade)
	{	soap_set_attr(soap, "FirmwareUpgrade", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->FirmwareUpgrade), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade)
	{	soap_set_attr(soap, "HttpFirmwareUpgrade", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSystemBackup)
	{	soap_set_attr(soap, "HttpSystemBackup", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSystemBackup), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSystemLogging)
	{	soap_set_attr(soap, "HttpSystemLogging", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSystemLogging), 1);
	}
	if (((tds__SystemCapabilities*)a)->HttpSupportInformation)
	{	soap_set_attr(soap, "HttpSupportInformation", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->HttpSupportInformation), 1);
	}
	if (((tds__SystemCapabilities*)a)->StorageConfiguration)
	{	soap_set_attr(soap, "StorageConfiguration", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->StorageConfiguration), 1);
	}
	if (((tds__SystemCapabilities*)a)->MaxStorageConfigurations)
	{	soap_set_attr(soap, "MaxStorageConfigurations", soap_int2s(soap, *((tds__SystemCapabilities*)a)->MaxStorageConfigurations), 1);
	}
	if (((tds__SystemCapabilities*)a)->GeoLocationEntries)
	{	soap_set_attr(soap, "GeoLocationEntries", soap_int2s(soap, *((tds__SystemCapabilities*)a)->GeoLocationEntries), 1);
	}
	if (((tds__SystemCapabilities*)a)->AutoGeo)
	{	soap_set_attr(soap, "AutoGeo", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->AutoGeo), 1);
	}
	if (((tds__SystemCapabilities*)a)->StorageTypesSupported)
	{	soap_set_attr(soap, "StorageTypesSupported", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->StorageTypesSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->DiscoveryNotSupported)
	{	soap_set_attr(soap, "DiscoveryNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->DiscoveryNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->NetworkConfigNotSupported)
	{	soap_set_attr(soap, "NetworkConfigNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->NetworkConfigNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->UserConfigNotSupported)
	{	soap_set_attr(soap, "UserConfigNotSupported", soap_bool2s(soap, *((tds__SystemCapabilities*)a)->UserConfigNotSupported), 1);
	}
	if (((tds__SystemCapabilities*)a)->Addons)
	{	soap_set_attr(soap, "Addons", soap_tt__StringAttrList2s(soap, *((tds__SystemCapabilities*)a)->Addons), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tds:SystemCapabilities");
}

void *tds__SystemCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__SystemCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__SystemCapabilities * SOAP_FMAC4 soap_in_tds__SystemCapabilities(struct soap *soap, const char *tag, tds__SystemCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__SystemCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SystemCapabilities, sizeof(tds__SystemCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__SystemCapabilities)
		return (tds__SystemCapabilities *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "DiscoveryResolve", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryResolve = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryResolve))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DiscoveryBye", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryBye = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryBye))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteDiscovery", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->RemoteDiscovery = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->RemoteDiscovery))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemBackup", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->SystemBackup = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->SystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SystemLogging", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->SystemLogging = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->SystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "FirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->FirmwareUpgrade = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->FirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpFirmwareUpgrade", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpFirmwareUpgrade))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemBackup", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSystemBackup = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSystemBackup))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSystemLogging", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSystemLogging = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSystemLogging))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpSupportInformation", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->HttpSupportInformation = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->HttpSupportInformation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StorageConfiguration", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->StorageConfiguration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->StorageConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxStorageConfigurations", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->MaxStorageConfigurations = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SystemCapabilities*)a)->MaxStorageConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoLocationEntries", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->GeoLocationEntries = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SystemCapabilities*)a)->GeoLocationEntries))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AutoGeo", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->AutoGeo = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->AutoGeo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StorageTypesSupported", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->StorageTypesSupported = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->StorageTypesSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DiscoveryNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->DiscoveryNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->DiscoveryNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NetworkConfigNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->NetworkConfigNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->NetworkConfigNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "UserConfigNotSupported", 5, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->UserConfigNotSupported = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SystemCapabilities*)a)->UserConfigNotSupported))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Addons", 1, 0);
		if (t)
		{
			if (!(((tds__SystemCapabilities*)a)->Addons = soap_new_tt__StringAttrList(soap)))
				return NULL;
			if (soap_s2tt__StringAttrList(soap, t, ((tds__SystemCapabilities*)a)->Addons))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_dup_tds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *d, tds__SystemCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__SystemCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__SystemCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__SystemCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::DiscoveryResolve, &a->tds__SystemCapabilities::DiscoveryResolve);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::DiscoveryBye, &a->tds__SystemCapabilities::DiscoveryBye);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::RemoteDiscovery, &a->tds__SystemCapabilities::RemoteDiscovery);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::SystemBackup, &a->tds__SystemCapabilities::SystemBackup);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::SystemLogging, &a->tds__SystemCapabilities::SystemLogging);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::FirmwareUpgrade, &a->tds__SystemCapabilities::FirmwareUpgrade);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::HttpFirmwareUpgrade, &a->tds__SystemCapabilities::HttpFirmwareUpgrade);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::HttpSystemBackup, &a->tds__SystemCapabilities::HttpSystemBackup);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::HttpSystemLogging, &a->tds__SystemCapabilities::HttpSystemLogging);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::HttpSupportInformation, &a->tds__SystemCapabilities::HttpSupportInformation);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::StorageConfiguration, &a->tds__SystemCapabilities::StorageConfiguration);
	soap_dup_PointerToint(soap, &d->tds__SystemCapabilities::MaxStorageConfigurations, &a->tds__SystemCapabilities::MaxStorageConfigurations);
	soap_dup_PointerToint(soap, &d->tds__SystemCapabilities::GeoLocationEntries, &a->tds__SystemCapabilities::GeoLocationEntries);
	soap_dup_PointerTott__StringAttrList(soap, &d->tds__SystemCapabilities::AutoGeo, &a->tds__SystemCapabilities::AutoGeo);
	soap_dup_PointerTott__StringAttrList(soap, &d->tds__SystemCapabilities::StorageTypesSupported, &a->tds__SystemCapabilities::StorageTypesSupported);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::DiscoveryNotSupported, &a->tds__SystemCapabilities::DiscoveryNotSupported);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::NetworkConfigNotSupported, &a->tds__SystemCapabilities::NetworkConfigNotSupported);
	soap_dup_PointerTobool(soap, &d->tds__SystemCapabilities::UserConfigNotSupported, &a->tds__SystemCapabilities::UserConfigNotSupported);
	soap_dup_PointerTott__StringAttrList(soap, &d->tds__SystemCapabilities::Addons, &a->tds__SystemCapabilities::Addons);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__SystemCapabilities(tds__SystemCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::DiscoveryResolve);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::DiscoveryBye);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::RemoteDiscovery);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::SystemBackup);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::SystemLogging);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::FirmwareUpgrade);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::HttpFirmwareUpgrade);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::HttpSystemBackup);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::HttpSystemLogging);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::HttpSupportInformation);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::StorageConfiguration);
	soap_del_PointerToint(&a->tds__SystemCapabilities::MaxStorageConfigurations);
	soap_del_PointerToint(&a->tds__SystemCapabilities::GeoLocationEntries);
	soap_del_PointerTott__StringAttrList(&a->tds__SystemCapabilities::AutoGeo);
	soap_del_PointerTott__StringAttrList(&a->tds__SystemCapabilities::StorageTypesSupported);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::DiscoveryNotSupported);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::NetworkConfigNotSupported);
	soap_del_PointerTobool(&a->tds__SystemCapabilities::UserConfigNotSupported);
	soap_del_PointerTott__StringAttrList(&a->tds__SystemCapabilities::Addons);
}

SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__SystemCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__SystemCapabilities *p;
	size_t k = sizeof(tds__SystemCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__SystemCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__SystemCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__SystemCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__SystemCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__SystemCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__SystemCapabilities(soap, tag ? tag : "tds:SystemCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__SystemCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__SystemCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__SystemCapabilities * SOAP_FMAC4 soap_get_tds__SystemCapabilities(struct soap *soap, tds__SystemCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__SecurityCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__SecurityCapabilities::TLS1_x002e0 = NULL;
	this->tds__SecurityCapabilities::TLS1_x002e1 = NULL;
	this->tds__SecurityCapabilities::TLS1_x002e2 = NULL;
	this->tds__SecurityCapabilities::OnboardKeyGeneration = NULL;
	this->tds__SecurityCapabilities::AccessPolicyConfig = NULL;
	this->tds__SecurityCapabilities::DefaultAccessPolicy = NULL;
	this->tds__SecurityCapabilities::Dot1X = NULL;
	this->tds__SecurityCapabilities::RemoteUserHandling = NULL;
	this->tds__SecurityCapabilities::X_x002e509Token = NULL;
	this->tds__SecurityCapabilities::SAMLToken = NULL;
	this->tds__SecurityCapabilities::KerberosToken = NULL;
	this->tds__SecurityCapabilities::UsernameToken = NULL;
	this->tds__SecurityCapabilities::HttpDigest = NULL;
	this->tds__SecurityCapabilities::RELToken = NULL;
	this->tds__SecurityCapabilities::SupportedEAPMethods = NULL;
	this->tds__SecurityCapabilities::MaxUsers = NULL;
	this->tds__SecurityCapabilities::MaxUserNameLength = NULL;
	this->tds__SecurityCapabilities::MaxPasswordLength = NULL;
	this->tds__SecurityCapabilities::SecurityPolicies = NULL;
	this->tds__SecurityCapabilities::MaxPasswordHistory = NULL;
	this->tds__SecurityCapabilities::HashingAlgorithms = NULL;
}

void tds__SecurityCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__SecurityCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__SecurityCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__SecurityCapabilities(struct soap *soap, const char *tag, int id, const tds__SecurityCapabilities *a, const char *type)
{
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e0)
	{	soap_set_attr(soap, "TLS1.0", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e0), 1);
	}
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e1)
	{	soap_set_attr(soap, "TLS1.1", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e1), 1);
	}
	if (((tds__SecurityCapabilities*)a)->TLS1_x002e2)
	{	soap_set_attr(soap, "TLS1.2", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->TLS1_x002e2), 1);
	}
	if (((tds__SecurityCapabilities*)a)->OnboardKeyGeneration)
	{	soap_set_attr(soap, "OnboardKeyGeneration", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->OnboardKeyGeneration), 1);
	}
	if (((tds__SecurityCapabilities*)a)->AccessPolicyConfig)
	{	soap_set_attr(soap, "AccessPolicyConfig", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->AccessPolicyConfig), 1);
	}
	if (((tds__SecurityCapabilities*)a)->DefaultAccessPolicy)
	{	soap_set_attr(soap, "DefaultAccessPolicy", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->DefaultAccessPolicy), 1);
	}
	if (((tds__SecurityCapabilities*)a)->Dot1X)
	{	soap_set_attr(soap, "Dot1X", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->Dot1X), 1);
	}
	if (((tds__SecurityCapabilities*)a)->RemoteUserHandling)
	{	soap_set_attr(soap, "RemoteUserHandling", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->RemoteUserHandling), 1);
	}
	if (((tds__SecurityCapabilities*)a)->X_x002e509Token)
	{	soap_set_attr(soap, "X.509Token", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->X_x002e509Token), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SAMLToken)
	{	soap_set_attr(soap, "SAMLToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->SAMLToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->KerberosToken)
	{	soap_set_attr(soap, "KerberosToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->KerberosToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->UsernameToken)
	{	soap_set_attr(soap, "UsernameToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->UsernameToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->HttpDigest)
	{	soap_set_attr(soap, "HttpDigest", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->HttpDigest), 1);
	}
	if (((tds__SecurityCapabilities*)a)->RELToken)
	{	soap_set_attr(soap, "RELToken", soap_bool2s(soap, *((tds__SecurityCapabilities*)a)->RELToken), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SupportedEAPMethods)
	{	soap_set_attr(soap, "SupportedEAPMethods", soap_tt__IntList2s(soap, *((tds__SecurityCapabilities*)a)->SupportedEAPMethods), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxUsers)
	{	soap_set_attr(soap, "MaxUsers", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxUsers), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxUserNameLength)
	{	soap_set_attr(soap, "MaxUserNameLength", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxUserNameLength), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxPasswordLength)
	{	soap_set_attr(soap, "MaxPasswordLength", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxPasswordLength), 1);
	}
	if (((tds__SecurityCapabilities*)a)->SecurityPolicies)
	{	soap_set_attr(soap, "SecurityPolicies", soap_tt__StringList2s(soap, *((tds__SecurityCapabilities*)a)->SecurityPolicies), 1);
	}
	if (((tds__SecurityCapabilities*)a)->MaxPasswordHistory)
	{	soap_set_attr(soap, "MaxPasswordHistory", soap_int2s(soap, *((tds__SecurityCapabilities*)a)->MaxPasswordHistory), 1);
	}
	if (((tds__SecurityCapabilities*)a)->HashingAlgorithms)
	{	soap_set_attr(soap, "HashingAlgorithms", soap_tt__StringList2s(soap, *((tds__SecurityCapabilities*)a)->HashingAlgorithms), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tds:SecurityCapabilities");
}

void *tds__SecurityCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__SecurityCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__SecurityCapabilities * SOAP_FMAC4 soap_in_tds__SecurityCapabilities(struct soap *soap, const char *tag, tds__SecurityCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__SecurityCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(tds__SecurityCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__SecurityCapabilities)
		return (tds__SecurityCapabilities *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "TLS1.0", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e0 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e0))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.1", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e1 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e1))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "TLS1.2", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->TLS1_x002e2 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->TLS1_x002e2))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "OnboardKeyGeneration", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->OnboardKeyGeneration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->OnboardKeyGeneration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "AccessPolicyConfig", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->AccessPolicyConfig = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->AccessPolicyConfig))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DefaultAccessPolicy", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->DefaultAccessPolicy = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->DefaultAccessPolicy))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1X", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->Dot1X = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->Dot1X))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RemoteUserHandling", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->RemoteUserHandling = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->RemoteUserHandling))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "X.509Token", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->X_x002e509Token = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->X_x002e509Token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SAMLToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SAMLToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->SAMLToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "KerberosToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->KerberosToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->KerberosToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "UsernameToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->UsernameToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->UsernameToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HttpDigest", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->HttpDigest = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->HttpDigest))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "RELToken", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->RELToken = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__SecurityCapabilities*)a)->RELToken))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SupportedEAPMethods", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SupportedEAPMethods = soap_new_tt__IntList(soap)))
				return NULL;
			if (soap_s2tt__IntList(soap, t, ((tds__SecurityCapabilities*)a)->SupportedEAPMethods))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxUsers", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxUsers = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxUsers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxUserNameLength", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxUserNameLength = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxUserNameLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPasswordLength", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxPasswordLength = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxPasswordLength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "SecurityPolicies", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->SecurityPolicies = soap_new_tt__StringList(soap)))
				return NULL;
			if (soap_s2tt__StringList(soap, t, ((tds__SecurityCapabilities*)a)->SecurityPolicies))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MaxPasswordHistory", 5, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->MaxPasswordHistory = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__SecurityCapabilities*)a)->MaxPasswordHistory))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HashingAlgorithms", 1, 0);
		if (t)
		{
			if (!(((tds__SecurityCapabilities*)a)->HashingAlgorithms = soap_new_tt__StringList(soap)))
				return NULL;
			if (soap_s2tt__StringList(soap, t, ((tds__SecurityCapabilities*)a)->HashingAlgorithms))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_dup_tds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *d, tds__SecurityCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__SecurityCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__SecurityCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__SecurityCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::TLS1_x002e0, &a->tds__SecurityCapabilities::TLS1_x002e0);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::TLS1_x002e1, &a->tds__SecurityCapabilities::TLS1_x002e1);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::TLS1_x002e2, &a->tds__SecurityCapabilities::TLS1_x002e2);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::OnboardKeyGeneration, &a->tds__SecurityCapabilities::OnboardKeyGeneration);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::AccessPolicyConfig, &a->tds__SecurityCapabilities::AccessPolicyConfig);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::DefaultAccessPolicy, &a->tds__SecurityCapabilities::DefaultAccessPolicy);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::Dot1X, &a->tds__SecurityCapabilities::Dot1X);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::RemoteUserHandling, &a->tds__SecurityCapabilities::RemoteUserHandling);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::X_x002e509Token, &a->tds__SecurityCapabilities::X_x002e509Token);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::SAMLToken, &a->tds__SecurityCapabilities::SAMLToken);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::KerberosToken, &a->tds__SecurityCapabilities::KerberosToken);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::UsernameToken, &a->tds__SecurityCapabilities::UsernameToken);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::HttpDigest, &a->tds__SecurityCapabilities::HttpDigest);
	soap_dup_PointerTobool(soap, &d->tds__SecurityCapabilities::RELToken, &a->tds__SecurityCapabilities::RELToken);
	soap_dup_PointerTott__IntList(soap, &d->tds__SecurityCapabilities::SupportedEAPMethods, &a->tds__SecurityCapabilities::SupportedEAPMethods);
	soap_dup_PointerToint(soap, &d->tds__SecurityCapabilities::MaxUsers, &a->tds__SecurityCapabilities::MaxUsers);
	soap_dup_PointerToint(soap, &d->tds__SecurityCapabilities::MaxUserNameLength, &a->tds__SecurityCapabilities::MaxUserNameLength);
	soap_dup_PointerToint(soap, &d->tds__SecurityCapabilities::MaxPasswordLength, &a->tds__SecurityCapabilities::MaxPasswordLength);
	soap_dup_PointerTott__StringList(soap, &d->tds__SecurityCapabilities::SecurityPolicies, &a->tds__SecurityCapabilities::SecurityPolicies);
	soap_dup_PointerToint(soap, &d->tds__SecurityCapabilities::MaxPasswordHistory, &a->tds__SecurityCapabilities::MaxPasswordHistory);
	soap_dup_PointerTott__StringList(soap, &d->tds__SecurityCapabilities::HashingAlgorithms, &a->tds__SecurityCapabilities::HashingAlgorithms);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__SecurityCapabilities(tds__SecurityCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::TLS1_x002e0);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::TLS1_x002e1);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::TLS1_x002e2);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::OnboardKeyGeneration);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::AccessPolicyConfig);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::DefaultAccessPolicy);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::Dot1X);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::RemoteUserHandling);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::X_x002e509Token);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::SAMLToken);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::KerberosToken);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::UsernameToken);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::HttpDigest);
	soap_del_PointerTobool(&a->tds__SecurityCapabilities::RELToken);
	soap_del_PointerTott__IntList(&a->tds__SecurityCapabilities::SupportedEAPMethods);
	soap_del_PointerToint(&a->tds__SecurityCapabilities::MaxUsers);
	soap_del_PointerToint(&a->tds__SecurityCapabilities::MaxUserNameLength);
	soap_del_PointerToint(&a->tds__SecurityCapabilities::MaxPasswordLength);
	soap_del_PointerTott__StringList(&a->tds__SecurityCapabilities::SecurityPolicies);
	soap_del_PointerToint(&a->tds__SecurityCapabilities::MaxPasswordHistory);
	soap_del_PointerTott__StringList(&a->tds__SecurityCapabilities::HashingAlgorithms);
}

SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__SecurityCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__SecurityCapabilities *p;
	size_t k = sizeof(tds__SecurityCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__SecurityCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__SecurityCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__SecurityCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__SecurityCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__SecurityCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__SecurityCapabilities(soap, tag ? tag : "tds:SecurityCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__SecurityCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__SecurityCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__SecurityCapabilities * SOAP_FMAC4 soap_get_tds__SecurityCapabilities(struct soap *soap, tds__SecurityCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__NetworkCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__NetworkCapabilities::IPFilter = NULL;
	this->tds__NetworkCapabilities::ZeroConfiguration = NULL;
	this->tds__NetworkCapabilities::IPVersion6 = NULL;
	this->tds__NetworkCapabilities::DynDNS = NULL;
	this->tds__NetworkCapabilities::Dot11Configuration = NULL;
	this->tds__NetworkCapabilities::Dot1XConfigurations = NULL;
	this->tds__NetworkCapabilities::HostnameFromDHCP = NULL;
	this->tds__NetworkCapabilities::NTP = NULL;
	this->tds__NetworkCapabilities::DHCPv6 = NULL;
}

void tds__NetworkCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__NetworkCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__NetworkCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__NetworkCapabilities(struct soap *soap, const char *tag, int id, const tds__NetworkCapabilities *a, const char *type)
{
	if (((tds__NetworkCapabilities*)a)->IPFilter)
	{	soap_set_attr(soap, "IPFilter", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->IPFilter), 1);
	}
	if (((tds__NetworkCapabilities*)a)->ZeroConfiguration)
	{	soap_set_attr(soap, "ZeroConfiguration", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->ZeroConfiguration), 1);
	}
	if (((tds__NetworkCapabilities*)a)->IPVersion6)
	{	soap_set_attr(soap, "IPVersion6", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->IPVersion6), 1);
	}
	if (((tds__NetworkCapabilities*)a)->DynDNS)
	{	soap_set_attr(soap, "DynDNS", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->DynDNS), 1);
	}
	if (((tds__NetworkCapabilities*)a)->Dot11Configuration)
	{	soap_set_attr(soap, "Dot11Configuration", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->Dot11Configuration), 1);
	}
	if (((tds__NetworkCapabilities*)a)->Dot1XConfigurations)
	{	soap_set_attr(soap, "Dot1XConfigurations", soap_int2s(soap, *((tds__NetworkCapabilities*)a)->Dot1XConfigurations), 1);
	}
	if (((tds__NetworkCapabilities*)a)->HostnameFromDHCP)
	{	soap_set_attr(soap, "HostnameFromDHCP", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->HostnameFromDHCP), 1);
	}
	if (((tds__NetworkCapabilities*)a)->NTP)
	{	soap_set_attr(soap, "NTP", soap_int2s(soap, *((tds__NetworkCapabilities*)a)->NTP), 1);
	}
	if (((tds__NetworkCapabilities*)a)->DHCPv6)
	{	soap_set_attr(soap, "DHCPv6", soap_bool2s(soap, *((tds__NetworkCapabilities*)a)->DHCPv6), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, "tds:NetworkCapabilities");
}

void *tds__NetworkCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__NetworkCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__NetworkCapabilities * SOAP_FMAC4 soap_in_tds__NetworkCapabilities(struct soap *soap, const char *tag, tds__NetworkCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tds__NetworkCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(tds__NetworkCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__NetworkCapabilities)
		return (tds__NetworkCapabilities *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "IPFilter", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->IPFilter = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->IPFilter))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "ZeroConfiguration", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->ZeroConfiguration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->ZeroConfiguration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "IPVersion6", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->IPVersion6 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->IPVersion6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DynDNS", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->DynDNS = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->DynDNS))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot11Configuration", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->Dot11Configuration = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->Dot11Configuration))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Dot1XConfigurations", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->Dot1XConfigurations = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__NetworkCapabilities*)a)->Dot1XConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "HostnameFromDHCP", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->HostnameFromDHCP = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->HostnameFromDHCP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "NTP", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->NTP = (int *)soap_malloc(soap, sizeof(int))))
				return NULL;
			if (soap_s2int(soap, t, ((tds__NetworkCapabilities*)a)->NTP))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "DHCPv6", 5, 0);
		if (t)
		{
			if (!(((tds__NetworkCapabilities*)a)->DHCPv6 = (bool *)soap_malloc(soap, sizeof(bool))))
				return NULL;
			if (soap_s2bool(soap, t, ((tds__NetworkCapabilities*)a)->DHCPv6))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_dup_tds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *d, tds__NetworkCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__NetworkCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__NetworkCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__NetworkCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::IPFilter, &a->tds__NetworkCapabilities::IPFilter);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::ZeroConfiguration, &a->tds__NetworkCapabilities::ZeroConfiguration);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::IPVersion6, &a->tds__NetworkCapabilities::IPVersion6);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::DynDNS, &a->tds__NetworkCapabilities::DynDNS);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::Dot11Configuration, &a->tds__NetworkCapabilities::Dot11Configuration);
	soap_dup_PointerToint(soap, &d->tds__NetworkCapabilities::Dot1XConfigurations, &a->tds__NetworkCapabilities::Dot1XConfigurations);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::HostnameFromDHCP, &a->tds__NetworkCapabilities::HostnameFromDHCP);
	soap_dup_PointerToint(soap, &d->tds__NetworkCapabilities::NTP, &a->tds__NetworkCapabilities::NTP);
	soap_dup_PointerTobool(soap, &d->tds__NetworkCapabilities::DHCPv6, &a->tds__NetworkCapabilities::DHCPv6);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__NetworkCapabilities(tds__NetworkCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::IPFilter);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::ZeroConfiguration);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::IPVersion6);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::DynDNS);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::Dot11Configuration);
	soap_del_PointerToint(&a->tds__NetworkCapabilities::Dot1XConfigurations);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::HostnameFromDHCP);
	soap_del_PointerToint(&a->tds__NetworkCapabilities::NTP);
	soap_del_PointerTobool(&a->tds__NetworkCapabilities::DHCPv6);
}

SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__NetworkCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__NetworkCapabilities *p;
	size_t k = sizeof(tds__NetworkCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__NetworkCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__NetworkCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__NetworkCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__NetworkCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__NetworkCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__NetworkCapabilities(soap, tag ? tag : "tds:NetworkCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__NetworkCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__NetworkCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__NetworkCapabilities * SOAP_FMAC4 soap_get_tds__NetworkCapabilities(struct soap *soap, tds__NetworkCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__DeviceServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tds__DeviceServiceCapabilities::Network = NULL;
	this->tds__DeviceServiceCapabilities::Security = NULL;
	this->tds__DeviceServiceCapabilities::System = NULL;
	this->tds__DeviceServiceCapabilities::Misc = NULL;
}

void tds__DeviceServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotds__NetworkCapabilities(soap, &this->tds__DeviceServiceCapabilities::Network);
	soap_serialize_PointerTotds__SecurityCapabilities(soap, &this->tds__DeviceServiceCapabilities::Security);
	soap_serialize_PointerTotds__SystemCapabilities(soap, &this->tds__DeviceServiceCapabilities::System);
	soap_serialize_PointerTotds__MiscCapabilities(soap, &this->tds__DeviceServiceCapabilities::Misc);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__DeviceServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, const tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__DeviceServiceCapabilities), type ? type : "tds:DeviceServiceCapabilities"))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::Network)
	{	if (soap_element_empty(soap, "tds:Network", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__NetworkCapabilities(soap, "tds:Network", -1, &a->tds__DeviceServiceCapabilities::Network, ""))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::Security)
	{	if (soap_element_empty(soap, "tds:Security", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SecurityCapabilities(soap, "tds:Security", -1, &a->tds__DeviceServiceCapabilities::Security, ""))
		return soap->error;
	if (!a->tds__DeviceServiceCapabilities::System)
	{	if (soap_element_empty(soap, "tds:System", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotds__SystemCapabilities(soap, "tds:System", -1, &a->tds__DeviceServiceCapabilities::System, ""))
		return soap->error;
	if (soap_out_PointerTotds__MiscCapabilities(soap, "tds:Misc", -1, &a->tds__DeviceServiceCapabilities::Misc, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__DeviceServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__DeviceServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_in_tds__DeviceServiceCapabilities(struct soap *soap, const char *tag, tds__DeviceServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__DeviceServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__DeviceServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__DeviceServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Network1 = 1;
	size_t soap_flag_Security1 = 1;
	size_t soap_flag_System1 = 1;
	size_t soap_flag_Misc1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Network1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__NetworkCapabilities(soap, "tds:Network", &a->tds__DeviceServiceCapabilities::Network, "tds:NetworkCapabilities"))
				{	soap_flag_Network1--;
					continue;
				}
			}
			if (soap_flag_Security1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SecurityCapabilities(soap, "tds:Security", &a->tds__DeviceServiceCapabilities::Security, "tds:SecurityCapabilities"))
				{	soap_flag_Security1--;
					continue;
				}
			}
			if (soap_flag_System1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__SystemCapabilities(soap, "tds:System", &a->tds__DeviceServiceCapabilities::System, "tds:SystemCapabilities"))
				{	soap_flag_System1--;
					continue;
				}
			}
			if (soap_flag_Misc1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotds__MiscCapabilities(soap, "tds:Misc", &a->tds__DeviceServiceCapabilities::Misc, "tds:MiscCapabilities"))
				{	soap_flag_Misc1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->tds__DeviceServiceCapabilities::Network || !a->tds__DeviceServiceCapabilities::Security || !a->tds__DeviceServiceCapabilities::System))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__DeviceServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__DeviceServiceCapabilities, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(tds__DeviceServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_dup_tds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *d, tds__DeviceServiceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__DeviceServiceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__DeviceServiceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__DeviceServiceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_PointerTotds__NetworkCapabilities(soap, &d->tds__DeviceServiceCapabilities::Network, &a->tds__DeviceServiceCapabilities::Network);
	soap_dup_PointerTotds__SecurityCapabilities(soap, &d->tds__DeviceServiceCapabilities::Security, &a->tds__DeviceServiceCapabilities::Security);
	soap_dup_PointerTotds__SystemCapabilities(soap, &d->tds__DeviceServiceCapabilities::System, &a->tds__DeviceServiceCapabilities::System);
	soap_dup_PointerTotds__MiscCapabilities(soap, &d->tds__DeviceServiceCapabilities::Misc, &a->tds__DeviceServiceCapabilities::Misc);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__DeviceServiceCapabilities(tds__DeviceServiceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_PointerTotds__NetworkCapabilities(&a->tds__DeviceServiceCapabilities::Network);
	soap_del_PointerTotds__SecurityCapabilities(&a->tds__DeviceServiceCapabilities::Security);
	soap_del_PointerTotds__SystemCapabilities(&a->tds__DeviceServiceCapabilities::System);
	soap_del_PointerTotds__MiscCapabilities(&a->tds__DeviceServiceCapabilities::Misc);
}

SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__DeviceServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__DeviceServiceCapabilities *p;
	size_t k = sizeof(tds__DeviceServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__DeviceServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__DeviceServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__DeviceServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__DeviceServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__DeviceServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__DeviceServiceCapabilities(soap, tag ? tag : "tds:DeviceServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__DeviceServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__DeviceServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 tds__DeviceServiceCapabilities * SOAP_FMAC4 soap_get_tds__DeviceServiceCapabilities(struct soap *soap, tds__DeviceServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tds__Service::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->tds__Service::Namespace);
	soap_default_xsd__anyURI(soap, &this->tds__Service::XAddr);
	this->tds__Service::Capabilities = NULL;
	this->tds__Service::Version = NULL;
}

void tds__Service::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tds__Service::Namespace, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tds__Service::Namespace);
	soap_embedded(soap, &this->tds__Service::XAddr, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tds__Service::XAddr);
	soap_serialize_PointerTo_tds__Service_Capabilities(soap, &this->tds__Service::Capabilities);
	soap_serialize_PointerTott__OnvifVersion(soap, &this->tds__Service::Version);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tds__Service::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tds__Service(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__Service(struct soap *soap, const char *tag, int id, const tds__Service *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tds__Service), type ? type : "tds:Service"))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:Namespace", -1, &a->tds__Service::Namespace, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:XAddr", -1, &a->tds__Service::XAddr, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", -1, &a->tds__Service::Capabilities, ""))
		return soap->error;
	if (!a->tds__Service::Version)
	{	if (soap_element_empty(soap, "tds:Version", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__OnvifVersion(soap, "tds:Version", -1, &a->tds__Service::Version, ""))
		return soap->error;
	if (soap_outliteral(soap, "-item", (char*const*)&a->xsd__anyType::__item, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tds__Service::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tds__Service(soap, tag, this, type);
}

SOAP_FMAC3 tds__Service * SOAP_FMAC4 soap_in_tds__Service(struct soap *soap, const char *tag, tds__Service *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tds__Service*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tds__Service, sizeof(tds__Service), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tds__Service)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tds__Service *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Namespace1 = 1;
	size_t soap_flag_XAddr1 = 1;
	size_t soap_flag_Capabilities1 = 1;
	size_t soap_flag_Version1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Namespace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:Namespace", &a->tds__Service::Namespace, "xsd:anyURI"))
				{	soap_flag_Namespace1--;
					continue;
				}
			}
			if (soap_flag_XAddr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tds:XAddr", &a->tds__Service::XAddr, "xsd:anyURI"))
				{	soap_flag_XAddr1--;
					continue;
				}
			}
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__Service_Capabilities(soap, "tds:Capabilities", &a->tds__Service::Capabilities, ""))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			if (soap_flag_Version1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__OnvifVersion(soap, "tds:Version", &a->tds__Service::Version, "tt:OnvifVersion"))
				{	soap_flag_Version1--;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-item", (char**)&a->xsd__anyType::__item))
				{	soap_flag___item2--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_Namespace1 > 0 || soap_flag_XAddr1 > 0 || !a->tds__Service::Version))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tds__Service *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tds__Service, SOAP_TYPE_tds__Service, sizeof(tds__Service), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_dup_tds__Service(struct soap *soap, tds__Service *d, tds__Service const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (tds__Service*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_tds__Service, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_tds__Service(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->tds__Service::Namespace, &a->tds__Service::Namespace);
	soap_dup_xsd__anyURI(soap, &d->tds__Service::XAddr, &a->tds__Service::XAddr);
	soap_dup_PointerTo_tds__Service_Capabilities(soap, &d->tds__Service::Capabilities, &a->tds__Service::Capabilities);
	soap_dup_PointerTott__OnvifVersion(soap, &d->tds__Service::Version, &a->tds__Service::Version);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_tds__Service(tds__Service const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->tds__Service::Namespace);
	soap_del_xsd__anyURI(&a->tds__Service::XAddr);
	soap_del_PointerTo_tds__Service_Capabilities(&a->tds__Service::Capabilities);
	soap_del_PointerTott__OnvifVersion(&a->tds__Service::Version);
}

SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tds__Service(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tds__Service *p;
	size_t k = sizeof(tds__Service);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tds__Service, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tds__Service);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tds__Service, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tds__Service location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tds__Service::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tds__Service(soap, tag ? tag : "tds:Service", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tds__Service::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tds__Service(soap, this, tag, type);
}

SOAP_FMAC3 tds__Service * SOAP_FMAC4 soap_get_tds__Service(struct soap *soap, tds__Service *p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

void xsd__token__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__token(soap, &this->xsd__token__::__item);
}

void xsd__token__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__token__::__item, SOAP_TYPE_xsd__token);
	soap_serialize_xsd__token(soap, &this->xsd__token__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__token__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__token__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token__(struct soap *soap, const char *tag, int id, const xsd__token__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__token(soap, tag, id, &a->xsd__token__::__item, "xsd:token");
}

void *xsd__token__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__token__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_in_xsd__token__(struct soap *soap, const char *tag, xsd__token__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__token__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__token__, sizeof(xsd__token__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__token__)
		return (xsd__token__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__token(soap, tag, &a->xsd__token__::__item, "xsd:token"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 soap_dup_xsd__token__(struct soap *soap, xsd__token__ *d, xsd__token__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__token__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__token__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__token__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__token(soap, &d->xsd__token__::__item, &a->xsd__token__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__token__(xsd__token__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__token(&a->xsd__token__::__item);
}

SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 soap_instantiate_xsd__token__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__token__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__token__ *p;
	size_t k = sizeof(xsd__token__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__token__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__token__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__token__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__token__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__token__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__token__(soap, tag ? tag : "xsd:token", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__token__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__token__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__token__ * SOAP_FMAC4 soap_get_xsd__token__(struct soap *soap, xsd__token__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__string_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_std__string(soap, &this->xsd__string_::__item);
}

void xsd__string_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__string_::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__string_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string_(struct soap *soap, const char *tag, int id, const xsd__string_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_std__string(soap, tag, id, &a->xsd__string_::__item, "xsd:string");
}

void *xsd__string_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__string_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_in_xsd__string_(struct soap *soap, const char *tag, xsd__string_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string_, sizeof(xsd__string_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__string_)
		return (xsd__string_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_std__string(soap, tag, &a->xsd__string_::__item, "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_dup_xsd__string_(struct soap *soap, xsd__string_ *d, xsd__string_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__string_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__string_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__string_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_std__string(soap, &d->xsd__string_::__item, &a->xsd__string_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__string_(xsd__string_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_std__string(&a->xsd__string_::__item);
}

SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__string_ *p;
	size_t k = sizeof(xsd__string_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__string_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__string_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__string_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__string_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__string_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__string_(soap, tag ? tag : "xsd:string", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__string_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string_ * SOAP_FMAC4 soap_get_xsd__string_(struct soap *soap, xsd__string_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__nonNegativeInteger__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger__::__item);
}

void xsd__nonNegativeInteger__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__nonNegativeInteger__::__item, SOAP_TYPE_xsd__nonNegativeInteger);
	soap_serialize_xsd__nonNegativeInteger(soap, &this->xsd__nonNegativeInteger__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__nonNegativeInteger__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__nonNegativeInteger__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger__(struct soap *soap, const char *tag, int id, const xsd__nonNegativeInteger__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__nonNegativeInteger(soap, tag, id, &a->xsd__nonNegativeInteger__::__item, "xsd:nonNegativeInteger");
}

void *xsd__nonNegativeInteger__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__nonNegativeInteger__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger__(struct soap *soap, const char *tag, xsd__nonNegativeInteger__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__nonNegativeInteger__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__nonNegativeInteger__, sizeof(xsd__nonNegativeInteger__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__nonNegativeInteger__)
		return (xsd__nonNegativeInteger__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__nonNegativeInteger(soap, tag, &a->xsd__nonNegativeInteger__::__item, "xsd:nonNegativeInteger"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 soap_dup_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ *d, xsd__nonNegativeInteger__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__nonNegativeInteger__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__nonNegativeInteger__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__nonNegativeInteger__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__nonNegativeInteger(soap, &d->xsd__nonNegativeInteger__::__item, &a->xsd__nonNegativeInteger__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__nonNegativeInteger__(xsd__nonNegativeInteger__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__nonNegativeInteger(&a->xsd__nonNegativeInteger__::__item);
}

SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 soap_instantiate_xsd__nonNegativeInteger__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__nonNegativeInteger__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__nonNegativeInteger__ *p;
	size_t k = sizeof(xsd__nonNegativeInteger__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__nonNegativeInteger__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__nonNegativeInteger__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__nonNegativeInteger__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__nonNegativeInteger__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__nonNegativeInteger__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__nonNegativeInteger__(soap, tag ? tag : "xsd:nonNegativeInteger", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__nonNegativeInteger__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__nonNegativeInteger__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__nonNegativeInteger__ * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger__(struct soap *soap, xsd__nonNegativeInteger__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__integer__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__integer(soap, &this->xsd__integer__::__item);
}

void xsd__integer__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__integer__::__item, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &this->xsd__integer__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__integer__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__integer__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer__(struct soap *soap, const char *tag, int id, const xsd__integer__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__integer(soap, tag, id, &a->xsd__integer__::__item, "xsd:integer");
}

void *xsd__integer__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__integer__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_in_xsd__integer__(struct soap *soap, const char *tag, xsd__integer__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__integer__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__integer__, sizeof(xsd__integer__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__integer__)
		return (xsd__integer__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__integer(soap, tag, &a->xsd__integer__::__item, "xsd:integer"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 soap_dup_xsd__integer__(struct soap *soap, xsd__integer__ *d, xsd__integer__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__integer__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__integer__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__integer__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__integer(soap, &d->xsd__integer__::__item, &a->xsd__integer__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__integer__(xsd__integer__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__integer(&a->xsd__integer__::__item);
}

SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 soap_instantiate_xsd__integer__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__integer__ *p;
	size_t k = sizeof(xsd__integer__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__integer__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__integer__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__integer__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__integer__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__integer__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__integer__(soap, tag ? tag : "xsd:integer", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__integer__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__integer__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__integer__ * SOAP_FMAC4 soap_get_xsd__integer__(struct soap *soap, xsd__integer__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__int_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->xsd__int_::__item);
}

void xsd__int_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__int_::__item, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__int_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int_(struct soap *soap, const char *tag, int id, const xsd__int_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->xsd__int_::__item, "xsd:int");
}

void *xsd__int_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__int_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_in_xsd__int_(struct soap *soap, const char *tag, xsd__int_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int_, sizeof(xsd__int_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__int_)
		return (xsd__int_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_int(soap, tag, &a->xsd__int_::__item, "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_dup_xsd__int_(struct soap *soap, xsd__int_ *d, xsd__int_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__int_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__int_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__int_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->xsd__int_::__item = a->xsd__int_::__item;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__int_(xsd__int_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* __item skipped */
}

SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__int_ *p;
	size_t k = sizeof(xsd__int_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__int_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__int_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__int_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__int_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__int_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__int_(soap, tag ? tag : "xsd:int", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__int_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int_ * SOAP_FMAC4 soap_get_xsd__int_(struct soap *soap, xsd__int_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__hexBinary__::__item.xsd__hexBinary::soap_default(soap);
}

void xsd__hexBinary__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__hexBinary__::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__hexBinary__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary__(struct soap *soap, const char *tag, int id, const xsd__hexBinary__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->xsd__hexBinary__::__item).soap_out(soap, tag, id, "xsd:hexBinary");
}

void *xsd__hexBinary__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_in_xsd__hexBinary__(struct soap *soap, const char *tag, xsd__hexBinary__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__hexBinary__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary__, sizeof(xsd__hexBinary__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__hexBinary__)
		return (xsd__hexBinary__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!(a->xsd__hexBinary__::__item).soap_in(soap, tag, "xsd:hexBinary"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 soap_dup_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ *d, xsd__hexBinary__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__hexBinary__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__hexBinary__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__hexBinary__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__hexBinary(soap, &d->xsd__hexBinary__::__item, &a->xsd__hexBinary__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__hexBinary__(xsd__hexBinary__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__hexBinary(&a->xsd__hexBinary__::__item);
}

SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 soap_instantiate_xsd__hexBinary__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary__ *p;
	size_t k = sizeof(xsd__hexBinary__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary__(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary__ * SOAP_FMAC4 soap_get_xsd__hexBinary__(struct soap *soap, xsd__hexBinary__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__float_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->xsd__float_::__item);
}

void xsd__float_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__float_::__item, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__float_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float_(struct soap *soap, const char *tag, int id, const xsd__float_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_float(soap, tag, id, &a->xsd__float_::__item, "xsd:float");
}

void *xsd__float_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__float_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_in_xsd__float_(struct soap *soap, const char *tag, xsd__float_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float_, sizeof(xsd__float_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__float_)
		return (xsd__float_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_float(soap, tag, &a->xsd__float_::__item, "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_dup_xsd__float_(struct soap *soap, xsd__float_ *d, xsd__float_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__float_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__float_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__float_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->xsd__float_::__item = a->xsd__float_::__item;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__float_(xsd__float_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* __item skipped */
}

SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__float_ *p;
	size_t k = sizeof(xsd__float_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__float_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__float_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__float_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__float_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__float_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__float_(soap, tag ? tag : "xsd:float", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__float_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float_ * SOAP_FMAC4 soap_get_xsd__float_(struct soap *soap, xsd__float_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__duration__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->xsd__duration__::__item);
}

void xsd__duration__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__duration__::__item, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->xsd__duration__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__duration__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__duration__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration__(struct soap *soap, const char *tag, int id, const xsd__duration__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__duration(soap, tag, id, &a->xsd__duration__::__item, "xsd:duration");
}

void *xsd__duration__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__duration__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_in_xsd__duration__(struct soap *soap, const char *tag, xsd__duration__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__duration__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__duration__, sizeof(xsd__duration__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__duration__)
		return (xsd__duration__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__duration(soap, tag, &a->xsd__duration__::__item, "xsd:duration"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_dup_xsd__duration__(struct soap *soap, xsd__duration__ *d, xsd__duration__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__duration__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__duration__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__duration__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__duration(soap, &d->xsd__duration__::__item, &a->xsd__duration__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__duration__(xsd__duration__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__duration(&a->xsd__duration__::__item);
}

SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__duration__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__duration__ *p;
	size_t k = sizeof(xsd__duration__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__duration__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__duration__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__duration__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__duration__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__duration__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__duration__(soap, tag ? tag : "xsd:duration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__duration__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__duration__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__duration__ * SOAP_FMAC4 soap_get_xsd__duration__(struct soap *soap, xsd__duration__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__double_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_double(soap, &this->xsd__double_::__item);
}

void xsd__double_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__double_::__item, SOAP_TYPE_double);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__double_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double_(struct soap *soap, const char *tag, int id, const xsd__double_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_double(soap, tag, id, &a->xsd__double_::__item, "xsd:double");
}

void *xsd__double_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__double_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_in_xsd__double_(struct soap *soap, const char *tag, xsd__double_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double_, sizeof(xsd__double_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__double_)
		return (xsd__double_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_double(soap, tag, &a->xsd__double_::__item, "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_dup_xsd__double_(struct soap *soap, xsd__double_ *d, xsd__double_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__double_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__double_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__double_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->xsd__double_::__item = a->xsd__double_::__item;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__double_(xsd__double_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* __item skipped */
}

SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__double_ *p;
	size_t k = sizeof(xsd__double_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__double_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__double_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__double_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__double_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__double_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__double_(soap, tag ? tag : "xsd:double", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__double_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double_ * SOAP_FMAC4 soap_get_xsd__double_(struct soap *soap, xsd__double_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__dateTime_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_dateTime(soap, &this->xsd__dateTime_::__item);
}

void xsd__dateTime_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__dateTime_::__item, SOAP_TYPE_dateTime);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__dateTime_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime_(struct soap *soap, const char *tag, int id, const xsd__dateTime_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_dateTime(soap, tag, id, &a->xsd__dateTime_::__item, "xsd:dateTime");
}

void *xsd__dateTime_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__dateTime_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_in_xsd__dateTime_(struct soap *soap, const char *tag, xsd__dateTime_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime_, sizeof(xsd__dateTime_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__dateTime_)
		return (xsd__dateTime_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_dateTime(soap, tag, &a->xsd__dateTime_::__item, "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_dup_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *d, xsd__dateTime_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__dateTime_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__dateTime_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__dateTime_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->xsd__dateTime_::__item = a->xsd__dateTime_::__item;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__dateTime_(xsd__dateTime_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* __item skipped */
}

SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__dateTime_ *p;
	size_t k = sizeof(xsd__dateTime_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__dateTime_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__dateTime_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__dateTime_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__dateTime_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__dateTime_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__dateTime_(soap, tag ? tag : "xsd:dateTime", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__dateTime_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime_ * SOAP_FMAC4 soap_get_xsd__dateTime_(struct soap *soap, xsd__dateTime_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__boolean_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_bool(soap, &this->xsd__boolean_::__item);
}

void xsd__boolean_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__boolean_::__item, SOAP_TYPE_bool);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__boolean_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean_(struct soap *soap, const char *tag, int id, const xsd__boolean_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_bool(soap, tag, id, &a->xsd__boolean_::__item, "xsd:boolean");
}

void *xsd__boolean_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__boolean_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_in_xsd__boolean_(struct soap *soap, const char *tag, xsd__boolean_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean_, sizeof(xsd__boolean_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__boolean_)
		return (xsd__boolean_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_bool(soap, tag, &a->xsd__boolean_::__item, "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_dup_xsd__boolean_(struct soap *soap, xsd__boolean_ *d, xsd__boolean_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__boolean_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__boolean_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__boolean_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	d->xsd__boolean_::__item = a->xsd__boolean_::__item;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__boolean_(xsd__boolean_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	/* __item skipped */
}

SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__boolean_ *p;
	size_t k = sizeof(xsd__boolean_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__boolean_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__boolean_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__boolean_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__boolean_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__boolean_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__boolean_(soap, tag ? tag : "xsd:boolean", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__boolean_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean_ * SOAP_FMAC4 soap_get_xsd__boolean_(struct soap *soap, xsd__boolean_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->xsd__base64Binary__::__item.xsd__base64Binary::soap_default(soap);
}

void xsd__base64Binary__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	this->xsd__base64Binary__::__item.soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__base64Binary__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary__(struct soap *soap, const char *tag, int id, const xsd__base64Binary__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return (a->xsd__base64Binary__::__item).soap_out(soap, tag, id, "xsd:base64Binary");
}

void *xsd__base64Binary__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_in_xsd__base64Binary__(struct soap *soap, const char *tag, xsd__base64Binary__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__base64Binary__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary__, sizeof(xsd__base64Binary__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__base64Binary__)
		return (xsd__base64Binary__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!(a->xsd__base64Binary__::__item).soap_in(soap, tag, "xsd:base64Binary"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_dup_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *d, xsd__base64Binary__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__base64Binary__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__base64Binary__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__base64Binary__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__base64Binary(soap, &d->xsd__base64Binary__::__item, &a->xsd__base64Binary__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__base64Binary__(xsd__base64Binary__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__base64Binary(&a->xsd__base64Binary__::__item);
}

SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary__ *p;
	size_t k = sizeof(xsd__base64Binary__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary__(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary__ * SOAP_FMAC4 soap_get_xsd__base64Binary__(struct soap *soap, xsd__base64Binary__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyURI__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
}

void xsd__anyURI__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__anyURI__::__item, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->xsd__anyURI__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anyURI__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyURI__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI__(struct soap *soap, const char *tag, int id, const xsd__anyURI__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anyURI(soap, tag, id, &a->xsd__anyURI__::__item, "xsd:anyURI");
}

void *xsd__anyURI__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyURI__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_in_xsd__anyURI__(struct soap *soap, const char *tag, xsd__anyURI__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyURI__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyURI__, sizeof(xsd__anyURI__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyURI__)
		return (xsd__anyURI__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anyURI(soap, tag, &a->xsd__anyURI__::__item, "xsd:anyURI"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_dup_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *d, xsd__anyURI__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__anyURI__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__anyURI__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__anyURI__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anyURI(soap, &d->xsd__anyURI__::__item, &a->xsd__anyURI__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__anyURI__(xsd__anyURI__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anyURI(&a->xsd__anyURI__::__item);
}

SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyURI__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyURI__ *p;
	size_t k = sizeof(xsd__anyURI__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyURI__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyURI__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyURI__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyURI__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyURI__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyURI__(soap, tag ? tag : "xsd:anyURI", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyURI__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyURI__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyURI__ * SOAP_FMAC4 soap_get_xsd__anyURI__(struct soap *soap, xsd__anyURI__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anySimpleType__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__anySimpleType(soap, &this->xsd__anySimpleType__::__item);
}

void xsd__anySimpleType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_xsd__anySimpleType(soap, &this->xsd__anySimpleType__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__anySimpleType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anySimpleType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType__(struct soap *soap, const char *tag, int id, const xsd__anySimpleType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__anySimpleType(soap, tag, id, &a->xsd__anySimpleType__::__item, "xsd:anySimpleType");
}

void *xsd__anySimpleType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anySimpleType__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_in_xsd__anySimpleType__(struct soap *soap, const char *tag, xsd__anySimpleType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anySimpleType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anySimpleType__, sizeof(xsd__anySimpleType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anySimpleType__)
		return (xsd__anySimpleType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__anySimpleType(soap, tag, &a->xsd__anySimpleType__::__item, "xsd:anySimpleType"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 soap_dup_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ *d, xsd__anySimpleType__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__anySimpleType__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__anySimpleType__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__anySimpleType__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__anySimpleType(soap, &d->xsd__anySimpleType__::__item, &a->xsd__anySimpleType__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__anySimpleType__(xsd__anySimpleType__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__anySimpleType(&a->xsd__anySimpleType__::__item);
}

SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 soap_instantiate_xsd__anySimpleType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anySimpleType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anySimpleType__ *p;
	size_t k = sizeof(xsd__anySimpleType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anySimpleType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anySimpleType__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anySimpleType__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anySimpleType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anySimpleType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anySimpleType__(soap, tag ? tag : "xsd:anySimpleType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anySimpleType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anySimpleType__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anySimpleType__ * SOAP_FMAC4 soap_get_xsd__anySimpleType__(struct soap *soap, xsd__anySimpleType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anySimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anySimpleType, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__QName__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__QName(soap, &this->xsd__QName__::__item);
}

void xsd__QName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__QName__::__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &this->xsd__QName__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__QName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName__(struct soap *soap, const char *tag, int id, const xsd__QName__ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__QName__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_in_xsd__QName__(struct soap *soap, const char *tag, xsd__QName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName__, sizeof(xsd__QName__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__QName__)
		return (xsd__QName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__QName(soap, tag, &a->xsd__QName__::__item, "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_dup_xsd__QName__(struct soap *soap, xsd__QName__ *d, xsd__QName__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__QName__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__QName__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__QName__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__QName(soap, &d->xsd__QName__::__item, &a->xsd__QName__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__QName__(xsd__QName__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__QName(&a->xsd__QName__::__item);
}

SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_instantiate_xsd__QName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__QName__ *p;
	size_t k = sizeof(xsd__QName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__QName__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__QName__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__QName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__QName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__QName__(soap, tag ? tag : "xsd:QName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__QName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName__ * SOAP_FMAC4 soap_get_xsd__QName__(struct soap *soap, xsd__QName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__NCName__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__NCName(soap, &this->xsd__NCName__::__item);
}

void xsd__NCName__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->xsd__NCName__::__item, SOAP_TYPE_xsd__NCName);
	soap_serialize_xsd__NCName(soap, &this->xsd__NCName__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int xsd__NCName__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__NCName__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName__(struct soap *soap, const char *tag, int id, const xsd__NCName__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_xsd__NCName(soap, tag, id, &a->xsd__NCName__::__item, "xsd:NCName");
}

void *xsd__NCName__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__NCName__(soap, tag, this, type);
}

SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_in_xsd__NCName__(struct soap *soap, const char *tag, xsd__NCName__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__NCName__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__NCName__, sizeof(xsd__NCName__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__NCName__)
		return (xsd__NCName__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_xsd__NCName(soap, tag, &a->xsd__NCName__::__item, "xsd:NCName"))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 soap_dup_xsd__NCName__(struct soap *soap, xsd__NCName__ *d, xsd__NCName__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__NCName__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__NCName__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__NCName__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_xsd__NCName(soap, &d->xsd__NCName__::__item, &a->xsd__NCName__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__NCName__(xsd__NCName__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_xsd__NCName(&a->xsd__NCName__::__item);
}

SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 soap_instantiate_xsd__NCName__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__NCName__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__NCName__ *p;
	size_t k = sizeof(xsd__NCName__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__NCName__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__NCName__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__NCName__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__NCName__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__NCName__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__NCName__(soap, tag ? tag : "xsd:NCName", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__NCName__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__NCName__(soap, this, tag, type);
}

SOAP_FMAC3 xsd__NCName__ * SOAP_FMAC4 soap_get_xsd__NCName__(struct soap *soap, xsd__NCName__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENV__Fault_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_SOAP_ENV__Fault(soap, &this->SOAP_ENV__Fault_::__item);
}

void SOAP_ENV__Fault_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SOAP_ENV__Fault(soap, &this->SOAP_ENV__Fault_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int SOAP_ENV__Fault_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENV__Fault_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault_(struct soap *soap, const char *tag, int id, const SOAP_ENV__Fault_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_SOAP_ENV__Fault(soap, tag, id, &a->SOAP_ENV__Fault_::__item, "");
}

void *SOAP_ENV__Fault_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENV__Fault_(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_in_SOAP_ENV__Fault_(struct soap *soap, const char *tag, SOAP_ENV__Fault_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (SOAP_ENV__Fault_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault_, sizeof(SOAP_ENV__Fault_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_SOAP_ENV__Fault_)
		return (SOAP_ENV__Fault_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_SOAP_ENV__Fault(soap, tag, &a->SOAP_ENV__Fault_::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 soap_dup_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ *d, SOAP_ENV__Fault_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (SOAP_ENV__Fault_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Fault_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Fault_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_SOAP_ENV__Fault(soap, &d->SOAP_ENV__Fault_::__item, &a->SOAP_ENV__Fault_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Fault_(SOAP_ENV__Fault_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_SOAP_ENV__Fault(&a->SOAP_ENV__Fault_::__item);
}

SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENV__Fault_ *p;
	size_t k = sizeof(SOAP_ENV__Fault_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENV__Fault_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENV__Fault_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENV__Fault_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENV__Fault_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENV__Fault_(soap, tag ? tag : "SOAP-ENV:Fault", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENV__Fault_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENV__Fault_(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENV__Fault_ * SOAP_FMAC4 soap_get_SOAP_ENV__Fault_(struct soap *soap, SOAP_ENV__Fault_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void SOAP_ENV__Envelope_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_SOAP_ENV__Envelope(soap, &this->SOAP_ENV__Envelope_::__item);
}

void SOAP_ENV__Envelope_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_SOAP_ENV__Envelope(soap, &this->SOAP_ENV__Envelope_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int SOAP_ENV__Envelope_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_SOAP_ENV__Envelope_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope_(struct soap *soap, const char *tag, int id, const SOAP_ENV__Envelope_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, &a->SOAP_ENV__Envelope_::__item, "");
}

void *SOAP_ENV__Envelope_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_SOAP_ENV__Envelope_(soap, tag, this, type);
}

SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope_(struct soap *soap, const char *tag, SOAP_ENV__Envelope_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (SOAP_ENV__Envelope_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope_, sizeof(SOAP_ENV__Envelope_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_SOAP_ENV__Envelope_)
		return (SOAP_ENV__Envelope_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_SOAP_ENV__Envelope(soap, tag, &a->SOAP_ENV__Envelope_::__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 soap_dup_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ *d, SOAP_ENV__Envelope_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (SOAP_ENV__Envelope_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Envelope_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Envelope_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_SOAP_ENV__Envelope(soap, &d->SOAP_ENV__Envelope_::__item, &a->SOAP_ENV__Envelope_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Envelope_(SOAP_ENV__Envelope_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_SOAP_ENV__Envelope(&a->SOAP_ENV__Envelope_::__item);
}

SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Envelope_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	SOAP_ENV__Envelope_ *p;
	size_t k = sizeof(SOAP_ENV__Envelope_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, SOAP_ENV__Envelope_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, SOAP_ENV__Envelope_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated SOAP_ENV__Envelope_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int SOAP_ENV__Envelope_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_SOAP_ENV__Envelope_(soap, tag ? tag : "SOAP-ENV:Envelope", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *SOAP_ENV__Envelope_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SOAP_ENV__Envelope_(soap, this, tag, type);
}

SOAP_FMAC3 SOAP_ENV__Envelope_ * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope_(struct soap *soap, SOAP_ENV__Envelope_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsa5__EndpointReferenceType__::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsa5__EndpointReferenceType(soap, &this->wsa5__EndpointReferenceType__::__item);
}

void wsa5__EndpointReferenceType__::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsa5__EndpointReferenceType__::__item, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &this->wsa5__EndpointReferenceType__::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsa5__EndpointReferenceType__::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsa5__EndpointReferenceType__(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType__(struct soap *soap, const char *tag, int id, const wsa5__EndpointReferenceType__ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, &a->wsa5__EndpointReferenceType__::__item, "wsa5:EndpointReferenceType");
}

void *wsa5__EndpointReferenceType__::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsa5__EndpointReferenceType__(soap, tag, this, type);
}

SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType__(struct soap *soap, const char *tag, wsa5__EndpointReferenceType__ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsa5__EndpointReferenceType__*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType__, sizeof(wsa5__EndpointReferenceType__), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsa5__EndpointReferenceType__)
		return (wsa5__EndpointReferenceType__ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsa5__EndpointReferenceType(soap, tag, &a->wsa5__EndpointReferenceType__::__item, "wsa5:EndpointReferenceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 soap_dup_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ *d, wsa5__EndpointReferenceType__ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsa5__EndpointReferenceType__*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__EndpointReferenceType__, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__EndpointReferenceType__(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsa5__EndpointReferenceType(soap, &d->wsa5__EndpointReferenceType__::__item, &a->wsa5__EndpointReferenceType__::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__EndpointReferenceType__(wsa5__EndpointReferenceType__ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsa5__EndpointReferenceType(&a->wsa5__EndpointReferenceType__::__item);
}

SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType__(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsa5__EndpointReferenceType__ *p;
	size_t k = sizeof(wsa5__EndpointReferenceType__);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType__, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsa5__EndpointReferenceType__);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsa5__EndpointReferenceType__, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsa5__EndpointReferenceType__ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsa5__EndpointReferenceType__::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsa5__EndpointReferenceType__(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsa5__EndpointReferenceType__::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsa5__EndpointReferenceType__(soap, this, tag, type);
}

SOAP_FMAC3 wsa5__EndpointReferenceType__ * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType__(struct soap *soap, wsa5__EndpointReferenceType__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdd10__ResolveType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsdd__ResolveType(soap, &this->wsdd10__ResolveType_::__item);
}

void wsdd10__ResolveType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsdd10__ResolveType_::__item, SOAP_TYPE_wsdd__ResolveType);
	soap_serialize_wsdd__ResolveType(soap, &this->wsdd10__ResolveType_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsdd10__ResolveType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdd10__ResolveType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd10__ResolveType_(struct soap *soap, const char *tag, int id, const wsdd10__ResolveType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__ResolveType(soap, tag, id, &a->wsdd10__ResolveType_::__item, "wsdd10:ResolveType");
}

void *wsdd10__ResolveType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsdd10__ResolveType_(soap, tag, this, type);
}

SOAP_FMAC3 wsdd10__ResolveType_ * SOAP_FMAC4 soap_in_wsdd10__ResolveType_(struct soap *soap, const char *tag, wsdd10__ResolveType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsdd10__ResolveType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd10__ResolveType_, sizeof(wsdd10__ResolveType_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdd10__ResolveType_)
		return (wsdd10__ResolveType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsdd__ResolveType(soap, tag, &a->wsdd10__ResolveType_::__item, "wsdd10:ResolveType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsdd10__ResolveType_ * SOAP_FMAC2 soap_dup_wsdd10__ResolveType_(struct soap *soap, wsdd10__ResolveType_ *d, wsdd10__ResolveType_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsdd10__ResolveType_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd10__ResolveType_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd10__ResolveType_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsdd__ResolveType(soap, &d->wsdd10__ResolveType_::__item, &a->wsdd10__ResolveType_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd10__ResolveType_(wsdd10__ResolveType_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsdd__ResolveType(&a->wsdd10__ResolveType_::__item);
}

SOAP_FMAC1 wsdd10__ResolveType_ * SOAP_FMAC2 soap_instantiate_wsdd10__ResolveType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd10__ResolveType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdd10__ResolveType_ *p;
	size_t k = sizeof(wsdd10__ResolveType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd10__ResolveType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsdd10__ResolveType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsdd10__ResolveType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdd10__ResolveType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsdd10__ResolveType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdd10__ResolveType_(soap, tag ? tag : "wsdd10:ResolveType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdd10__ResolveType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdd10__ResolveType_(soap, this, tag, type);
}

SOAP_FMAC3 wsdd10__ResolveType_ * SOAP_FMAC4 soap_get_wsdd10__ResolveType_(struct soap *soap, wsdd10__ResolveType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd10__ResolveType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdd10__ProbeType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsdd__ProbeType(soap, &this->wsdd10__ProbeType_::__item);
}

void wsdd10__ProbeType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsdd10__ProbeType_::__item, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &this->wsdd10__ProbeType_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsdd10__ProbeType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdd10__ProbeType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd10__ProbeType_(struct soap *soap, const char *tag, int id, const wsdd10__ProbeType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__ProbeType(soap, tag, id, &a->wsdd10__ProbeType_::__item, "wsdd10:ProbeType");
}

void *wsdd10__ProbeType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsdd10__ProbeType_(soap, tag, this, type);
}

SOAP_FMAC3 wsdd10__ProbeType_ * SOAP_FMAC4 soap_in_wsdd10__ProbeType_(struct soap *soap, const char *tag, wsdd10__ProbeType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsdd10__ProbeType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd10__ProbeType_, sizeof(wsdd10__ProbeType_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdd10__ProbeType_)
		return (wsdd10__ProbeType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsdd__ProbeType(soap, tag, &a->wsdd10__ProbeType_::__item, "wsdd10:ProbeType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsdd10__ProbeType_ * SOAP_FMAC2 soap_dup_wsdd10__ProbeType_(struct soap *soap, wsdd10__ProbeType_ *d, wsdd10__ProbeType_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsdd10__ProbeType_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd10__ProbeType_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd10__ProbeType_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsdd__ProbeType(soap, &d->wsdd10__ProbeType_::__item, &a->wsdd10__ProbeType_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd10__ProbeType_(wsdd10__ProbeType_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsdd__ProbeType(&a->wsdd10__ProbeType_::__item);
}

SOAP_FMAC1 wsdd10__ProbeType_ * SOAP_FMAC2 soap_instantiate_wsdd10__ProbeType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd10__ProbeType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdd10__ProbeType_ *p;
	size_t k = sizeof(wsdd10__ProbeType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd10__ProbeType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsdd10__ProbeType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsdd10__ProbeType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdd10__ProbeType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsdd10__ProbeType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdd10__ProbeType_(soap, tag ? tag : "wsdd10:ProbeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdd10__ProbeType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdd10__ProbeType_(soap, this, tag, type);
}

SOAP_FMAC3 wsdd10__ProbeType_ * SOAP_FMAC4 soap_get_wsdd10__ProbeType_(struct soap *soap, wsdd10__ProbeType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd10__ProbeType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdd10__ProbeMatchesType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsdd__ProbeMatchesType(soap, &this->wsdd10__ProbeMatchesType_::__item);
}

void wsdd10__ProbeMatchesType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsdd10__ProbeMatchesType_::__item, SOAP_TYPE_wsdd__ProbeMatchesType);
	soap_serialize_wsdd__ProbeMatchesType(soap, &this->wsdd10__ProbeMatchesType_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsdd10__ProbeMatchesType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdd10__ProbeMatchesType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd10__ProbeMatchesType_(struct soap *soap, const char *tag, int id, const wsdd10__ProbeMatchesType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, &a->wsdd10__ProbeMatchesType_::__item, "wsdd10:ProbeMatchesType");
}

void *wsdd10__ProbeMatchesType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsdd10__ProbeMatchesType_(soap, tag, this, type);
}

SOAP_FMAC3 wsdd10__ProbeMatchesType_ * SOAP_FMAC4 soap_in_wsdd10__ProbeMatchesType_(struct soap *soap, const char *tag, wsdd10__ProbeMatchesType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsdd10__ProbeMatchesType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd10__ProbeMatchesType_, sizeof(wsdd10__ProbeMatchesType_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdd10__ProbeMatchesType_)
		return (wsdd10__ProbeMatchesType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsdd__ProbeMatchesType(soap, tag, &a->wsdd10__ProbeMatchesType_::__item, "wsdd10:ProbeMatchesType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsdd10__ProbeMatchesType_ * SOAP_FMAC2 soap_dup_wsdd10__ProbeMatchesType_(struct soap *soap, wsdd10__ProbeMatchesType_ *d, wsdd10__ProbeMatchesType_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsdd10__ProbeMatchesType_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd10__ProbeMatchesType_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd10__ProbeMatchesType_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsdd__ProbeMatchesType(soap, &d->wsdd10__ProbeMatchesType_::__item, &a->wsdd10__ProbeMatchesType_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd10__ProbeMatchesType_(wsdd10__ProbeMatchesType_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsdd__ProbeMatchesType(&a->wsdd10__ProbeMatchesType_::__item);
}

SOAP_FMAC1 wsdd10__ProbeMatchesType_ * SOAP_FMAC2 soap_instantiate_wsdd10__ProbeMatchesType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd10__ProbeMatchesType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdd10__ProbeMatchesType_ *p;
	size_t k = sizeof(wsdd10__ProbeMatchesType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd10__ProbeMatchesType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsdd10__ProbeMatchesType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsdd10__ProbeMatchesType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdd10__ProbeMatchesType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsdd10__ProbeMatchesType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdd10__ProbeMatchesType_(soap, tag ? tag : "wsdd10:ProbeMatchesType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdd10__ProbeMatchesType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdd10__ProbeMatchesType_(soap, this, tag, type);
}

SOAP_FMAC3 wsdd10__ProbeMatchesType_ * SOAP_FMAC4 soap_get_wsdd10__ProbeMatchesType_(struct soap *soap, wsdd10__ProbeMatchesType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd10__ProbeMatchesType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdd10__HelloType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsdd__HelloType(soap, &this->wsdd10__HelloType_::__item);
}

void wsdd10__HelloType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsdd10__HelloType_::__item, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &this->wsdd10__HelloType_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsdd10__HelloType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdd10__HelloType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd10__HelloType_(struct soap *soap, const char *tag, int id, const wsdd10__HelloType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__HelloType(soap, tag, id, &a->wsdd10__HelloType_::__item, "wsdd10:HelloType");
}

void *wsdd10__HelloType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsdd10__HelloType_(soap, tag, this, type);
}

SOAP_FMAC3 wsdd10__HelloType_ * SOAP_FMAC4 soap_in_wsdd10__HelloType_(struct soap *soap, const char *tag, wsdd10__HelloType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsdd10__HelloType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd10__HelloType_, sizeof(wsdd10__HelloType_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdd10__HelloType_)
		return (wsdd10__HelloType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsdd__HelloType(soap, tag, &a->wsdd10__HelloType_::__item, "wsdd10:HelloType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsdd10__HelloType_ * SOAP_FMAC2 soap_dup_wsdd10__HelloType_(struct soap *soap, wsdd10__HelloType_ *d, wsdd10__HelloType_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsdd10__HelloType_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd10__HelloType_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd10__HelloType_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsdd__HelloType(soap, &d->wsdd10__HelloType_::__item, &a->wsdd10__HelloType_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd10__HelloType_(wsdd10__HelloType_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsdd__HelloType(&a->wsdd10__HelloType_::__item);
}

SOAP_FMAC1 wsdd10__HelloType_ * SOAP_FMAC2 soap_instantiate_wsdd10__HelloType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd10__HelloType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdd10__HelloType_ *p;
	size_t k = sizeof(wsdd10__HelloType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd10__HelloType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsdd10__HelloType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsdd10__HelloType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdd10__HelloType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsdd10__HelloType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdd10__HelloType_(soap, tag ? tag : "wsdd10:HelloType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdd10__HelloType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdd10__HelloType_(soap, this, tag, type);
}

SOAP_FMAC3 wsdd10__HelloType_ * SOAP_FMAC4 soap_get_wsdd10__HelloType_(struct soap *soap, wsdd10__HelloType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd10__HelloType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void wsdd10__ByeType_::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_wsdd__ByeType(soap, &this->wsdd10__ByeType_::__item);
}

void wsdd10__ByeType_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->wsdd10__ByeType_::__item, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &this->wsdd10__ByeType_::__item);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int wsdd10__ByeType_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_wsdd10__ByeType_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd10__ByeType_(struct soap *soap, const char *tag, int id, const wsdd10__ByeType_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__ByeType(soap, tag, id, &a->wsdd10__ByeType_::__item, "wsdd10:ByeType");
}

void *wsdd10__ByeType_::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_wsdd10__ByeType_(soap, tag, this, type);
}

SOAP_FMAC3 wsdd10__ByeType_ * SOAP_FMAC4 soap_in_wsdd10__ByeType_(struct soap *soap, const char *tag, wsdd10__ByeType_ *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (wsdd10__ByeType_*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd10__ByeType_, sizeof(wsdd10__ByeType_), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_wsdd10__ByeType_)
		return (wsdd10__ByeType_ *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_in_wsdd__ByeType(soap, tag, &a->wsdd10__ByeType_::__item, "wsdd10:ByeType"))
		return NULL;
	return a;
}

SOAP_FMAC1 wsdd10__ByeType_ * SOAP_FMAC2 soap_dup_wsdd10__ByeType_(struct soap *soap, wsdd10__ByeType_ *d, wsdd10__ByeType_ const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (wsdd10__ByeType_*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd10__ByeType_, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd10__ByeType_(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_xsd__anyType(soap, d, a);
	soap_dup_wsdd__ByeType(soap, &d->wsdd10__ByeType_::__item, &a->wsdd10__ByeType_::__item);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd10__ByeType_(wsdd10__ByeType_ const*a)
{
	if (!a)
		return;
	soap_del_xsd__anyType(a);
	soap_del_wsdd__ByeType(&a->wsdd10__ByeType_::__item);
}

SOAP_FMAC1 wsdd10__ByeType_ * SOAP_FMAC2 soap_instantiate_wsdd10__ByeType_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd10__ByeType_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	wsdd10__ByeType_ *p;
	size_t k = sizeof(wsdd10__ByeType_);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd10__ByeType_, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, wsdd10__ByeType_);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, wsdd10__ByeType_, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated wsdd10__ByeType_ location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int wsdd10__ByeType_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_wsdd10__ByeType_(soap, tag ? tag : "wsdd10:ByeType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *wsdd10__ByeType_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_wsdd10__ByeType_(soap, this, tag, type);
}

SOAP_FMAC3 wsdd10__ByeType_ * SOAP_FMAC4 soap_get_wsdd10__ByeType_(struct soap *soap, wsdd10__ByeType_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd10__ByeType_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_dup_xsd__hexBinary(struct soap *soap, xsd__hexBinary *d, xsd__hexBinary const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__hexBinary*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__hexBinary, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__hexBinary(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__ptr = NULL;
	d->__size = a->__size;
	if (a->__ptr && a->__size > 0)
	{	d->__ptr = (unsigned char*)soap_malloc(soap, a->__size);
		if (!d->__ptr)
			return NULL;
		soap_memcpy(d->__ptr, d->__size, a->__ptr, a->__size);
	}
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__hexBinary(xsd__hexBinary const*a)
{
	if (!a)
		return;
	if (a->__ptr)
		SOAP_FREE(NULL, a->__ptr);
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary *p;
	size_t k = sizeof(xsd__hexBinary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_dup_xsd__base64Binary(struct soap *soap, xsd__base64Binary *d, xsd__base64Binary const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__base64Binary*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__base64Binary, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__base64Binary(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__ptr = NULL;
	d->__size = a->__size;
	if (a->__ptr && a->__size > 0)
	{	d->__ptr = (unsigned char*)soap_malloc(soap, a->__size);
		if (!d->__ptr)
			return NULL;
		soap_memcpy(d->__ptr, d->__size, a->__ptr, a->__size);
	}
	d->id = soap_strdup(soap, a->id);
	d->type = soap_strdup(soap, a->type);
	d->options = soap_strdup(soap, a->options); /* WARNING: cannot copy binary DIME attachment options correctly, MIME/MTOM is OK */
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__base64Binary(xsd__base64Binary const*a)
{
	if (!a)
		return;
	if (a->__ptr)
		SOAP_FREE(NULL, a->__ptr);
	if (a->id)
		SOAP_FREE(NULL, a->id);
	if (a->type)
		SOAP_FREE(NULL, a->type);
	if (a->options)
		SOAP_FREE(NULL, a->options);
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_dup_xsd__QName(struct soap *soap, std::string *d, std::string const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (std::string*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__QName, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__QName(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__QName(std::string const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (s->empty())
		return (soap->mode & SOAP_C_NILSTRING) ? soap_element_null(soap, tag, id, type) : soap_element_empty(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_dup_std__string(struct soap *soap, std::string *d, std::string const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (std::string*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_std__string, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_std__string(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	*d = *a;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_std__string(std::string const*a)
{
	if (!a)
		return;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_dup_xsd__anyType(struct soap *soap, xsd__anyType *d, xsd__anyType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (xsd__anyType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_xsd__anyType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_xsd__anyType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->xsd__anyType::__item = soap_strdup(soap, (char*)a->xsd__anyType::__item);
	d->xsd__anyType::soap = soap;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_xsd__anyType(xsd__anyType const*a)
{
	if (!a)
		return;
	if (a->xsd__anyType::__item)
		SOAP_FREE(NULL, a->xsd__anyType::__item);
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "wsdd10:ByeType"))
		return soap_instantiate_wsdd10__ByeType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsdd10:HelloType"))
		return soap_instantiate_wsdd10__HelloType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsdd10:ProbeMatchesType"))
		return soap_instantiate_wsdd10__ProbeMatchesType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsdd10:ProbeType"))
		return soap_instantiate_wsdd10__ProbeType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsdd10:ResolveType"))
		return soap_instantiate_wsdd10__ResolveType_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsa5:EndpointReferenceType"))
		return soap_instantiate_wsa5__EndpointReferenceType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "SOAP-ENV:Envelope"))
		return soap_instantiate_SOAP_ENV__Envelope_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "SOAP-ENV:Fault"))
		return soap_instantiate_SOAP_ENV__Fault_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:NCName"))
		return soap_instantiate_xsd__NCName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:QName"))
		return soap_instantiate_xsd__QName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:anySimpleType"))
		return soap_instantiate_xsd__anySimpleType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:anyURI"))
		return soap_instantiate_xsd__anyURI__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:base64Binary"))
		return soap_instantiate_xsd__base64Binary__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:boolean"))
		return soap_instantiate_xsd__boolean_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:dateTime"))
		return soap_instantiate_xsd__dateTime_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:double"))
		return soap_instantiate_xsd__double_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:duration"))
		return soap_instantiate_xsd__duration__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:float"))
		return soap_instantiate_xsd__float_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:hexBinary"))
		return soap_instantiate_xsd__hexBinary__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:int"))
		return soap_instantiate_xsd__int_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:integer"))
		return soap_instantiate_xsd__integer__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:nonNegativeInteger"))
		return soap_instantiate_xsd__nonNegativeInteger__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:string"))
		return soap_instantiate_xsd__string_(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "xsd:token"))
		return soap_instantiate_xsd__token__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Name"))
		return soap_instantiate_tt__Name__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateMode"))
		return soap_instantiate_tt__RotateMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SceneOrientationMode"))
		return soap_instantiate_tt__SceneOrientationMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoding"))
		return soap_instantiate_tt__VideoEncoding__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Profile"))
		return soap_instantiate_tt__Mpeg4Profile__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Profile"))
		return soap_instantiate_tt__H264Profile__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoding"))
		return soap_instantiate_tt__AudioEncoding__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:StreamType"))
		return soap_instantiate_tt__StreamType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:TransportProtocol"))
		return soap_instantiate_tt__TransportProtocol__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ScopeDefinition"))
		return soap_instantiate_tt__ScopeDefinition__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DiscoveryMode"))
		return soap_instantiate_tt__DiscoveryMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceConfigPriority"))
		return soap_instantiate_tt__NetworkInterfaceConfigPriority__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Duplex"))
		return soap_instantiate_tt__Duplex__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IANA-IfTypes"))
		return soap_instantiate_tt__IANA_IfTypes__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6DHCPConfiguration"))
		return soap_instantiate_tt__IPv6DHCPConfiguration__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkProtocolType"))
		return soap_instantiate_tt__NetworkProtocolType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkHostType"))
		return soap_instantiate_tt__NetworkHostType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv4Address"))
		return soap_instantiate_tt__IPv4Address__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6Address"))
		return soap_instantiate_tt__IPv6Address__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:HwAddress"))
		return soap_instantiate_tt__HwAddress__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPType"))
		return soap_instantiate_tt__IPType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DNSName"))
		return soap_instantiate_tt__DNSName__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPAddressFilterType"))
		return soap_instantiate_tt__IPAddressFilterType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DynamicDNSType"))
		return soap_instantiate_tt__DynamicDNSType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11SSIDType"))
		return soap_instantiate_tt__Dot11SSIDType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11StationMode"))
		return soap_instantiate_tt__Dot11StationMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11SecurityMode"))
		return soap_instantiate_tt__Dot11SecurityMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11Cipher"))
		return soap_instantiate_tt__Dot11Cipher__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11PSK"))
		return soap_instantiate_tt__Dot11PSK__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11PSKPassphrase"))
		return soap_instantiate_tt__Dot11PSKPassphrase__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11SignalStrength"))
		return soap_instantiate_tt__Dot11SignalStrength__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11AuthAndMangementSuite"))
		return soap_instantiate_tt__Dot11AuthAndMangementSuite__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CapabilityCategory"))
		return soap_instantiate_tt__CapabilityCategory__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemLogType"))
		return soap_instantiate_tt__SystemLogType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FactoryDefaultType"))
		return soap_instantiate_tt__FactoryDefaultType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SetDateTimeType"))
		return soap_instantiate_tt__SetDateTimeType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:UserLevel"))
		return soap_instantiate_tt__UserLevel__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayLogicalState"))
		return soap_instantiate_tt__RelayLogicalState__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayIdleState"))
		return soap_instantiate_tt__RelayIdleState__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayMode"))
		return soap_instantiate_tt__RelayMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EFlipMode"))
		return soap_instantiate_tt__EFlipMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReverseMode"))
		return soap_instantiate_tt__ReverseMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AuxiliaryData"))
		return soap_instantiate_tt__AuxiliaryData__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AutoFocusMode"))
		return soap_instantiate_tt__AutoFocusMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicMode"))
		return soap_instantiate_tt__WideDynamicMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensationMode"))
		return soap_instantiate_tt__BacklightCompensationMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposurePriority"))
		return soap_instantiate_tt__ExposurePriority__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposureMode"))
		return soap_instantiate_tt__ExposureMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceMode"))
		return soap_instantiate_tt__WhiteBalanceMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterMode"))
		return soap_instantiate_tt__IrCutFilterMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationMode"))
		return soap_instantiate_tt__ImageStabilizationMode__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PropertyOperation"))
		return soap_instantiate_tt__PropertyOperation__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Description"))
		return soap_instantiate_tt__Description__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDType"))
		return soap_instantiate_tt__OSDType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReferenceToken"))
		return soap_instantiate_tt__ReferenceToken__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MoveStatus"))
		return soap_instantiate_tt__MoveStatus__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RTSPServerType"))
		return soap_instantiate_tt__RTSPServerType__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:ConcreteTopicExpression"))
		return soap_instantiate_wstop__ConcreteTopicExpression__(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:Service"))
		return soap_instantiate_tds__Service(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:DeviceServiceCapabilities"))
		return soap_instantiate_tds__DeviceServiceCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:NetworkCapabilities"))
		return soap_instantiate_tds__NetworkCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:SecurityCapabilities"))
		return soap_instantiate_tds__SecurityCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:SystemCapabilities"))
		return soap_instantiate_tds__SystemCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:MiscCapabilities"))
		return soap_instantiate_tds__MiscCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:UserCredential"))
		return soap_instantiate_tds__UserCredential(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:StorageConfigurationData"))
		return soap_instantiate_tds__StorageConfigurationData(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceEntity"))
		return soap_instantiate_tt__DeviceEntity(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRectangle"))
		return soap_instantiate_tt__IntRectangle(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRectangleRange"))
		return soap_instantiate_tt__IntRectangleRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FloatRange"))
		return soap_instantiate_tt__FloatRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DurationRange"))
		return soap_instantiate_tt__DurationRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntItems"))
		return soap_instantiate_tt__IntItems(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceExtension"))
		return soap_instantiate_tt__VideoSourceExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceExtension2"))
		return soap_instantiate_tt__VideoSourceExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Profile"))
		return soap_instantiate_tt__Profile(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ProfileExtension"))
		return soap_instantiate_tt__ProfileExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ProfileExtension2"))
		return soap_instantiate_tt__ProfileExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ConfigurationEntity"))
		return soap_instantiate_tt__ConfigurationEntity(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationExtension"))
		return soap_instantiate_tt__VideoSourceConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationExtension2"))
		return soap_instantiate_tt__VideoSourceConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Rotate"))
		return soap_instantiate_tt__Rotate(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateExtension"))
		return soap_instantiate_tt__RotateExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensProjection"))
		return soap_instantiate_tt__LensProjection(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensOffset"))
		return soap_instantiate_tt__LensOffset(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LensDescription"))
		return soap_instantiate_tt__LensDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationOptions"))
		return soap_instantiate_tt__VideoSourceConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationOptionsExtension"))
		return soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfigurationOptionsExtension2"))
		return soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateOptions"))
		return soap_instantiate_tt__RotateOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RotateOptionsExtension"))
		return soap_instantiate_tt__RotateOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SceneOrientation"))
		return soap_instantiate_tt__SceneOrientation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoResolution"))
		return soap_instantiate_tt__VideoResolution(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoRateControl"))
		return soap_instantiate_tt__VideoRateControl(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Configuration"))
		return soap_instantiate_tt__Mpeg4Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Configuration"))
		return soap_instantiate_tt__H264Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfigurationOptions"))
		return soap_instantiate_tt__VideoEncoderConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderOptionsExtension"))
		return soap_instantiate_tt__VideoEncoderOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderOptionsExtension2"))
		return soap_instantiate_tt__VideoEncoderOptionsExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:JpegOptions"))
		return soap_instantiate_tt__JpegOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Options"))
		return soap_instantiate_tt__Mpeg4Options(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Options"))
		return soap_instantiate_tt__H264Options(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfigurationOptions"))
		return soap_instantiate_tt__AudioSourceConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceOptionsExtension"))
		return soap_instantiate_tt__AudioSourceOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfigurationOptions"))
		return soap_instantiate_tt__AudioEncoderConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfigurationOption"))
		return soap_instantiate_tt__AudioEncoderConfigurationOption(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfigurationExtension"))
		return soap_instantiate_tt__MetadataConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZFilter"))
		return soap_instantiate_tt__PTZFilter(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EventSubscription"))
		return soap_instantiate_tt__EventSubscription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfigurationOptions"))
		return soap_instantiate_tt__MetadataConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfigurationOptionsExtension"))
		return soap_instantiate_tt__MetadataConfigurationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfigurationOptionsExtension2"))
		return soap_instantiate_tt__MetadataConfigurationOptionsExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZStatusFilterOptions"))
		return soap_instantiate_tt__PTZStatusFilterOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZStatusFilterOptionsExtension"))
		return soap_instantiate_tt__PTZStatusFilterOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfigurationOptions"))
		return soap_instantiate_tt__AudioOutputConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfigurationOptions"))
		return soap_instantiate_tt__AudioDecoderConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:G711DecOptions"))
		return soap_instantiate_tt__G711DecOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AACDecOptions"))
		return soap_instantiate_tt__AACDecOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:G726DecOptions"))
		return soap_instantiate_tt__G726DecOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfigurationOptionsExtension"))
		return soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MulticastConfiguration"))
		return soap_instantiate_tt__MulticastConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:StreamSetup"))
		return soap_instantiate_tt__StreamSetup(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Transport"))
		return soap_instantiate_tt__Transport(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MediaUri"))
		return soap_instantiate_tt__MediaUri(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Scope"))
		return soap_instantiate_tt__Scope(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceExtension"))
		return soap_instantiate_tt__NetworkInterfaceExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot3Configuration"))
		return soap_instantiate_tt__Dot3Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceExtension2"))
		return soap_instantiate_tt__NetworkInterfaceExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceLink"))
		return soap_instantiate_tt__NetworkInterfaceLink(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceConnectionSetting"))
		return soap_instantiate_tt__NetworkInterfaceConnectionSetting(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceInfo"))
		return soap_instantiate_tt__NetworkInterfaceInfo(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6NetworkInterface"))
		return soap_instantiate_tt__IPv6NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv4NetworkInterface"))
		return soap_instantiate_tt__IPv4NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv4Configuration"))
		return soap_instantiate_tt__IPv4Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6Configuration"))
		return soap_instantiate_tt__IPv6Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6ConfigurationExtension"))
		return soap_instantiate_tt__IPv6ConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkProtocol"))
		return soap_instantiate_tt__NetworkProtocol(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkProtocolExtension"))
		return soap_instantiate_tt__NetworkProtocolExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkHost"))
		return soap_instantiate_tt__NetworkHost(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkHostExtension"))
		return soap_instantiate_tt__NetworkHostExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPAddress"))
		return soap_instantiate_tt__IPAddress(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PrefixedIPv4Address"))
		return soap_instantiate_tt__PrefixedIPv4Address(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PrefixedIPv6Address"))
		return soap_instantiate_tt__PrefixedIPv6Address(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:HostnameInformation"))
		return soap_instantiate_tt__HostnameInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:HostnameInformationExtension"))
		return soap_instantiate_tt__HostnameInformationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DNSInformation"))
		return soap_instantiate_tt__DNSInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DNSInformationExtension"))
		return soap_instantiate_tt__DNSInformationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NTPInformation"))
		return soap_instantiate_tt__NTPInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NTPInformationExtension"))
		return soap_instantiate_tt__NTPInformationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DynamicDNSInformation"))
		return soap_instantiate_tt__DynamicDNSInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DynamicDNSInformationExtension"))
		return soap_instantiate_tt__DynamicDNSInformationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceSetConfiguration"))
		return soap_instantiate_tt__NetworkInterfaceSetConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceSetConfigurationExtension"))
		return soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv6NetworkInterfaceSetConfiguration"))
		return soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPv4NetworkInterfaceSetConfiguration"))
		return soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkGateway"))
		return soap_instantiate_tt__NetworkGateway(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkZeroConfiguration"))
		return soap_instantiate_tt__NetworkZeroConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkZeroConfigurationExtension"))
		return soap_instantiate_tt__NetworkZeroConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkZeroConfigurationExtension2"))
		return soap_instantiate_tt__NetworkZeroConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPAddressFilter"))
		return soap_instantiate_tt__IPAddressFilter(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IPAddressFilterExtension"))
		return soap_instantiate_tt__IPAddressFilterExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11Configuration"))
		return soap_instantiate_tt__Dot11Configuration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11SecurityConfiguration"))
		return soap_instantiate_tt__Dot11SecurityConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11SecurityConfigurationExtension"))
		return soap_instantiate_tt__Dot11SecurityConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11PSKSet"))
		return soap_instantiate_tt__Dot11PSKSet(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11PSKSetExtension"))
		return soap_instantiate_tt__Dot11PSKSetExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterfaceSetConfigurationExtension2"))
		return soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11Capabilities"))
		return soap_instantiate_tt__Dot11Capabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11Status"))
		return soap_instantiate_tt__Dot11Status(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11AvailableNetworks"))
		return soap_instantiate_tt__Dot11AvailableNetworks(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot11AvailableNetworksExtension"))
		return soap_instantiate_tt__Dot11AvailableNetworksExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Capabilities"))
		return soap_instantiate_tt__Capabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CapabilitiesExtension"))
		return soap_instantiate_tt__CapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CapabilitiesExtension2"))
		return soap_instantiate_tt__CapabilitiesExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsCapabilities"))
		return soap_instantiate_tt__AnalyticsCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceCapabilities"))
		return soap_instantiate_tt__DeviceCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceCapabilitiesExtension"))
		return soap_instantiate_tt__DeviceCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EventCapabilities"))
		return soap_instantiate_tt__EventCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IOCapabilities"))
		return soap_instantiate_tt__IOCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IOCapabilitiesExtension"))
		return soap_instantiate_tt__IOCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IOCapabilitiesExtension2"))
		return soap_instantiate_tt__IOCapabilitiesExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MediaCapabilities"))
		return soap_instantiate_tt__MediaCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MediaCapabilitiesExtension"))
		return soap_instantiate_tt__MediaCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RealTimeStreamingCapabilities"))
		return soap_instantiate_tt__RealTimeStreamingCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RealTimeStreamingCapabilitiesExtension"))
		return soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ProfileCapabilities"))
		return soap_instantiate_tt__ProfileCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkCapabilities"))
		return soap_instantiate_tt__NetworkCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkCapabilitiesExtension"))
		return soap_instantiate_tt__NetworkCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkCapabilitiesExtension2"))
		return soap_instantiate_tt__NetworkCapabilitiesExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SecurityCapabilities"))
		return soap_instantiate_tt__SecurityCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SecurityCapabilitiesExtension"))
		return soap_instantiate_tt__SecurityCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SecurityCapabilitiesExtension2"))
		return soap_instantiate_tt__SecurityCapabilitiesExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemCapabilities"))
		return soap_instantiate_tt__SystemCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemCapabilitiesExtension"))
		return soap_instantiate_tt__SystemCapabilitiesExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemCapabilitiesExtension2"))
		return soap_instantiate_tt__SystemCapabilitiesExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OnvifVersion"))
		return soap_instantiate_tt__OnvifVersion(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingCapabilities"))
		return soap_instantiate_tt__ImagingCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZCapabilities"))
		return soap_instantiate_tt__PTZCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceIOCapabilities"))
		return soap_instantiate_tt__DeviceIOCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DisplayCapabilities"))
		return soap_instantiate_tt__DisplayCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RecordingCapabilities"))
		return soap_instantiate_tt__RecordingCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SearchCapabilities"))
		return soap_instantiate_tt__SearchCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReplayCapabilities"))
		return soap_instantiate_tt__ReplayCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ReceiverCapabilities"))
		return soap_instantiate_tt__ReceiverCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsDeviceCapabilities"))
		return soap_instantiate_tt__AnalyticsDeviceCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsDeviceExtension"))
		return soap_instantiate_tt__AnalyticsDeviceExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemLog"))
		return soap_instantiate_tt__SystemLog(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SupportInformation"))
		return soap_instantiate_tt__SupportInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BinaryData"))
		return soap_instantiate_tt__BinaryData(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AttachmentData"))
		return soap_instantiate_tt__AttachmentData(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BackupFile"))
		return soap_instantiate_tt__BackupFile(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemLogUriList"))
		return soap_instantiate_tt__SystemLogUriList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemLogUri"))
		return soap_instantiate_tt__SystemLogUri(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemDateTime"))
		return soap_instantiate_tt__SystemDateTime(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:SystemDateTimeExtension"))
		return soap_instantiate_tt__SystemDateTimeExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DateTime"))
		return soap_instantiate_tt__DateTime(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Date"))
		return soap_instantiate_tt__Date(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Time"))
		return soap_instantiate_tt__Time(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:TimeZone"))
		return soap_instantiate_tt__TimeZone(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RemoteUser"))
		return soap_instantiate_tt__RemoteUser(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:User"))
		return soap_instantiate_tt__User(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:UserExtension"))
		return soap_instantiate_tt__UserExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Certificate"))
		return soap_instantiate_tt__Certificate(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CertificateStatus"))
		return soap_instantiate_tt__CertificateStatus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CertificateWithPrivateKey"))
		return soap_instantiate_tt__CertificateWithPrivateKey(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CertificateInformation"))
		return soap_instantiate_tt__CertificateInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CertificateInformationExtension"))
		return soap_instantiate_tt__CertificateInformationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot1XConfiguration"))
		return soap_instantiate_tt__Dot1XConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Dot1XConfigurationExtension"))
		return soap_instantiate_tt__Dot1XConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EAPMethodConfiguration"))
		return soap_instantiate_tt__EAPMethodConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EapMethodExtension"))
		return soap_instantiate_tt__EapMethodExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:TLSConfiguration"))
		return soap_instantiate_tt__TLSConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayOutputSettings"))
		return soap_instantiate_tt__RelayOutputSettings(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfigurationExtension"))
		return soap_instantiate_tt__PTZConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfigurationExtension2"))
		return soap_instantiate_tt__PTZConfigurationExtension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTControlDirection"))
		return soap_instantiate_tt__PTControlDirection(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTControlDirectionExtension"))
		return soap_instantiate_tt__PTControlDirectionExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:EFlip"))
		return soap_instantiate_tt__EFlip(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Reverse"))
		return soap_instantiate_tt__Reverse(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PanTiltLimits"))
		return soap_instantiate_tt__PanTiltLimits(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ZoomLimits"))
		return soap_instantiate_tt__ZoomLimits(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Space2DDescription"))
		return soap_instantiate_tt__Space2DDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Space1DDescription"))
		return soap_instantiate_tt__Space1DDescription(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZSpeed"))
		return soap_instantiate_tt__PTZSpeed(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusConfiguration"))
		return soap_instantiate_tt__FocusConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettings"))
		return soap_instantiate_tt__ImagingSettings(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension"))
		return soap_instantiate_tt__ImagingSettingsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Exposure"))
		return soap_instantiate_tt__Exposure(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicRange"))
		return soap_instantiate_tt__WideDynamicRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensation"))
		return soap_instantiate_tt__BacklightCompensation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusMove"))
		return soap_instantiate_tt__FocusMove(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AbsoluteFocus"))
		return soap_instantiate_tt__AbsoluteFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelativeFocus"))
		return soap_instantiate_tt__RelativeFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ContinuousFocus"))
		return soap_instantiate_tt__ContinuousFocus(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AbsoluteFocusOptions"))
		return soap_instantiate_tt__AbsoluteFocusOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ContinuousFocusOptions"))
		return soap_instantiate_tt__ContinuousFocusOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalance"))
		return soap_instantiate_tt__WhiteBalance(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingStatus20"))
		return soap_instantiate_tt__ImagingStatus20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingStatus20Extension"))
		return soap_instantiate_tt__ImagingStatus20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusStatus20"))
		return soap_instantiate_tt__FocusStatus20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusStatus20Extension"))
		return soap_instantiate_tt__FocusStatus20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettings20"))
		return soap_instantiate_tt__ImagingSettings20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension20"))
		return soap_instantiate_tt__ImagingSettingsExtension20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension202"))
		return soap_instantiate_tt__ImagingSettingsExtension202(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension203"))
		return soap_instantiate_tt__ImagingSettingsExtension203(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingSettingsExtension204"))
		return soap_instantiate_tt__ImagingSettingsExtension204(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilization"))
		return soap_instantiate_tt__ImageStabilization(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationExtension"))
		return soap_instantiate_tt__ImageStabilizationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustment"))
		return soap_instantiate_tt__IrCutFilterAutoAdjustment(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentExtension"))
		return soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicRange20"))
		return soap_instantiate_tt__WideDynamicRange20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensation20"))
		return soap_instantiate_tt__BacklightCompensation20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Exposure20"))
		return soap_instantiate_tt__Exposure20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensation"))
		return soap_instantiate_tt__ToneCompensation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensationExtension"))
		return soap_instantiate_tt__ToneCompensationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Defogging"))
		return soap_instantiate_tt__Defogging(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DefoggingExtension"))
		return soap_instantiate_tt__DefoggingExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NoiseReduction"))
		return soap_instantiate_tt__NoiseReduction(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20"))
		return soap_instantiate_tt__ImagingOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension"))
		return soap_instantiate_tt__ImagingOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension2"))
		return soap_instantiate_tt__ImagingOptions20Extension2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension3"))
		return soap_instantiate_tt__ImagingOptions20Extension3(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingOptions20Extension4"))
		return soap_instantiate_tt__ImagingOptions20Extension4(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationOptions"))
		return soap_instantiate_tt__ImageStabilizationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImageStabilizationOptionsExtension"))
		return soap_instantiate_tt__ImageStabilizationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentOptions"))
		return soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IrCutFilterAutoAdjustmentOptionsExtension"))
		return soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WideDynamicRangeOptions20"))
		return soap_instantiate_tt__WideDynamicRangeOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:BacklightCompensationOptions20"))
		return soap_instantiate_tt__BacklightCompensationOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ExposureOptions20"))
		return soap_instantiate_tt__ExposureOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MoveOptions20"))
		return soap_instantiate_tt__MoveOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelativeFocusOptions20"))
		return soap_instantiate_tt__RelativeFocusOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalance20"))
		return soap_instantiate_tt__WhiteBalance20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalance20Extension"))
		return soap_instantiate_tt__WhiteBalance20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusConfiguration20"))
		return soap_instantiate_tt__FocusConfiguration20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusConfiguration20Extension"))
		return soap_instantiate_tt__FocusConfiguration20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceOptions20"))
		return soap_instantiate_tt__WhiteBalanceOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:WhiteBalanceOptions20Extension"))
		return soap_instantiate_tt__WhiteBalanceOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusOptions20"))
		return soap_instantiate_tt__FocusOptions20(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:FocusOptions20Extension"))
		return soap_instantiate_tt__FocusOptions20Extension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ToneCompensationOptions"))
		return soap_instantiate_tt__ToneCompensationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DefoggingOptions"))
		return soap_instantiate_tt__DefoggingOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NoiseReductionOptions"))
		return soap_instantiate_tt__NoiseReductionOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MessageExtension"))
		return soap_instantiate_tt__MessageExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ItemList"))
		return soap_instantiate_tt__ItemList(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ItemListExtension"))
		return soap_instantiate_tt__ItemListExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Polyline"))
		return soap_instantiate_tt__Polyline(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineConfiguration"))
		return soap_instantiate_tt__AnalyticsEngineConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AnalyticsEngineConfigurationExtension"))
		return soap_instantiate_tt__AnalyticsEngineConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RuleEngineConfiguration"))
		return soap_instantiate_tt__RuleEngineConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RuleEngineConfigurationExtension"))
		return soap_instantiate_tt__RuleEngineConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Config"))
		return soap_instantiate_tt__Config(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DateTimeRange"))
		return soap_instantiate_tt__DateTimeRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDPosConfiguration"))
		return soap_instantiate_tt__OSDPosConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDPosConfigurationExtension"))
		return soap_instantiate_tt__OSDPosConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDColor"))
		return soap_instantiate_tt__OSDColor(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDTextConfiguration"))
		return soap_instantiate_tt__OSDTextConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDTextConfigurationExtension"))
		return soap_instantiate_tt__OSDTextConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDImgConfiguration"))
		return soap_instantiate_tt__OSDImgConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDImgConfigurationExtension"))
		return soap_instantiate_tt__OSDImgConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ColorspaceRange"))
		return soap_instantiate_tt__ColorspaceRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ColorOptions"))
		return soap_instantiate_tt__ColorOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDColorOptions"))
		return soap_instantiate_tt__OSDColorOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDColorOptionsExtension"))
		return soap_instantiate_tt__OSDColorOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDTextOptions"))
		return soap_instantiate_tt__OSDTextOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDTextOptionsExtension"))
		return soap_instantiate_tt__OSDTextOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDImgOptions"))
		return soap_instantiate_tt__OSDImgOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDImgOptionsExtension"))
		return soap_instantiate_tt__OSDImgOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfigurationExtension"))
		return soap_instantiate_tt__OSDConfigurationExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MaximumNumberOfOSDs"))
		return soap_instantiate_tt__MaximumNumberOfOSDs(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfigurationOptions"))
		return soap_instantiate_tt__OSDConfigurationOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfigurationOptionsExtension"))
		return soap_instantiate_tt__OSDConfigurationOptionsExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PolygonOptions"))
		return soap_instantiate_tt__PolygonOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:IntRange"))
		return soap_instantiate_tt__IntRange(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector2D"))
		return soap_instantiate_tt__Vector2D(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector1D"))
		return soap_instantiate_tt__Vector1D(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Vector"))
		return soap_instantiate_tt__Vector(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Rectangle"))
		return soap_instantiate_tt__Rectangle(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Polygon"))
		return soap_instantiate_tt__Polygon(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Color"))
		return soap_instantiate_tt__Color(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:GeoLocation"))
		return soap_instantiate_tt__GeoLocation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:GeoOrientation"))
		return soap_instantiate_tt__GeoOrientation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LocalLocation"))
		return soap_instantiate_tt__LocalLocation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LocalOrientation"))
		return soap_instantiate_tt__LocalOrientation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:LocationEntity"))
		return soap_instantiate_tt__LocationEntity(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MediaServiceProperties"))
		return soap_instantiate_tt__MediaServiceProperties(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingVideoSourceOptions"))
		return soap_instantiate_tt__ImagingVideoSourceOptions(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingServiceProperties"))
		return soap_instantiate_tt__ImagingServiceProperties(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceInformation"))
		return soap_instantiate_tt__DeviceInformation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceManagementServiceProperties"))
		return soap_instantiate_tt__DeviceManagementServiceProperties(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RTSPServerExecutable"))
		return soap_instantiate_tt__RTSPServerExecutable(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RTSPServerAPI"))
		return soap_instantiate_tt__RTSPServerAPI(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RTSPStream"))
		return soap_instantiate_tt__RTSPStream(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:DeviceHomePage"))
		return soap_instantiate_tt__DeviceHomePage(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:HTMLWebServer"))
		return soap_instantiate_tt__HTMLWebServer(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MinimumProfile"))
		return soap_instantiate_tt__MinimumProfile(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingVideoSource"))
		return soap_instantiate_tt__ImagingVideoSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:ImagingServiceConfiguration"))
		return soap_instantiate_tt__ImagingServiceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MediaServiceConfiguration"))
		return soap_instantiate_tt__MediaServiceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:QueryExpressionType"))
		return soap_instantiate_wsnt__QueryExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionType"))
		return soap_instantiate_wsnt__TopicExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:FilterType"))
		return soap_instantiate_wsnt__FilterType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscriptionPolicyType"))
		return soap_instantiate_wsnt__SubscriptionPolicyType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotificationMessageHolderType"))
		return soap_instantiate_wsnt__NotificationMessageHolderType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsrfbf:BaseFaultType"))
		return soap_instantiate_wsrfbf__BaseFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:Documentation"))
		return soap_instantiate_wstop__Documentation(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:ExtensibleDocumented"))
		return soap_instantiate_wstop__ExtensibleDocumented(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:QueryExpressionType"))
		return soap_instantiate_wstop__QueryExpressionType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "timg:Capabilities"))
		return soap_instantiate_timg__Capabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "timg:ImagingPreset"))
		return soap_instantiate_timg__ImagingPreset(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "trt:Capabilities"))
		return soap_instantiate_trt__Capabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "trt:ProfileCapabilities"))
		return soap_instantiate_trt__ProfileCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "trt:StreamingCapabilities"))
		return soap_instantiate_trt__StreamingCapabilities(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "trt:VideoSourceMode"))
		return soap_instantiate_trt__VideoSourceMode(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "trt:VideoSourceModeExtension"))
		return soap_instantiate_trt__VideoSourceModeExtension(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tds:StorageConfiguration"))
		return soap_instantiate_tds__StorageConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSource"))
		return soap_instantiate_tt__VideoSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSource"))
		return soap_instantiate_tt__AudioSource(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
		return soap_instantiate_tt__VideoSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
		return soap_instantiate_tt__VideoEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:JpegOptions2"))
		return soap_instantiate_tt__JpegOptions2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:Mpeg4Options2"))
		return soap_instantiate_tt__Mpeg4Options2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:H264Options2"))
		return soap_instantiate_tt__H264Options2(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
		return soap_instantiate_tt__AudioSourceConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
		return soap_instantiate_tt__AudioEncoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
		return soap_instantiate_tt__VideoAnalyticsConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
		return soap_instantiate_tt__MetadataConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutput"))
		return soap_instantiate_tt__AudioOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
		return soap_instantiate_tt__AudioOutputConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
		return soap_instantiate_tt__AudioDecoderConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
		return soap_instantiate_tt__NetworkInterface(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:CertificateUsage"))
		return soap_instantiate_tt__CertificateUsage(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:RelayOutput"))
		return soap_instantiate_tt__RelayOutput(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return soap_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDConfiguration"))
		return soap_instantiate_tt__OSDConfiguration(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:SubscribeCreationFailedFaultType"))
		return soap_instantiate_wsnt__SubscribeCreationFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidFilterFaultType"))
		return soap_instantiate_wsnt__InvalidFilterFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicExpressionDialectUnknownFaultType"))
		return soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidTopicExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidTopicExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:TopicNotSupportedFaultType"))
		return soap_instantiate_wsnt__TopicNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:MultipleTopicsSpecifiedFaultType"))
		return soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:InvalidMessageContentExpressionFaultType"))
		return soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnrecognizedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnsupportedPolicyRequestFaultType"))
		return soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NotifyMessageNotSupportedFaultType"))
		return soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:NoCurrentMessageOnTopicFaultType"))
		return soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToGetMessagesFaultType"))
		return soap_instantiate_wsnt__UnableToGetMessagesFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroyPullPointFaultType"))
		return soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToCreatePullPointFaultType"))
		return soap_instantiate_wsnt__UnableToCreatePullPointFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnacceptableTerminationTimeFaultType"))
		return soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:UnableToDestroySubscriptionFaultType"))
		return soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:PauseFailedFaultType"))
		return soap_instantiate_wsnt__PauseFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wsnt:ResumeFailedFaultType"))
		return soap_instantiate_wsnt__ResumeFailedFaultType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicNamespaceType"))
		return soap_instantiate_wstop__TopicNamespaceType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicType"))
		return soap_instantiate_wstop__TopicType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "wstop:TopicSetType"))
		return soap_instantiate_wstop__TopicSetType(soap, n, NULL, NULL, size);
	if (soap && type && !soap_match_tag(soap, type, "tt:OSDReference"))
		return soap_instantiate_tt__OSDReference(soap, n, NULL, NULL, size);
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__DeleteOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__DeleteOSD(soap, &a->trt__DeleteOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__DeleteOSD(struct soap *soap, const char *tag, int id, const struct __trt__DeleteOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", -1, &a->trt__DeleteOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_in___trt__DeleteOSD(struct soap *soap, const char *tag, struct __trt__DeleteOSD *a, const char *type)
{
	size_t soap_flag_trt__DeleteOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__DeleteOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__DeleteOSD, sizeof(struct __trt__DeleteOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__DeleteOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__DeleteOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__DeleteOSD(soap, "trt:DeleteOSD", &a->trt__DeleteOSD, ""))
				{	soap_flag_trt__DeleteOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__DeleteOSD * SOAP_FMAC2 soap_dup___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *d, struct __trt__DeleteOSD const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__DeleteOSD*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__DeleteOSD, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__DeleteOSD(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__DeleteOSD(soap, &d->trt__DeleteOSD, &a->trt__DeleteOSD);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__DeleteOSD(struct __trt__DeleteOSD const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__DeleteOSD(&a->trt__DeleteOSD);
}

SOAP_FMAC1 struct __trt__DeleteOSD * SOAP_FMAC2 soap_instantiate___trt__DeleteOSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__DeleteOSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__DeleteOSD *p;
	size_t k = sizeof(struct __trt__DeleteOSD);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__DeleteOSD, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__DeleteOSD);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__DeleteOSD, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__DeleteOSD location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__DeleteOSD(struct soap *soap, const struct __trt__DeleteOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__DeleteOSD(soap, tag ? tag : "-trt:DeleteOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteOSD * SOAP_FMAC4 soap_get___trt__DeleteOSD(struct soap *soap, struct __trt__DeleteOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__CreateOSD(soap, &a->trt__CreateOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateOSD(struct soap *soap, const char *tag, int id, const struct __trt__CreateOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", -1, &a->trt__CreateOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_in___trt__CreateOSD(struct soap *soap, const char *tag, struct __trt__CreateOSD *a, const char *type)
{
	size_t soap_flag_trt__CreateOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__CreateOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateOSD, sizeof(struct __trt__CreateOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__CreateOSD(soap, "trt:CreateOSD", &a->trt__CreateOSD, ""))
				{	soap_flag_trt__CreateOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__CreateOSD * SOAP_FMAC2 soap_dup___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *d, struct __trt__CreateOSD const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__CreateOSD*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__CreateOSD, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__CreateOSD(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__CreateOSD(soap, &d->trt__CreateOSD, &a->trt__CreateOSD);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__CreateOSD(struct __trt__CreateOSD const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__CreateOSD(&a->trt__CreateOSD);
}

SOAP_FMAC1 struct __trt__CreateOSD * SOAP_FMAC2 soap_instantiate___trt__CreateOSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__CreateOSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__CreateOSD *p;
	size_t k = sizeof(struct __trt__CreateOSD);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__CreateOSD, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__CreateOSD);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__CreateOSD, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__CreateOSD location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateOSD(struct soap *soap, const struct __trt__CreateOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__CreateOSD(soap, tag ? tag : "-trt:CreateOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateOSD * SOAP_FMAC4 soap_get___trt__CreateOSD(struct soap *soap, struct __trt__CreateOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetOSD(soap, &a->trt__SetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetOSD(struct soap *soap, const char *tag, int id, const struct __trt__SetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetOSD(soap, "trt:SetOSD", -1, &a->trt__SetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_in___trt__SetOSD(struct soap *soap, const char *tag, struct __trt__SetOSD *a, const char *type)
{
	size_t soap_flag_trt__SetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetOSD, sizeof(struct __trt__SetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetOSD(soap, "trt:SetOSD", &a->trt__SetOSD, ""))
				{	soap_flag_trt__SetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetOSD * SOAP_FMAC2 soap_dup___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *d, struct __trt__SetOSD const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetOSD*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetOSD, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetOSD(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetOSD(soap, &d->trt__SetOSD, &a->trt__SetOSD);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetOSD(struct __trt__SetOSD const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetOSD(&a->trt__SetOSD);
}

SOAP_FMAC1 struct __trt__SetOSD * SOAP_FMAC2 soap_instantiate___trt__SetOSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetOSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetOSD *p;
	size_t k = sizeof(struct __trt__SetOSD);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetOSD, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetOSD);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetOSD, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetOSD location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetOSD(struct soap *soap, const struct __trt__SetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetOSD(soap, tag ? tag : "-trt:SetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetOSD * SOAP_FMAC4 soap_get___trt__SetOSD(struct soap *soap, struct __trt__SetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDOptions(soap, &a->trt__GetOSDOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", -1, &a->trt__GetOSDOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_in___trt__GetOSDOptions(struct soap *soap, const char *tag, struct __trt__GetOSDOptions *a, const char *type)
{
	size_t soap_flag_trt__GetOSDOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDOptions, sizeof(struct __trt__GetOSDOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDOptions(soap, "trt:GetOSDOptions", &a->trt__GetOSDOptions, ""))
				{	soap_flag_trt__GetOSDOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetOSDOptions * SOAP_FMAC2 soap_dup___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *d, struct __trt__GetOSDOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetOSDOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetOSDOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetOSDOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetOSDOptions(soap, &d->trt__GetOSDOptions, &a->trt__GetOSDOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetOSDOptions(struct __trt__GetOSDOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetOSDOptions(&a->trt__GetOSDOptions);
}

SOAP_FMAC1 struct __trt__GetOSDOptions * SOAP_FMAC2 soap_instantiate___trt__GetOSDOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetOSDOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetOSDOptions *p;
	size_t k = sizeof(struct __trt__GetOSDOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetOSDOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetOSDOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetOSDOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetOSDOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDOptions(struct soap *soap, const struct __trt__GetOSDOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDOptions(soap, tag ? tag : "-trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDOptions * SOAP_FMAC4 soap_get___trt__GetOSDOptions(struct soap *soap, struct __trt__GetOSDOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSD = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSD(soap, &a->trt__GetOSD);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSD(struct soap *soap, const char *tag, int id, const struct __trt__GetOSD *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSD(soap, "trt:GetOSD", -1, &a->trt__GetOSD, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_in___trt__GetOSD(struct soap *soap, const char *tag, struct __trt__GetOSD *a, const char *type)
{
	size_t soap_flag_trt__GetOSD = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSD*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSD, sizeof(struct __trt__GetOSD), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSD(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSD && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSD(soap, "trt:GetOSD", &a->trt__GetOSD, ""))
				{	soap_flag_trt__GetOSD--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetOSD * SOAP_FMAC2 soap_dup___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *d, struct __trt__GetOSD const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetOSD*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetOSD, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetOSD(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetOSD(soap, &d->trt__GetOSD, &a->trt__GetOSD);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetOSD(struct __trt__GetOSD const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetOSD(&a->trt__GetOSD);
}

SOAP_FMAC1 struct __trt__GetOSD * SOAP_FMAC2 soap_instantiate___trt__GetOSD(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetOSD(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetOSD *p;
	size_t k = sizeof(struct __trt__GetOSD);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetOSD, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetOSD);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetOSD, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetOSD location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSD(struct soap *soap, const struct __trt__GetOSD *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSD(soap, tag ? tag : "-trt:GetOSD", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSD * SOAP_FMAC4 soap_get___trt__GetOSD(struct soap *soap, struct __trt__GetOSD *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetOSDs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetOSDs(soap, &a->trt__GetOSDs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetOSDs(struct soap *soap, const char *tag, int id, const struct __trt__GetOSDs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", -1, &a->trt__GetOSDs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_in___trt__GetOSDs(struct soap *soap, const char *tag, struct __trt__GetOSDs *a, const char *type)
{
	size_t soap_flag_trt__GetOSDs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetOSDs*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetOSDs, sizeof(struct __trt__GetOSDs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetOSDs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetOSDs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetOSDs(soap, "trt:GetOSDs", &a->trt__GetOSDs, ""))
				{	soap_flag_trt__GetOSDs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetOSDs * SOAP_FMAC2 soap_dup___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *d, struct __trt__GetOSDs const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetOSDs*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetOSDs, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetOSDs(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetOSDs(soap, &d->trt__GetOSDs, &a->trt__GetOSDs);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetOSDs(struct __trt__GetOSDs const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetOSDs(&a->trt__GetOSDs);
}

SOAP_FMAC1 struct __trt__GetOSDs * SOAP_FMAC2 soap_instantiate___trt__GetOSDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetOSDs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetOSDs *p;
	size_t k = sizeof(struct __trt__GetOSDs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetOSDs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetOSDs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetOSDs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetOSDs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetOSDs(struct soap *soap, const struct __trt__GetOSDs *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetOSDs(soap, tag ? tag : "-trt:GetOSDs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetOSDs * SOAP_FMAC4 soap_get___trt__GetOSDs(struct soap *soap, struct __trt__GetOSDs *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoSourceMode(soap, &a->trt__SetVideoSourceMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", -1, &a->trt__SetVideoSourceMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_in___trt__SetVideoSourceMode(struct soap *soap, const char *tag, struct __trt__SetVideoSourceMode *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoSourceMode*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceMode, sizeof(struct __trt__SetVideoSourceMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoSourceMode(soap, "trt:SetVideoSourceMode", &a->trt__SetVideoSourceMode, ""))
				{	soap_flag_trt__SetVideoSourceMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetVideoSourceMode * SOAP_FMAC2 soap_dup___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *d, struct __trt__SetVideoSourceMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetVideoSourceMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetVideoSourceMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetVideoSourceMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetVideoSourceMode(soap, &d->trt__SetVideoSourceMode, &a->trt__SetVideoSourceMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetVideoSourceMode(struct __trt__SetVideoSourceMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetVideoSourceMode(&a->trt__SetVideoSourceMode);
}

SOAP_FMAC1 struct __trt__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoSourceMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetVideoSourceMode *p;
	size_t k = sizeof(struct __trt__SetVideoSourceMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetVideoSourceMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetVideoSourceMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetVideoSourceMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetVideoSourceMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceMode(struct soap *soap, const struct __trt__SetVideoSourceMode *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoSourceMode(soap, tag ? tag : "-trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceMode * SOAP_FMAC4 soap_get___trt__SetVideoSourceMode(struct soap *soap, struct __trt__SetVideoSourceMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceModes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceModes(struct soap *soap, const struct __trt__GetVideoSourceModes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceModes(soap, &a->trt__GetVideoSourceModes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceModes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceModes(soap, "trt:GetVideoSourceModes", -1, &a->trt__GetVideoSourceModes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceModes * SOAP_FMAC4 soap_in___trt__GetVideoSourceModes(struct soap *soap, const char *tag, struct __trt__GetVideoSourceModes *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceModes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceModes*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceModes, sizeof(struct __trt__GetVideoSourceModes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceModes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceModes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceModes(soap, "trt:GetVideoSourceModes", &a->trt__GetVideoSourceModes, ""))
				{	soap_flag_trt__GetVideoSourceModes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoSourceModes * SOAP_FMAC2 soap_dup___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *d, struct __trt__GetVideoSourceModes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoSourceModes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoSourceModes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoSourceModes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoSourceModes(soap, &d->trt__GetVideoSourceModes, &a->trt__GetVideoSourceModes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoSourceModes(struct __trt__GetVideoSourceModes const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoSourceModes(&a->trt__GetVideoSourceModes);
}

SOAP_FMAC1 struct __trt__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceModes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceModes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoSourceModes *p;
	size_t k = sizeof(struct __trt__GetVideoSourceModes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoSourceModes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoSourceModes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoSourceModes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoSourceModes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceModes(struct soap *soap, const struct __trt__GetVideoSourceModes *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceModes(soap, tag ? tag : "-trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceModes * SOAP_FMAC4 soap_get___trt__GetVideoSourceModes(struct soap *soap, struct __trt__GetVideoSourceModes *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetSnapshotUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetSnapshotUri(soap, &a->trt__GetSnapshotUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, const struct __trt__GetSnapshotUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", -1, &a->trt__GetSnapshotUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_in___trt__GetSnapshotUri(struct soap *soap, const char *tag, struct __trt__GetSnapshotUri *a, const char *type)
{
	size_t soap_flag_trt__GetSnapshotUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetSnapshotUri*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetSnapshotUri, sizeof(struct __trt__GetSnapshotUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetSnapshotUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetSnapshotUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetSnapshotUri(soap, "trt:GetSnapshotUri", &a->trt__GetSnapshotUri, ""))
				{	soap_flag_trt__GetSnapshotUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetSnapshotUri * SOAP_FMAC2 soap_dup___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *d, struct __trt__GetSnapshotUri const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetSnapshotUri*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetSnapshotUri, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetSnapshotUri(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetSnapshotUri(soap, &d->trt__GetSnapshotUri, &a->trt__GetSnapshotUri);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetSnapshotUri(struct __trt__GetSnapshotUri const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetSnapshotUri(&a->trt__GetSnapshotUri);
}

SOAP_FMAC1 struct __trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___trt__GetSnapshotUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetSnapshotUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetSnapshotUri *p;
	size_t k = sizeof(struct __trt__GetSnapshotUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetSnapshotUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetSnapshotUri);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetSnapshotUri, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetSnapshotUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetSnapshotUri(struct soap *soap, const struct __trt__GetSnapshotUri *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetSnapshotUri(soap, tag ? tag : "-trt:GetSnapshotUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetSnapshotUri * SOAP_FMAC4 soap_get___trt__GetSnapshotUri(struct soap *soap, struct __trt__GetSnapshotUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetSynchronizationPoint = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetSynchronizationPoint(soap, &a->trt__SetSynchronizationPoint);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct __trt__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", -1, &a->trt__SetSynchronizationPoint, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_in___trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct __trt__SetSynchronizationPoint *a, const char *type)
{
	size_t soap_flag_trt__SetSynchronizationPoint = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetSynchronizationPoint*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetSynchronizationPoint, sizeof(struct __trt__SetSynchronizationPoint), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetSynchronizationPoint(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetSynchronizationPoint && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetSynchronizationPoint(soap, "trt:SetSynchronizationPoint", &a->trt__SetSynchronizationPoint, ""))
				{	soap_flag_trt__SetSynchronizationPoint--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetSynchronizationPoint * SOAP_FMAC2 soap_dup___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *d, struct __trt__SetSynchronizationPoint const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetSynchronizationPoint*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetSynchronizationPoint, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetSynchronizationPoint(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetSynchronizationPoint(soap, &d->trt__SetSynchronizationPoint, &a->trt__SetSynchronizationPoint);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetSynchronizationPoint(struct __trt__SetSynchronizationPoint const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetSynchronizationPoint(&a->trt__SetSynchronizationPoint);
}

SOAP_FMAC1 struct __trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___trt__SetSynchronizationPoint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetSynchronizationPoint(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetSynchronizationPoint *p;
	size_t k = sizeof(struct __trt__SetSynchronizationPoint);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetSynchronizationPoint, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetSynchronizationPoint);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetSynchronizationPoint, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetSynchronizationPoint location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetSynchronizationPoint(struct soap *soap, const struct __trt__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetSynchronizationPoint(soap, tag ? tag : "-trt:SetSynchronizationPoint", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetSynchronizationPoint * SOAP_FMAC4 soap_get___trt__SetSynchronizationPoint(struct soap *soap, struct __trt__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StopMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__StopMulticastStreaming(soap, &a->trt__StopMulticastStreaming);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StopMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", -1, &a->trt__StopMulticastStreaming, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_in___trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StopMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StopMulticastStreaming = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__StopMulticastStreaming*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StopMulticastStreaming, sizeof(struct __trt__StopMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__StopMulticastStreaming(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__StopMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__StopMulticastStreaming(soap, "trt:StopMulticastStreaming", &a->trt__StopMulticastStreaming, ""))
				{	soap_flag_trt__StopMulticastStreaming--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__StopMulticastStreaming * SOAP_FMAC2 soap_dup___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *d, struct __trt__StopMulticastStreaming const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__StopMulticastStreaming*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__StopMulticastStreaming, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__StopMulticastStreaming(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__StopMulticastStreaming(soap, &d->trt__StopMulticastStreaming, &a->trt__StopMulticastStreaming);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__StopMulticastStreaming(struct __trt__StopMulticastStreaming const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__StopMulticastStreaming(&a->trt__StopMulticastStreaming);
}

SOAP_FMAC1 struct __trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StopMulticastStreaming(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__StopMulticastStreaming(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__StopMulticastStreaming *p;
	size_t k = sizeof(struct __trt__StopMulticastStreaming);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__StopMulticastStreaming, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__StopMulticastStreaming);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__StopMulticastStreaming, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__StopMulticastStreaming location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StopMulticastStreaming(struct soap *soap, const struct __trt__StopMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out___trt__StopMulticastStreaming(soap, tag ? tag : "-trt:StopMulticastStreaming", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StopMulticastStreaming * SOAP_FMAC4 soap_get___trt__StopMulticastStreaming(struct soap *soap, struct __trt__StopMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__StartMulticastStreaming = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__StartMulticastStreaming(soap, &a->trt__StartMulticastStreaming);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, const struct __trt__StartMulticastStreaming *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", -1, &a->trt__StartMulticastStreaming, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_in___trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct __trt__StartMulticastStreaming *a, const char *type)
{
	size_t soap_flag_trt__StartMulticastStreaming = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__StartMulticastStreaming*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__StartMulticastStreaming, sizeof(struct __trt__StartMulticastStreaming), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__StartMulticastStreaming(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__StartMulticastStreaming && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__StartMulticastStreaming(soap, "trt:StartMulticastStreaming", &a->trt__StartMulticastStreaming, ""))
				{	soap_flag_trt__StartMulticastStreaming--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__StartMulticastStreaming * SOAP_FMAC2 soap_dup___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *d, struct __trt__StartMulticastStreaming const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__StartMulticastStreaming*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__StartMulticastStreaming, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__StartMulticastStreaming(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__StartMulticastStreaming(soap, &d->trt__StartMulticastStreaming, &a->trt__StartMulticastStreaming);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__StartMulticastStreaming(struct __trt__StartMulticastStreaming const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__StartMulticastStreaming(&a->trt__StartMulticastStreaming);
}

SOAP_FMAC1 struct __trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StartMulticastStreaming(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__StartMulticastStreaming(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__StartMulticastStreaming *p;
	size_t k = sizeof(struct __trt__StartMulticastStreaming);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__StartMulticastStreaming, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__StartMulticastStreaming);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__StartMulticastStreaming, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__StartMulticastStreaming location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__StartMulticastStreaming(struct soap *soap, const struct __trt__StartMulticastStreaming *a, const char *tag, const char *type)
{
	if (soap_out___trt__StartMulticastStreaming(soap, tag ? tag : "-trt:StartMulticastStreaming", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__StartMulticastStreaming * SOAP_FMAC4 soap_get___trt__StartMulticastStreaming(struct soap *soap, struct __trt__StartMulticastStreaming *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetStreamUri = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetStreamUri(soap, &a->trt__GetStreamUri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetStreamUri(struct soap *soap, const char *tag, int id, const struct __trt__GetStreamUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", -1, &a->trt__GetStreamUri, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_in___trt__GetStreamUri(struct soap *soap, const char *tag, struct __trt__GetStreamUri *a, const char *type)
{
	size_t soap_flag_trt__GetStreamUri = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetStreamUri*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetStreamUri, sizeof(struct __trt__GetStreamUri), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetStreamUri(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetStreamUri && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetStreamUri(soap, "trt:GetStreamUri", &a->trt__GetStreamUri, ""))
				{	soap_flag_trt__GetStreamUri--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetStreamUri * SOAP_FMAC2 soap_dup___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *d, struct __trt__GetStreamUri const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetStreamUri*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetStreamUri, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetStreamUri(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetStreamUri(soap, &d->trt__GetStreamUri, &a->trt__GetStreamUri);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetStreamUri(struct __trt__GetStreamUri const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetStreamUri(&a->trt__GetStreamUri);
}

SOAP_FMAC1 struct __trt__GetStreamUri * SOAP_FMAC2 soap_instantiate___trt__GetStreamUri(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetStreamUri(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetStreamUri *p;
	size_t k = sizeof(struct __trt__GetStreamUri);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetStreamUri, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetStreamUri);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetStreamUri, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetStreamUri location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetStreamUri(struct soap *soap, const struct __trt__GetStreamUri *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetStreamUri(soap, tag ? tag : "-trt:GetStreamUri", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetStreamUri * SOAP_FMAC4 soap_get___trt__GetStreamUri(struct soap *soap, struct __trt__GetStreamUri *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetGuaranteedNumberOfVideoEncoderInstances = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, &a->trt__GetGuaranteedNumberOfVideoEncoderInstances);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, "trt:GetGuaranteedNumberOfVideoEncoderInstances", -1, &a->trt__GetGuaranteedNumberOfVideoEncoderInstances, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_in___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *type)
{
	size_t soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct __trt__GetGuaranteedNumberOfVideoEncoderInstances), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, "trt:GetGuaranteedNumberOfVideoEncoderInstances", &a->trt__GetGuaranteedNumberOfVideoEncoderInstances, ""))
				{	soap_flag_trt__GetGuaranteedNumberOfVideoEncoderInstances--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_dup___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *d, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetGuaranteedNumberOfVideoEncoderInstances*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, &d->trt__GetGuaranteedNumberOfVideoEncoderInstances, &a->trt__GetGuaranteedNumberOfVideoEncoderInstances);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct __trt__GetGuaranteedNumberOfVideoEncoderInstances const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(&a->trt__GetGuaranteedNumberOfVideoEncoderInstances);
}

SOAP_FMAC1 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *p;
	size_t k = sizeof(struct __trt__GetGuaranteedNumberOfVideoEncoderInstances);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetGuaranteedNumberOfVideoEncoderInstances location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag ? tag : "-trt:GetGuaranteedNumberOfVideoEncoderInstances", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC4 soap_get___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct __trt__GetGuaranteedNumberOfVideoEncoderInstances *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioDecoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, &a->trt__GetAudioDecoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, "trt:GetAudioDecoderConfigurationOptions", -1, &a->trt__GetAudioDecoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions, sizeof(struct __trt__GetAudioDecoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, "trt:GetAudioDecoderConfigurationOptions", &a->trt__GetAudioDecoderConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioDecoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioDecoderConfigurationOptions *d, struct __trt__GetAudioDecoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioDecoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioDecoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, &d->trt__GetAudioDecoderConfigurationOptions, &a->trt__GetAudioDecoderConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioDecoderConfigurationOptions(struct __trt__GetAudioDecoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioDecoderConfigurationOptions(&a->trt__GetAudioDecoderConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioDecoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioDecoderConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetAudioDecoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioDecoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioDecoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioDecoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioDecoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfigurationOptions(soap, tag ? tag : "-trt:GetAudioDecoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioDecoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct __trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct __trt__GetAudioOutputConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, &a->trt__GetAudioOutputConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, "trt:GetAudioOutputConfigurationOptions", -1, &a->trt__GetAudioOutputConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfigurationOptions, sizeof(struct __trt__GetAudioOutputConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, "trt:GetAudioOutputConfigurationOptions", &a->trt__GetAudioOutputConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioOutputConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct __trt__GetAudioOutputConfigurationOptions *d, struct __trt__GetAudioOutputConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioOutputConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioOutputConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioOutputConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, &d->trt__GetAudioOutputConfigurationOptions, &a->trt__GetAudioOutputConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioOutputConfigurationOptions(struct __trt__GetAudioOutputConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioOutputConfigurationOptions(&a->trt__GetAudioOutputConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioOutputConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetAudioOutputConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioOutputConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioOutputConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioOutputConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioOutputConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfigurationOptions(struct soap *soap, const struct __trt__GetAudioOutputConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfigurationOptions(soap, tag ? tag : "-trt:GetAudioOutputConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct __trt__GetAudioOutputConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfigurationOptions(struct soap *soap, struct __trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfigurationOptions(struct soap *soap, const struct __trt__GetMetadataConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(soap, &a->trt__GetMetadataConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, "trt:GetMetadataConfigurationOptions", -1, &a->trt__GetMetadataConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetMetadataConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfigurationOptions, sizeof(struct __trt__GetMetadataConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, "trt:GetMetadataConfigurationOptions", &a->trt__GetMetadataConfigurationOptions, ""))
				{	soap_flag_trt__GetMetadataConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetMetadataConfigurationOptions(struct soap *soap, struct __trt__GetMetadataConfigurationOptions *d, struct __trt__GetMetadataConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetMetadataConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetMetadataConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetMetadataConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetMetadataConfigurationOptions(soap, &d->trt__GetMetadataConfigurationOptions, &a->trt__GetMetadataConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetMetadataConfigurationOptions(struct __trt__GetMetadataConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetMetadataConfigurationOptions(&a->trt__GetMetadataConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetMetadataConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetMetadataConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetMetadataConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetMetadataConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetMetadataConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetMetadataConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetMetadataConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfigurationOptions(struct soap *soap, const struct __trt__GetMetadataConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfigurationOptions(soap, tag ? tag : "-trt:GetMetadataConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetMetadataConfigurationOptions(struct soap *soap, struct __trt__GetMetadataConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, &a->trt__GetAudioEncoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", -1, &a->trt__GetAudioEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioEncoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, sizeof(struct __trt__GetAudioEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", &a->trt__GetAudioEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioEncoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *d, struct __trt__GetAudioEncoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioEncoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioEncoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, &d->trt__GetAudioEncoderConfigurationOptions, &a->trt__GetAudioEncoderConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioEncoderConfigurationOptions(struct __trt__GetAudioEncoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioEncoderConfigurationOptions(&a->trt__GetAudioEncoderConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioEncoderConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetAudioEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioEncoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioEncoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioEncoderConfigurationOptions(soap, tag ? tag : "-trt:GetAudioEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, &a->trt__GetAudioSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", -1, &a->trt__GetAudioSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSourceConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, sizeof(struct __trt__GetAudioSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", &a->trt__GetAudioSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioSourceConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *d, struct __trt__GetAudioSourceConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioSourceConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioSourceConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, &d->trt__GetAudioSourceConfigurationOptions, &a->trt__GetAudioSourceConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioSourceConfigurationOptions(struct __trt__GetAudioSourceConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioSourceConfigurationOptions(&a->trt__GetAudioSourceConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioSourceConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetAudioSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioSourceConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioSourceConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSourceConfigurationOptions(soap, tag ? tag : "-trt:GetAudioSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, &a->trt__GetVideoEncoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", -1, &a->trt__GetVideoEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoEncoderConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, sizeof(struct __trt__GetVideoEncoderConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", &a->trt__GetVideoEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoEncoderConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *d, struct __trt__GetVideoEncoderConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoEncoderConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoEncoderConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, &d->trt__GetVideoEncoderConfigurationOptions, &a->trt__GetVideoEncoderConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoEncoderConfigurationOptions(struct __trt__GetVideoEncoderConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoEncoderConfigurationOptions(&a->trt__GetVideoEncoderConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoEncoderConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetVideoEncoderConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoEncoderConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoEncoderConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoEncoderConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoEncoderConfigurationOptions(soap, tag ? tag : "-trt:GetVideoEncoderConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, &a->trt__GetVideoSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", -1, &a->trt__GetVideoSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, sizeof(struct __trt__GetVideoSourceConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", &a->trt__GetVideoSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoSourceConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_dup___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *d, struct __trt__GetVideoSourceConfigurationOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoSourceConfigurationOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoSourceConfigurationOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, &d->trt__GetVideoSourceConfigurationOptions, &a->trt__GetVideoSourceConfigurationOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoSourceConfigurationOptions(struct __trt__GetVideoSourceConfigurationOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoSourceConfigurationOptions(&a->trt__GetVideoSourceConfigurationOptions);
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoSourceConfigurationOptions *p;
	size_t k = sizeof(struct __trt__GetVideoSourceConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoSourceConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoSourceConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoSourceConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceConfigurationOptions(soap, tag ? tag : "-trt:GetVideoSourceConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(soap, &a->trt__SetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", -1, &a->trt__SetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioDecoderConfiguration, sizeof(struct __trt__SetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", &a->trt__SetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__SetAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_dup___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *d, struct __trt__SetAudioDecoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetAudioDecoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetAudioDecoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetAudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetAudioDecoderConfiguration(soap, &d->trt__SetAudioDecoderConfiguration, &a->trt__SetAudioDecoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetAudioDecoderConfiguration(struct __trt__SetAudioDecoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetAudioDecoderConfiguration(&a->trt__SetAudioDecoderConfiguration);
}

SOAP_FMAC1 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetAudioDecoderConfiguration *p;
	size_t k = sizeof(struct __trt__SetAudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetAudioDecoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetAudioDecoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetAudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioDecoderConfiguration(soap, tag ? tag : "-trt:SetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(soap, &a->trt__SetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", -1, &a->trt__SetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioOutputConfiguration, sizeof(struct __trt__SetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", &a->trt__SetAudioOutputConfiguration, ""))
				{	soap_flag_trt__SetAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_dup___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *d, struct __trt__SetAudioOutputConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetAudioOutputConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetAudioOutputConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetAudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetAudioOutputConfiguration(soap, &d->trt__SetAudioOutputConfiguration, &a->trt__SetAudioOutputConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetAudioOutputConfiguration(struct __trt__SetAudioOutputConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetAudioOutputConfiguration(&a->trt__SetAudioOutputConfiguration);
}

SOAP_FMAC1 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetAudioOutputConfiguration *p;
	size_t k = sizeof(struct __trt__SetAudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetAudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetAudioOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetAudioOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetAudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioOutputConfiguration(soap, tag ? tag : "-trt:SetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetMetadataConfiguration(soap, &a->trt__SetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", -1, &a->trt__SetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__SetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetMetadataConfiguration, sizeof(struct __trt__SetMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", &a->trt__SetMetadataConfiguration, ""))
				{	soap_flag_trt__SetMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_dup___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *d, struct __trt__SetMetadataConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetMetadataConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetMetadataConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetMetadataConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetMetadataConfiguration(soap, &d->trt__SetMetadataConfiguration, &a->trt__SetMetadataConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetMetadataConfiguration(struct __trt__SetMetadataConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetMetadataConfiguration(&a->trt__SetMetadataConfiguration);
}

SOAP_FMAC1 struct __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetMetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetMetadataConfiguration *p;
	size_t k = sizeof(struct __trt__SetMetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetMetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetMetadataConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetMetadataConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetMetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetMetadataConfiguration(soap, tag ? tag : "-trt:SetMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, &a->trt__SetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", -1, &a->trt__SetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, sizeof(struct __trt__SetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", &a->trt__SetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__SetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_dup___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *d, struct __trt__SetVideoAnalyticsConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetVideoAnalyticsConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetVideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, &d->trt__SetVideoAnalyticsConfiguration, &a->trt__SetVideoAnalyticsConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetVideoAnalyticsConfiguration(struct __trt__SetVideoAnalyticsConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetVideoAnalyticsConfiguration(&a->trt__SetVideoAnalyticsConfiguration);
}

SOAP_FMAC1 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetVideoAnalyticsConfiguration *p;
	size_t k = sizeof(struct __trt__SetVideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetVideoAnalyticsConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetVideoAnalyticsConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetVideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:SetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(soap, &a->trt__SetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", -1, &a->trt__SetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioEncoderConfiguration, sizeof(struct __trt__SetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", &a->trt__SetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__SetAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *d, struct __trt__SetAudioEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetAudioEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetAudioEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetAudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetAudioEncoderConfiguration(soap, &d->trt__SetAudioEncoderConfiguration, &a->trt__SetAudioEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetAudioEncoderConfiguration(struct __trt__SetAudioEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetAudioEncoderConfiguration(&a->trt__SetAudioEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetAudioEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__SetAudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetAudioEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetAudioEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetAudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioEncoderConfiguration(soap, tag ? tag : "-trt:SetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(soap, &a->trt__SetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", -1, &a->trt__SetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioSourceConfiguration, sizeof(struct __trt__SetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", &a->trt__SetAudioSourceConfiguration, ""))
				{	soap_flag_trt__SetAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_dup___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *d, struct __trt__SetAudioSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetAudioSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetAudioSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetAudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetAudioSourceConfiguration(soap, &d->trt__SetAudioSourceConfiguration, &a->trt__SetAudioSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetAudioSourceConfiguration(struct __trt__SetAudioSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetAudioSourceConfiguration(&a->trt__SetAudioSourceConfiguration);
}

SOAP_FMAC1 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetAudioSourceConfiguration *p;
	size_t k = sizeof(struct __trt__SetAudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetAudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetAudioSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetAudioSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetAudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetAudioSourceConfiguration(soap, tag ? tag : "-trt:SetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(soap, &a->trt__SetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", -1, &a->trt__SetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoEncoderConfiguration, sizeof(struct __trt__SetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", &a->trt__SetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__SetVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *d, struct __trt__SetVideoEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetVideoEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetVideoEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetVideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetVideoEncoderConfiguration(soap, &d->trt__SetVideoEncoderConfiguration, &a->trt__SetVideoEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetVideoEncoderConfiguration(struct __trt__SetVideoEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetVideoEncoderConfiguration(&a->trt__SetVideoEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetVideoEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__SetVideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetVideoEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetVideoEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetVideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoEncoderConfiguration(soap, tag ? tag : "-trt:SetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(soap, &a->trt__SetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", -1, &a->trt__SetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__SetVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceConfiguration, sizeof(struct __trt__SetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", &a->trt__SetVideoSourceConfiguration, ""))
				{	soap_flag_trt__SetVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_dup___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *d, struct __trt__SetVideoSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__SetVideoSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__SetVideoSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__SetVideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__SetVideoSourceConfiguration(soap, &d->trt__SetVideoSourceConfiguration, &a->trt__SetVideoSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__SetVideoSourceConfiguration(struct __trt__SetVideoSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__SetVideoSourceConfiguration(&a->trt__SetVideoSourceConfiguration);
}

SOAP_FMAC1 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__SetVideoSourceConfiguration *p;
	size_t k = sizeof(struct __trt__SetVideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__SetVideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__SetVideoSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__SetVideoSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__SetVideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__SetVideoSourceConfiguration(soap, tag ? tag : "-trt:SetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, &a->trt__GetCompatibleAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", -1, &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioDecoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioDecoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioDecoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *d, struct __trt__GetCompatibleAudioDecoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleAudioDecoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleAudioDecoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, &d->trt__GetCompatibleAudioDecoderConfigurations, &a->trt__GetCompatibleAudioDecoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleAudioDecoderConfigurations(struct __trt__GetCompatibleAudioDecoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(&a->trt__GetCompatibleAudioDecoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleAudioDecoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleAudioDecoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleAudioDecoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleAudioDecoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioDecoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, &a->trt__GetCompatibleAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", -1, &a->trt__GetCompatibleAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioOutputConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioOutputConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, sizeof(struct __trt__GetCompatibleAudioOutputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", &a->trt__GetCompatibleAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioOutputConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *d, struct __trt__GetCompatibleAudioOutputConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleAudioOutputConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleAudioOutputConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, &d->trt__GetCompatibleAudioOutputConfigurations, &a->trt__GetCompatibleAudioOutputConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleAudioOutputConfigurations(struct __trt__GetCompatibleAudioOutputConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleAudioOutputConfigurations(&a->trt__GetCompatibleAudioOutputConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleAudioOutputConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleAudioOutputConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleAudioOutputConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleAudioOutputConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleAudioOutputConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioOutputConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, &a->trt__GetCompatibleMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", -1, &a->trt__GetCompatibleMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleMetadataConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleMetadataConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, sizeof(struct __trt__GetCompatibleMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", &a->trt__GetCompatibleMetadataConfigurations, ""))
				{	soap_flag_trt__GetCompatibleMetadataConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *d, struct __trt__GetCompatibleMetadataConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleMetadataConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleMetadataConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, &d->trt__GetCompatibleMetadataConfigurations, &a->trt__GetCompatibleMetadataConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleMetadataConfigurations(struct __trt__GetCompatibleMetadataConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleMetadataConfigurations(&a->trt__GetCompatibleMetadataConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleMetadataConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleMetadataConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleMetadataConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleMetadataConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleMetadataConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleMetadataConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleMetadataConfigurations(soap, tag ? tag : "-trt:GetCompatibleMetadataConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, &a->trt__GetCompatibleVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", -1, &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoAnalyticsConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *d, struct __trt__GetCompatibleVideoAnalyticsConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleVideoAnalyticsConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleVideoAnalyticsConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, &d->trt__GetCompatibleVideoAnalyticsConfigurations, &a->trt__GetCompatibleVideoAnalyticsConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleVideoAnalyticsConfigurations(struct __trt__GetCompatibleVideoAnalyticsConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(&a->trt__GetCompatibleVideoAnalyticsConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleVideoAnalyticsConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleVideoAnalyticsConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, &a->trt__GetCompatibleAudioSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", -1, &a->trt__GetCompatibleAudioSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, sizeof(struct __trt__GetCompatibleAudioSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", &a->trt__GetCompatibleAudioSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *d, struct __trt__GetCompatibleAudioSourceConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleAudioSourceConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleAudioSourceConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, &d->trt__GetCompatibleAudioSourceConfigurations, &a->trt__GetCompatibleAudioSourceConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleAudioSourceConfigurations(struct __trt__GetCompatibleAudioSourceConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleAudioSourceConfigurations(&a->trt__GetCompatibleAudioSourceConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleAudioSourceConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleAudioSourceConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleAudioSourceConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleAudioSourceConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleAudioSourceConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioSourceConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, &a->trt__GetCompatibleAudioEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", -1, &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleAudioEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *d, struct __trt__GetCompatibleAudioEncoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleAudioEncoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleAudioEncoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, &d->trt__GetCompatibleAudioEncoderConfigurations, &a->trt__GetCompatibleAudioEncoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleAudioEncoderConfigurations(struct __trt__GetCompatibleAudioEncoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(&a->trt__GetCompatibleAudioEncoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleAudioEncoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleAudioEncoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleAudioEncoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleAudioEncoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleAudioEncoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, &a->trt__GetCompatibleVideoSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", -1, &a->trt__GetCompatibleVideoSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, sizeof(struct __trt__GetCompatibleVideoSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", &a->trt__GetCompatibleVideoSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *d, struct __trt__GetCompatibleVideoSourceConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleVideoSourceConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleVideoSourceConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, &d->trt__GetCompatibleVideoSourceConfigurations, &a->trt__GetCompatibleVideoSourceConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleVideoSourceConfigurations(struct __trt__GetCompatibleVideoSourceConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleVideoSourceConfigurations(&a->trt__GetCompatibleVideoSourceConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleVideoSourceConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleVideoSourceConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleVideoSourceConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleVideoSourceConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleVideoSourceConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoSourceConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, &a->trt__GetCompatibleVideoEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", -1, &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetCompatibleVideoEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *d, struct __trt__GetCompatibleVideoEncoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetCompatibleVideoEncoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetCompatibleVideoEncoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, &d->trt__GetCompatibleVideoEncoderConfigurations, &a->trt__GetCompatibleVideoEncoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetCompatibleVideoEncoderConfigurations(struct __trt__GetCompatibleVideoEncoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(&a->trt__GetCompatibleVideoEncoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetCompatibleVideoEncoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetCompatibleVideoEncoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetCompatibleVideoEncoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetCompatibleVideoEncoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetCompatibleVideoEncoderConfigurations(soap, tag ? tag : "-trt:GetCompatibleVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(soap, &a->trt__GetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", -1, &a->trt__GetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfiguration, sizeof(struct __trt__GetAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", &a->trt__GetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__GetAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_dup___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *d, struct __trt__GetAudioDecoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioDecoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioDecoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioDecoderConfiguration(soap, &d->trt__GetAudioDecoderConfiguration, &a->trt__GetAudioDecoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioDecoderConfiguration(struct __trt__GetAudioDecoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioDecoderConfiguration(&a->trt__GetAudioDecoderConfiguration);
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioDecoderConfiguration *p;
	size_t k = sizeof(struct __trt__GetAudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioDecoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioDecoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfiguration(soap, tag ? tag : "-trt:GetAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(soap, &a->trt__GetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", -1, &a->trt__GetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfiguration, sizeof(struct __trt__GetAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", &a->trt__GetAudioOutputConfiguration, ""))
				{	soap_flag_trt__GetAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_dup___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *d, struct __trt__GetAudioOutputConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioOutputConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioOutputConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioOutputConfiguration(soap, &d->trt__GetAudioOutputConfiguration, &a->trt__GetAudioOutputConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioOutputConfiguration(struct __trt__GetAudioOutputConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioOutputConfiguration(&a->trt__GetAudioOutputConfiguration);
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioOutputConfiguration *p;
	size_t k = sizeof(struct __trt__GetAudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfiguration(soap, tag ? tag : "-trt:GetAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfiguration(soap, &a->trt__GetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", -1, &a->trt__GetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__GetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfiguration, sizeof(struct __trt__GetMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", &a->trt__GetMetadataConfiguration, ""))
				{	soap_flag_trt__GetMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_dup___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *d, struct __trt__GetMetadataConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetMetadataConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetMetadataConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetMetadataConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetMetadataConfiguration(soap, &d->trt__GetMetadataConfiguration, &a->trt__GetMetadataConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetMetadataConfiguration(struct __trt__GetMetadataConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetMetadataConfiguration(&a->trt__GetMetadataConfiguration);
}

SOAP_FMAC1 struct __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetMetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetMetadataConfiguration *p;
	size_t k = sizeof(struct __trt__GetMetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetMetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetMetadataConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetMetadataConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetMetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfiguration(soap, tag ? tag : "-trt:GetMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, &a->trt__GetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", -1, &a->trt__GetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, sizeof(struct __trt__GetVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", &a->trt__GetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_dup___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *d, struct __trt__GetVideoAnalyticsConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoAnalyticsConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, &d->trt__GetVideoAnalyticsConfiguration, &a->trt__GetVideoAnalyticsConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoAnalyticsConfiguration(struct __trt__GetVideoAnalyticsConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoAnalyticsConfiguration(&a->trt__GetVideoAnalyticsConfiguration);
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoAnalyticsConfiguration *p;
	size_t k = sizeof(struct __trt__GetVideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoAnalyticsConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoAnalyticsConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:GetVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(soap, &a->trt__GetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", -1, &a->trt__GetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfiguration, sizeof(struct __trt__GetAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", &a->trt__GetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__GetAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *d, struct __trt__GetAudioEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioEncoderConfiguration(soap, &d->trt__GetAudioEncoderConfiguration, &a->trt__GetAudioEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioEncoderConfiguration(struct __trt__GetAudioEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioEncoderConfiguration(&a->trt__GetAudioEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__GetAudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioEncoderConfiguration(soap, tag ? tag : "-trt:GetAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(soap, &a->trt__GetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", -1, &a->trt__GetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfiguration, sizeof(struct __trt__GetAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", &a->trt__GetAudioSourceConfiguration, ""))
				{	soap_flag_trt__GetAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_dup___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *d, struct __trt__GetAudioSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioSourceConfiguration(soap, &d->trt__GetAudioSourceConfiguration, &a->trt__GetAudioSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioSourceConfiguration(struct __trt__GetAudioSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioSourceConfiguration(&a->trt__GetAudioSourceConfiguration);
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioSourceConfiguration *p;
	size_t k = sizeof(struct __trt__GetAudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSourceConfiguration(soap, tag ? tag : "-trt:GetAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(soap, &a->trt__GetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", -1, &a->trt__GetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfiguration, sizeof(struct __trt__GetVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", &a->trt__GetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__GetVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *d, struct __trt__GetVideoEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoEncoderConfiguration(soap, &d->trt__GetVideoEncoderConfiguration, &a->trt__GetVideoEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoEncoderConfiguration(struct __trt__GetVideoEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoEncoderConfiguration(&a->trt__GetVideoEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__GetVideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoEncoderConfiguration(soap, tag ? tag : "-trt:GetVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(soap, &a->trt__GetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", -1, &a->trt__GetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfiguration, sizeof(struct __trt__GetVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", &a->trt__GetVideoSourceConfiguration, ""))
				{	soap_flag_trt__GetVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_dup___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *d, struct __trt__GetVideoSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoSourceConfiguration(soap, &d->trt__GetVideoSourceConfiguration, &a->trt__GetVideoSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoSourceConfiguration(struct __trt__GetVideoSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoSourceConfiguration(&a->trt__GetVideoSourceConfiguration);
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoSourceConfiguration *p;
	size_t k = sizeof(struct __trt__GetVideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceConfiguration(soap, tag ? tag : "-trt:GetVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(soap, &a->trt__GetAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", -1, &a->trt__GetAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioDecoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfigurations, sizeof(struct __trt__GetAudioDecoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", &a->trt__GetAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetAudioDecoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *d, struct __trt__GetAudioDecoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioDecoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioDecoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioDecoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioDecoderConfigurations(soap, &d->trt__GetAudioDecoderConfigurations, &a->trt__GetAudioDecoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioDecoderConfigurations(struct __trt__GetAudioDecoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioDecoderConfigurations(&a->trt__GetAudioDecoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioDecoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioDecoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetAudioDecoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioDecoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioDecoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioDecoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioDecoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioDecoderConfigurations(soap, tag ? tag : "-trt:GetAudioDecoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(soap, &a->trt__GetAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", -1, &a->trt__GetAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfigurations, sizeof(struct __trt__GetAudioOutputConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", &a->trt__GetAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetAudioOutputConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_dup___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *d, struct __trt__GetAudioOutputConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioOutputConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioOutputConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioOutputConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioOutputConfigurations(soap, &d->trt__GetAudioOutputConfigurations, &a->trt__GetAudioOutputConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioOutputConfigurations(struct __trt__GetAudioOutputConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioOutputConfigurations(&a->trt__GetAudioOutputConfigurations);
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioOutputConfigurations *p;
	size_t k = sizeof(struct __trt__GetAudioOutputConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioOutputConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioOutputConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioOutputConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioOutputConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputConfigurations(soap, tag ? tag : "-trt:GetAudioOutputConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetMetadataConfigurations(soap, &a->trt__GetMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", -1, &a->trt__GetMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetMetadataConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfigurations, sizeof(struct __trt__GetMetadataConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", &a->trt__GetMetadataConfigurations, ""))
				{	soap_flag_trt__GetMetadataConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_dup___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *d, struct __trt__GetMetadataConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetMetadataConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetMetadataConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetMetadataConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetMetadataConfigurations(soap, &d->trt__GetMetadataConfigurations, &a->trt__GetMetadataConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetMetadataConfigurations(struct __trt__GetMetadataConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetMetadataConfigurations(&a->trt__GetMetadataConfigurations);
}

SOAP_FMAC1 struct __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetMetadataConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetMetadataConfigurations *p;
	size_t k = sizeof(struct __trt__GetMetadataConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetMetadataConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetMetadataConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetMetadataConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetMetadataConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetMetadataConfigurations(soap, tag ? tag : "-trt:GetMetadataConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, &a->trt__GetVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", -1, &a->trt__GetVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoAnalyticsConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, sizeof(struct __trt__GetVideoAnalyticsConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", &a->trt__GetVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_dup___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *d, struct __trt__GetVideoAnalyticsConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoAnalyticsConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoAnalyticsConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, &d->trt__GetVideoAnalyticsConfigurations, &a->trt__GetVideoAnalyticsConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoAnalyticsConfigurations(struct __trt__GetVideoAnalyticsConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoAnalyticsConfigurations(&a->trt__GetVideoAnalyticsConfigurations);
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoAnalyticsConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoAnalyticsConfigurations *p;
	size_t k = sizeof(struct __trt__GetVideoAnalyticsConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoAnalyticsConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoAnalyticsConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoAnalyticsConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoAnalyticsConfigurations(soap, tag ? tag : "-trt:GetVideoAnalyticsConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfigurations(struct soap *soap, struct __trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(soap, &a->trt__GetAudioEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, "trt:GetAudioEncoderConfigurations", -1, &a->trt__GetAudioEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfigurations, sizeof(struct __trt__GetAudioEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, "trt:GetAudioEncoderConfigurations", &a->trt__GetAudioEncoderConfigurations, ""))
				{	soap_flag_trt__GetAudioEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetAudioEncoderConfigurations(struct soap *soap, struct __trt__GetAudioEncoderConfigurations *d, struct __trt__GetAudioEncoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioEncoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioEncoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioEncoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioEncoderConfigurations(soap, &d->trt__GetAudioEncoderConfigurations, &a->trt__GetAudioEncoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioEncoderConfigurations(struct __trt__GetAudioEncoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioEncoderConfigurations(&a->trt__GetAudioEncoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioEncoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetAudioEncoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioEncoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioEncoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioEncoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioEncoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioEncoderConfigurations(soap, tag ? tag : "-trt:GetAudioEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfigurations(struct soap *soap, struct __trt__GetAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfigurations(struct soap *soap, struct __trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfigurations(struct soap *soap, const struct __trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(soap, &a->trt__GetAudioSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, "trt:GetAudioSourceConfigurations", -1, &a->trt__GetAudioSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfigurations, sizeof(struct __trt__GetAudioSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, "trt:GetAudioSourceConfigurations", &a->trt__GetAudioSourceConfigurations, ""))
				{	soap_flag_trt__GetAudioSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_dup___trt__GetAudioSourceConfigurations(struct soap *soap, struct __trt__GetAudioSourceConfigurations *d, struct __trt__GetAudioSourceConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioSourceConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioSourceConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioSourceConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioSourceConfigurations(soap, &d->trt__GetAudioSourceConfigurations, &a->trt__GetAudioSourceConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioSourceConfigurations(struct __trt__GetAudioSourceConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioSourceConfigurations(&a->trt__GetAudioSourceConfigurations);
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioSourceConfigurations *p;
	size_t k = sizeof(struct __trt__GetAudioSourceConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioSourceConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioSourceConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioSourceConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioSourceConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfigurations(struct soap *soap, const struct __trt__GetAudioSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSourceConfigurations(soap, tag ? tag : "-trt:GetAudioSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfigurations(struct soap *soap, struct __trt__GetAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurations(struct soap *soap, struct __trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(soap, &a->trt__GetVideoEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, "trt:GetVideoEncoderConfigurations", -1, &a->trt__GetVideoEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoEncoderConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurations, sizeof(struct __trt__GetVideoEncoderConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, "trt:GetVideoEncoderConfigurations", &a->trt__GetVideoEncoderConfigurations, ""))
				{	soap_flag_trt__GetVideoEncoderConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_dup___trt__GetVideoEncoderConfigurations(struct soap *soap, struct __trt__GetVideoEncoderConfigurations *d, struct __trt__GetVideoEncoderConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoEncoderConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoEncoderConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoEncoderConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoEncoderConfigurations(soap, &d->trt__GetVideoEncoderConfigurations, &a->trt__GetVideoEncoderConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoEncoderConfigurations(struct __trt__GetVideoEncoderConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoEncoderConfigurations(&a->trt__GetVideoEncoderConfigurations);
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoEncoderConfigurations *p;
	size_t k = sizeof(struct __trt__GetVideoEncoderConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoEncoderConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoEncoderConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoEncoderConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoEncoderConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoEncoderConfigurations(soap, tag ? tag : "-trt:GetVideoEncoderConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurations(struct soap *soap, struct __trt__GetVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfigurations(struct soap *soap, struct __trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfigurations(struct soap *soap, const struct __trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(soap, &a->trt__GetVideoSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, "trt:GetVideoSourceConfigurations", -1, &a->trt__GetVideoSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSourceConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfigurations, sizeof(struct __trt__GetVideoSourceConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, "trt:GetVideoSourceConfigurations", &a->trt__GetVideoSourceConfigurations, ""))
				{	soap_flag_trt__GetVideoSourceConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_dup___trt__GetVideoSourceConfigurations(struct soap *soap, struct __trt__GetVideoSourceConfigurations *d, struct __trt__GetVideoSourceConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoSourceConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoSourceConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoSourceConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoSourceConfigurations(soap, &d->trt__GetVideoSourceConfigurations, &a->trt__GetVideoSourceConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoSourceConfigurations(struct __trt__GetVideoSourceConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoSourceConfigurations(&a->trt__GetVideoSourceConfigurations);
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoSourceConfigurations *p;
	size_t k = sizeof(struct __trt__GetVideoSourceConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoSourceConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoSourceConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoSourceConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoSourceConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfigurations(struct soap *soap, const struct __trt__GetVideoSourceConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSourceConfigurations(soap, tag ? tag : "-trt:GetVideoSourceConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfigurations(struct soap *soap, struct __trt__GetVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__DeleteProfile(struct soap *soap, struct __trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__DeleteProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__DeleteProfile(struct soap *soap, const struct __trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__DeleteProfile(soap, &a->trt__DeleteProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct __trt__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__DeleteProfile(soap, "trt:DeleteProfile", -1, &a->trt__DeleteProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteProfile * SOAP_FMAC4 soap_in___trt__DeleteProfile(struct soap *soap, const char *tag, struct __trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_trt__DeleteProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__DeleteProfile*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__DeleteProfile, sizeof(struct __trt__DeleteProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__DeleteProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__DeleteProfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__DeleteProfile(soap, "trt:DeleteProfile", &a->trt__DeleteProfile, ""))
				{	soap_flag_trt__DeleteProfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__DeleteProfile * SOAP_FMAC2 soap_dup___trt__DeleteProfile(struct soap *soap, struct __trt__DeleteProfile *d, struct __trt__DeleteProfile const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__DeleteProfile*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__DeleteProfile, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__DeleteProfile(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__DeleteProfile(soap, &d->trt__DeleteProfile, &a->trt__DeleteProfile);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__DeleteProfile(struct __trt__DeleteProfile const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__DeleteProfile(&a->trt__DeleteProfile);
}

SOAP_FMAC1 struct __trt__DeleteProfile * SOAP_FMAC2 soap_instantiate___trt__DeleteProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__DeleteProfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__DeleteProfile *p;
	size_t k = sizeof(struct __trt__DeleteProfile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__DeleteProfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__DeleteProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__DeleteProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__DeleteProfile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__DeleteProfile(struct soap *soap, const struct __trt__DeleteProfile *a, const char *tag, const char *type)
{
	if (soap_out___trt__DeleteProfile(soap, tag ? tag : "-trt:DeleteProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteProfile * SOAP_FMAC4 soap_get___trt__DeleteProfile(struct soap *soap, struct __trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct __trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, &a->trt__RemoveAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, "trt:RemoveAudioDecoderConfiguration", -1, &a->trt__RemoveAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioDecoderConfiguration, sizeof(struct __trt__RemoveAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, "trt:RemoveAudioDecoderConfiguration", &a->trt__RemoveAudioDecoderConfiguration, ""))
				{	soap_flag_trt__RemoveAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct __trt__RemoveAudioDecoderConfiguration *d, struct __trt__RemoveAudioDecoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveAudioDecoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveAudioDecoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveAudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, &d->trt__RemoveAudioDecoderConfiguration, &a->trt__RemoveAudioDecoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveAudioDecoderConfiguration(struct __trt__RemoveAudioDecoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveAudioDecoderConfiguration(&a->trt__RemoveAudioDecoderConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveAudioDecoderConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveAudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveAudioDecoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveAudioDecoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveAudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveAudioDecoderConfiguration(soap, tag ? tag : "-trt:RemoveAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct __trt__RemoveAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioOutputConfiguration(struct soap *soap, struct __trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct __trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(soap, &a->trt__RemoveAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, "trt:RemoveAudioOutputConfiguration", -1, &a->trt__RemoveAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioOutputConfiguration, sizeof(struct __trt__RemoveAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, "trt:RemoveAudioOutputConfiguration", &a->trt__RemoveAudioOutputConfiguration, ""))
				{	soap_flag_trt__RemoveAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveAudioOutputConfiguration(struct soap *soap, struct __trt__RemoveAudioOutputConfiguration *d, struct __trt__RemoveAudioOutputConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveAudioOutputConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveAudioOutputConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveAudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveAudioOutputConfiguration(soap, &d->trt__RemoveAudioOutputConfiguration, &a->trt__RemoveAudioOutputConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveAudioOutputConfiguration(struct __trt__RemoveAudioOutputConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveAudioOutputConfiguration(&a->trt__RemoveAudioOutputConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveAudioOutputConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveAudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveAudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveAudioOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveAudioOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveAudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct __trt__RemoveAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveAudioOutputConfiguration(soap, tag ? tag : "-trt:RemoveAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioOutputConfiguration(struct soap *soap, struct __trt__RemoveAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveMetadataConfiguration(struct soap *soap, struct __trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveMetadataConfiguration(struct soap *soap, const struct __trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(soap, &a->trt__RemoveMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, "trt:RemoveMetadataConfiguration", -1, &a->trt__RemoveMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_in___trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveMetadataConfiguration, sizeof(struct __trt__RemoveMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, "trt:RemoveMetadataConfiguration", &a->trt__RemoveMetadataConfiguration, ""))
				{	soap_flag_trt__RemoveMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveMetadataConfiguration(struct soap *soap, struct __trt__RemoveMetadataConfiguration *d, struct __trt__RemoveMetadataConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveMetadataConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveMetadataConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveMetadataConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveMetadataConfiguration(soap, &d->trt__RemoveMetadataConfiguration, &a->trt__RemoveMetadataConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveMetadataConfiguration(struct __trt__RemoveMetadataConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveMetadataConfiguration(&a->trt__RemoveMetadataConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveMetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveMetadataConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveMetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveMetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveMetadataConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveMetadataConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveMetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveMetadataConfiguration(struct soap *soap, const struct __trt__RemoveMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveMetadataConfiguration(soap, tag ? tag : "-trt:RemoveMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_get___trt__RemoveMetadataConfiguration(struct soap *soap, struct __trt__RemoveMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct __trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, &a->trt__RemoveVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, "trt:RemoveVideoAnalyticsConfiguration", -1, &a->trt__RemoveVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration, sizeof(struct __trt__RemoveVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, "trt:RemoveVideoAnalyticsConfiguration", &a->trt__RemoveVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__RemoveVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct __trt__RemoveVideoAnalyticsConfiguration *d, struct __trt__RemoveVideoAnalyticsConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveVideoAnalyticsConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveVideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, &d->trt__RemoveVideoAnalyticsConfiguration, &a->trt__RemoveVideoAnalyticsConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveVideoAnalyticsConfiguration(struct __trt__RemoveVideoAnalyticsConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveVideoAnalyticsConfiguration(&a->trt__RemoveVideoAnalyticsConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveVideoAnalyticsConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveVideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveVideoAnalyticsConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveVideoAnalyticsConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveVideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:RemoveVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct __trt__RemoveVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemovePTZConfiguration(struct soap *soap, struct __trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemovePTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemovePTZConfiguration(struct soap *soap, const struct __trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemovePTZConfiguration(soap, &a->trt__RemovePTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemovePTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, "trt:RemovePTZConfiguration", -1, &a->trt__RemovePTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemovePTZConfiguration * SOAP_FMAC4 soap_in___trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct __trt__RemovePTZConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemovePTZConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemovePTZConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemovePTZConfiguration, sizeof(struct __trt__RemovePTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemovePTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemovePTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemovePTZConfiguration(soap, "trt:RemovePTZConfiguration", &a->trt__RemovePTZConfiguration, ""))
				{	soap_flag_trt__RemovePTZConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_dup___trt__RemovePTZConfiguration(struct soap *soap, struct __trt__RemovePTZConfiguration *d, struct __trt__RemovePTZConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemovePTZConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemovePTZConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemovePTZConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemovePTZConfiguration(soap, &d->trt__RemovePTZConfiguration, &a->trt__RemovePTZConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemovePTZConfiguration(struct __trt__RemovePTZConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemovePTZConfiguration(&a->trt__RemovePTZConfiguration);
}

SOAP_FMAC1 struct __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemovePTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemovePTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemovePTZConfiguration *p;
	size_t k = sizeof(struct __trt__RemovePTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemovePTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemovePTZConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemovePTZConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemovePTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemovePTZConfiguration(struct soap *soap, const struct __trt__RemovePTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemovePTZConfiguration(soap, tag ? tag : "-trt:RemovePTZConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemovePTZConfiguration * SOAP_FMAC4 soap_get___trt__RemovePTZConfiguration(struct soap *soap, struct __trt__RemovePTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioSourceConfiguration(struct soap *soap, struct __trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct __trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(soap, &a->trt__RemoveAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, "trt:RemoveAudioSourceConfiguration", -1, &a->trt__RemoveAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioSourceConfiguration, sizeof(struct __trt__RemoveAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, "trt:RemoveAudioSourceConfiguration", &a->trt__RemoveAudioSourceConfiguration, ""))
				{	soap_flag_trt__RemoveAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveAudioSourceConfiguration(struct soap *soap, struct __trt__RemoveAudioSourceConfiguration *d, struct __trt__RemoveAudioSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveAudioSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveAudioSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveAudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveAudioSourceConfiguration(soap, &d->trt__RemoveAudioSourceConfiguration, &a->trt__RemoveAudioSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveAudioSourceConfiguration(struct __trt__RemoveAudioSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveAudioSourceConfiguration(&a->trt__RemoveAudioSourceConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveAudioSourceConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveAudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveAudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveAudioSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveAudioSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveAudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct __trt__RemoveAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveAudioSourceConfiguration(soap, tag ? tag : "-trt:RemoveAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioSourceConfiguration(struct soap *soap, struct __trt__RemoveAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct __trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, &a->trt__RemoveAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, "trt:RemoveAudioEncoderConfiguration", -1, &a->trt__RemoveAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioEncoderConfiguration, sizeof(struct __trt__RemoveAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, "trt:RemoveAudioEncoderConfiguration", &a->trt__RemoveAudioEncoderConfiguration, ""))
				{	soap_flag_trt__RemoveAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct __trt__RemoveAudioEncoderConfiguration *d, struct __trt__RemoveAudioEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveAudioEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveAudioEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveAudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, &d->trt__RemoveAudioEncoderConfiguration, &a->trt__RemoveAudioEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveAudioEncoderConfiguration(struct __trt__RemoveAudioEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveAudioEncoderConfiguration(&a->trt__RemoveAudioEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveAudioEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveAudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveAudioEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveAudioEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveAudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveAudioEncoderConfiguration(soap, tag ? tag : "-trt:RemoveAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct __trt__RemoveAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoSourceConfiguration(struct soap *soap, struct __trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct __trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(soap, &a->trt__RemoveVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, "trt:RemoveVideoSourceConfiguration", -1, &a->trt__RemoveVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoSourceConfiguration, sizeof(struct __trt__RemoveVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, "trt:RemoveVideoSourceConfiguration", &a->trt__RemoveVideoSourceConfiguration, ""))
				{	soap_flag_trt__RemoveVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveVideoSourceConfiguration(struct soap *soap, struct __trt__RemoveVideoSourceConfiguration *d, struct __trt__RemoveVideoSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveVideoSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveVideoSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveVideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveVideoSourceConfiguration(soap, &d->trt__RemoveVideoSourceConfiguration, &a->trt__RemoveVideoSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveVideoSourceConfiguration(struct __trt__RemoveVideoSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveVideoSourceConfiguration(&a->trt__RemoveVideoSourceConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveVideoSourceConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveVideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveVideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveVideoSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveVideoSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveVideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct __trt__RemoveVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveVideoSourceConfiguration(soap, tag ? tag : "-trt:RemoveVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoSourceConfiguration(struct soap *soap, struct __trt__RemoveVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct __trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct __trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, &a->trt__RemoveVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, "trt:RemoveVideoEncoderConfiguration", -1, &a->trt__RemoveVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__RemoveVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoEncoderConfiguration, sizeof(struct __trt__RemoveVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, "trt:RemoveVideoEncoderConfiguration", &a->trt__RemoveVideoEncoderConfiguration, ""))
				{	soap_flag_trt__RemoveVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct __trt__RemoveVideoEncoderConfiguration *d, struct __trt__RemoveVideoEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__RemoveVideoEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__RemoveVideoEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__RemoveVideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, &d->trt__RemoveVideoEncoderConfiguration, &a->trt__RemoveVideoEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__RemoveVideoEncoderConfiguration(struct __trt__RemoveVideoEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__RemoveVideoEncoderConfiguration(&a->trt__RemoveVideoEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__RemoveVideoEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__RemoveVideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__RemoveVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__RemoveVideoEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__RemoveVideoEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__RemoveVideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct __trt__RemoveVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__RemoveVideoEncoderConfiguration(soap, tag ? tag : "-trt:RemoveVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct __trt__RemoveVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioDecoderConfiguration(struct soap *soap, struct __trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioDecoderConfiguration(struct soap *soap, const struct __trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(soap, &a->trt__AddAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, "trt:AddAudioDecoderConfiguration", -1, &a->trt__AddAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioDecoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddAudioDecoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioDecoderConfiguration, sizeof(struct __trt__AddAudioDecoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, "trt:AddAudioDecoderConfiguration", &a->trt__AddAudioDecoderConfiguration, ""))
				{	soap_flag_trt__AddAudioDecoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_dup___trt__AddAudioDecoderConfiguration(struct soap *soap, struct __trt__AddAudioDecoderConfiguration *d, struct __trt__AddAudioDecoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddAudioDecoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddAudioDecoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddAudioDecoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddAudioDecoderConfiguration(soap, &d->trt__AddAudioDecoderConfiguration, &a->trt__AddAudioDecoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddAudioDecoderConfiguration(struct __trt__AddAudioDecoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddAudioDecoderConfiguration(&a->trt__AddAudioDecoderConfiguration);
}

SOAP_FMAC1 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioDecoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddAudioDecoderConfiguration *p;
	size_t k = sizeof(struct __trt__AddAudioDecoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddAudioDecoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddAudioDecoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddAudioDecoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioDecoderConfiguration(struct soap *soap, const struct __trt__AddAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddAudioDecoderConfiguration(soap, tag ? tag : "-trt:AddAudioDecoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioDecoderConfiguration(struct soap *soap, struct __trt__AddAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioOutputConfiguration(struct soap *soap, struct __trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioOutputConfiguration(struct soap *soap, const struct __trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(soap, &a->trt__AddAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, "trt:AddAudioOutputConfiguration", -1, &a->trt__AddAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioOutputConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddAudioOutputConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioOutputConfiguration, sizeof(struct __trt__AddAudioOutputConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, "trt:AddAudioOutputConfiguration", &a->trt__AddAudioOutputConfiguration, ""))
				{	soap_flag_trt__AddAudioOutputConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_dup___trt__AddAudioOutputConfiguration(struct soap *soap, struct __trt__AddAudioOutputConfiguration *d, struct __trt__AddAudioOutputConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddAudioOutputConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddAudioOutputConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddAudioOutputConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddAudioOutputConfiguration(soap, &d->trt__AddAudioOutputConfiguration, &a->trt__AddAudioOutputConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddAudioOutputConfiguration(struct __trt__AddAudioOutputConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddAudioOutputConfiguration(&a->trt__AddAudioOutputConfiguration);
}

SOAP_FMAC1 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioOutputConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddAudioOutputConfiguration *p;
	size_t k = sizeof(struct __trt__AddAudioOutputConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddAudioOutputConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddAudioOutputConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddAudioOutputConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddAudioOutputConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioOutputConfiguration(struct soap *soap, const struct __trt__AddAudioOutputConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddAudioOutputConfiguration(soap, tag ? tag : "-trt:AddAudioOutputConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioOutputConfiguration(struct soap *soap, struct __trt__AddAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddMetadataConfiguration(struct soap *soap, struct __trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddMetadataConfiguration(struct soap *soap, const struct __trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddMetadataConfiguration(soap, &a->trt__AddMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, "trt:AddMetadataConfiguration", -1, &a->trt__AddMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddMetadataConfiguration * SOAP_FMAC4 soap_in___trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__AddMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddMetadataConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddMetadataConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddMetadataConfiguration, sizeof(struct __trt__AddMetadataConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddMetadataConfiguration(soap, "trt:AddMetadataConfiguration", &a->trt__AddMetadataConfiguration, ""))
				{	soap_flag_trt__AddMetadataConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_dup___trt__AddMetadataConfiguration(struct soap *soap, struct __trt__AddMetadataConfiguration *d, struct __trt__AddMetadataConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddMetadataConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddMetadataConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddMetadataConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddMetadataConfiguration(soap, &d->trt__AddMetadataConfiguration, &a->trt__AddMetadataConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddMetadataConfiguration(struct __trt__AddMetadataConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddMetadataConfiguration(&a->trt__AddMetadataConfiguration);
}

SOAP_FMAC1 struct __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddMetadataConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddMetadataConfiguration *p;
	size_t k = sizeof(struct __trt__AddMetadataConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddMetadataConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddMetadataConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddMetadataConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddMetadataConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddMetadataConfiguration(struct soap *soap, const struct __trt__AddMetadataConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddMetadataConfiguration(soap, tag ? tag : "-trt:AddMetadataConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddMetadataConfiguration * SOAP_FMAC4 soap_get___trt__AddMetadataConfiguration(struct soap *soap, struct __trt__AddMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct __trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, &a->trt__AddVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, "trt:AddVideoAnalyticsConfiguration", -1, &a->trt__AddVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoAnalyticsConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddVideoAnalyticsConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoAnalyticsConfiguration, sizeof(struct __trt__AddVideoAnalyticsConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, "trt:AddVideoAnalyticsConfiguration", &a->trt__AddVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__AddVideoAnalyticsConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_dup___trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct __trt__AddVideoAnalyticsConfiguration *d, struct __trt__AddVideoAnalyticsConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddVideoAnalyticsConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddVideoAnalyticsConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddVideoAnalyticsConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, &d->trt__AddVideoAnalyticsConfiguration, &a->trt__AddVideoAnalyticsConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddVideoAnalyticsConfiguration(struct __trt__AddVideoAnalyticsConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddVideoAnalyticsConfiguration(&a->trt__AddVideoAnalyticsConfiguration);
}

SOAP_FMAC1 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoAnalyticsConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddVideoAnalyticsConfiguration *p;
	size_t k = sizeof(struct __trt__AddVideoAnalyticsConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddVideoAnalyticsConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddVideoAnalyticsConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddVideoAnalyticsConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__AddVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddVideoAnalyticsConfiguration(soap, tag ? tag : "-trt:AddVideoAnalyticsConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct __trt__AddVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddPTZConfiguration(struct soap *soap, struct __trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddPTZConfiguration(struct soap *soap, const struct __trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddPTZConfiguration(soap, &a->trt__AddPTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddPTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, "trt:AddPTZConfiguration", -1, &a->trt__AddPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddPTZConfiguration * SOAP_FMAC4 soap_in___trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct __trt__AddPTZConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddPTZConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddPTZConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddPTZConfiguration, sizeof(struct __trt__AddPTZConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddPTZConfiguration(soap, "trt:AddPTZConfiguration", &a->trt__AddPTZConfiguration, ""))
				{	soap_flag_trt__AddPTZConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddPTZConfiguration * SOAP_FMAC2 soap_dup___trt__AddPTZConfiguration(struct soap *soap, struct __trt__AddPTZConfiguration *d, struct __trt__AddPTZConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddPTZConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddPTZConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddPTZConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddPTZConfiguration(soap, &d->trt__AddPTZConfiguration, &a->trt__AddPTZConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddPTZConfiguration(struct __trt__AddPTZConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddPTZConfiguration(&a->trt__AddPTZConfiguration);
}

SOAP_FMAC1 struct __trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddPTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddPTZConfiguration *p;
	size_t k = sizeof(struct __trt__AddPTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddPTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddPTZConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddPTZConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddPTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddPTZConfiguration(struct soap *soap, const struct __trt__AddPTZConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddPTZConfiguration(soap, tag ? tag : "-trt:AddPTZConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddPTZConfiguration * SOAP_FMAC4 soap_get___trt__AddPTZConfiguration(struct soap *soap, struct __trt__AddPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioSourceConfiguration(struct soap *soap, struct __trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioSourceConfiguration(struct soap *soap, const struct __trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(soap, &a->trt__AddAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, "trt:AddAudioSourceConfiguration", -1, &a->trt__AddAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddAudioSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioSourceConfiguration, sizeof(struct __trt__AddAudioSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, "trt:AddAudioSourceConfiguration", &a->trt__AddAudioSourceConfiguration, ""))
				{	soap_flag_trt__AddAudioSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_dup___trt__AddAudioSourceConfiguration(struct soap *soap, struct __trt__AddAudioSourceConfiguration *d, struct __trt__AddAudioSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddAudioSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddAudioSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddAudioSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddAudioSourceConfiguration(soap, &d->trt__AddAudioSourceConfiguration, &a->trt__AddAudioSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddAudioSourceConfiguration(struct __trt__AddAudioSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddAudioSourceConfiguration(&a->trt__AddAudioSourceConfiguration);
}

SOAP_FMAC1 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddAudioSourceConfiguration *p;
	size_t k = sizeof(struct __trt__AddAudioSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddAudioSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddAudioSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddAudioSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddAudioSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioSourceConfiguration(struct soap *soap, const struct __trt__AddAudioSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddAudioSourceConfiguration(soap, tag ? tag : "-trt:AddAudioSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioSourceConfiguration(struct soap *soap, struct __trt__AddAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioEncoderConfiguration(struct soap *soap, struct __trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioEncoderConfiguration(struct soap *soap, const struct __trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(soap, &a->trt__AddAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, "trt:AddAudioEncoderConfiguration", -1, &a->trt__AddAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddAudioEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioEncoderConfiguration, sizeof(struct __trt__AddAudioEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, "trt:AddAudioEncoderConfiguration", &a->trt__AddAudioEncoderConfiguration, ""))
				{	soap_flag_trt__AddAudioEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__AddAudioEncoderConfiguration(struct soap *soap, struct __trt__AddAudioEncoderConfiguration *d, struct __trt__AddAudioEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddAudioEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddAudioEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddAudioEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddAudioEncoderConfiguration(soap, &d->trt__AddAudioEncoderConfiguration, &a->trt__AddAudioEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddAudioEncoderConfiguration(struct __trt__AddAudioEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddAudioEncoderConfiguration(&a->trt__AddAudioEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddAudioEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__AddAudioEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddAudioEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddAudioEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddAudioEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioEncoderConfiguration(struct soap *soap, const struct __trt__AddAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddAudioEncoderConfiguration(soap, tag ? tag : "-trt:AddAudioEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioEncoderConfiguration(struct soap *soap, struct __trt__AddAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoSourceConfiguration(struct soap *soap, struct __trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoSourceConfiguration(struct soap *soap, const struct __trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(soap, &a->trt__AddVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, "trt:AddVideoSourceConfiguration", -1, &a->trt__AddVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoSourceConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddVideoSourceConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoSourceConfiguration, sizeof(struct __trt__AddVideoSourceConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, "trt:AddVideoSourceConfiguration", &a->trt__AddVideoSourceConfiguration, ""))
				{	soap_flag_trt__AddVideoSourceConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_dup___trt__AddVideoSourceConfiguration(struct soap *soap, struct __trt__AddVideoSourceConfiguration *d, struct __trt__AddVideoSourceConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddVideoSourceConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddVideoSourceConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddVideoSourceConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddVideoSourceConfiguration(soap, &d->trt__AddVideoSourceConfiguration, &a->trt__AddVideoSourceConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddVideoSourceConfiguration(struct __trt__AddVideoSourceConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddVideoSourceConfiguration(&a->trt__AddVideoSourceConfiguration);
}

SOAP_FMAC1 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoSourceConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddVideoSourceConfiguration *p;
	size_t k = sizeof(struct __trt__AddVideoSourceConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddVideoSourceConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddVideoSourceConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddVideoSourceConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddVideoSourceConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoSourceConfiguration(struct soap *soap, const struct __trt__AddVideoSourceConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddVideoSourceConfiguration(soap, tag ? tag : "-trt:AddVideoSourceConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoSourceConfiguration(struct soap *soap, struct __trt__AddVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoEncoderConfiguration(struct soap *soap, struct __trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoEncoderConfiguration(struct soap *soap, const struct __trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(soap, &a->trt__AddVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, "trt:AddVideoEncoderConfiguration", -1, &a->trt__AddVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoEncoderConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__AddVideoEncoderConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoEncoderConfiguration, sizeof(struct __trt__AddVideoEncoderConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, "trt:AddVideoEncoderConfiguration", &a->trt__AddVideoEncoderConfiguration, ""))
				{	soap_flag_trt__AddVideoEncoderConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_dup___trt__AddVideoEncoderConfiguration(struct soap *soap, struct __trt__AddVideoEncoderConfiguration *d, struct __trt__AddVideoEncoderConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__AddVideoEncoderConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__AddVideoEncoderConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__AddVideoEncoderConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__AddVideoEncoderConfiguration(soap, &d->trt__AddVideoEncoderConfiguration, &a->trt__AddVideoEncoderConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__AddVideoEncoderConfiguration(struct __trt__AddVideoEncoderConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__AddVideoEncoderConfiguration(&a->trt__AddVideoEncoderConfiguration);
}

SOAP_FMAC1 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoEncoderConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__AddVideoEncoderConfiguration *p;
	size_t k = sizeof(struct __trt__AddVideoEncoderConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__AddVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__AddVideoEncoderConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__AddVideoEncoderConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__AddVideoEncoderConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoEncoderConfiguration(struct soap *soap, const struct __trt__AddVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___trt__AddVideoEncoderConfiguration(soap, tag ? tag : "-trt:AddVideoEncoderConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoEncoderConfiguration(struct soap *soap, struct __trt__AddVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetProfiles(soap, &a->trt__GetProfiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct __trt__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", -1, &a->trt__GetProfiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_in___trt__GetProfiles(struct soap *soap, const char *tag, struct __trt__GetProfiles *a, const char *type)
{
	size_t soap_flag_trt__GetProfiles = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetProfiles*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfiles, sizeof(struct __trt__GetProfiles), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", &a->trt__GetProfiles, ""))
				{	soap_flag_trt__GetProfiles--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetProfiles * SOAP_FMAC2 soap_dup___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *d, struct __trt__GetProfiles const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetProfiles*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetProfiles, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetProfiles(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetProfiles(soap, &d->trt__GetProfiles, &a->trt__GetProfiles);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetProfiles(struct __trt__GetProfiles const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetProfiles(&a->trt__GetProfiles);
}

SOAP_FMAC1 struct __trt__GetProfiles * SOAP_FMAC2 soap_instantiate___trt__GetProfiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetProfiles(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetProfiles *p;
	size_t k = sizeof(struct __trt__GetProfiles);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetProfiles, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetProfiles);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetProfiles, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetProfiles location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetProfiles(soap, tag ? tag : "-trt:GetProfiles", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_get___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetProfile(soap, &a->trt__GetProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfile(struct soap *soap, const char *tag, int id, const struct __trt__GetProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetProfile(soap, "trt:GetProfile", -1, &a->trt__GetProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_in___trt__GetProfile(struct soap *soap, const char *tag, struct __trt__GetProfile *a, const char *type)
{
	size_t soap_flag_trt__GetProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetProfile*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfile, sizeof(struct __trt__GetProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetProfile(soap, "trt:GetProfile", &a->trt__GetProfile, ""))
				{	soap_flag_trt__GetProfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetProfile * SOAP_FMAC2 soap_dup___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *d, struct __trt__GetProfile const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetProfile*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetProfile, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetProfile(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetProfile(soap, &d->trt__GetProfile, &a->trt__GetProfile);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetProfile(struct __trt__GetProfile const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetProfile(&a->trt__GetProfile);
}

SOAP_FMAC1 struct __trt__GetProfile * SOAP_FMAC2 soap_instantiate___trt__GetProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetProfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetProfile *p;
	size_t k = sizeof(struct __trt__GetProfile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetProfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetProfile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetProfile(soap, tag ? tag : "-trt:GetProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_get___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__CreateProfile(soap, &a->trt__CreateProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct __trt__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", -1, &a->trt__CreateProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_in___trt__CreateProfile(struct soap *soap, const char *tag, struct __trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_trt__CreateProfile = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__CreateProfile*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateProfile, sizeof(struct __trt__CreateProfile), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateProfile && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", &a->trt__CreateProfile, ""))
				{	soap_flag_trt__CreateProfile--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__CreateProfile * SOAP_FMAC2 soap_dup___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *d, struct __trt__CreateProfile const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__CreateProfile*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__CreateProfile, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__CreateProfile(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__CreateProfile(soap, &d->trt__CreateProfile, &a->trt__CreateProfile);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__CreateProfile(struct __trt__CreateProfile const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__CreateProfile(&a->trt__CreateProfile);
}

SOAP_FMAC1 struct __trt__CreateProfile * SOAP_FMAC2 soap_instantiate___trt__CreateProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__CreateProfile(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__CreateProfile *p;
	size_t k = sizeof(struct __trt__CreateProfile);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__CreateProfile, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__CreateProfile);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__CreateProfile, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__CreateProfile location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a, const char *tag, const char *type)
{
	if (soap_out___trt__CreateProfile(soap, tag ? tag : "-trt:CreateProfile", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_get___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputs(struct soap *soap, struct __trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputs(struct soap *soap, const struct __trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioOutputs(soap, &a->trt__GetAudioOutputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, "trt:GetAudioOutputs", -1, &a->trt__GetAudioOutputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputs * SOAP_FMAC4 soap_in___trt__GetAudioOutputs(struct soap *soap, const char *tag, struct __trt__GetAudioOutputs *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioOutputs*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputs, sizeof(struct __trt__GetAudioOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioOutputs(soap, "trt:GetAudioOutputs", &a->trt__GetAudioOutputs, ""))
				{	soap_flag_trt__GetAudioOutputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioOutputs * SOAP_FMAC2 soap_dup___trt__GetAudioOutputs(struct soap *soap, struct __trt__GetAudioOutputs *d, struct __trt__GetAudioOutputs const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioOutputs*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioOutputs, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioOutputs(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioOutputs(soap, &d->trt__GetAudioOutputs, &a->trt__GetAudioOutputs);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioOutputs(struct __trt__GetAudioOutputs const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioOutputs(&a->trt__GetAudioOutputs);
}

SOAP_FMAC1 struct __trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioOutputs *p;
	size_t k = sizeof(struct __trt__GetAudioOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioOutputs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioOutputs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputs(struct soap *soap, const struct __trt__GetAudioOutputs *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioOutputs(soap, tag ? tag : "-trt:GetAudioOutputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputs * SOAP_FMAC4 soap_get___trt__GetAudioOutputs(struct soap *soap, struct __trt__GetAudioOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSources(struct soap *soap, struct __trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSources(struct soap *soap, const struct __trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetAudioSources(soap, &a->trt__GetAudioSources);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSources(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetAudioSources(soap, "trt:GetAudioSources", -1, &a->trt__GetAudioSources, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSources * SOAP_FMAC4 soap_in___trt__GetAudioSources(struct soap *soap, const char *tag, struct __trt__GetAudioSources *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSources = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetAudioSources*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSources, sizeof(struct __trt__GetAudioSources), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSources(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSources && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetAudioSources(soap, "trt:GetAudioSources", &a->trt__GetAudioSources, ""))
				{	soap_flag_trt__GetAudioSources--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetAudioSources * SOAP_FMAC2 soap_dup___trt__GetAudioSources(struct soap *soap, struct __trt__GetAudioSources *d, struct __trt__GetAudioSources const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetAudioSources*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetAudioSources, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetAudioSources(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetAudioSources(soap, &d->trt__GetAudioSources, &a->trt__GetAudioSources);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetAudioSources(struct __trt__GetAudioSources const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetAudioSources(&a->trt__GetAudioSources);
}

SOAP_FMAC1 struct __trt__GetAudioSources * SOAP_FMAC2 soap_instantiate___trt__GetAudioSources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSources(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetAudioSources *p;
	size_t k = sizeof(struct __trt__GetAudioSources);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetAudioSources, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetAudioSources);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetAudioSources, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetAudioSources location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSources(struct soap *soap, const struct __trt__GetAudioSources *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetAudioSources(soap, tag ? tag : "-trt:GetAudioSources", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSources * SOAP_FMAC4 soap_get___trt__GetAudioSources(struct soap *soap, struct __trt__GetAudioSources *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSources(struct soap *soap, struct __trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSources(struct soap *soap, const struct __trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetVideoSources(soap, &a->trt__GetVideoSources);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSources(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetVideoSources(soap, "trt:GetVideoSources", -1, &a->trt__GetVideoSources, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSources * SOAP_FMAC4 soap_in___trt__GetVideoSources(struct soap *soap, const char *tag, struct __trt__GetVideoSources *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSources = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetVideoSources*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSources, sizeof(struct __trt__GetVideoSources), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSources(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSources && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetVideoSources(soap, "trt:GetVideoSources", &a->trt__GetVideoSources, ""))
				{	soap_flag_trt__GetVideoSources--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetVideoSources * SOAP_FMAC2 soap_dup___trt__GetVideoSources(struct soap *soap, struct __trt__GetVideoSources *d, struct __trt__GetVideoSources const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetVideoSources*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetVideoSources, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetVideoSources(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetVideoSources(soap, &d->trt__GetVideoSources, &a->trt__GetVideoSources);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetVideoSources(struct __trt__GetVideoSources const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetVideoSources(&a->trt__GetVideoSources);
}

SOAP_FMAC1 struct __trt__GetVideoSources * SOAP_FMAC2 soap_instantiate___trt__GetVideoSources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSources(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetVideoSources *p;
	size_t k = sizeof(struct __trt__GetVideoSources);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetVideoSources, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetVideoSources);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetVideoSources, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetVideoSources location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSources(struct soap *soap, const struct __trt__GetVideoSources *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetVideoSources(soap, tag ? tag : "-trt:GetVideoSources", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSources * SOAP_FMAC4 soap_get___trt__GetVideoSources(struct soap *soap, struct __trt__GetVideoSources *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_trt__GetServiceCapabilities(soap, &a->trt__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __trt__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", -1, &a->trt__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_in___trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct __trt__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_trt__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __trt__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetServiceCapabilities, sizeof(struct __trt__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", &a->trt__GetServiceCapabilities, ""))
				{	soap_flag_trt__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __trt__GetServiceCapabilities * SOAP_FMAC2 soap_dup___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *d, struct __trt__GetServiceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __trt__GetServiceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___trt__GetServiceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___trt__GetServiceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_trt__GetServiceCapabilities(soap, &d->trt__GetServiceCapabilities, &a->trt__GetServiceCapabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___trt__GetServiceCapabilities(struct __trt__GetServiceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_trt__GetServiceCapabilities(&a->trt__GetServiceCapabilities);
}

SOAP_FMAC1 struct __trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trt__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __trt__GetServiceCapabilities *p;
	size_t k = sizeof(struct __trt__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___trt__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __trt__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __trt__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __trt__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___trt__GetServiceCapabilities(soap, tag ? tag : "-trt:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_get___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetCurrentPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetCurrentPreset(struct soap *soap, const struct __timg__SetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__SetCurrentPreset(soap, &a->timg__SetCurrentPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetCurrentPreset(struct soap *soap, const char *tag, int id, const struct __timg__SetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__SetCurrentPreset(soap, "timg:SetCurrentPreset", -1, &a->timg__SetCurrentPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_in___timg__SetCurrentPreset(struct soap *soap, const char *tag, struct __timg__SetCurrentPreset *a, const char *type)
{
	size_t soap_flag_timg__SetCurrentPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__SetCurrentPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetCurrentPreset, sizeof(struct __timg__SetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__SetCurrentPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__SetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__SetCurrentPreset(soap, "timg:SetCurrentPreset", &a->timg__SetCurrentPreset, ""))
				{	soap_flag_timg__SetCurrentPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__SetCurrentPreset * SOAP_FMAC2 soap_dup___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *d, struct __timg__SetCurrentPreset const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__SetCurrentPreset*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__SetCurrentPreset, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__SetCurrentPreset(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__SetCurrentPreset(soap, &d->timg__SetCurrentPreset, &a->timg__SetCurrentPreset);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__SetCurrentPreset(struct __timg__SetCurrentPreset const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__SetCurrentPreset(&a->timg__SetCurrentPreset);
}

SOAP_FMAC1 struct __timg__SetCurrentPreset * SOAP_FMAC2 soap_instantiate___timg__SetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__SetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__SetCurrentPreset *p;
	size_t k = sizeof(struct __timg__SetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__SetCurrentPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__SetCurrentPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__SetCurrentPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__SetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetCurrentPreset(struct soap *soap, const struct __timg__SetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out___timg__SetCurrentPreset(soap, tag ? tag : "-timg:SetCurrentPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetCurrentPreset * SOAP_FMAC4 soap_get___timg__SetCurrentPreset(struct soap *soap, struct __timg__SetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetCurrentPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetCurrentPreset(struct soap *soap, const struct __timg__GetCurrentPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetCurrentPreset(soap, &a->timg__GetCurrentPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetCurrentPreset(struct soap *soap, const char *tag, int id, const struct __timg__GetCurrentPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetCurrentPreset(soap, "timg:GetCurrentPreset", -1, &a->timg__GetCurrentPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_in___timg__GetCurrentPreset(struct soap *soap, const char *tag, struct __timg__GetCurrentPreset *a, const char *type)
{
	size_t soap_flag_timg__GetCurrentPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetCurrentPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetCurrentPreset, sizeof(struct __timg__GetCurrentPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetCurrentPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetCurrentPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetCurrentPreset(soap, "timg:GetCurrentPreset", &a->timg__GetCurrentPreset, ""))
				{	soap_flag_timg__GetCurrentPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetCurrentPreset * SOAP_FMAC2 soap_dup___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *d, struct __timg__GetCurrentPreset const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetCurrentPreset*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetCurrentPreset, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetCurrentPreset(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetCurrentPreset(soap, &d->timg__GetCurrentPreset, &a->timg__GetCurrentPreset);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetCurrentPreset(struct __timg__GetCurrentPreset const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetCurrentPreset(&a->timg__GetCurrentPreset);
}

SOAP_FMAC1 struct __timg__GetCurrentPreset * SOAP_FMAC2 soap_instantiate___timg__GetCurrentPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetCurrentPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetCurrentPreset *p;
	size_t k = sizeof(struct __timg__GetCurrentPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetCurrentPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetCurrentPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetCurrentPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetCurrentPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetCurrentPreset(struct soap *soap, const struct __timg__GetCurrentPreset *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetCurrentPreset(soap, tag ? tag : "-timg:GetCurrentPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetCurrentPreset * SOAP_FMAC4 soap_get___timg__GetCurrentPreset(struct soap *soap, struct __timg__GetCurrentPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetCurrentPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetPresets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetPresets(struct soap *soap, const struct __timg__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetPresets(soap, &a->timg__GetPresets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetPresets(struct soap *soap, const char *tag, int id, const struct __timg__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetPresets(soap, "timg:GetPresets", -1, &a->timg__GetPresets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_in___timg__GetPresets(struct soap *soap, const char *tag, struct __timg__GetPresets *a, const char *type)
{
	size_t soap_flag_timg__GetPresets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetPresets*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetPresets, sizeof(struct __timg__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetPresets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetPresets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetPresets(soap, "timg:GetPresets", &a->timg__GetPresets, ""))
				{	soap_flag_timg__GetPresets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetPresets * SOAP_FMAC2 soap_dup___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *d, struct __timg__GetPresets const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetPresets*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetPresets, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetPresets(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetPresets(soap, &d->timg__GetPresets, &a->timg__GetPresets);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetPresets(struct __timg__GetPresets const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetPresets(&a->timg__GetPresets);
}

SOAP_FMAC1 struct __timg__GetPresets * SOAP_FMAC2 soap_instantiate___timg__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetPresets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetPresets *p;
	size_t k = sizeof(struct __timg__GetPresets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetPresets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetPresets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetPresets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetPresets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetPresets(struct soap *soap, const struct __timg__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetPresets(soap, tag ? tag : "-timg:GetPresets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetPresets * SOAP_FMAC4 soap_get___timg__GetPresets(struct soap *soap, struct __timg__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetMoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetMoveOptions(soap, &a->timg__GetMoveOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", -1, &a->timg__GetMoveOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_in___timg__GetMoveOptions(struct soap *soap, const char *tag, struct __timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_timg__GetMoveOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetMoveOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetMoveOptions, sizeof(struct __timg__GetMoveOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetMoveOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetMoveOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", &a->timg__GetMoveOptions, ""))
				{	soap_flag_timg__GetMoveOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetMoveOptions * SOAP_FMAC2 soap_dup___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *d, struct __timg__GetMoveOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetMoveOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetMoveOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetMoveOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetMoveOptions(soap, &d->timg__GetMoveOptions, &a->timg__GetMoveOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetMoveOptions(struct __timg__GetMoveOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetMoveOptions(&a->timg__GetMoveOptions);
}

SOAP_FMAC1 struct __timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate___timg__GetMoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetMoveOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetMoveOptions *p;
	size_t k = sizeof(struct __timg__GetMoveOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetMoveOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetMoveOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetMoveOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetMoveOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetMoveOptions(soap, tag ? tag : "-timg:GetMoveOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_get___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetStatus(soap, &a->timg__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetStatus(struct soap *soap, const char *tag, int id, const struct __timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetStatus(soap, "timg:GetStatus", -1, &a->timg__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_in___timg__GetStatus(struct soap *soap, const char *tag, struct __timg__GetStatus *a, const char *type)
{
	size_t soap_flag_timg__GetStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetStatus, sizeof(struct __timg__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetStatus(soap, "timg:GetStatus", &a->timg__GetStatus, ""))
				{	soap_flag_timg__GetStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetStatus * SOAP_FMAC2 soap_dup___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *d, struct __timg__GetStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetStatus(soap, &d->timg__GetStatus, &a->timg__GetStatus);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetStatus(struct __timg__GetStatus const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetStatus(&a->timg__GetStatus);
}

SOAP_FMAC1 struct __timg__GetStatus * SOAP_FMAC2 soap_instantiate___timg__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetStatus *p;
	size_t k = sizeof(struct __timg__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetStatus(soap, tag ? tag : "-timg:GetStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_get___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Stop(struct soap *soap, struct __timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Stop(struct soap *soap, const struct __timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__Stop(soap, &a->timg__Stop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Stop(struct soap *soap, const char *tag, int id, const struct __timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__Stop(soap, "timg:Stop", -1, &a->timg__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_in___timg__Stop(struct soap *soap, const char *tag, struct __timg__Stop *a, const char *type)
{
	size_t soap_flag_timg__Stop = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__Stop*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Stop, sizeof(struct __timg__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Stop && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__Stop(soap, "timg:Stop", &a->timg__Stop, ""))
				{	soap_flag_timg__Stop--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__Stop * SOAP_FMAC2 soap_dup___timg__Stop(struct soap *soap, struct __timg__Stop *d, struct __timg__Stop const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__Stop*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__Stop, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__Stop(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__Stop(soap, &d->timg__Stop, &a->timg__Stop);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__Stop(struct __timg__Stop const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__Stop(&a->timg__Stop);
}

SOAP_FMAC1 struct __timg__Stop * SOAP_FMAC2 soap_instantiate___timg__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__Stop *p;
	size_t k = sizeof(struct __timg__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__Stop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__Stop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__Stop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Stop(struct soap *soap, const struct __timg__Stop *a, const char *tag, const char *type)
{
	if (soap_out___timg__Stop(soap, tag ? tag : "-timg:Stop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_get___timg__Stop(struct soap *soap, struct __timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Move(struct soap *soap, struct __timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Move = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Move(struct soap *soap, const struct __timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__Move(soap, &a->timg__Move);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Move(struct soap *soap, const char *tag, int id, const struct __timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__Move(soap, "timg:Move", -1, &a->timg__Move, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_in___timg__Move(struct soap *soap, const char *tag, struct __timg__Move *a, const char *type)
{
	size_t soap_flag_timg__Move = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__Move*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Move, sizeof(struct __timg__Move), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Move(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Move && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__Move(soap, "timg:Move", &a->timg__Move, ""))
				{	soap_flag_timg__Move--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__Move * SOAP_FMAC2 soap_dup___timg__Move(struct soap *soap, struct __timg__Move *d, struct __timg__Move const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__Move*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__Move, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__Move(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__Move(soap, &d->timg__Move, &a->timg__Move);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__Move(struct __timg__Move const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__Move(&a->timg__Move);
}

SOAP_FMAC1 struct __timg__Move * SOAP_FMAC2 soap_instantiate___timg__Move(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__Move(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__Move *p;
	size_t k = sizeof(struct __timg__Move);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__Move, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__Move);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__Move, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__Move location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Move(struct soap *soap, const struct __timg__Move *a, const char *tag, const char *type)
{
	if (soap_out___timg__Move(soap, tag ? tag : "-timg:Move", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_get___timg__Move(struct soap *soap, struct __timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetOptions(soap, &a->timg__GetOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetOptions(soap, "timg:GetOptions", -1, &a->timg__GetOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_in___timg__GetOptions(struct soap *soap, const char *tag, struct __timg__GetOptions *a, const char *type)
{
	size_t soap_flag_timg__GetOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetOptions, sizeof(struct __timg__GetOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetOptions(soap, "timg:GetOptions", &a->timg__GetOptions, ""))
				{	soap_flag_timg__GetOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetOptions * SOAP_FMAC2 soap_dup___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *d, struct __timg__GetOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetOptions(soap, &d->timg__GetOptions, &a->timg__GetOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetOptions(struct __timg__GetOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetOptions(&a->timg__GetOptions);
}

SOAP_FMAC1 struct __timg__GetOptions * SOAP_FMAC2 soap_instantiate___timg__GetOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetOptions *p;
	size_t k = sizeof(struct __timg__GetOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetOptions(soap, tag ? tag : "-timg:GetOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_get___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__SetImagingSettings(soap, &a->timg__SetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", -1, &a->timg__SetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_in___timg__SetImagingSettings(struct soap *soap, const char *tag, struct __timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__SetImagingSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__SetImagingSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetImagingSettings, sizeof(struct __timg__SetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__SetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__SetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", &a->timg__SetImagingSettings, ""))
				{	soap_flag_timg__SetImagingSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__SetImagingSettings * SOAP_FMAC2 soap_dup___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *d, struct __timg__SetImagingSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__SetImagingSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__SetImagingSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__SetImagingSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__SetImagingSettings(soap, &d->timg__SetImagingSettings, &a->timg__SetImagingSettings);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__SetImagingSettings(struct __timg__SetImagingSettings const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__SetImagingSettings(&a->timg__SetImagingSettings);
}

SOAP_FMAC1 struct __timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__SetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__SetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__SetImagingSettings *p;
	size_t k = sizeof(struct __timg__SetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__SetImagingSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__SetImagingSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__SetImagingSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__SetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out___timg__SetImagingSettings(soap, tag ? tag : "-timg:SetImagingSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_get___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetImagingSettings(soap, &a->timg__GetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", -1, &a->timg__GetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_in___timg__GetImagingSettings(struct soap *soap, const char *tag, struct __timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__GetImagingSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetImagingSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetImagingSettings, sizeof(struct __timg__GetImagingSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", &a->timg__GetImagingSettings, ""))
				{	soap_flag_timg__GetImagingSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetImagingSettings * SOAP_FMAC2 soap_dup___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *d, struct __timg__GetImagingSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetImagingSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetImagingSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetImagingSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetImagingSettings(soap, &d->timg__GetImagingSettings, &a->timg__GetImagingSettings);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetImagingSettings(struct __timg__GetImagingSettings const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetImagingSettings(&a->timg__GetImagingSettings);
}

SOAP_FMAC1 struct __timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__GetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetImagingSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetImagingSettings *p;
	size_t k = sizeof(struct __timg__GetImagingSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetImagingSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetImagingSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetImagingSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetImagingSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetImagingSettings(soap, tag ? tag : "-timg:GetImagingSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_get___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_timg__GetServiceCapabilities(soap, &a->timg__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", -1, &a->timg__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_in___timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct __timg__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_timg__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __timg__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetServiceCapabilities, sizeof(struct __timg__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", &a->timg__GetServiceCapabilities, ""))
				{	soap_flag_timg__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __timg__GetServiceCapabilities * SOAP_FMAC2 soap_dup___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *d, struct __timg__GetServiceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __timg__GetServiceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___timg__GetServiceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___timg__GetServiceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_timg__GetServiceCapabilities(soap, &d->timg__GetServiceCapabilities, &a->timg__GetServiceCapabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___timg__GetServiceCapabilities(struct __timg__GetServiceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_timg__GetServiceCapabilities(&a->timg__GetServiceCapabilities);
}

SOAP_FMAC1 struct __timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___timg__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __timg__GetServiceCapabilities *p;
	size_t k = sizeof(struct __timg__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___timg__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __timg__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __timg__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __timg__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___timg__GetServiceCapabilities(soap, tag ? tag : "-timg:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_get___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHashingAlgorithm(struct soap *soap, struct __tds__SetHashingAlgorithm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHashingAlgorithm = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHashingAlgorithm(struct soap *soap, const struct __tds__SetHashingAlgorithm *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHashingAlgorithm(soap, &a->tds__SetHashingAlgorithm);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHashingAlgorithm(struct soap *soap, const char *tag, int id, const struct __tds__SetHashingAlgorithm *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHashingAlgorithm(soap, "tds:SetHashingAlgorithm", -1, &a->tds__SetHashingAlgorithm, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHashingAlgorithm * SOAP_FMAC4 soap_in___tds__SetHashingAlgorithm(struct soap *soap, const char *tag, struct __tds__SetHashingAlgorithm *a, const char *type)
{
	size_t soap_flag_tds__SetHashingAlgorithm = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHashingAlgorithm*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHashingAlgorithm, sizeof(struct __tds__SetHashingAlgorithm), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHashingAlgorithm(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHashingAlgorithm && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHashingAlgorithm(soap, "tds:SetHashingAlgorithm", &a->tds__SetHashingAlgorithm, ""))
				{	soap_flag_tds__SetHashingAlgorithm--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHashingAlgorithm * SOAP_FMAC2 soap_dup___tds__SetHashingAlgorithm(struct soap *soap, struct __tds__SetHashingAlgorithm *d, struct __tds__SetHashingAlgorithm const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetHashingAlgorithm*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetHashingAlgorithm, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetHashingAlgorithm(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetHashingAlgorithm(soap, &d->tds__SetHashingAlgorithm, &a->tds__SetHashingAlgorithm);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetHashingAlgorithm(struct __tds__SetHashingAlgorithm const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetHashingAlgorithm(&a->tds__SetHashingAlgorithm);
}

SOAP_FMAC1 struct __tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate___tds__SetHashingAlgorithm(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHashingAlgorithm(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHashingAlgorithm *p;
	size_t k = sizeof(struct __tds__SetHashingAlgorithm);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHashingAlgorithm, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHashingAlgorithm);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHashingAlgorithm, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHashingAlgorithm location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHashingAlgorithm(struct soap *soap, const struct __tds__SetHashingAlgorithm *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHashingAlgorithm(soap, tag ? tag : "-tds:SetHashingAlgorithm", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHashingAlgorithm * SOAP_FMAC4 soap_get___tds__SetHashingAlgorithm(struct soap *soap, struct __tds__SetHashingAlgorithm *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHashingAlgorithm(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteGeoLocation(struct soap *soap, struct __tds__DeleteGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteGeoLocation(struct soap *soap, const struct __tds__DeleteGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteGeoLocation(soap, &a->tds__DeleteGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__DeleteGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteGeoLocation(soap, "tds:DeleteGeoLocation", -1, &a->tds__DeleteGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteGeoLocation * SOAP_FMAC4 soap_in___tds__DeleteGeoLocation(struct soap *soap, const char *tag, struct __tds__DeleteGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__DeleteGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteGeoLocation, sizeof(struct __tds__DeleteGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteGeoLocation(soap, "tds:DeleteGeoLocation", &a->tds__DeleteGeoLocation, ""))
				{	soap_flag_tds__DeleteGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteGeoLocation * SOAP_FMAC2 soap_dup___tds__DeleteGeoLocation(struct soap *soap, struct __tds__DeleteGeoLocation *d, struct __tds__DeleteGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__DeleteGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__DeleteGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__DeleteGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__DeleteGeoLocation(soap, &d->tds__DeleteGeoLocation, &a->tds__DeleteGeoLocation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__DeleteGeoLocation(struct __tds__DeleteGeoLocation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__DeleteGeoLocation(&a->tds__DeleteGeoLocation);
}

SOAP_FMAC1 struct __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteGeoLocation *p;
	size_t k = sizeof(struct __tds__DeleteGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteGeoLocation(struct soap *soap, const struct __tds__DeleteGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteGeoLocation(soap, tag ? tag : "-tds:DeleteGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteGeoLocation * SOAP_FMAC4 soap_get___tds__DeleteGeoLocation(struct soap *soap, struct __tds__DeleteGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetGeoLocation(struct soap *soap, struct __tds__SetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetGeoLocation(struct soap *soap, const struct __tds__SetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetGeoLocation(soap, &a->tds__SetGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__SetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetGeoLocation(soap, "tds:SetGeoLocation", -1, &a->tds__SetGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetGeoLocation * SOAP_FMAC4 soap_in___tds__SetGeoLocation(struct soap *soap, const char *tag, struct __tds__SetGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__SetGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetGeoLocation, sizeof(struct __tds__SetGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetGeoLocation(soap, "tds:SetGeoLocation", &a->tds__SetGeoLocation, ""))
				{	soap_flag_tds__SetGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetGeoLocation * SOAP_FMAC2 soap_dup___tds__SetGeoLocation(struct soap *soap, struct __tds__SetGeoLocation *d, struct __tds__SetGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetGeoLocation(soap, &d->tds__SetGeoLocation, &a->tds__SetGeoLocation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetGeoLocation(struct __tds__SetGeoLocation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetGeoLocation(&a->tds__SetGeoLocation);
}

SOAP_FMAC1 struct __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetGeoLocation *p;
	size_t k = sizeof(struct __tds__SetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetGeoLocation(struct soap *soap, const struct __tds__SetGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetGeoLocation(soap, tag ? tag : "-tds:SetGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetGeoLocation * SOAP_FMAC4 soap_get___tds__SetGeoLocation(struct soap *soap, struct __tds__SetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetGeoLocation(struct soap *soap, struct __tds__GetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetGeoLocation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetGeoLocation(struct soap *soap, const struct __tds__GetGeoLocation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetGeoLocation(soap, &a->tds__GetGeoLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetGeoLocation(struct soap *soap, const char *tag, int id, const struct __tds__GetGeoLocation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetGeoLocation(soap, "tds:GetGeoLocation", -1, &a->tds__GetGeoLocation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetGeoLocation * SOAP_FMAC4 soap_in___tds__GetGeoLocation(struct soap *soap, const char *tag, struct __tds__GetGeoLocation *a, const char *type)
{
	size_t soap_flag_tds__GetGeoLocation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetGeoLocation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetGeoLocation, sizeof(struct __tds__GetGeoLocation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetGeoLocation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetGeoLocation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetGeoLocation(soap, "tds:GetGeoLocation", &a->tds__GetGeoLocation, ""))
				{	soap_flag_tds__GetGeoLocation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetGeoLocation * SOAP_FMAC2 soap_dup___tds__GetGeoLocation(struct soap *soap, struct __tds__GetGeoLocation *d, struct __tds__GetGeoLocation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetGeoLocation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetGeoLocation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetGeoLocation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetGeoLocation(soap, &d->tds__GetGeoLocation, &a->tds__GetGeoLocation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetGeoLocation(struct __tds__GetGeoLocation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetGeoLocation(&a->tds__GetGeoLocation);
}

SOAP_FMAC1 struct __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetGeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetGeoLocation *p;
	size_t k = sizeof(struct __tds__GetGeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetGeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetGeoLocation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetGeoLocation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetGeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetGeoLocation(struct soap *soap, const struct __tds__GetGeoLocation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetGeoLocation(soap, tag ? tag : "-tds:GetGeoLocation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetGeoLocation * SOAP_FMAC4 soap_get___tds__GetGeoLocation(struct soap *soap, struct __tds__GetGeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetGeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteStorageConfiguration(struct soap *soap, struct __tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteStorageConfiguration(struct soap *soap, const struct __tds__DeleteStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteStorageConfiguration(soap, &a->tds__DeleteStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__DeleteStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteStorageConfiguration(soap, "tds:DeleteStorageConfiguration", -1, &a->tds__DeleteStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_in___tds__DeleteStorageConfiguration(struct soap *soap, const char *tag, struct __tds__DeleteStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__DeleteStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteStorageConfiguration, sizeof(struct __tds__DeleteStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteStorageConfiguration(soap, "tds:DeleteStorageConfiguration", &a->tds__DeleteStorageConfiguration, ""))
				{	soap_flag_tds__DeleteStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_dup___tds__DeleteStorageConfiguration(struct soap *soap, struct __tds__DeleteStorageConfiguration *d, struct __tds__DeleteStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__DeleteStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__DeleteStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__DeleteStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__DeleteStorageConfiguration(soap, &d->tds__DeleteStorageConfiguration, &a->tds__DeleteStorageConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__DeleteStorageConfiguration(struct __tds__DeleteStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__DeleteStorageConfiguration(&a->tds__DeleteStorageConfiguration);
}

SOAP_FMAC1 struct __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteStorageConfiguration *p;
	size_t k = sizeof(struct __tds__DeleteStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteStorageConfiguration(struct soap *soap, const struct __tds__DeleteStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteStorageConfiguration(soap, tag ? tag : "-tds:DeleteStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteStorageConfiguration * SOAP_FMAC4 soap_get___tds__DeleteStorageConfiguration(struct soap *soap, struct __tds__DeleteStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetStorageConfiguration(struct soap *soap, struct __tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetStorageConfiguration(struct soap *soap, const struct __tds__SetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetStorageConfiguration(soap, &a->tds__SetStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetStorageConfiguration(soap, "tds:SetStorageConfiguration", -1, &a->tds__SetStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetStorageConfiguration * SOAP_FMAC4 soap_in___tds__SetStorageConfiguration(struct soap *soap, const char *tag, struct __tds__SetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetStorageConfiguration, sizeof(struct __tds__SetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetStorageConfiguration(soap, "tds:SetStorageConfiguration", &a->tds__SetStorageConfiguration, ""))
				{	soap_flag_tds__SetStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetStorageConfiguration * SOAP_FMAC2 soap_dup___tds__SetStorageConfiguration(struct soap *soap, struct __tds__SetStorageConfiguration *d, struct __tds__SetStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetStorageConfiguration(soap, &d->tds__SetStorageConfiguration, &a->tds__SetStorageConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetStorageConfiguration(struct __tds__SetStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetStorageConfiguration(&a->tds__SetStorageConfiguration);
}

SOAP_FMAC1 struct __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetStorageConfiguration *p;
	size_t k = sizeof(struct __tds__SetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetStorageConfiguration(struct soap *soap, const struct __tds__SetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetStorageConfiguration(soap, tag ? tag : "-tds:SetStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetStorageConfiguration * SOAP_FMAC4 soap_get___tds__SetStorageConfiguration(struct soap *soap, struct __tds__SetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetStorageConfiguration(struct soap *soap, struct __tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetStorageConfiguration(struct soap *soap, const struct __tds__GetStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetStorageConfiguration(soap, &a->tds__GetStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetStorageConfiguration(soap, "tds:GetStorageConfiguration", -1, &a->tds__GetStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfiguration * SOAP_FMAC4 soap_in___tds__GetStorageConfiguration(struct soap *soap, const char *tag, struct __tds__GetStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetStorageConfiguration, sizeof(struct __tds__GetStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetStorageConfiguration(soap, "tds:GetStorageConfiguration", &a->tds__GetStorageConfiguration, ""))
				{	soap_flag_tds__GetStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetStorageConfiguration * SOAP_FMAC2 soap_dup___tds__GetStorageConfiguration(struct soap *soap, struct __tds__GetStorageConfiguration *d, struct __tds__GetStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetStorageConfiguration(soap, &d->tds__GetStorageConfiguration, &a->tds__GetStorageConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetStorageConfiguration(struct __tds__GetStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetStorageConfiguration(&a->tds__GetStorageConfiguration);
}

SOAP_FMAC1 struct __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetStorageConfiguration *p;
	size_t k = sizeof(struct __tds__GetStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetStorageConfiguration(struct soap *soap, const struct __tds__GetStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetStorageConfiguration(soap, tag ? tag : "-tds:GetStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfiguration * SOAP_FMAC4 soap_get___tds__GetStorageConfiguration(struct soap *soap, struct __tds__GetStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateStorageConfiguration(struct soap *soap, struct __tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateStorageConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateStorageConfiguration(struct soap *soap, const struct __tds__CreateStorageConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateStorageConfiguration(soap, &a->tds__CreateStorageConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateStorageConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__CreateStorageConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateStorageConfiguration(soap, "tds:CreateStorageConfiguration", -1, &a->tds__CreateStorageConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateStorageConfiguration * SOAP_FMAC4 soap_in___tds__CreateStorageConfiguration(struct soap *soap, const char *tag, struct __tds__CreateStorageConfiguration *a, const char *type)
{
	size_t soap_flag_tds__CreateStorageConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateStorageConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateStorageConfiguration, sizeof(struct __tds__CreateStorageConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateStorageConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateStorageConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateStorageConfiguration(soap, "tds:CreateStorageConfiguration", &a->tds__CreateStorageConfiguration, ""))
				{	soap_flag_tds__CreateStorageConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_dup___tds__CreateStorageConfiguration(struct soap *soap, struct __tds__CreateStorageConfiguration *d, struct __tds__CreateStorageConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__CreateStorageConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__CreateStorageConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__CreateStorageConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__CreateStorageConfiguration(soap, &d->tds__CreateStorageConfiguration, &a->tds__CreateStorageConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__CreateStorageConfiguration(struct __tds__CreateStorageConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__CreateStorageConfiguration(&a->tds__CreateStorageConfiguration);
}

SOAP_FMAC1 struct __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateStorageConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateStorageConfiguration *p;
	size_t k = sizeof(struct __tds__CreateStorageConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateStorageConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateStorageConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateStorageConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateStorageConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateStorageConfiguration(struct soap *soap, const struct __tds__CreateStorageConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateStorageConfiguration(soap, tag ? tag : "-tds:CreateStorageConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateStorageConfiguration * SOAP_FMAC4 soap_get___tds__CreateStorageConfiguration(struct soap *soap, struct __tds__CreateStorageConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateStorageConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetStorageConfigurations(struct soap *soap, struct __tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetStorageConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetStorageConfigurations(struct soap *soap, const struct __tds__GetStorageConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetStorageConfigurations(soap, &a->tds__GetStorageConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetStorageConfigurations(struct soap *soap, const char *tag, int id, const struct __tds__GetStorageConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetStorageConfigurations(soap, "tds:GetStorageConfigurations", -1, &a->tds__GetStorageConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfigurations * SOAP_FMAC4 soap_in___tds__GetStorageConfigurations(struct soap *soap, const char *tag, struct __tds__GetStorageConfigurations *a, const char *type)
{
	size_t soap_flag_tds__GetStorageConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetStorageConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetStorageConfigurations, sizeof(struct __tds__GetStorageConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetStorageConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetStorageConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetStorageConfigurations(soap, "tds:GetStorageConfigurations", &a->tds__GetStorageConfigurations, ""))
				{	soap_flag_tds__GetStorageConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetStorageConfigurations * SOAP_FMAC2 soap_dup___tds__GetStorageConfigurations(struct soap *soap, struct __tds__GetStorageConfigurations *d, struct __tds__GetStorageConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetStorageConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetStorageConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetStorageConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetStorageConfigurations(soap, &d->tds__GetStorageConfigurations, &a->tds__GetStorageConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetStorageConfigurations(struct __tds__GetStorageConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetStorageConfigurations(&a->tds__GetStorageConfigurations);
}

SOAP_FMAC1 struct __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetStorageConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetStorageConfigurations *p;
	size_t k = sizeof(struct __tds__GetStorageConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetStorageConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetStorageConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetStorageConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetStorageConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetStorageConfigurations(struct soap *soap, const struct __tds__GetStorageConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetStorageConfigurations(soap, tag ? tag : "-tds:GetStorageConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetStorageConfigurations * SOAP_FMAC4 soap_get___tds__GetStorageConfigurations(struct soap *soap, struct __tds__GetStorageConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetStorageConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartSystemRestore = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__StartSystemRestore(soap, &a->tds__StartSystemRestore);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct __tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", -1, &a->tds__StartSystemRestore, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_in___tds__StartSystemRestore(struct soap *soap, const char *tag, struct __tds__StartSystemRestore *a, const char *type)
{
	size_t soap_flag_tds__StartSystemRestore = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__StartSystemRestore*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartSystemRestore, sizeof(struct __tds__StartSystemRestore), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartSystemRestore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartSystemRestore && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", &a->tds__StartSystemRestore, ""))
				{	soap_flag_tds__StartSystemRestore--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__StartSystemRestore * SOAP_FMAC2 soap_dup___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *d, struct __tds__StartSystemRestore const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__StartSystemRestore*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__StartSystemRestore, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__StartSystemRestore(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__StartSystemRestore(soap, &d->tds__StartSystemRestore, &a->tds__StartSystemRestore);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__StartSystemRestore(struct __tds__StartSystemRestore const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__StartSystemRestore(&a->tds__StartSystemRestore);
}

SOAP_FMAC1 struct __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartSystemRestore(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__StartSystemRestore *p;
	size_t k = sizeof(struct __tds__StartSystemRestore);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__StartSystemRestore, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__StartSystemRestore);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__StartSystemRestore, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__StartSystemRestore location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a, const char *tag, const char *type)
{
	if (soap_out___tds__StartSystemRestore(soap, tag ? tag : "-tds:StartSystemRestore", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_get___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartFirmwareUpgrade = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__StartFirmwareUpgrade(soap, &a->tds__StartFirmwareUpgrade);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", -1, &a->tds__StartFirmwareUpgrade, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	size_t soap_flag_tds__StartFirmwareUpgrade = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__StartFirmwareUpgrade*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartFirmwareUpgrade, sizeof(struct __tds__StartFirmwareUpgrade), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartFirmwareUpgrade(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", &a->tds__StartFirmwareUpgrade, ""))
				{	soap_flag_tds__StartFirmwareUpgrade--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_dup___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *d, struct __tds__StartFirmwareUpgrade const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__StartFirmwareUpgrade*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__StartFirmwareUpgrade, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__StartFirmwareUpgrade(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__StartFirmwareUpgrade(soap, &d->tds__StartFirmwareUpgrade, &a->tds__StartFirmwareUpgrade);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__StartFirmwareUpgrade(struct __tds__StartFirmwareUpgrade const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__StartFirmwareUpgrade(&a->tds__StartFirmwareUpgrade);
}

SOAP_FMAC1 struct __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartFirmwareUpgrade(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__StartFirmwareUpgrade *p;
	size_t k = sizeof(struct __tds__StartFirmwareUpgrade);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__StartFirmwareUpgrade);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__StartFirmwareUpgrade, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__StartFirmwareUpgrade location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	if (soap_out___tds__StartFirmwareUpgrade(soap, tag ? tag : "-tds:StartFirmwareUpgrade", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemUris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemUris(soap, &a->tds__GetSystemUris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", -1, &a->tds__GetSystemUris, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_in___tds__GetSystemUris(struct soap *soap, const char *tag, struct __tds__GetSystemUris *a, const char *type)
{
	size_t soap_flag_tds__GetSystemUris = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemUris*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemUris, sizeof(struct __tds__GetSystemUris), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemUris(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemUris && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", &a->tds__GetSystemUris, ""))
				{	soap_flag_tds__GetSystemUris--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemUris * SOAP_FMAC2 soap_dup___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *d, struct __tds__GetSystemUris const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetSystemUris*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetSystemUris, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetSystemUris(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetSystemUris(soap, &d->tds__GetSystemUris, &a->tds__GetSystemUris);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetSystemUris(struct __tds__GetSystemUris const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetSystemUris(&a->tds__GetSystemUris);
}

SOAP_FMAC1 struct __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemUris(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemUris *p;
	size_t k = sizeof(struct __tds__GetSystemUris);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemUris, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemUris);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemUris, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemUris location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemUris(soap, tag ? tag : "-tds:GetSystemUris", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_get___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__ScanAvailableDot11Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(soap, &a->tds__ScanAvailableDot11Networks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", -1, &a->tds__ScanAvailableDot11Networks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_tds__ScanAvailableDot11Networks = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__ScanAvailableDot11Networks*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__ScanAvailableDot11Networks, sizeof(struct __tds__ScanAvailableDot11Networks), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__ScanAvailableDot11Networks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__ScanAvailableDot11Networks && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", &a->tds__ScanAvailableDot11Networks, ""))
				{	soap_flag_tds__ScanAvailableDot11Networks--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_dup___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *d, struct __tds__ScanAvailableDot11Networks const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__ScanAvailableDot11Networks*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__ScanAvailableDot11Networks, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__ScanAvailableDot11Networks(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__ScanAvailableDot11Networks(soap, &d->tds__ScanAvailableDot11Networks, &a->tds__ScanAvailableDot11Networks);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__ScanAvailableDot11Networks(struct __tds__ScanAvailableDot11Networks const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__ScanAvailableDot11Networks(&a->tds__ScanAvailableDot11Networks);
}

SOAP_FMAC1 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__ScanAvailableDot11Networks(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__ScanAvailableDot11Networks *p;
	size_t k = sizeof(struct __tds__ScanAvailableDot11Networks);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__ScanAvailableDot11Networks);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__ScanAvailableDot11Networks, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__ScanAvailableDot11Networks location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	if (soap_out___tds__ScanAvailableDot11Networks(soap, tag ? tag : "-tds:ScanAvailableDot11Networks", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot11Status(soap, &a->tds__GetDot11Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", -1, &a->tds__GetDot11Status, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_in___tds__GetDot11Status(struct soap *soap, const char *tag, struct __tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Status = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot11Status*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Status, sizeof(struct __tds__GetDot11Status), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Status(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Status && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", &a->tds__GetDot11Status, ""))
				{	soap_flag_tds__GetDot11Status--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot11Status * SOAP_FMAC2 soap_dup___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *d, struct __tds__GetDot11Status const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDot11Status*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDot11Status, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDot11Status(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDot11Status(soap, &d->tds__GetDot11Status, &a->tds__GetDot11Status);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDot11Status(struct __tds__GetDot11Status const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDot11Status(&a->tds__GetDot11Status);
}

SOAP_FMAC1 struct __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot11Status *p;
	size_t k = sizeof(struct __tds__GetDot11Status);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot11Status, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot11Status);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot11Status, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot11Status location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot11Status(soap, tag ? tag : "-tds:GetDot11Status", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_get___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot11Capabilities(soap, &a->tds__GetDot11Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", -1, &a->tds__GetDot11Capabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_in___tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct __tds__GetDot11Capabilities *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Capabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot11Capabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Capabilities, sizeof(struct __tds__GetDot11Capabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Capabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Capabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", &a->tds__GetDot11Capabilities, ""))
				{	soap_flag_tds__GetDot11Capabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot11Capabilities * SOAP_FMAC2 soap_dup___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *d, struct __tds__GetDot11Capabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDot11Capabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDot11Capabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDot11Capabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDot11Capabilities(soap, &d->tds__GetDot11Capabilities, &a->tds__GetDot11Capabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDot11Capabilities(struct __tds__GetDot11Capabilities const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDot11Capabilities(&a->tds__GetDot11Capabilities);
}

SOAP_FMAC1 struct __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot11Capabilities *p;
	size_t k = sizeof(struct __tds__GetDot11Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot11Capabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot11Capabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot11Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot11Capabilities(soap, tag ? tag : "-tds:GetDot11Capabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_get___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(soap, &a->tds__DeleteDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", -1, &a->tds__DeleteDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__DeleteDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteDot1XConfiguration, sizeof(struct __tds__DeleteDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", &a->tds__DeleteDot1XConfiguration, ""))
				{	soap_flag_tds__DeleteDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_dup___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *d, struct __tds__DeleteDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__DeleteDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__DeleteDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__DeleteDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__DeleteDot1XConfiguration(soap, &d->tds__DeleteDot1XConfiguration, &a->tds__DeleteDot1XConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__DeleteDot1XConfiguration(struct __tds__DeleteDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__DeleteDot1XConfiguration(&a->tds__DeleteDot1XConfiguration);
}

SOAP_FMAC1 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__DeleteDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteDot1XConfiguration(soap, tag ? tag : "-tds:DeleteDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot1XConfigurations(soap, &a->tds__GetDot1XConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", -1, &a->tds__GetDot1XConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct __tds__GetDot1XConfigurations *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot1XConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfigurations, sizeof(struct __tds__GetDot1XConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", &a->tds__GetDot1XConfigurations, ""))
				{	soap_flag_tds__GetDot1XConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_dup___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *d, struct __tds__GetDot1XConfigurations const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDot1XConfigurations*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDot1XConfigurations, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDot1XConfigurations(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDot1XConfigurations(soap, &d->tds__GetDot1XConfigurations, &a->tds__GetDot1XConfigurations);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDot1XConfigurations(struct __tds__GetDot1XConfigurations const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDot1XConfigurations(&a->tds__GetDot1XConfigurations);
}

SOAP_FMAC1 struct __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot1XConfigurations *p;
	size_t k = sizeof(struct __tds__GetDot1XConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot1XConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot1XConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot1XConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot1XConfigurations(soap, tag ? tag : "-tds:GetDot1XConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDot1XConfiguration(soap, &a->tds__GetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", -1, &a->tds__GetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfiguration, sizeof(struct __tds__GetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", &a->tds__GetDot1XConfiguration, ""))
				{	soap_flag_tds__GetDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_dup___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *d, struct __tds__GetDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDot1XConfiguration(soap, &d->tds__GetDot1XConfiguration, &a->tds__GetDot1XConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDot1XConfiguration(struct __tds__GetDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDot1XConfiguration(&a->tds__GetDot1XConfiguration);
}

SOAP_FMAC1 struct __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__GetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDot1XConfiguration(soap, tag ? tag : "-tds:GetDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDot1XConfiguration(soap, &a->tds__SetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", -1, &a->tds__SetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDot1XConfiguration, sizeof(struct __tds__SetDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", &a->tds__SetDot1XConfiguration, ""))
				{	soap_flag_tds__SetDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_dup___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *d, struct __tds__SetDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetDot1XConfiguration(soap, &d->tds__SetDot1XConfiguration, &a->tds__SetDot1XConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetDot1XConfiguration(struct __tds__SetDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetDot1XConfiguration(&a->tds__SetDot1XConfiguration);
}

SOAP_FMAC1 struct __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__SetDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDot1XConfiguration(soap, tag ? tag : "-tds:SetDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateDot1XConfiguration(soap, &a->tds__CreateDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", -1, &a->tds__CreateDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__CreateDot1XConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateDot1XConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateDot1XConfiguration, sizeof(struct __tds__CreateDot1XConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", &a->tds__CreateDot1XConfiguration, ""))
				{	soap_flag_tds__CreateDot1XConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_dup___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *d, struct __tds__CreateDot1XConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__CreateDot1XConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__CreateDot1XConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__CreateDot1XConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__CreateDot1XConfiguration(soap, &d->tds__CreateDot1XConfiguration, &a->tds__CreateDot1XConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__CreateDot1XConfiguration(struct __tds__CreateDot1XConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__CreateDot1XConfiguration(&a->tds__CreateDot1XConfiguration);
}

SOAP_FMAC1 struct __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateDot1XConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateDot1XConfiguration *p;
	size_t k = sizeof(struct __tds__CreateDot1XConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateDot1XConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateDot1XConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateDot1XConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateDot1XConfiguration(soap, tag ? tag : "-tds:CreateDot1XConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCACertificates(soap, &a->tds__LoadCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", -1, &a->tds__LoadCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_in___tds__LoadCACertificates(struct soap *soap, const char *tag, struct __tds__LoadCACertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCACertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCACertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCACertificates, sizeof(struct __tds__LoadCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCACertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", &a->tds__LoadCACertificates, ""))
				{	soap_flag_tds__LoadCACertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCACertificates * SOAP_FMAC2 soap_dup___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *d, struct __tds__LoadCACertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__LoadCACertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__LoadCACertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__LoadCACertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__LoadCACertificates(soap, &d->tds__LoadCACertificates, &a->tds__LoadCACertificates);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__LoadCACertificates(struct __tds__LoadCACertificates const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__LoadCACertificates(&a->tds__LoadCACertificates);
}

SOAP_FMAC1 struct __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCACertificates *p;
	size_t k = sizeof(struct __tds__LoadCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCACertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCACertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCACertificates(soap, tag ? tag : "-tds:LoadCACertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_get___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificateInformation(soap, &a->tds__GetCertificateInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", -1, &a->tds__GetCertificateInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_in___tds__GetCertificateInformation(struct soap *soap, const char *tag, struct __tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_tds__GetCertificateInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificateInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificateInformation, sizeof(struct __tds__GetCertificateInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificateInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificateInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", &a->tds__GetCertificateInformation, ""))
				{	soap_flag_tds__GetCertificateInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificateInformation * SOAP_FMAC2 soap_dup___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *d, struct __tds__GetCertificateInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetCertificateInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetCertificateInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetCertificateInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetCertificateInformation(soap, &d->tds__GetCertificateInformation, &a->tds__GetCertificateInformation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetCertificateInformation(struct __tds__GetCertificateInformation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetCertificateInformation(&a->tds__GetCertificateInformation);
}

SOAP_FMAC1 struct __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificateInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificateInformation *p;
	size_t k = sizeof(struct __tds__GetCertificateInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificateInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificateInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificateInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificateInformation(soap, tag ? tag : "-tds:GetCertificateInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_get___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(soap, &a->tds__LoadCertificateWithPrivateKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", -1, &a->tds__LoadCertificateWithPrivateKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificateWithPrivateKey = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCertificateWithPrivateKey*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, sizeof(struct __tds__LoadCertificateWithPrivateKey), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificateWithPrivateKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificateWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", &a->tds__LoadCertificateWithPrivateKey, ""))
				{	soap_flag_tds__LoadCertificateWithPrivateKey--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_dup___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *d, struct __tds__LoadCertificateWithPrivateKey const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__LoadCertificateWithPrivateKey*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__LoadCertificateWithPrivateKey(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__LoadCertificateWithPrivateKey(soap, &d->tds__LoadCertificateWithPrivateKey, &a->tds__LoadCertificateWithPrivateKey);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__LoadCertificateWithPrivateKey(struct __tds__LoadCertificateWithPrivateKey const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__LoadCertificateWithPrivateKey(&a->tds__LoadCertificateWithPrivateKey);
}

SOAP_FMAC1 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificateWithPrivateKey(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCertificateWithPrivateKey *p;
	size_t k = sizeof(struct __tds__LoadCertificateWithPrivateKey);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCertificateWithPrivateKey);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCertificateWithPrivateKey, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCertificateWithPrivateKey location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCertificateWithPrivateKey(soap, tag ? tag : "-tds:LoadCertificateWithPrivateKey", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCACertificates(soap, &a->tds__GetCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", -1, &a->tds__GetCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_in___tds__GetCACertificates(struct soap *soap, const char *tag, struct __tds__GetCACertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCACertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCACertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCACertificates, sizeof(struct __tds__GetCACertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCACertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", &a->tds__GetCACertificates, ""))
				{	soap_flag_tds__GetCACertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCACertificates * SOAP_FMAC2 soap_dup___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *d, struct __tds__GetCACertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetCACertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetCACertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetCACertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetCACertificates(soap, &d->tds__GetCACertificates, &a->tds__GetCACertificates);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetCACertificates(struct __tds__GetCACertificates const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetCACertificates(&a->tds__GetCACertificates);
}

SOAP_FMAC1 struct __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCACertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCACertificates *p;
	size_t k = sizeof(struct __tds__GetCACertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCACertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCACertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCACertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCACertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCACertificates(soap, tag ? tag : "-tds:GetCACertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_get___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SendAuxiliaryCommand(soap, &a->tds__SendAuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", -1, &a->tds__SendAuxiliaryCommand, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tds__SendAuxiliaryCommand = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SendAuxiliaryCommand*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SendAuxiliaryCommand, sizeof(struct __tds__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SendAuxiliaryCommand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", &a->tds__SendAuxiliaryCommand, ""))
				{	soap_flag_tds__SendAuxiliaryCommand--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_dup___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *d, struct __tds__SendAuxiliaryCommand const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SendAuxiliaryCommand*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SendAuxiliaryCommand, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SendAuxiliaryCommand(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SendAuxiliaryCommand(soap, &d->tds__SendAuxiliaryCommand, &a->tds__SendAuxiliaryCommand);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SendAuxiliaryCommand(struct __tds__SendAuxiliaryCommand const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SendAuxiliaryCommand(&a->tds__SendAuxiliaryCommand);
}

SOAP_FMAC1 struct __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SendAuxiliaryCommand *p;
	size_t k = sizeof(struct __tds__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SendAuxiliaryCommand);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SendAuxiliaryCommand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out___tds__SendAuxiliaryCommand(soap, tag ? tag : "-tds:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRelayOutputState(soap, &a->tds__SetRelayOutputState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", -1, &a->tds__SetRelayOutputState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_in___tds__SetRelayOutputState(struct soap *soap, const char *tag, struct __tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputState = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRelayOutputState*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputState, sizeof(struct __tds__SetRelayOutputState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", &a->tds__SetRelayOutputState, ""))
				{	soap_flag_tds__SetRelayOutputState--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRelayOutputState * SOAP_FMAC2 soap_dup___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *d, struct __tds__SetRelayOutputState const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetRelayOutputState*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetRelayOutputState, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetRelayOutputState(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetRelayOutputState(soap, &d->tds__SetRelayOutputState, &a->tds__SetRelayOutputState);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetRelayOutputState(struct __tds__SetRelayOutputState const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetRelayOutputState(&a->tds__SetRelayOutputState);
}

SOAP_FMAC1 struct __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputState(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRelayOutputState *p;
	size_t k = sizeof(struct __tds__SetRelayOutputState);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRelayOutputState);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRelayOutputState, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRelayOutputState location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRelayOutputState(soap, tag ? tag : "-tds:SetRelayOutputState", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_get___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRelayOutputSettings(soap, &a->tds__SetRelayOutputSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", -1, &a->tds__SetRelayOutputSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct __tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputSettings = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRelayOutputSettings*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputSettings, sizeof(struct __tds__SetRelayOutputSettings), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", &a->tds__SetRelayOutputSettings, ""))
				{	soap_flag_tds__SetRelayOutputSettings--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_dup___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *d, struct __tds__SetRelayOutputSettings const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetRelayOutputSettings*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetRelayOutputSettings, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetRelayOutputSettings(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetRelayOutputSettings(soap, &d->tds__SetRelayOutputSettings, &a->tds__SetRelayOutputSettings);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetRelayOutputSettings(struct __tds__SetRelayOutputSettings const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetRelayOutputSettings(&a->tds__SetRelayOutputSettings);
}

SOAP_FMAC1 struct __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputSettings(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRelayOutputSettings *p;
	size_t k = sizeof(struct __tds__SetRelayOutputSettings);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRelayOutputSettings);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRelayOutputSettings, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRelayOutputSettings location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRelayOutputSettings(soap, tag ? tag : "-tds:SetRelayOutputSettings", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRelayOutputs(soap, &a->tds__GetRelayOutputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct __tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", -1, &a->tds__GetRelayOutputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_in___tds__GetRelayOutputs(struct soap *soap, const char *tag, struct __tds__GetRelayOutputs *a, const char *type)
{
	size_t soap_flag_tds__GetRelayOutputs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRelayOutputs*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRelayOutputs, sizeof(struct __tds__GetRelayOutputs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRelayOutputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", &a->tds__GetRelayOutputs, ""))
				{	soap_flag_tds__GetRelayOutputs--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRelayOutputs * SOAP_FMAC2 soap_dup___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *d, struct __tds__GetRelayOutputs const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetRelayOutputs*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetRelayOutputs, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetRelayOutputs(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetRelayOutputs(soap, &d->tds__GetRelayOutputs, &a->tds__GetRelayOutputs);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetRelayOutputs(struct __tds__GetRelayOutputs const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetRelayOutputs(&a->tds__GetRelayOutputs);
}

SOAP_FMAC1 struct __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRelayOutputs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRelayOutputs *p;
	size_t k = sizeof(struct __tds__GetRelayOutputs);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRelayOutputs);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRelayOutputs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRelayOutputs location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRelayOutputs(soap, tag ? tag : "-tds:GetRelayOutputs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_get___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetClientCertificateMode(soap, &a->tds__SetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", -1, &a->tds__SetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_in___tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__SetClientCertificateMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetClientCertificateMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetClientCertificateMode, sizeof(struct __tds__SetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", &a->tds__SetClientCertificateMode, ""))
				{	soap_flag_tds__SetClientCertificateMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetClientCertificateMode * SOAP_FMAC2 soap_dup___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *d, struct __tds__SetClientCertificateMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetClientCertificateMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetClientCertificateMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetClientCertificateMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetClientCertificateMode(soap, &d->tds__SetClientCertificateMode, &a->tds__SetClientCertificateMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetClientCertificateMode(struct __tds__SetClientCertificateMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetClientCertificateMode(&a->tds__SetClientCertificateMode);
}

SOAP_FMAC1 struct __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetClientCertificateMode *p;
	size_t k = sizeof(struct __tds__SetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetClientCertificateMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetClientCertificateMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetClientCertificateMode(soap, tag ? tag : "-tds:SetClientCertificateMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_get___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetClientCertificateMode(soap, &a->tds__GetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", -1, &a->tds__GetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_in___tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__GetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__GetClientCertificateMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetClientCertificateMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetClientCertificateMode, sizeof(struct __tds__GetClientCertificateMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", &a->tds__GetClientCertificateMode, ""))
				{	soap_flag_tds__GetClientCertificateMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetClientCertificateMode * SOAP_FMAC2 soap_dup___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *d, struct __tds__GetClientCertificateMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetClientCertificateMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetClientCertificateMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetClientCertificateMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetClientCertificateMode(soap, &d->tds__GetClientCertificateMode, &a->tds__GetClientCertificateMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetClientCertificateMode(struct __tds__GetClientCertificateMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetClientCertificateMode(&a->tds__GetClientCertificateMode);
}

SOAP_FMAC1 struct __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetClientCertificateMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetClientCertificateMode *p;
	size_t k = sizeof(struct __tds__GetClientCertificateMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetClientCertificateMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetClientCertificateMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetClientCertificateMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetClientCertificateMode(soap, tag ? tag : "-tds:GetClientCertificateMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_get___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__LoadCertificates(soap, &a->tds__LoadCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", -1, &a->tds__LoadCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_in___tds__LoadCertificates(struct soap *soap, const char *tag, struct __tds__LoadCertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__LoadCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificates, sizeof(struct __tds__LoadCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", &a->tds__LoadCertificates, ""))
				{	soap_flag_tds__LoadCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__LoadCertificates * SOAP_FMAC2 soap_dup___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *d, struct __tds__LoadCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__LoadCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__LoadCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__LoadCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__LoadCertificates(soap, &d->tds__LoadCertificates, &a->tds__LoadCertificates);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__LoadCertificates(struct __tds__LoadCertificates const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__LoadCertificates(&a->tds__LoadCertificates);
}

SOAP_FMAC1 struct __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__LoadCertificates *p;
	size_t k = sizeof(struct __tds__LoadCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__LoadCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__LoadCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__LoadCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__LoadCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__LoadCertificates(soap, tag ? tag : "-tds:LoadCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_get___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPkcs10Request(soap, &a->tds__GetPkcs10Request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct __tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", -1, &a->tds__GetPkcs10Request, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_in___tds__GetPkcs10Request(struct soap *soap, const char *tag, struct __tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_tds__GetPkcs10Request = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPkcs10Request*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPkcs10Request, sizeof(struct __tds__GetPkcs10Request), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPkcs10Request(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPkcs10Request && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", &a->tds__GetPkcs10Request, ""))
				{	soap_flag_tds__GetPkcs10Request--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPkcs10Request * SOAP_FMAC2 soap_dup___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *d, struct __tds__GetPkcs10Request const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetPkcs10Request*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetPkcs10Request, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetPkcs10Request(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetPkcs10Request(soap, &d->tds__GetPkcs10Request, &a->tds__GetPkcs10Request);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetPkcs10Request(struct __tds__GetPkcs10Request const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetPkcs10Request(&a->tds__GetPkcs10Request);
}

SOAP_FMAC1 struct __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPkcs10Request(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPkcs10Request *p;
	size_t k = sizeof(struct __tds__GetPkcs10Request);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPkcs10Request);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPkcs10Request, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPkcs10Request location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPkcs10Request(soap, tag ? tag : "-tds:GetPkcs10Request", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_get___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteCertificates(soap, &a->tds__DeleteCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct __tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", -1, &a->tds__DeleteCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_in___tds__DeleteCertificates(struct soap *soap, const char *tag, struct __tds__DeleteCertificates *a, const char *type)
{
	size_t soap_flag_tds__DeleteCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteCertificates, sizeof(struct __tds__DeleteCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", &a->tds__DeleteCertificates, ""))
				{	soap_flag_tds__DeleteCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteCertificates * SOAP_FMAC2 soap_dup___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *d, struct __tds__DeleteCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__DeleteCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__DeleteCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__DeleteCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__DeleteCertificates(soap, &d->tds__DeleteCertificates, &a->tds__DeleteCertificates);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__DeleteCertificates(struct __tds__DeleteCertificates const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__DeleteCertificates(&a->tds__DeleteCertificates);
}

SOAP_FMAC1 struct __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteCertificates *p;
	size_t k = sizeof(struct __tds__DeleteCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteCertificates(soap, tag ? tag : "-tds:DeleteCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_get___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetCertificatesStatus(soap, &a->tds__SetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", -1, &a->tds__SetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_in___tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__SetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__SetCertificatesStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetCertificatesStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetCertificatesStatus, sizeof(struct __tds__SetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", &a->tds__SetCertificatesStatus, ""))
				{	soap_flag_tds__SetCertificatesStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetCertificatesStatus * SOAP_FMAC2 soap_dup___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *d, struct __tds__SetCertificatesStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetCertificatesStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetCertificatesStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetCertificatesStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetCertificatesStatus(soap, &d->tds__SetCertificatesStatus, &a->tds__SetCertificatesStatus);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetCertificatesStatus(struct __tds__SetCertificatesStatus const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetCertificatesStatus(&a->tds__SetCertificatesStatus);
}

SOAP_FMAC1 struct __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetCertificatesStatus *p;
	size_t k = sizeof(struct __tds__SetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetCertificatesStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetCertificatesStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetCertificatesStatus(soap, tag ? tag : "-tds:SetCertificatesStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_get___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificatesStatus(soap, &a->tds__GetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", -1, &a->tds__GetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_in___tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__GetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__GetCertificatesStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificatesStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificatesStatus, sizeof(struct __tds__GetCertificatesStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", &a->tds__GetCertificatesStatus, ""))
				{	soap_flag_tds__GetCertificatesStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificatesStatus * SOAP_FMAC2 soap_dup___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *d, struct __tds__GetCertificatesStatus const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetCertificatesStatus*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetCertificatesStatus, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetCertificatesStatus(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetCertificatesStatus(soap, &d->tds__GetCertificatesStatus, &a->tds__GetCertificatesStatus);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetCertificatesStatus(struct __tds__GetCertificatesStatus const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetCertificatesStatus(&a->tds__GetCertificatesStatus);
}

SOAP_FMAC1 struct __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificatesStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificatesStatus *p;
	size_t k = sizeof(struct __tds__GetCertificatesStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificatesStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificatesStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificatesStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificatesStatus(soap, tag ? tag : "-tds:GetCertificatesStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_get___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCertificates(soap, &a->tds__GetCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", -1, &a->tds__GetCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_in___tds__GetCertificates(struct soap *soap, const char *tag, struct __tds__GetCertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCertificates = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCertificates*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificates, sizeof(struct __tds__GetCertificates), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificates && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", &a->tds__GetCertificates, ""))
				{	soap_flag_tds__GetCertificates--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCertificates * SOAP_FMAC2 soap_dup___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *d, struct __tds__GetCertificates const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetCertificates*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetCertificates, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetCertificates(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetCertificates(soap, &d->tds__GetCertificates, &a->tds__GetCertificates);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetCertificates(struct __tds__GetCertificates const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetCertificates(&a->tds__GetCertificates);
}

SOAP_FMAC1 struct __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificates(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCertificates *p;
	size_t k = sizeof(struct __tds__GetCertificates);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCertificates, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCertificates);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCertificates, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCertificates location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCertificates(soap, tag ? tag : "-tds:GetCertificates", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_get___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateCertificate(soap, &a->tds__CreateCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct __tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", -1, &a->tds__CreateCertificate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_in___tds__CreateCertificate(struct soap *soap, const char *tag, struct __tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_tds__CreateCertificate = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateCertificate*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateCertificate, sizeof(struct __tds__CreateCertificate), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateCertificate && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", &a->tds__CreateCertificate, ""))
				{	soap_flag_tds__CreateCertificate--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateCertificate * SOAP_FMAC2 soap_dup___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *d, struct __tds__CreateCertificate const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__CreateCertificate*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__CreateCertificate, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__CreateCertificate(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__CreateCertificate(soap, &d->tds__CreateCertificate, &a->tds__CreateCertificate);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__CreateCertificate(struct __tds__CreateCertificate const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__CreateCertificate(&a->tds__CreateCertificate);
}

SOAP_FMAC1 struct __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateCertificate(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateCertificate *p;
	size_t k = sizeof(struct __tds__CreateCertificate);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateCertificate, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateCertificate);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateCertificate, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateCertificate location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateCertificate(soap, tag ? tag : "-tds:CreateCertificate", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_get___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetAccessPolicy(soap, &a->tds__SetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", -1, &a->tds__SetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_in___tds__SetAccessPolicy(struct soap *soap, const char *tag, struct __tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__SetAccessPolicy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetAccessPolicy*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetAccessPolicy, sizeof(struct __tds__SetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", &a->tds__SetAccessPolicy, ""))
				{	soap_flag_tds__SetAccessPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetAccessPolicy * SOAP_FMAC2 soap_dup___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *d, struct __tds__SetAccessPolicy const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetAccessPolicy*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetAccessPolicy, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetAccessPolicy(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetAccessPolicy(soap, &d->tds__SetAccessPolicy, &a->tds__SetAccessPolicy);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetAccessPolicy(struct __tds__SetAccessPolicy const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetAccessPolicy(&a->tds__SetAccessPolicy);
}

SOAP_FMAC1 struct __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetAccessPolicy *p;
	size_t k = sizeof(struct __tds__SetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetAccessPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetAccessPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetAccessPolicy(soap, tag ? tag : "-tds:SetAccessPolicy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_get___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAccessPolicy(soap, &a->tds__GetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", -1, &a->tds__GetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_in___tds__GetAccessPolicy(struct soap *soap, const char *tag, struct __tds__GetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__GetAccessPolicy = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAccessPolicy*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAccessPolicy, sizeof(struct __tds__GetAccessPolicy), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", &a->tds__GetAccessPolicy, ""))
				{	soap_flag_tds__GetAccessPolicy--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAccessPolicy * SOAP_FMAC2 soap_dup___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *d, struct __tds__GetAccessPolicy const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetAccessPolicy*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetAccessPolicy, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetAccessPolicy(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetAccessPolicy(soap, &d->tds__GetAccessPolicy, &a->tds__GetAccessPolicy);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetAccessPolicy(struct __tds__GetAccessPolicy const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetAccessPolicy(&a->tds__GetAccessPolicy);
}

SOAP_FMAC1 struct __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAccessPolicy(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAccessPolicy *p;
	size_t k = sizeof(struct __tds__GetAccessPolicy);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAccessPolicy);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAccessPolicy, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAccessPolicy location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAccessPolicy(soap, tag ? tag : "-tds:GetAccessPolicy", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_get___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveIPAddressFilter(soap, &a->tds__RemoveIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", -1, &a->tds__RemoveIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__RemoveIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveIPAddressFilter, sizeof(struct __tds__RemoveIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", &a->tds__RemoveIPAddressFilter, ""))
				{	soap_flag_tds__RemoveIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_dup___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *d, struct __tds__RemoveIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__RemoveIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__RemoveIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__RemoveIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__RemoveIPAddressFilter(soap, &d->tds__RemoveIPAddressFilter, &a->tds__RemoveIPAddressFilter);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__RemoveIPAddressFilter(struct __tds__RemoveIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__RemoveIPAddressFilter(&a->tds__RemoveIPAddressFilter);
}

SOAP_FMAC1 struct __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RemoveIPAddressFilter *p;
	size_t k = sizeof(struct __tds__RemoveIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RemoveIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RemoveIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RemoveIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveIPAddressFilter(soap, tag ? tag : "-tds:RemoveIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddIPAddressFilter(soap, &a->tds__AddIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", -1, &a->tds__AddIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_in___tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct __tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__AddIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddIPAddressFilter, sizeof(struct __tds__AddIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", &a->tds__AddIPAddressFilter, ""))
				{	soap_flag_tds__AddIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__AddIPAddressFilter * SOAP_FMAC2 soap_dup___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *d, struct __tds__AddIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__AddIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__AddIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__AddIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__AddIPAddressFilter(soap, &d->tds__AddIPAddressFilter, &a->tds__AddIPAddressFilter);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__AddIPAddressFilter(struct __tds__AddIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__AddIPAddressFilter(&a->tds__AddIPAddressFilter);
}

SOAP_FMAC1 struct __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__AddIPAddressFilter *p;
	size_t k = sizeof(struct __tds__AddIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__AddIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__AddIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__AddIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddIPAddressFilter(soap, tag ? tag : "-tds:AddIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_get___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetIPAddressFilter(soap, &a->tds__SetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", -1, &a->tds__SetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_in___tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__SetIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetIPAddressFilter, sizeof(struct __tds__SetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", &a->tds__SetIPAddressFilter, ""))
				{	soap_flag_tds__SetIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetIPAddressFilter * SOAP_FMAC2 soap_dup___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *d, struct __tds__SetIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetIPAddressFilter(soap, &d->tds__SetIPAddressFilter, &a->tds__SetIPAddressFilter);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetIPAddressFilter(struct __tds__SetIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetIPAddressFilter(&a->tds__SetIPAddressFilter);
}

SOAP_FMAC1 struct __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetIPAddressFilter *p;
	size_t k = sizeof(struct __tds__SetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetIPAddressFilter(soap, tag ? tag : "-tds:SetIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_get___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetIPAddressFilter(soap, &a->tds__GetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", -1, &a->tds__GetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_in___tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__GetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__GetIPAddressFilter = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetIPAddressFilter*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetIPAddressFilter, sizeof(struct __tds__GetIPAddressFilter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", &a->tds__GetIPAddressFilter, ""))
				{	soap_flag_tds__GetIPAddressFilter--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetIPAddressFilter * SOAP_FMAC2 soap_dup___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *d, struct __tds__GetIPAddressFilter const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetIPAddressFilter*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetIPAddressFilter, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetIPAddressFilter(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetIPAddressFilter(soap, &d->tds__GetIPAddressFilter, &a->tds__GetIPAddressFilter);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetIPAddressFilter(struct __tds__GetIPAddressFilter const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetIPAddressFilter(&a->tds__GetIPAddressFilter);
}

SOAP_FMAC1 struct __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetIPAddressFilter(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetIPAddressFilter *p;
	size_t k = sizeof(struct __tds__GetIPAddressFilter);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetIPAddressFilter);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetIPAddressFilter, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetIPAddressFilter location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetIPAddressFilter(soap, tag ? tag : "-tds:GetIPAddressFilter", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_get___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetZeroConfiguration(soap, &a->tds__SetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", -1, &a->tds__SetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_in___tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__SetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetZeroConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetZeroConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetZeroConfiguration, sizeof(struct __tds__SetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", &a->tds__SetZeroConfiguration, ""))
				{	soap_flag_tds__SetZeroConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetZeroConfiguration * SOAP_FMAC2 soap_dup___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *d, struct __tds__SetZeroConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetZeroConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetZeroConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetZeroConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetZeroConfiguration(soap, &d->tds__SetZeroConfiguration, &a->tds__SetZeroConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetZeroConfiguration(struct __tds__SetZeroConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetZeroConfiguration(&a->tds__SetZeroConfiguration);
}

SOAP_FMAC1 struct __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetZeroConfiguration *p;
	size_t k = sizeof(struct __tds__SetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetZeroConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetZeroConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetZeroConfiguration(soap, tag ? tag : "-tds:SetZeroConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_get___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetZeroConfiguration(soap, &a->tds__GetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", -1, &a->tds__GetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_in___tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__GetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetZeroConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetZeroConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetZeroConfiguration, sizeof(struct __tds__GetZeroConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", &a->tds__GetZeroConfiguration, ""))
				{	soap_flag_tds__GetZeroConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetZeroConfiguration * SOAP_FMAC2 soap_dup___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *d, struct __tds__GetZeroConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetZeroConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetZeroConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetZeroConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetZeroConfiguration(soap, &d->tds__GetZeroConfiguration, &a->tds__GetZeroConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetZeroConfiguration(struct __tds__GetZeroConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetZeroConfiguration(&a->tds__GetZeroConfiguration);
}

SOAP_FMAC1 struct __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetZeroConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetZeroConfiguration *p;
	size_t k = sizeof(struct __tds__GetZeroConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetZeroConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetZeroConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetZeroConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetZeroConfiguration(soap, tag ? tag : "-tds:GetZeroConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_get___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, &a->tds__SetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", -1, &a->tds__SetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkDefaultGateway, sizeof(struct __tds__SetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", &a->tds__SetNetworkDefaultGateway, ""))
				{	soap_flag_tds__SetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_dup___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *d, struct __tds__SetNetworkDefaultGateway const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetNetworkDefaultGateway*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetNetworkDefaultGateway, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetNetworkDefaultGateway(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetNetworkDefaultGateway(soap, &d->tds__SetNetworkDefaultGateway, &a->tds__SetNetworkDefaultGateway);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetNetworkDefaultGateway(struct __tds__SetNetworkDefaultGateway const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetNetworkDefaultGateway(&a->tds__SetNetworkDefaultGateway);
}

SOAP_FMAC1 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkDefaultGateway *p;
	size_t k = sizeof(struct __tds__SetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkDefaultGateway);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkDefaultGateway, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkDefaultGateway(soap, tag ? tag : "-tds:SetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, &a->tds__GetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", -1, &a->tds__GetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkDefaultGateway = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkDefaultGateway*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkDefaultGateway, sizeof(struct __tds__GetNetworkDefaultGateway), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", &a->tds__GetNetworkDefaultGateway, ""))
				{	soap_flag_tds__GetNetworkDefaultGateway--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_dup___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *d, struct __tds__GetNetworkDefaultGateway const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetNetworkDefaultGateway*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetNetworkDefaultGateway, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetNetworkDefaultGateway(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetNetworkDefaultGateway(soap, &d->tds__GetNetworkDefaultGateway, &a->tds__GetNetworkDefaultGateway);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetNetworkDefaultGateway(struct __tds__GetNetworkDefaultGateway const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetNetworkDefaultGateway(&a->tds__GetNetworkDefaultGateway);
}

SOAP_FMAC1 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkDefaultGateway(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkDefaultGateway *p;
	size_t k = sizeof(struct __tds__GetNetworkDefaultGateway);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkDefaultGateway);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkDefaultGateway, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkDefaultGateway location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkDefaultGateway(soap, tag ? tag : "-tds:GetNetworkDefaultGateway", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, &a->tds__SetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", -1, &a->tds__SetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_in___tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__SetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkProtocols, sizeof(struct __tds__SetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", &a->tds__SetNetworkProtocols, ""))
				{	soap_flag_tds__SetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkProtocols * SOAP_FMAC2 soap_dup___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *d, struct __tds__SetNetworkProtocols const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetNetworkProtocols*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetNetworkProtocols, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetNetworkProtocols(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetNetworkProtocols(soap, &d->tds__SetNetworkProtocols, &a->tds__SetNetworkProtocols);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetNetworkProtocols(struct __tds__SetNetworkProtocols const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetNetworkProtocols(&a->tds__SetNetworkProtocols);
}

SOAP_FMAC1 struct __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkProtocols *p;
	size_t k = sizeof(struct __tds__SetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkProtocols);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkProtocols, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkProtocols(soap, tag ? tag : "-tds:SetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_get___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, &a->tds__GetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", -1, &a->tds__GetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_in___tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__GetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkProtocols = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkProtocols*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkProtocols, sizeof(struct __tds__GetNetworkProtocols), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", &a->tds__GetNetworkProtocols, ""))
				{	soap_flag_tds__GetNetworkProtocols--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkProtocols * SOAP_FMAC2 soap_dup___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *d, struct __tds__GetNetworkProtocols const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetNetworkProtocols*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetNetworkProtocols, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetNetworkProtocols(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetNetworkProtocols(soap, &d->tds__GetNetworkProtocols, &a->tds__GetNetworkProtocols);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetNetworkProtocols(struct __tds__GetNetworkProtocols const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetNetworkProtocols(&a->tds__GetNetworkProtocols);
}

SOAP_FMAC1 struct __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkProtocols(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkProtocols *p;
	size_t k = sizeof(struct __tds__GetNetworkProtocols);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkProtocols);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkProtocols, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkProtocols location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkProtocols(soap, tag ? tag : "-tds:GetNetworkProtocols", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_get___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, &a->tds__SetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", -1, &a->tds__SetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkInterfaces, sizeof(struct __tds__SetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", &a->tds__SetNetworkInterfaces, ""))
				{	soap_flag_tds__SetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_dup___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *d, struct __tds__SetNetworkInterfaces const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetNetworkInterfaces*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetNetworkInterfaces, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetNetworkInterfaces(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetNetworkInterfaces(soap, &d->tds__SetNetworkInterfaces, &a->tds__SetNetworkInterfaces);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetNetworkInterfaces(struct __tds__SetNetworkInterfaces const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetNetworkInterfaces(&a->tds__SetNetworkInterfaces);
}

SOAP_FMAC1 struct __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNetworkInterfaces *p;
	size_t k = sizeof(struct __tds__SetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNetworkInterfaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNetworkInterfaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNetworkInterfaces(soap, tag ? tag : "-tds:SetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, &a->tds__GetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", -1, &a->tds__GetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__GetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkInterfaces = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNetworkInterfaces*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkInterfaces, sizeof(struct __tds__GetNetworkInterfaces), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", &a->tds__GetNetworkInterfaces, ""))
				{	soap_flag_tds__GetNetworkInterfaces--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_dup___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *d, struct __tds__GetNetworkInterfaces const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetNetworkInterfaces*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetNetworkInterfaces, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetNetworkInterfaces(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetNetworkInterfaces(soap, &d->tds__GetNetworkInterfaces, &a->tds__GetNetworkInterfaces);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetNetworkInterfaces(struct __tds__GetNetworkInterfaces const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetNetworkInterfaces(&a->tds__GetNetworkInterfaces);
}

SOAP_FMAC1 struct __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkInterfaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNetworkInterfaces *p;
	size_t k = sizeof(struct __tds__GetNetworkInterfaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNetworkInterfaces);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNetworkInterfaces, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNetworkInterfaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNetworkInterfaces(soap, tag ? tag : "-tds:GetNetworkInterfaces", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDynamicDNS(soap, &a->tds__SetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", -1, &a->tds__SetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_in___tds__SetDynamicDNS(struct soap *soap, const char *tag, struct __tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDynamicDNS, sizeof(struct __tds__SetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", &a->tds__SetDynamicDNS, ""))
				{	soap_flag_tds__SetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDynamicDNS * SOAP_FMAC2 soap_dup___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *d, struct __tds__SetDynamicDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetDynamicDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetDynamicDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetDynamicDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetDynamicDNS(soap, &d->tds__SetDynamicDNS, &a->tds__SetDynamicDNS);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetDynamicDNS(struct __tds__SetDynamicDNS const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetDynamicDNS(&a->tds__SetDynamicDNS);
}

SOAP_FMAC1 struct __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDynamicDNS *p;
	size_t k = sizeof(struct __tds__SetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDynamicDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDynamicDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDynamicDNS(soap, tag ? tag : "-tds:SetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_get___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDynamicDNS(soap, &a->tds__GetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", -1, &a->tds__GetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_in___tds__GetDynamicDNS(struct soap *soap, const char *tag, struct __tds__GetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDynamicDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDynamicDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDynamicDNS, sizeof(struct __tds__GetDynamicDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", &a->tds__GetDynamicDNS, ""))
				{	soap_flag_tds__GetDynamicDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDynamicDNS * SOAP_FMAC2 soap_dup___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *d, struct __tds__GetDynamicDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDynamicDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDynamicDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDynamicDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDynamicDNS(soap, &d->tds__GetDynamicDNS, &a->tds__GetDynamicDNS);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDynamicDNS(struct __tds__GetDynamicDNS const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDynamicDNS(&a->tds__GetDynamicDNS);
}

SOAP_FMAC1 struct __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDynamicDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDynamicDNS *p;
	size_t k = sizeof(struct __tds__GetDynamicDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDynamicDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDynamicDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDynamicDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDynamicDNS(soap, tag ? tag : "-tds:GetDynamicDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_get___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetNTP(soap, &a->tds__SetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNTP(struct soap *soap, const char *tag, int id, const struct __tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetNTP(soap, "tds:SetNTP", -1, &a->tds__SetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_in___tds__SetNTP(struct soap *soap, const char *tag, struct __tds__SetNTP *a, const char *type)
{
	size_t soap_flag_tds__SetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNTP, sizeof(struct __tds__SetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetNTP(soap, "tds:SetNTP", &a->tds__SetNTP, ""))
				{	soap_flag_tds__SetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetNTP * SOAP_FMAC2 soap_dup___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *d, struct __tds__SetNTP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetNTP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetNTP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetNTP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetNTP(soap, &d->tds__SetNTP, &a->tds__SetNTP);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetNTP(struct __tds__SetNTP const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetNTP(&a->tds__SetNTP);
}

SOAP_FMAC1 struct __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetNTP *p;
	size_t k = sizeof(struct __tds__SetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetNTP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetNTP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetNTP(soap, tag ? tag : "-tds:SetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_get___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetNTP(soap, &a->tds__GetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNTP(struct soap *soap, const char *tag, int id, const struct __tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetNTP(soap, "tds:GetNTP", -1, &a->tds__GetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_in___tds__GetNTP(struct soap *soap, const char *tag, struct __tds__GetNTP *a, const char *type)
{
	size_t soap_flag_tds__GetNTP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetNTP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNTP, sizeof(struct __tds__GetNTP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetNTP(soap, "tds:GetNTP", &a->tds__GetNTP, ""))
				{	soap_flag_tds__GetNTP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetNTP * SOAP_FMAC2 soap_dup___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *d, struct __tds__GetNTP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetNTP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetNTP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetNTP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetNTP(soap, &d->tds__GetNTP, &a->tds__GetNTP);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetNTP(struct __tds__GetNTP const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetNTP(&a->tds__GetNTP);
}

SOAP_FMAC1 struct __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNTP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetNTP *p;
	size_t k = sizeof(struct __tds__GetNTP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetNTP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetNTP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetNTP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetNTP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetNTP(soap, tag ? tag : "-tds:GetNTP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_get___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDNS(soap, &a->tds__SetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDNS(soap, "tds:SetDNS", -1, &a->tds__SetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_in___tds__SetDNS(struct soap *soap, const char *tag, struct __tds__SetDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDNS, sizeof(struct __tds__SetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDNS(soap, "tds:SetDNS", &a->tds__SetDNS, ""))
				{	soap_flag_tds__SetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDNS * SOAP_FMAC2 soap_dup___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *d, struct __tds__SetDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetDNS(soap, &d->tds__SetDNS, &a->tds__SetDNS);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetDNS(struct __tds__SetDNS const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetDNS(&a->tds__SetDNS);
}

SOAP_FMAC1 struct __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDNS *p;
	size_t k = sizeof(struct __tds__SetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDNS(soap, tag ? tag : "-tds:SetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_get___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDNS*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
				{	soap_flag_tds__GetDNS--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDNS * SOAP_FMAC2 soap_dup___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *d, struct __tds__GetDNS const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDNS*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDNS, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDNS(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDNS(soap, &d->tds__GetDNS, &a->tds__GetDNS);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDNS(struct __tds__GetDNS const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDNS(&a->tds__GetDNS);
}

SOAP_FMAC1 struct __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDNS(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDNS *p;
	size_t k = sizeof(struct __tds__GetDNS);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDNS, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDNS);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDNS, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDNS location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDNS(soap, tag ? tag : "-tds:GetDNS", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostnameFromDHCP*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
				{	soap_flag_tds__SetHostnameFromDHCP--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_dup___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *d, struct __tds__SetHostnameFromDHCP const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetHostnameFromDHCP*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetHostnameFromDHCP, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetHostnameFromDHCP(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetHostnameFromDHCP(soap, &d->tds__SetHostnameFromDHCP, &a->tds__SetHostnameFromDHCP);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetHostnameFromDHCP(struct __tds__SetHostnameFromDHCP const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetHostnameFromDHCP(&a->tds__SetHostnameFromDHCP);
}

SOAP_FMAC1 struct __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostnameFromDHCP(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHostnameFromDHCP *p;
	size_t k = sizeof(struct __tds__SetHostnameFromDHCP);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHostnameFromDHCP);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHostnameFromDHCP, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHostnameFromDHCP location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag ? tag : "-tds:SetHostnameFromDHCP", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
				{	soap_flag_tds__SetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetHostname * SOAP_FMAC2 soap_dup___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *d, struct __tds__SetHostname const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetHostname*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetHostname, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetHostname(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetHostname(soap, &d->tds__SetHostname, &a->tds__SetHostname);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetHostname(struct __tds__SetHostname const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetHostname(&a->tds__SetHostname);
}

SOAP_FMAC1 struct __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetHostname *p;
	size_t k = sizeof(struct __tds__SetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetHostname);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetHostname, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetHostname(soap, tag ? tag : "-tds:SetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetHostname*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
				{	soap_flag_tds__GetHostname--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetHostname * SOAP_FMAC2 soap_dup___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *d, struct __tds__GetHostname const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetHostname*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetHostname, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetHostname(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetHostname(soap, &d->tds__GetHostname, &a->tds__GetHostname);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetHostname(struct __tds__GetHostname const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetHostname(&a->tds__GetHostname);
}

SOAP_FMAC1 struct __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetHostname(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetHostname *p;
	size_t k = sizeof(struct __tds__GetHostname);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetHostname, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetHostname);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetHostname, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetHostname location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetHostname(soap, tag ? tag : "-tds:GetHostname", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDPAddresses(soap, &a->tds__SetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", -1, &a->tds__SetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_in___tds__SetDPAddresses(struct soap *soap, const char *tag, struct __tds__SetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__SetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDPAddresses, sizeof(struct __tds__SetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", &a->tds__SetDPAddresses, ""))
				{	soap_flag_tds__SetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDPAddresses * SOAP_FMAC2 soap_dup___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *d, struct __tds__SetDPAddresses const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetDPAddresses*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetDPAddresses, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetDPAddresses(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetDPAddresses(soap, &d->tds__SetDPAddresses, &a->tds__SetDPAddresses);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetDPAddresses(struct __tds__SetDPAddresses const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetDPAddresses(&a->tds__SetDPAddresses);
}

SOAP_FMAC1 struct __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDPAddresses *p;
	size_t k = sizeof(struct __tds__SetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDPAddresses);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDPAddresses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDPAddresses(soap, tag ? tag : "-tds:SetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_get___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetCapabilities * SOAP_FMAC2 soap_dup___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *d, struct __tds__GetCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetCapabilities(soap, &d->tds__GetCapabilities, &a->tds__GetCapabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetCapabilities(struct __tds__GetCapabilities const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetCapabilities(&a->tds__GetCapabilities);
}

SOAP_FMAC1 struct __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetCapabilities *p;
	size_t k = sizeof(struct __tds__GetCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetCapabilities(soap, tag ? tag : "-tds:GetCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__SetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetAuthFailureWarningConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__SetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, &a->tds__SetAuthFailureWarningConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, "tds:SetAuthFailureWarningConfiguration", -1, &a->tds__SetAuthFailureWarningConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, struct __tds__SetAuthFailureWarningConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetAuthFailureWarningConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetAuthFailureWarningConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetAuthFailureWarningConfiguration, sizeof(struct __tds__SetAuthFailureWarningConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetAuthFailureWarningConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetAuthFailureWarningConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, "tds:SetAuthFailureWarningConfiguration", &a->tds__SetAuthFailureWarningConfiguration, ""))
				{	soap_flag_tds__SetAuthFailureWarningConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_dup___tds__SetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__SetAuthFailureWarningConfiguration *d, struct __tds__SetAuthFailureWarningConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetAuthFailureWarningConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetAuthFailureWarningConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetAuthFailureWarningConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetAuthFailureWarningConfiguration(soap, &d->tds__SetAuthFailureWarningConfiguration, &a->tds__SetAuthFailureWarningConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetAuthFailureWarningConfiguration(struct __tds__SetAuthFailureWarningConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetAuthFailureWarningConfiguration(&a->tds__SetAuthFailureWarningConfiguration);
}

SOAP_FMAC1 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(struct __tds__SetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetAuthFailureWarningConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetAuthFailureWarningConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__SetAuthFailureWarningConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetAuthFailureWarningConfiguration(soap, tag ? tag : "-tds:SetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get___tds__SetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__SetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__GetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAuthFailureWarningConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__GetAuthFailureWarningConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, &a->tds__GetAuthFailureWarningConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, "tds:GetAuthFailureWarningConfiguration", -1, &a->tds__GetAuthFailureWarningConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_in___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const char *tag, struct __tds__GetAuthFailureWarningConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetAuthFailureWarningConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAuthFailureWarningConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAuthFailureWarningConfiguration, sizeof(struct __tds__GetAuthFailureWarningConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAuthFailureWarningConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAuthFailureWarningConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, "tds:GetAuthFailureWarningConfiguration", &a->tds__GetAuthFailureWarningConfiguration, ""))
				{	soap_flag_tds__GetAuthFailureWarningConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_dup___tds__GetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__GetAuthFailureWarningConfiguration *d, struct __tds__GetAuthFailureWarningConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetAuthFailureWarningConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetAuthFailureWarningConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetAuthFailureWarningConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetAuthFailureWarningConfiguration(soap, &d->tds__GetAuthFailureWarningConfiguration, &a->tds__GetAuthFailureWarningConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetAuthFailureWarningConfiguration(struct __tds__GetAuthFailureWarningConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetAuthFailureWarningConfiguration(&a->tds__GetAuthFailureWarningConfiguration);
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAuthFailureWarningConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAuthFailureWarningConfiguration *p;
	size_t k = sizeof(struct __tds__GetAuthFailureWarningConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAuthFailureWarningConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAuthFailureWarningConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAuthFailureWarningConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAuthFailureWarningConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAuthFailureWarningConfiguration(struct soap *soap, const struct __tds__GetAuthFailureWarningConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAuthFailureWarningConfiguration(soap, tag ? tag : "-tds:GetAuthFailureWarningConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC4 soap_get___tds__GetAuthFailureWarningConfiguration(struct soap *soap, struct __tds__GetAuthFailureWarningConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAuthFailureWarningConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAuthFailureWarningOptions(struct soap *soap, struct __tds__GetAuthFailureWarningOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAuthFailureWarningOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAuthFailureWarningOptions(struct soap *soap, const struct __tds__GetAuthFailureWarningOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetAuthFailureWarningOptions(soap, &a->tds__GetAuthFailureWarningOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, int id, const struct __tds__GetAuthFailureWarningOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetAuthFailureWarningOptions(soap, "tds:GetAuthFailureWarningOptions", -1, &a->tds__GetAuthFailureWarningOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_in___tds__GetAuthFailureWarningOptions(struct soap *soap, const char *tag, struct __tds__GetAuthFailureWarningOptions *a, const char *type)
{
	size_t soap_flag_tds__GetAuthFailureWarningOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetAuthFailureWarningOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAuthFailureWarningOptions, sizeof(struct __tds__GetAuthFailureWarningOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAuthFailureWarningOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAuthFailureWarningOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetAuthFailureWarningOptions(soap, "tds:GetAuthFailureWarningOptions", &a->tds__GetAuthFailureWarningOptions, ""))
				{	soap_flag_tds__GetAuthFailureWarningOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_dup___tds__GetAuthFailureWarningOptions(struct soap *soap, struct __tds__GetAuthFailureWarningOptions *d, struct __tds__GetAuthFailureWarningOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetAuthFailureWarningOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetAuthFailureWarningOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetAuthFailureWarningOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetAuthFailureWarningOptions(soap, &d->tds__GetAuthFailureWarningOptions, &a->tds__GetAuthFailureWarningOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetAuthFailureWarningOptions(struct __tds__GetAuthFailureWarningOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetAuthFailureWarningOptions(&a->tds__GetAuthFailureWarningOptions);
}

SOAP_FMAC1 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAuthFailureWarningOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetAuthFailureWarningOptions *p;
	size_t k = sizeof(struct __tds__GetAuthFailureWarningOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetAuthFailureWarningOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetAuthFailureWarningOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetAuthFailureWarningOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetAuthFailureWarningOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAuthFailureWarningOptions(struct soap *soap, const struct __tds__GetAuthFailureWarningOptions *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetAuthFailureWarningOptions(soap, tag ? tag : "-tds:GetAuthFailureWarningOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAuthFailureWarningOptions * SOAP_FMAC4 soap_get___tds__GetAuthFailureWarningOptions(struct soap *soap, struct __tds__GetAuthFailureWarningOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAuthFailureWarningOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetPasswordHistoryConfiguration(struct soap *soap, struct __tds__SetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetPasswordHistoryConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__SetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetPasswordHistoryConfiguration(soap, &a->tds__SetPasswordHistoryConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetPasswordHistoryConfiguration(soap, "tds:SetPasswordHistoryConfiguration", -1, &a->tds__SetPasswordHistoryConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in___tds__SetPasswordHistoryConfiguration(struct soap *soap, const char *tag, struct __tds__SetPasswordHistoryConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetPasswordHistoryConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetPasswordHistoryConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetPasswordHistoryConfiguration, sizeof(struct __tds__SetPasswordHistoryConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetPasswordHistoryConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetPasswordHistoryConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetPasswordHistoryConfiguration(soap, "tds:SetPasswordHistoryConfiguration", &a->tds__SetPasswordHistoryConfiguration, ""))
				{	soap_flag_tds__SetPasswordHistoryConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_dup___tds__SetPasswordHistoryConfiguration(struct soap *soap, struct __tds__SetPasswordHistoryConfiguration *d, struct __tds__SetPasswordHistoryConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetPasswordHistoryConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetPasswordHistoryConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetPasswordHistoryConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetPasswordHistoryConfiguration(soap, &d->tds__SetPasswordHistoryConfiguration, &a->tds__SetPasswordHistoryConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetPasswordHistoryConfiguration(struct __tds__SetPasswordHistoryConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetPasswordHistoryConfiguration(&a->tds__SetPasswordHistoryConfiguration);
}

SOAP_FMAC1 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetPasswordHistoryConfiguration *p;
	size_t k = sizeof(struct __tds__SetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetPasswordHistoryConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetPasswordHistoryConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__SetPasswordHistoryConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetPasswordHistoryConfiguration(soap, tag ? tag : "-tds:SetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get___tds__SetPasswordHistoryConfiguration(struct soap *soap, struct __tds__SetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordHistoryConfiguration(struct soap *soap, struct __tds__GetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordHistoryConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__GetPasswordHistoryConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordHistoryConfiguration(soap, &a->tds__GetPasswordHistoryConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordHistoryConfiguration(soap, "tds:GetPasswordHistoryConfiguration", -1, &a->tds__GetPasswordHistoryConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_in___tds__GetPasswordHistoryConfiguration(struct soap *soap, const char *tag, struct __tds__GetPasswordHistoryConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordHistoryConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordHistoryConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordHistoryConfiguration, sizeof(struct __tds__GetPasswordHistoryConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordHistoryConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordHistoryConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordHistoryConfiguration(soap, "tds:GetPasswordHistoryConfiguration", &a->tds__GetPasswordHistoryConfiguration, ""))
				{	soap_flag_tds__GetPasswordHistoryConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_dup___tds__GetPasswordHistoryConfiguration(struct soap *soap, struct __tds__GetPasswordHistoryConfiguration *d, struct __tds__GetPasswordHistoryConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetPasswordHistoryConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetPasswordHistoryConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetPasswordHistoryConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetPasswordHistoryConfiguration(soap, &d->tds__GetPasswordHistoryConfiguration, &a->tds__GetPasswordHistoryConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetPasswordHistoryConfiguration(struct __tds__GetPasswordHistoryConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetPasswordHistoryConfiguration(&a->tds__GetPasswordHistoryConfiguration);
}

SOAP_FMAC1 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordHistoryConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordHistoryConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordHistoryConfiguration *p;
	size_t k = sizeof(struct __tds__GetPasswordHistoryConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordHistoryConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordHistoryConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordHistoryConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordHistoryConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordHistoryConfiguration(struct soap *soap, const struct __tds__GetPasswordHistoryConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordHistoryConfiguration(soap, tag ? tag : "-tds:GetPasswordHistoryConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordHistoryConfiguration * SOAP_FMAC4 soap_get___tds__GetPasswordHistoryConfiguration(struct soap *soap, struct __tds__GetPasswordHistoryConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordHistoryConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetPasswordComplexityConfiguration(struct soap *soap, struct __tds__SetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetPasswordComplexityConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__SetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetPasswordComplexityConfiguration(soap, &a->tds__SetPasswordComplexityConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetPasswordComplexityConfiguration(soap, "tds:SetPasswordComplexityConfiguration", -1, &a->tds__SetPasswordComplexityConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in___tds__SetPasswordComplexityConfiguration(struct soap *soap, const char *tag, struct __tds__SetPasswordComplexityConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetPasswordComplexityConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetPasswordComplexityConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetPasswordComplexityConfiguration, sizeof(struct __tds__SetPasswordComplexityConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetPasswordComplexityConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetPasswordComplexityConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetPasswordComplexityConfiguration(soap, "tds:SetPasswordComplexityConfiguration", &a->tds__SetPasswordComplexityConfiguration, ""))
				{	soap_flag_tds__SetPasswordComplexityConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_dup___tds__SetPasswordComplexityConfiguration(struct soap *soap, struct __tds__SetPasswordComplexityConfiguration *d, struct __tds__SetPasswordComplexityConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetPasswordComplexityConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetPasswordComplexityConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetPasswordComplexityConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetPasswordComplexityConfiguration(soap, &d->tds__SetPasswordComplexityConfiguration, &a->tds__SetPasswordComplexityConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetPasswordComplexityConfiguration(struct __tds__SetPasswordComplexityConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetPasswordComplexityConfiguration(&a->tds__SetPasswordComplexityConfiguration);
}

SOAP_FMAC1 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetPasswordComplexityConfiguration *p;
	size_t k = sizeof(struct __tds__SetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetPasswordComplexityConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetPasswordComplexityConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__SetPasswordComplexityConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetPasswordComplexityConfiguration(soap, tag ? tag : "-tds:SetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get___tds__SetPasswordComplexityConfiguration(struct soap *soap, struct __tds__SetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordComplexityConfiguration(struct soap *soap, struct __tds__GetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordComplexityConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__GetPasswordComplexityConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordComplexityConfiguration(soap, &a->tds__GetPasswordComplexityConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordComplexityConfiguration(soap, "tds:GetPasswordComplexityConfiguration", -1, &a->tds__GetPasswordComplexityConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_in___tds__GetPasswordComplexityConfiguration(struct soap *soap, const char *tag, struct __tds__GetPasswordComplexityConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordComplexityConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordComplexityConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordComplexityConfiguration, sizeof(struct __tds__GetPasswordComplexityConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordComplexityConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordComplexityConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordComplexityConfiguration(soap, "tds:GetPasswordComplexityConfiguration", &a->tds__GetPasswordComplexityConfiguration, ""))
				{	soap_flag_tds__GetPasswordComplexityConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_dup___tds__GetPasswordComplexityConfiguration(struct soap *soap, struct __tds__GetPasswordComplexityConfiguration *d, struct __tds__GetPasswordComplexityConfiguration const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetPasswordComplexityConfiguration*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetPasswordComplexityConfiguration, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetPasswordComplexityConfiguration(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetPasswordComplexityConfiguration(soap, &d->tds__GetPasswordComplexityConfiguration, &a->tds__GetPasswordComplexityConfiguration);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetPasswordComplexityConfiguration(struct __tds__GetPasswordComplexityConfiguration const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetPasswordComplexityConfiguration(&a->tds__GetPasswordComplexityConfiguration);
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordComplexityConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordComplexityConfiguration *p;
	size_t k = sizeof(struct __tds__GetPasswordComplexityConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordComplexityConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordComplexityConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordComplexityConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordComplexityConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordComplexityConfiguration(struct soap *soap, const struct __tds__GetPasswordComplexityConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordComplexityConfiguration(soap, tag ? tag : "-tds:GetPasswordComplexityConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityConfiguration * SOAP_FMAC4 soap_get___tds__GetPasswordComplexityConfiguration(struct soap *soap, struct __tds__GetPasswordComplexityConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordComplexityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPasswordComplexityOptions(struct soap *soap, struct __tds__GetPasswordComplexityOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPasswordComplexityOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPasswordComplexityOptions(struct soap *soap, const struct __tds__GetPasswordComplexityOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetPasswordComplexityOptions(soap, &a->tds__GetPasswordComplexityOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, int id, const struct __tds__GetPasswordComplexityOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetPasswordComplexityOptions(soap, "tds:GetPasswordComplexityOptions", -1, &a->tds__GetPasswordComplexityOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_in___tds__GetPasswordComplexityOptions(struct soap *soap, const char *tag, struct __tds__GetPasswordComplexityOptions *a, const char *type)
{
	size_t soap_flag_tds__GetPasswordComplexityOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetPasswordComplexityOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPasswordComplexityOptions, sizeof(struct __tds__GetPasswordComplexityOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPasswordComplexityOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPasswordComplexityOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetPasswordComplexityOptions(soap, "tds:GetPasswordComplexityOptions", &a->tds__GetPasswordComplexityOptions, ""))
				{	soap_flag_tds__GetPasswordComplexityOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_dup___tds__GetPasswordComplexityOptions(struct soap *soap, struct __tds__GetPasswordComplexityOptions *d, struct __tds__GetPasswordComplexityOptions const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetPasswordComplexityOptions*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetPasswordComplexityOptions, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetPasswordComplexityOptions(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetPasswordComplexityOptions(soap, &d->tds__GetPasswordComplexityOptions, &a->tds__GetPasswordComplexityOptions);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetPasswordComplexityOptions(struct __tds__GetPasswordComplexityOptions const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetPasswordComplexityOptions(&a->tds__GetPasswordComplexityOptions);
}

SOAP_FMAC1 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPasswordComplexityOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetPasswordComplexityOptions *p;
	size_t k = sizeof(struct __tds__GetPasswordComplexityOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetPasswordComplexityOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetPasswordComplexityOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetPasswordComplexityOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetPasswordComplexityOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPasswordComplexityOptions(struct soap *soap, const struct __tds__GetPasswordComplexityOptions *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetPasswordComplexityOptions(soap, tag ? tag : "-tds:GetPasswordComplexityOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPasswordComplexityOptions * SOAP_FMAC4 soap_get___tds__GetPasswordComplexityOptions(struct soap *soap, struct __tds__GetPasswordComplexityOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPasswordComplexityOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetWsdlUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetWsdlUrl(soap, &a->tds__GetWsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct __tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", -1, &a->tds__GetWsdlUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_in___tds__GetWsdlUrl(struct soap *soap, const char *tag, struct __tds__GetWsdlUrl *a, const char *type)
{
	size_t soap_flag_tds__GetWsdlUrl = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetWsdlUrl*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetWsdlUrl, sizeof(struct __tds__GetWsdlUrl), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetWsdlUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", &a->tds__GetWsdlUrl, ""))
				{	soap_flag_tds__GetWsdlUrl--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetWsdlUrl * SOAP_FMAC2 soap_dup___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *d, struct __tds__GetWsdlUrl const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetWsdlUrl*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetWsdlUrl, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetWsdlUrl(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetWsdlUrl(soap, &d->tds__GetWsdlUrl, &a->tds__GetWsdlUrl);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetWsdlUrl(struct __tds__GetWsdlUrl const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetWsdlUrl(&a->tds__GetWsdlUrl);
}

SOAP_FMAC1 struct __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetWsdlUrl(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetWsdlUrl *p;
	size_t k = sizeof(struct __tds__GetWsdlUrl);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetWsdlUrl);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetWsdlUrl, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetWsdlUrl location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetWsdlUrl(soap, tag ? tag : "-tds:GetWsdlUrl", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_get___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
				{	soap_flag_tds__SetUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetUser * SOAP_FMAC2 soap_dup___tds__SetUser(struct soap *soap, struct __tds__SetUser *d, struct __tds__SetUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetUser(soap, &d->tds__SetUser, &a->tds__SetUser);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetUser(struct __tds__SetUser const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetUser(&a->tds__SetUser);
}

SOAP_FMAC1 struct __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetUser *p;
	size_t k = sizeof(struct __tds__SetUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetUser(soap, tag ? tag : "-tds:SetUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__DeleteUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
				{	soap_flag_tds__DeleteUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__DeleteUsers * SOAP_FMAC2 soap_dup___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *d, struct __tds__DeleteUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__DeleteUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__DeleteUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__DeleteUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__DeleteUsers(soap, &d->tds__DeleteUsers, &a->tds__DeleteUsers);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__DeleteUsers(struct __tds__DeleteUsers const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__DeleteUsers(&a->tds__DeleteUsers);
}

SOAP_FMAC1 struct __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__DeleteUsers *p;
	size_t k = sizeof(struct __tds__DeleteUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__DeleteUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__DeleteUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__DeleteUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__DeleteUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__DeleteUsers(soap, tag ? tag : "-tds:DeleteUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__CreateUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
				{	soap_flag_tds__CreateUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__CreateUsers * SOAP_FMAC2 soap_dup___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *d, struct __tds__CreateUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__CreateUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__CreateUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__CreateUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__CreateUsers(soap, &d->tds__CreateUsers, &a->tds__CreateUsers);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__CreateUsers(struct __tds__CreateUsers const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__CreateUsers(&a->tds__CreateUsers);
}

SOAP_FMAC1 struct __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__CreateUsers *p;
	size_t k = sizeof(struct __tds__CreateUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__CreateUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__CreateUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__CreateUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__CreateUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__CreateUsers(soap, tag ? tag : "-tds:CreateUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetUsers*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
				{	soap_flag_tds__GetUsers--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetUsers * SOAP_FMAC2 soap_dup___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *d, struct __tds__GetUsers const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetUsers*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetUsers, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetUsers(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetUsers(soap, &d->tds__GetUsers, &a->tds__GetUsers);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetUsers(struct __tds__GetUsers const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetUsers(&a->tds__GetUsers);
}

SOAP_FMAC1 struct __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetUsers(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetUsers *p;
	size_t k = sizeof(struct __tds__GetUsers);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetUsers, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetUsers);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetUsers, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetUsers location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetUsers(soap, tag ? tag : "-tds:GetUsers", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteUser(soap, &a->tds__SetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", -1, &a->tds__SetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_in___tds__SetRemoteUser(struct soap *soap, const char *tag, struct __tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteUser, sizeof(struct __tds__SetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", &a->tds__SetRemoteUser, ""))
				{	soap_flag_tds__SetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRemoteUser * SOAP_FMAC2 soap_dup___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *d, struct __tds__SetRemoteUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetRemoteUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetRemoteUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetRemoteUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetRemoteUser(soap, &d->tds__SetRemoteUser, &a->tds__SetRemoteUser);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetRemoteUser(struct __tds__SetRemoteUser const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetRemoteUser(&a->tds__SetRemoteUser);
}

SOAP_FMAC1 struct __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRemoteUser *p;
	size_t k = sizeof(struct __tds__SetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRemoteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRemoteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteUser(soap, tag ? tag : "-tds:SetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_get___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteUser(soap, &a->tds__GetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", -1, &a->tds__GetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_in___tds__GetRemoteUser(struct soap *soap, const char *tag, struct __tds__GetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteUser = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteUser*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteUser, sizeof(struct __tds__GetRemoteUser), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", &a->tds__GetRemoteUser, ""))
				{	soap_flag_tds__GetRemoteUser--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRemoteUser * SOAP_FMAC2 soap_dup___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *d, struct __tds__GetRemoteUser const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetRemoteUser*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetRemoteUser, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetRemoteUser(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetRemoteUser(soap, &d->tds__GetRemoteUser, &a->tds__GetRemoteUser);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetRemoteUser(struct __tds__GetRemoteUser const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetRemoteUser(&a->tds__GetRemoteUser);
}

SOAP_FMAC1 struct __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteUser(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRemoteUser *p;
	size_t k = sizeof(struct __tds__GetRemoteUser);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRemoteUser, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRemoteUser);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRemoteUser, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRemoteUser location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteUser(soap, tag ? tag : "-tds:GetRemoteUser", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_get___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetEndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetEndpointReference(soap, &a->tds__GetEndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct __tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", -1, &a->tds__GetEndpointReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_in___tds__GetEndpointReference(struct soap *soap, const char *tag, struct __tds__GetEndpointReference *a, const char *type)
{
	size_t soap_flag_tds__GetEndpointReference = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetEndpointReference*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetEndpointReference, sizeof(struct __tds__GetEndpointReference), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetEndpointReference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", &a->tds__GetEndpointReference, ""))
				{	soap_flag_tds__GetEndpointReference--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetEndpointReference * SOAP_FMAC2 soap_dup___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *d, struct __tds__GetEndpointReference const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetEndpointReference*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetEndpointReference, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetEndpointReference(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetEndpointReference(soap, &d->tds__GetEndpointReference, &a->tds__GetEndpointReference);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetEndpointReference(struct __tds__GetEndpointReference const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetEndpointReference(&a->tds__GetEndpointReference);
}

SOAP_FMAC1 struct __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetEndpointReference(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetEndpointReference *p;
	size_t k = sizeof(struct __tds__GetEndpointReference);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetEndpointReference, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetEndpointReference);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetEndpointReference, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetEndpointReference location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetEndpointReference(soap, tag ? tag : "-tds:GetEndpointReference", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_get___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDPAddresses(soap, &a->tds__GetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", -1, &a->tds__GetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_in___tds__GetDPAddresses(struct soap *soap, const char *tag, struct __tds__GetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__GetDPAddresses = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDPAddresses*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDPAddresses, sizeof(struct __tds__GetDPAddresses), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", &a->tds__GetDPAddresses, ""))
				{	soap_flag_tds__GetDPAddresses--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDPAddresses * SOAP_FMAC2 soap_dup___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *d, struct __tds__GetDPAddresses const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDPAddresses*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDPAddresses, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDPAddresses(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDPAddresses(soap, &d->tds__GetDPAddresses, &a->tds__GetDPAddresses);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDPAddresses(struct __tds__GetDPAddresses const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDPAddresses(&a->tds__GetDPAddresses);
}

SOAP_FMAC1 struct __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDPAddresses(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDPAddresses *p;
	size_t k = sizeof(struct __tds__GetDPAddresses);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDPAddresses, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDPAddresses);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDPAddresses, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDPAddresses location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDPAddresses(soap, tag ? tag : "-tds:GetDPAddresses", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_get___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, &a->tds__SetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", -1, &a->tds__SetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, sizeof(struct __tds__SetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", &a->tds__SetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__SetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_dup___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *d, struct __tds__SetRemoteDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetRemoteDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetRemoteDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetRemoteDiscoveryMode(soap, &d->tds__SetRemoteDiscoveryMode, &a->tds__SetRemoteDiscoveryMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetRemoteDiscoveryMode(struct __tds__SetRemoteDiscoveryMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetRemoteDiscoveryMode(&a->tds__SetRemoteDiscoveryMode);
}

SOAP_FMAC1 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetRemoteDiscoveryMode *p;
	size_t k = sizeof(struct __tds__SetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetRemoteDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetRemoteDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetRemoteDiscoveryMode(soap, tag ? tag : "-tds:SetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, &a->tds__GetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", -1, &a->tds__GetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetRemoteDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, sizeof(struct __tds__GetRemoteDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", &a->tds__GetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__GetRemoteDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_dup___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *d, struct __tds__GetRemoteDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetRemoteDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetRemoteDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetRemoteDiscoveryMode(soap, &d->tds__GetRemoteDiscoveryMode, &a->tds__GetRemoteDiscoveryMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetRemoteDiscoveryMode(struct __tds__GetRemoteDiscoveryMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetRemoteDiscoveryMode(&a->tds__GetRemoteDiscoveryMode);
}

SOAP_FMAC1 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetRemoteDiscoveryMode *p;
	size_t k = sizeof(struct __tds__GetRemoteDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetRemoteDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetRemoteDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetRemoteDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetRemoteDiscoveryMode(soap, tag ? tag : "-tds:GetRemoteDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, &a->tds__SetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", -1, &a->tds__SetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDiscoveryMode, sizeof(struct __tds__SetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", &a->tds__SetDiscoveryMode, ""))
				{	soap_flag_tds__SetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetDiscoveryMode * SOAP_FMAC2 soap_dup___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *d, struct __tds__SetDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetDiscoveryMode(soap, &d->tds__SetDiscoveryMode, &a->tds__SetDiscoveryMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetDiscoveryMode(struct __tds__SetDiscoveryMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetDiscoveryMode(&a->tds__SetDiscoveryMode);
}

SOAP_FMAC1 struct __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetDiscoveryMode *p;
	size_t k = sizeof(struct __tds__SetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetDiscoveryMode(soap, tag ? tag : "-tds:SetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, &a->tds__GetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", -1, &a->tds__GetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetDiscoveryMode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDiscoveryMode*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDiscoveryMode, sizeof(struct __tds__GetDiscoveryMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", &a->tds__GetDiscoveryMode, ""))
				{	soap_flag_tds__GetDiscoveryMode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDiscoveryMode * SOAP_FMAC2 soap_dup___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *d, struct __tds__GetDiscoveryMode const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDiscoveryMode*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDiscoveryMode, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDiscoveryMode(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDiscoveryMode(soap, &d->tds__GetDiscoveryMode, &a->tds__GetDiscoveryMode);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDiscoveryMode(struct __tds__GetDiscoveryMode const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDiscoveryMode(&a->tds__GetDiscoveryMode);
}

SOAP_FMAC1 struct __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDiscoveryMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDiscoveryMode *p;
	size_t k = sizeof(struct __tds__GetDiscoveryMode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDiscoveryMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDiscoveryMode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDiscoveryMode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDiscoveryMode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDiscoveryMode(soap, tag ? tag : "-tds:GetDiscoveryMode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RemoveScopes(soap, &a->tds__RemoveScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct __tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", -1, &a->tds__RemoveScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_in___tds__RemoveScopes(struct soap *soap, const char *tag, struct __tds__RemoveScopes *a, const char *type)
{
	size_t soap_flag_tds__RemoveScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RemoveScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveScopes, sizeof(struct __tds__RemoveScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", &a->tds__RemoveScopes, ""))
				{	soap_flag_tds__RemoveScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RemoveScopes * SOAP_FMAC2 soap_dup___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *d, struct __tds__RemoveScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__RemoveScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__RemoveScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__RemoveScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__RemoveScopes(soap, &d->tds__RemoveScopes, &a->tds__RemoveScopes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__RemoveScopes(struct __tds__RemoveScopes const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__RemoveScopes(&a->tds__RemoveScopes);
}

SOAP_FMAC1 struct __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RemoveScopes *p;
	size_t k = sizeof(struct __tds__RemoveScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RemoveScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RemoveScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RemoveScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RemoveScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__RemoveScopes(soap, tag ? tag : "-tds:RemoveScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_get___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__AddScopes(soap, &a->tds__AddScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddScopes(struct soap *soap, const char *tag, int id, const struct __tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__AddScopes(soap, "tds:AddScopes", -1, &a->tds__AddScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_in___tds__AddScopes(struct soap *soap, const char *tag, struct __tds__AddScopes *a, const char *type)
{
	size_t soap_flag_tds__AddScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__AddScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddScopes, sizeof(struct __tds__AddScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__AddScopes(soap, "tds:AddScopes", &a->tds__AddScopes, ""))
				{	soap_flag_tds__AddScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__AddScopes * SOAP_FMAC2 soap_dup___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *d, struct __tds__AddScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__AddScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__AddScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__AddScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__AddScopes(soap, &d->tds__AddScopes, &a->tds__AddScopes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__AddScopes(struct __tds__AddScopes const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__AddScopes(&a->tds__AddScopes);
}

SOAP_FMAC1 struct __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__AddScopes *p;
	size_t k = sizeof(struct __tds__AddScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__AddScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__AddScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__AddScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__AddScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__AddScopes(soap, tag ? tag : "-tds:AddScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_get___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetScopes(soap, &a->tds__SetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetScopes(struct soap *soap, const char *tag, int id, const struct __tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetScopes(soap, "tds:SetScopes", -1, &a->tds__SetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_in___tds__SetScopes(struct soap *soap, const char *tag, struct __tds__SetScopes *a, const char *type)
{
	size_t soap_flag_tds__SetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetScopes, sizeof(struct __tds__SetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetScopes(soap, "tds:SetScopes", &a->tds__SetScopes, ""))
				{	soap_flag_tds__SetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetScopes * SOAP_FMAC2 soap_dup___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *d, struct __tds__SetScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetScopes(soap, &d->tds__SetScopes, &a->tds__SetScopes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetScopes(struct __tds__SetScopes const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetScopes(&a->tds__SetScopes);
}

SOAP_FMAC1 struct __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetScopes *p;
	size_t k = sizeof(struct __tds__SetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetScopes(soap, tag ? tag : "-tds:SetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_get___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetScopes(soap, &a->tds__GetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetScopes(struct soap *soap, const char *tag, int id, const struct __tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetScopes(soap, "tds:GetScopes", -1, &a->tds__GetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_in___tds__GetScopes(struct soap *soap, const char *tag, struct __tds__GetScopes *a, const char *type)
{
	size_t soap_flag_tds__GetScopes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetScopes*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetScopes, sizeof(struct __tds__GetScopes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetScopes(soap, "tds:GetScopes", &a->tds__GetScopes, ""))
				{	soap_flag_tds__GetScopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetScopes * SOAP_FMAC2 soap_dup___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *d, struct __tds__GetScopes const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetScopes*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetScopes, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetScopes(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetScopes(soap, &d->tds__GetScopes, &a->tds__GetScopes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetScopes(struct __tds__GetScopes const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetScopes(&a->tds__GetScopes);
}

SOAP_FMAC1 struct __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetScopes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetScopes *p;
	size_t k = sizeof(struct __tds__GetScopes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetScopes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetScopes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetScopes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetScopes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetScopes(soap, tag ? tag : "-tds:GetScopes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_get___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemSupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, &a->tds__GetSystemSupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", -1, &a->tds__GetSystemSupportInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct __tds__GetSystemSupportInformation *a, const char *type)
{
	size_t soap_flag_tds__GetSystemSupportInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemSupportInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemSupportInformation, sizeof(struct __tds__GetSystemSupportInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemSupportInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", &a->tds__GetSystemSupportInformation, ""))
				{	soap_flag_tds__GetSystemSupportInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_dup___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *d, struct __tds__GetSystemSupportInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetSystemSupportInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetSystemSupportInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetSystemSupportInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetSystemSupportInformation(soap, &d->tds__GetSystemSupportInformation, &a->tds__GetSystemSupportInformation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetSystemSupportInformation(struct __tds__GetSystemSupportInformation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetSystemSupportInformation(&a->tds__GetSystemSupportInformation);
}

SOAP_FMAC1 struct __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemSupportInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemSupportInformation *p;
	size_t k = sizeof(struct __tds__GetSystemSupportInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemSupportInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemSupportInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemSupportInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemSupportInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemSupportInformation(soap, tag ? tag : "-tds:GetSystemSupportInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemLog(soap, &a->tds__GetSystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", -1, &a->tds__GetSystemLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_in___tds__GetSystemLog(struct soap *soap, const char *tag, struct __tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_tds__GetSystemLog = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemLog*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemLog, sizeof(struct __tds__GetSystemLog), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", &a->tds__GetSystemLog, ""))
				{	soap_flag_tds__GetSystemLog--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemLog * SOAP_FMAC2 soap_dup___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *d, struct __tds__GetSystemLog const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetSystemLog*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetSystemLog, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetSystemLog(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetSystemLog(soap, &d->tds__GetSystemLog, &a->tds__GetSystemLog);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetSystemLog(struct __tds__GetSystemLog const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetSystemLog(&a->tds__GetSystemLog);
}

SOAP_FMAC1 struct __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemLog(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemLog *p;
	size_t k = sizeof(struct __tds__GetSystemLog);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemLog, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemLog);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemLog, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemLog location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemLog(soap, tag ? tag : "-tds:GetSystemLog", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_get___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemBackup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemBackup(soap, &a->tds__GetSystemBackup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", -1, &a->tds__GetSystemBackup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_in___tds__GetSystemBackup(struct soap *soap, const char *tag, struct __tds__GetSystemBackup *a, const char *type)
{
	size_t soap_flag_tds__GetSystemBackup = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemBackup*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemBackup, sizeof(struct __tds__GetSystemBackup), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemBackup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", &a->tds__GetSystemBackup, ""))
				{	soap_flag_tds__GetSystemBackup--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemBackup * SOAP_FMAC2 soap_dup___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *d, struct __tds__GetSystemBackup const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetSystemBackup*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetSystemBackup, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetSystemBackup(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetSystemBackup(soap, &d->tds__GetSystemBackup, &a->tds__GetSystemBackup);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetSystemBackup(struct __tds__GetSystemBackup const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetSystemBackup(&a->tds__GetSystemBackup);
}

SOAP_FMAC1 struct __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemBackup(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemBackup *p;
	size_t k = sizeof(struct __tds__GetSystemBackup);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemBackup, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemBackup);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemBackup, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemBackup location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemBackup(soap, tag ? tag : "-tds:GetSystemBackup", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_get___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RestoreSystem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__RestoreSystem(soap, &a->tds__RestoreSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct __tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", -1, &a->tds__RestoreSystem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_in___tds__RestoreSystem(struct soap *soap, const char *tag, struct __tds__RestoreSystem *a, const char *type)
{
	size_t soap_flag_tds__RestoreSystem = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__RestoreSystem*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RestoreSystem, sizeof(struct __tds__RestoreSystem), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RestoreSystem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", &a->tds__RestoreSystem, ""))
				{	soap_flag_tds__RestoreSystem--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__RestoreSystem * SOAP_FMAC2 soap_dup___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *d, struct __tds__RestoreSystem const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__RestoreSystem*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__RestoreSystem, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__RestoreSystem(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__RestoreSystem(soap, &d->tds__RestoreSystem, &a->tds__RestoreSystem);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__RestoreSystem(struct __tds__RestoreSystem const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__RestoreSystem(&a->tds__RestoreSystem);
}

SOAP_FMAC1 struct __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RestoreSystem(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__RestoreSystem *p;
	size_t k = sizeof(struct __tds__RestoreSystem);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__RestoreSystem, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__RestoreSystem);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__RestoreSystem, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__RestoreSystem location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a, const char *tag, const char *type)
{
	if (soap_out___tds__RestoreSystem(soap, tag ? tag : "-tds:RestoreSystem", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_get___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SystemReboot*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SystemReboot * SOAP_FMAC2 soap_dup___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *d, struct __tds__SystemReboot const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SystemReboot*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SystemReboot, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SystemReboot(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SystemReboot(soap, &d->tds__SystemReboot, &a->tds__SystemReboot);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SystemReboot(struct __tds__SystemReboot const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SystemReboot(&a->tds__SystemReboot);
}

SOAP_FMAC1 struct __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SystemReboot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SystemReboot *p;
	size_t k = sizeof(struct __tds__SystemReboot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SystemReboot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SystemReboot);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SystemReboot, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SystemReboot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	if (soap_out___tds__SystemReboot(soap, tag ? tag : "-tds:SystemReboot", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__UpgradeSystemFirmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, &a->tds__UpgradeSystemFirmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", -1, &a->tds__UpgradeSystemFirmware, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_tds__UpgradeSystemFirmware = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__UpgradeSystemFirmware*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__UpgradeSystemFirmware, sizeof(struct __tds__UpgradeSystemFirmware), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__UpgradeSystemFirmware(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", &a->tds__UpgradeSystemFirmware, ""))
				{	soap_flag_tds__UpgradeSystemFirmware--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_dup___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *d, struct __tds__UpgradeSystemFirmware const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__UpgradeSystemFirmware*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__UpgradeSystemFirmware, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__UpgradeSystemFirmware(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__UpgradeSystemFirmware(soap, &d->tds__UpgradeSystemFirmware, &a->tds__UpgradeSystemFirmware);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__UpgradeSystemFirmware(struct __tds__UpgradeSystemFirmware const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__UpgradeSystemFirmware(&a->tds__UpgradeSystemFirmware);
}

SOAP_FMAC1 struct __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__UpgradeSystemFirmware(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__UpgradeSystemFirmware *p;
	size_t k = sizeof(struct __tds__UpgradeSystemFirmware);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__UpgradeSystemFirmware, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__UpgradeSystemFirmware);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__UpgradeSystemFirmware, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__UpgradeSystemFirmware location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	if (soap_out___tds__UpgradeSystemFirmware(soap, tag ? tag : "-tds:UpgradeSystemFirmware", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemFactoryDefault*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
				{	soap_flag_tds__SetSystemFactoryDefault--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_dup___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *d, struct __tds__SetSystemFactoryDefault const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetSystemFactoryDefault*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetSystemFactoryDefault, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetSystemFactoryDefault(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetSystemFactoryDefault(soap, &d->tds__SetSystemFactoryDefault, &a->tds__SetSystemFactoryDefault);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetSystemFactoryDefault(struct __tds__SetSystemFactoryDefault const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetSystemFactoryDefault(&a->tds__SetSystemFactoryDefault);
}

SOAP_FMAC1 struct __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemFactoryDefault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetSystemFactoryDefault *p;
	size_t k = sizeof(struct __tds__SetSystemFactoryDefault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetSystemFactoryDefault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetSystemFactoryDefault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetSystemFactoryDefault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetSystemFactoryDefault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag ? tag : "-tds:SetSystemFactoryDefault", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
				{	soap_flag_tds__GetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_dup___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *d, struct __tds__GetSystemDateAndTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetSystemDateAndTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetSystemDateAndTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetSystemDateAndTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetSystemDateAndTime(soap, &d->tds__GetSystemDateAndTime, &a->tds__GetSystemDateAndTime);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetSystemDateAndTime(struct __tds__GetSystemDateAndTime const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetSystemDateAndTime(&a->tds__GetSystemDateAndTime);
}

SOAP_FMAC1 struct __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetSystemDateAndTime *p;
	size_t k = sizeof(struct __tds__GetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetSystemDateAndTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetSystemDateAndTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetSystemDateAndTime(soap, tag ? tag : "-tds:GetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__SetSystemDateAndTime*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
				{	soap_flag_tds__SetSystemDateAndTime--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_dup___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *d, struct __tds__SetSystemDateAndTime const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__SetSystemDateAndTime*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__SetSystemDateAndTime, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__SetSystemDateAndTime(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__SetSystemDateAndTime(soap, &d->tds__SetSystemDateAndTime, &a->tds__SetSystemDateAndTime);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__SetSystemDateAndTime(struct __tds__SetSystemDateAndTime const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__SetSystemDateAndTime(&a->tds__SetSystemDateAndTime);
}

SOAP_FMAC1 struct __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemDateAndTime(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__SetSystemDateAndTime *p;
	size_t k = sizeof(struct __tds__SetSystemDateAndTime);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__SetSystemDateAndTime, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__SetSystemDateAndTime);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__SetSystemDateAndTime, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__SetSystemDateAndTime location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	if (soap_out___tds__SetSystemDateAndTime(soap, tag ? tag : "-tds:SetSystemDateAndTime", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetDeviceInformation*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetDeviceInformation * SOAP_FMAC2 soap_dup___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *d, struct __tds__GetDeviceInformation const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetDeviceInformation*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetDeviceInformation, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetDeviceInformation(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetDeviceInformation(soap, &d->tds__GetDeviceInformation, &a->tds__GetDeviceInformation);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetDeviceInformation(struct __tds__GetDeviceInformation const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetDeviceInformation(&a->tds__GetDeviceInformation);
}

SOAP_FMAC1 struct __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDeviceInformation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetDeviceInformation *p;
	size_t k = sizeof(struct __tds__GetDeviceInformation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetDeviceInformation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetDeviceInformation);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetDeviceInformation, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetDeviceInformation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetDeviceInformation(soap, tag ? tag : "-tds:GetDeviceInformation", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetServiceCapabilities * SOAP_FMAC2 soap_dup___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *d, struct __tds__GetServiceCapabilities const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetServiceCapabilities*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetServiceCapabilities, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetServiceCapabilities(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetServiceCapabilities(soap, &d->tds__GetServiceCapabilities, &a->tds__GetServiceCapabilities);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetServiceCapabilities(struct __tds__GetServiceCapabilities const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetServiceCapabilities(&a->tds__GetServiceCapabilities);
}

SOAP_FMAC1 struct __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetServiceCapabilities *p;
	size_t k = sizeof(struct __tds__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServiceCapabilities(soap, tag ? tag : "-tds:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tds__GetServices*)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tds__GetServices * SOAP_FMAC2 soap_dup___tds__GetServices(struct soap *soap, struct __tds__GetServices *d, struct __tds__GetServices const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tds__GetServices*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tds__GetServices, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tds__GetServices(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTo_tds__GetServices(soap, &d->tds__GetServices, &a->tds__GetServices);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tds__GetServices(struct __tds__GetServices const*a)
{
	if (!a)
		return;
	soap_del_PointerTo_tds__GetServices(&a->tds__GetServices);
}

SOAP_FMAC1 struct __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServices(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tds__GetServices *p;
	size_t k = sizeof(struct __tds__GetServices);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tds__GetServices, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tds__GetServices);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tds__GetServices, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tds__GetServices location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	if (soap_out___tds__GetServices(soap, tag ? tag : "-tds:GetServices", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Probe(struct soap *soap, struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->tdn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->tdn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Probe(struct soap *soap, const char *tag, int id, const struct __tdn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ProbeType(soap, "tdn:Probe", -1, &a->tdn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_in___tdn__Probe(struct soap *soap, const char *tag, struct __tdn__Probe *a, const char *type)
{
	size_t soap_flag_tdn__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Probe, sizeof(struct __tdn__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ProbeType(soap, "tdn:Probe", &a->tdn__Probe, "wsdd:ProbeType"))
				{	soap_flag_tdn__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Probe > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tdn__Probe * SOAP_FMAC2 soap_dup___tdn__Probe(struct soap *soap, struct __tdn__Probe *d, struct __tdn__Probe const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tdn__Probe*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tdn__Probe, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tdn__Probe(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_wsdd__ProbeType(soap, &d->tdn__Probe, &a->tdn__Probe);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tdn__Probe(struct __tdn__Probe const*a)
{
	if (!a)
		return;
	soap_del_wsdd__ProbeType(&a->tdn__Probe);
}

SOAP_FMAC1 struct __tdn__Probe * SOAP_FMAC2 soap_instantiate___tdn__Probe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tdn__Probe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tdn__Probe *p;
	size_t k = sizeof(struct __tdn__Probe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tdn__Probe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tdn__Probe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tdn__Probe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tdn__Probe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Probe(struct soap *soap, const struct __tdn__Probe *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Probe(soap, tag ? tag : "-tdn:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Probe * SOAP_FMAC4 soap_get___tdn__Probe(struct soap *soap, struct __tdn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Bye(struct soap *soap, struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->tdn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->tdn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Bye(struct soap *soap, const char *tag, int id, const struct __tdn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__ByeType(soap, "tdn:Bye", -1, &a->tdn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_in___tdn__Bye(struct soap *soap, const char *tag, struct __tdn__Bye *a, const char *type)
{
	size_t soap_flag_tdn__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Bye, sizeof(struct __tdn__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__ByeType(soap, "tdn:Bye", &a->tdn__Bye, "wsdd:ByeType"))
				{	soap_flag_tdn__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Bye > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tdn__Bye * SOAP_FMAC2 soap_dup___tdn__Bye(struct soap *soap, struct __tdn__Bye *d, struct __tdn__Bye const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tdn__Bye*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tdn__Bye, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tdn__Bye(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_wsdd__ByeType(soap, &d->tdn__Bye, &a->tdn__Bye);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tdn__Bye(struct __tdn__Bye const*a)
{
	if (!a)
		return;
	soap_del_wsdd__ByeType(&a->tdn__Bye);
}

SOAP_FMAC1 struct __tdn__Bye * SOAP_FMAC2 soap_instantiate___tdn__Bye(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tdn__Bye(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tdn__Bye *p;
	size_t k = sizeof(struct __tdn__Bye);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tdn__Bye, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tdn__Bye);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tdn__Bye, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tdn__Bye location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Bye(struct soap *soap, const struct __tdn__Bye *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Bye(soap, tag ? tag : "-tdn:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Bye * SOAP_FMAC4 soap_get___tdn__Bye(struct soap *soap, struct __tdn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tdn__Hello(struct soap *soap, struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->tdn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->tdn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->tdn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tdn__Hello(struct soap *soap, const char *tag, int id, const struct __tdn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_wsdd__HelloType(soap, "tdn:Hello", -1, &a->tdn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_in___tdn__Hello(struct soap *soap, const char *tag, struct __tdn__Hello *a, const char *type)
{
	size_t soap_flag_tdn__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tdn__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___tdn__Hello, sizeof(struct __tdn__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tdn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tdn__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_wsdd__HelloType(soap, "tdn:Hello", &a->tdn__Hello, "wsdd:HelloType"))
				{	soap_flag_tdn__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap_flag_tdn__Hello > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tdn__Hello * SOAP_FMAC2 soap_dup___tdn__Hello(struct soap *soap, struct __tdn__Hello *d, struct __tdn__Hello const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __tdn__Hello*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___tdn__Hello, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___tdn__Hello(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_wsdd__HelloType(soap, &d->tdn__Hello, &a->tdn__Hello);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___tdn__Hello(struct __tdn__Hello const*a)
{
	if (!a)
		return;
	soap_del_wsdd__HelloType(&a->tdn__Hello);
}

SOAP_FMAC1 struct __tdn__Hello * SOAP_FMAC2 soap_instantiate___tdn__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tdn__Hello(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tdn__Hello *p;
	size_t k = sizeof(struct __tdn__Hello);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tdn__Hello, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tdn__Hello);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tdn__Hello, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tdn__Hello location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tdn__Hello(struct soap *soap, const struct __tdn__Hello *a, const char *tag, const char *type)
{
	if (soap_out___tdn__Hello(soap, tag ? tag : "-tdn:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tdn__Hello * SOAP_FMAC4 soap_get___tdn__Hello(struct soap *soap, struct __tdn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___tdn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	if (soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Envelope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 soap_dup_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *d, struct SOAP_ENV__Envelope const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Envelope*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Envelope, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Envelope(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerToSOAP_ENV__Header(soap, &d->SOAP_ENV__Header, &a->SOAP_ENV__Header);
	d->SOAP_ENV__Body = soap_strdup(soap, (char*)a->SOAP_ENV__Body);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Envelope(struct SOAP_ENV__Envelope const*a)
{
	if (!a)
		return;
	soap_del_PointerToSOAP_ENV__Header(&a->SOAP_ENV__Header);
	if (a->SOAP_ENV__Body)
		SOAP_FREE(NULL, a->SOAP_ENV__Body);
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Envelope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Envelope *p;
	size_t k = sizeof(struct SOAP_ENV__Envelope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Envelope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Envelope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Envelope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, const struct _xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE__xop__Include, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap *soap, struct _xop__Include a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__xop__Include, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap *soap, const char *s, struct _xop__Include *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_dup__xop__Include(struct soap *soap, struct _xop__Include *d, struct _xop__Include const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct _xop__Include*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE__xop__Include, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new__xop__Include(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__ptr = NULL;
	d->__size = a->__size;
	if (a->__ptr && a->__size > 0)
	{	d->__ptr = (unsigned char*)soap_malloc(soap, a->__size);
		if (!d->__ptr)
			return NULL;
		soap_memcpy(d->__ptr, d->__size, a->__ptr, a->__size);
	}
	d->id = soap_strdup(soap, a->id);
	d->type = soap_strdup(soap, a->type);
	d->options = soap_strdup(soap, a->options); /* WARNING: cannot copy binary DIME attachment options correctly, MIME/MTOM is OK */
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del__xop__Include(struct _xop__Include const*a)
{
	if (!a)
		return;
	if (a->__ptr)
		SOAP_FREE(NULL, a->__ptr);
	if (a->id)
		SOAP_FREE(NULL, a->id);
	if (a->type)
		SOAP_FREE(NULL, a->type);
	if (a->options)
		SOAP_FREE(NULL, a->options);
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xop__Include *p;
	size_t k = sizeof(struct _xop__Include);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xop__Include);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xop__Include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xop__Include location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	if (soap_out__xop__Include(soap, tag ? tag : "xop:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ResolveMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchesType(soap, &a->wsdd__ResolveMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ResolveMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ResolveMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", -1, &a->wsdd__ResolveMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_in___wsdd__ResolveMatches(struct soap *soap, const char *tag, struct __wsdd__ResolveMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ResolveMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ResolveMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ResolveMatches, sizeof(struct __wsdd__ResolveMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ResolveMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", &a->wsdd__ResolveMatches, "wsdd:ResolveMatchesType"))
				{	soap_flag_wsdd__ResolveMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__ResolveMatches * SOAP_FMAC2 soap_dup___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *d, struct __wsdd__ResolveMatches const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__ResolveMatches*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__ResolveMatches, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__ResolveMatches(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ResolveMatchesType(soap, &d->wsdd__ResolveMatches, &a->wsdd__ResolveMatches);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__ResolveMatches(struct __wsdd__ResolveMatches const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ResolveMatchesType(&a->wsdd__ResolveMatches);
}

SOAP_FMAC1 struct __wsdd__ResolveMatches * SOAP_FMAC2 soap_instantiate___wsdd__ResolveMatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__ResolveMatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__ResolveMatches *p;
	size_t k = sizeof(struct __wsdd__ResolveMatches);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__ResolveMatches, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__ResolveMatches);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__ResolveMatches, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__ResolveMatches location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ResolveMatches(soap, tag ? tag : "-wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_get___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ResolveMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Resolve = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveType(soap, &a->wsdd__Resolve);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Resolve(struct soap *soap, const char *tag, int id, const struct __wsdd__Resolve *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", -1, &a->wsdd__Resolve, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_in___wsdd__Resolve(struct soap *soap, const char *tag, struct __wsdd__Resolve *a, const char *type)
{
	size_t soap_flag_wsdd__Resolve = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Resolve*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Resolve, sizeof(struct __wsdd__Resolve), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Resolve(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", &a->wsdd__Resolve, "wsdd:ResolveType"))
				{	soap_flag_wsdd__Resolve--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__Resolve * SOAP_FMAC2 soap_dup___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *d, struct __wsdd__Resolve const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__Resolve*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__Resolve, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__Resolve(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ResolveType(soap, &d->wsdd__Resolve, &a->wsdd__Resolve);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__Resolve(struct __wsdd__Resolve const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ResolveType(&a->wsdd__Resolve);
}

SOAP_FMAC1 struct __wsdd__Resolve * SOAP_FMAC2 soap_instantiate___wsdd__Resolve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Resolve(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__Resolve *p;
	size_t k = sizeof(struct __wsdd__Resolve);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__Resolve, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__Resolve);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__Resolve, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__Resolve location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Resolve(soap, tag ? tag : "-wsdd:Resolve", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_get___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Resolve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ProbeMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeMatchesType(soap, &a->wsdd__ProbeMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ProbeMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ProbeMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", -1, &a->wsdd__ProbeMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_in___wsdd__ProbeMatches(struct soap *soap, const char *tag, struct __wsdd__ProbeMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ProbeMatches = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__ProbeMatches*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ProbeMatches, sizeof(struct __wsdd__ProbeMatches), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ProbeMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", &a->wsdd__ProbeMatches, "wsdd:ProbeMatchesType"))
				{	soap_flag_wsdd__ProbeMatches--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__ProbeMatches * SOAP_FMAC2 soap_dup___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *d, struct __wsdd__ProbeMatches const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__ProbeMatches*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__ProbeMatches, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__ProbeMatches(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ProbeMatchesType(soap, &d->wsdd__ProbeMatches, &a->wsdd__ProbeMatches);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__ProbeMatches(struct __wsdd__ProbeMatches const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ProbeMatchesType(&a->wsdd__ProbeMatches);
}

SOAP_FMAC1 struct __wsdd__ProbeMatches * SOAP_FMAC2 soap_instantiate___wsdd__ProbeMatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__ProbeMatches(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__ProbeMatches *p;
	size_t k = sizeof(struct __wsdd__ProbeMatches);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__ProbeMatches, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__ProbeMatches);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__ProbeMatches, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__ProbeMatches location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__ProbeMatches(soap, tag ? tag : "-wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_get___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ProbeMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ProbeType(soap, &a->wsdd__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Probe(struct soap *soap, const char *tag, int id, const struct __wsdd__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ProbeType(soap, "wsdd:Probe", -1, &a->wsdd__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_in___wsdd__Probe(struct soap *soap, const char *tag, struct __wsdd__Probe *a, const char *type)
{
	size_t soap_flag_wsdd__Probe = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Probe*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Probe, sizeof(struct __wsdd__Probe), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ProbeType(soap, "wsdd:Probe", &a->wsdd__Probe, "wsdd:ProbeType"))
				{	soap_flag_wsdd__Probe--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__Probe * SOAP_FMAC2 soap_dup___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *d, struct __wsdd__Probe const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__Probe*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__Probe, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__Probe(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ProbeType(soap, &d->wsdd__Probe, &a->wsdd__Probe);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__Probe(struct __wsdd__Probe const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ProbeType(&a->wsdd__Probe);
}

SOAP_FMAC1 struct __wsdd__Probe * SOAP_FMAC2 soap_instantiate___wsdd__Probe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Probe(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__Probe *p;
	size_t k = sizeof(struct __wsdd__Probe);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__Probe, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__Probe);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__Probe, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__Probe location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Probe(soap, tag ? tag : "-wsdd:Probe", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_get___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ByeType(soap, &a->wsdd__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Bye(struct soap *soap, const char *tag, int id, const struct __wsdd__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__ByeType(soap, "wsdd:Bye", -1, &a->wsdd__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_in___wsdd__Bye(struct soap *soap, const char *tag, struct __wsdd__Bye *a, const char *type)
{
	size_t soap_flag_wsdd__Bye = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Bye*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Bye, sizeof(struct __wsdd__Bye), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ByeType(soap, "wsdd:Bye", &a->wsdd__Bye, "wsdd:ByeType"))
				{	soap_flag_wsdd__Bye--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__Bye * SOAP_FMAC2 soap_dup___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *d, struct __wsdd__Bye const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__Bye*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__Bye, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__Bye(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ByeType(soap, &d->wsdd__Bye, &a->wsdd__Bye);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__Bye(struct __wsdd__Bye const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ByeType(&a->wsdd__Bye);
}

SOAP_FMAC1 struct __wsdd__Bye * SOAP_FMAC2 soap_instantiate___wsdd__Bye(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Bye(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__Bye *p;
	size_t k = sizeof(struct __wsdd__Bye);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__Bye, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__Bye);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__Bye, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__Bye location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Bye(soap, tag ? tag : "-wsdd:Bye", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_get___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__HelloType(soap, &a->wsdd__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Hello(struct soap *soap, const char *tag, int id, const struct __wsdd__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTowsdd__HelloType(soap, "wsdd:Hello", -1, &a->wsdd__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_in___wsdd__Hello(struct soap *soap, const char *tag, struct __wsdd__Hello *a, const char *type)
{
	size_t soap_flag_wsdd__Hello = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __wsdd__Hello*)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Hello, sizeof(struct __wsdd__Hello), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__HelloType(soap, "wsdd:Hello", &a->wsdd__Hello, "wsdd:HelloType"))
				{	soap_flag_wsdd__Hello--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __wsdd__Hello * SOAP_FMAC2 soap_dup___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *d, struct __wsdd__Hello const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct __wsdd__Hello*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE___wsdd__Hello, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new___wsdd__Hello(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__HelloType(soap, &d->wsdd__Hello, &a->wsdd__Hello);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del___wsdd__Hello(struct __wsdd__Hello const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__HelloType(&a->wsdd__Hello);
}

SOAP_FMAC1 struct __wsdd__Hello * SOAP_FMAC2 soap_instantiate___wsdd__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Hello(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __wsdd__Hello *p;
	size_t k = sizeof(struct __wsdd__Hello);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___wsdd__Hello, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __wsdd__Hello);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __wsdd__Hello, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __wsdd__Hello location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a, const char *tag, const char *type)
{
	if (soap_out___wsdd__Hello(soap, tag ? tag : "-wsdd:Hello", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_get___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__AppSequence(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__AppSequence(soap, tag ? tag : "wsdd:AppSequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Sig(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Sig(soap, tag ? tag : "wsdd:Sig", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Security(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Security(soap, tag ? tag : "wsdd:Security", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Scopes(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Scopes(soap, tag ? tag : "wsdd:Scopes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ResolveMatches(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ResolveMatches(soap, tag ? tag : "wsdd:ResolveMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Resolve(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Resolve(soap, tag ? tag : "wsdd:Resolve", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__ProbeMatches(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__ProbeMatches(soap, tag ? tag : "wsdd:ProbeMatches", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Probe(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Probe(soap, tag ? tag : "wsdd:Probe", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Bye(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Bye(soap, tag ? tag : "wsdd:Bye", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsdd__Hello(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out__wsdd__Hello(soap, tag ? tag : "wsdd:Hello", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__AppSequenceType(struct soap *soap, const char *tag, int id, const struct wsdd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", soap_string2s(soap, a->SequenceId), 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_in_wsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__AppSequenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 5, 3), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 1, 0), &a->SequenceId))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 5, 3), &a->MessageNumber))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__AppSequenceType * SOAP_FMAC2 soap_dup_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *d, struct wsdd__AppSequenceType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__AppSequenceType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__AppSequenceType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__AppSequenceType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->InstanceId = a->InstanceId;
	soap_dup_string(soap, &d->SequenceId, &a->SequenceId);
	d->MessageNumber = a->MessageNumber;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__AppSequenceType(struct wsdd__AppSequenceType const*a)
{
	if (!a)
		return;
	/* InstanceId skipped */
	soap_del_string(&a->SequenceId);
	/* MessageNumber skipped */
}

SOAP_FMAC1 struct wsdd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsdd__AppSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__AppSequenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__AppSequenceType *p;
	size_t k = sizeof(struct wsdd__AppSequenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__AppSequenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__AppSequenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__AppSequenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__AppSequenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__AppSequenceType(soap, tag ? tag : "wsdd:AppSequenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_get_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SigType(struct soap *soap, struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_string(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SigType(struct soap *soap, const char *tag, int id, const struct wsdd__SigType *a, const char *type)
{
	soap_set_attr(soap, "Scheme", a->Scheme ? soap_string2s(soap, a->Scheme) : "", 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", soap_string2s(soap, a->KeyId), 1);
	soap_set_attr(soap, "Refs", a->Refs ? soap_string2s(soap, a->Refs) : "", 1);
	soap_set_attr(soap, "Sig", a->Sig ? soap_string2s(soap, a->Sig) : "", 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SigType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_in_wsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SigType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1, 3), &a->Scheme))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 1, 0), &a->KeyId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1, 3), &a->Refs))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1, 3), &a->Sig))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__SigType * SOAP_FMAC2 soap_dup_wsdd__SigType(struct soap *soap, struct wsdd__SigType *d, struct wsdd__SigType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__SigType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__SigType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__SigType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->Scheme, &a->Scheme);
	soap_dup_string(soap, &d->KeyId, &a->KeyId);
	soap_dup_string(soap, &d->Refs, &a->Refs);
	soap_dup_string(soap, &d->Sig, &a->Sig);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__SigType(struct wsdd__SigType const*a)
{
	if (!a)
		return;
	soap_del_string(&a->Scheme);
	soap_del_string(&a->KeyId);
	soap_del_string(&a->Refs);
	soap_del_string(&a->Sig);
}

SOAP_FMAC1 struct wsdd__SigType * SOAP_FMAC2 soap_instantiate_wsdd__SigType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__SigType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__SigType *p;
	size_t k = sizeof(struct wsdd__SigType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__SigType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__SigType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__SigType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__SigType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SigType(soap, tag ? tag : "wsdd:SigType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_get_wsdd__SigType(struct soap *soap, struct wsdd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__SigType(soap, &a->Sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SecurityType(struct soap *soap, const char *tag, int id, const struct wsdd__SecurityType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__SigType(soap, "wsdd:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_in_wsdd__SecurityType(struct soap *soap, const char *tag, struct wsdd__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__SecurityType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SecurityType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__SigType(soap, "wsdd:Sig", &a->Sig, "wsdd:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__SecurityType * SOAP_FMAC2 soap_dup_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *d, struct wsdd__SecurityType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__SecurityType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__SecurityType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__SecurityType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__SigType(soap, &d->Sig, &a->Sig);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__SecurityType(struct wsdd__SecurityType const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__SigType(&a->Sig);
}

SOAP_FMAC1 struct wsdd__SecurityType * SOAP_FMAC2 soap_instantiate_wsdd__SecurityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__SecurityType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__SecurityType *p;
	size_t k = sizeof(struct wsdd__SecurityType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__SecurityType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__SecurityType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__SecurityType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__SecurityType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__SecurityType(soap, tag ? tag : "wsdd:SecurityType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_get_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ScopesType(struct soap *soap, const char *tag, int id, const struct wsdd__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", soap_string2s(soap, a->MatchBy), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_wsdd__UriListType(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_in_wsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsdd__ScopesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsdd__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 1, 0), &a->MatchBy))
		return NULL;
	if (!soap_in_wsdd__UriListType(soap, tag, (char**)&a->__item, "wsdd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsdd__ScopesType * SOAP_FMAC2 soap_dup_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *d, struct wsdd__ScopesType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ScopesType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ScopesType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ScopesType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_wsdd__UriListType(soap, &d->__item, &a->__item);
	soap_dup_string(soap, &d->MatchBy, &a->MatchBy);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ScopesType(struct wsdd__ScopesType const*a)
{
	if (!a)
		return;
	soap_del_wsdd__UriListType(&a->__item);
	soap_del_string(&a->MatchBy);
}

SOAP_FMAC1 struct wsdd__ScopesType * SOAP_FMAC2 soap_instantiate_wsdd__ScopesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ScopesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ScopesType *p;
	size_t k = sizeof(struct wsdd__ScopesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ScopesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ScopesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ScopesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ScopesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ScopesType(soap, tag ? tag : "wsdd:ScopesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_get_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa5__EndpointReference(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, ""))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa5__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveMatchType * SOAP_FMAC2 soap_dup_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *d, struct wsdd__ResolveMatchType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ResolveMatchType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ResolveMatchType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ResolveMatchType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__EndpointReference(soap, &d->wsa5__EndpointReference, &a->wsa5__EndpointReference);
	soap_dup_wsdd__QNameListType(soap, &d->Types, &a->Types);
	soap_dup_PointerTowsdd__ScopesType(soap, &d->Scopes, &a->Scopes);
	soap_dup_wsdd__UriListType(soap, &d->XAddrs, &a->XAddrs);
	d->MetadataVersion = a->MetadataVersion;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ResolveMatchType(struct wsdd__ResolveMatchType const*a)
{
	if (!a)
		return;
	soap_del__wsa5__EndpointReference(&a->wsa5__EndpointReference);
	soap_del_wsdd__QNameListType(&a->Types);
	soap_del_PointerTowsdd__ScopesType(&a->Scopes);
	soap_del_wsdd__UriListType(&a->XAddrs);
	/* MetadataVersion skipped */
}

SOAP_FMAC1 struct wsdd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveMatchType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ResolveMatchType *p;
	size_t k = sizeof(struct wsdd__ResolveMatchType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ResolveMatchType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ResolveMatchType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ResolveMatchType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ResolveMatchType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchType(soap, tag ? tag : "wsdd:ResolveMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTowsdd__ResolveMatchType(soap, &a->ResolveMatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", &a->ResolveMatch, "wsdd:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveMatchesType * SOAP_FMAC2 soap_dup_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *d, struct wsdd__ResolveMatchesType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ResolveMatchesType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ResolveMatchesType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ResolveMatchesType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerTowsdd__ResolveMatchType(soap, &d->ResolveMatch, &a->ResolveMatch);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ResolveMatchesType(struct wsdd__ResolveMatchesType const*a)
{
	if (!a)
		return;
	soap_del_PointerTowsdd__ResolveMatchType(&a->ResolveMatch);
}

SOAP_FMAC1 struct wsdd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveMatchesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ResolveMatchesType *p;
	size_t k = sizeof(struct wsdd__ResolveMatchesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ResolveMatchesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ResolveMatchesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ResolveMatchesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ResolveMatchesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveMatchesType(soap, tag ? tag : "wsdd:ResolveMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa5:EndpointReference");
	if (soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_in_wsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ResolveType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa5__EndpointReference(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, ""))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			soap_check_result(soap, "wsa5:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa5__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ResolveType * SOAP_FMAC2 soap_dup_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *d, struct wsdd__ResolveType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ResolveType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ResolveType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ResolveType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__EndpointReference(soap, &d->wsa5__EndpointReference, &a->wsa5__EndpointReference);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ResolveType(struct wsdd__ResolveType const*a)
{
	if (!a)
		return;
	soap_del__wsa5__EndpointReference(&a->wsa5__EndpointReference);
}

SOAP_FMAC1 struct wsdd__ResolveType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ResolveType *p;
	size_t k = sizeof(struct wsdd__ResolveType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ResolveType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ResolveType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ResolveType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ResolveType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ResolveType(soap, tag ? tag : "wsdd:ResolveType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_get_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa5__EndpointReference(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, ""))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa5__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeMatchType * SOAP_FMAC2 soap_dup_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *d, struct wsdd__ProbeMatchType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ProbeMatchType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ProbeMatchType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ProbeMatchType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__EndpointReference(soap, &d->wsa5__EndpointReference, &a->wsa5__EndpointReference);
	soap_dup_wsdd__QNameListType(soap, &d->Types, &a->Types);
	soap_dup_PointerTowsdd__ScopesType(soap, &d->Scopes, &a->Scopes);
	soap_dup_wsdd__UriListType(soap, &d->XAddrs, &a->XAddrs);
	d->MetadataVersion = a->MetadataVersion;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ProbeMatchType(struct wsdd__ProbeMatchType const*a)
{
	if (!a)
		return;
	soap_del__wsa5__EndpointReference(&a->wsa5__EndpointReference);
	soap_del_wsdd__QNameListType(&a->Types);
	soap_del_PointerTowsdd__ScopesType(&a->Scopes);
	soap_del_wsdd__UriListType(&a->XAddrs);
	/* MetadataVersion skipped */
}

SOAP_FMAC1 struct wsdd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeMatchType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ProbeMatchType *p;
	size_t k = sizeof(struct wsdd__ProbeMatchType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ProbeMatchType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ProbeMatchType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ProbeMatchType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ProbeMatchType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchType(soap, tag ? tag : "wsdd:ProbeMatchType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_wsdd__ProbeMatchType);
			soap_serialize_wsdd__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			if (soap_out_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeMatchesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchesType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_alloc_block(soap);
					a->ProbeMatch = soap_block<struct wsdd__ProbeMatchType>::push(soap, soap_blist_ProbeMatch);
					if (a->ProbeMatch == NULL)
						return NULL;
					soap_default_wsdd__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", a->ProbeMatch, "wsdd:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_block<struct wsdd__ProbeMatchType>::pop(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
		{	a->ProbeMatch = soap_new_wsdd__ProbeMatchType(soap, a->__sizeProbeMatch);
			if (!a->ProbeMatch)
				return NULL;
			soap_block<struct wsdd__ProbeMatchType>::save(soap, soap_blist_ProbeMatch, a->ProbeMatch);
		}
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_block<struct wsdd__ProbeMatchType>::end(soap, soap_blist_ProbeMatch);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeMatchesType * SOAP_FMAC2 soap_dup_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *d, struct wsdd__ProbeMatchesType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ProbeMatchesType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ProbeMatchesType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ProbeMatchesType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__sizeProbeMatch = a->__sizeProbeMatch;
	if (a->__sizeProbeMatch > 0 && a->ProbeMatch)
	{	int i;
		d->ProbeMatch = soap_new_wsdd__ProbeMatchType(soap, a->__sizeProbeMatch);
		if (!d->ProbeMatch)
			return NULL;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			soap_dup_wsdd__ProbeMatchType(soap, &d->ProbeMatch[i], &a->ProbeMatch[i]);
	}
	else
		d->ProbeMatch = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ProbeMatchesType(struct wsdd__ProbeMatchesType const*a)
{
	if (!a)
		return;
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < (int)a->__sizeProbeMatch; i++)
			soap_del_wsdd__ProbeMatchType(&a->ProbeMatch[i]);
		SOAP_DELETE_ARRAY(soap, a->ProbeMatch, struct wsdd__ProbeMatchType);
	}
}

SOAP_FMAC1 struct wsdd__ProbeMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeMatchesType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ProbeMatchesType *p;
	size_t k = sizeof(struct wsdd__ProbeMatchesType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ProbeMatchesType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ProbeMatchesType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ProbeMatchesType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ProbeMatchesType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeMatchesType(soap, tag ? tag : "wsdd:ProbeMatchesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeType), type))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_in_wsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ProbeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ProbeType * SOAP_FMAC2 soap_dup_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *d, struct wsdd__ProbeType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ProbeType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ProbeType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ProbeType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_wsdd__QNameListType(soap, &d->Types, &a->Types);
	soap_dup_PointerTowsdd__ScopesType(soap, &d->Scopes, &a->Scopes);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ProbeType(struct wsdd__ProbeType const*a)
{
	if (!a)
		return;
	soap_del_wsdd__QNameListType(&a->Types);
	soap_del_PointerTowsdd__ScopesType(&a->Scopes);
}

SOAP_FMAC1 struct wsdd__ProbeType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ProbeType *p;
	size_t k = sizeof(struct wsdd__ProbeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ProbeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ProbeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ProbeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ProbeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ProbeType(soap, tag ? tag : "wsdd:ProbeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_get_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ByeType(struct soap *soap, const char *tag, int id, const struct wsdd__ByeType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ByeType), type))
		return soap->error;
	if (soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_in_wsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__ByeType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ByeType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa5__EndpointReference(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, ""))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTounsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa5__EndpointReference > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__ByeType * SOAP_FMAC2 soap_dup_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *d, struct wsdd__ByeType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__ByeType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__ByeType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__ByeType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__EndpointReference(soap, &d->wsa5__EndpointReference, &a->wsa5__EndpointReference);
	soap_dup_wsdd__QNameListType(soap, &d->Types, &a->Types);
	soap_dup_PointerTowsdd__ScopesType(soap, &d->Scopes, &a->Scopes);
	soap_dup_wsdd__UriListType(soap, &d->XAddrs, &a->XAddrs);
	soap_dup_PointerTounsignedInt(soap, &d->MetadataVersion, &a->MetadataVersion);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__ByeType(struct wsdd__ByeType const*a)
{
	if (!a)
		return;
	soap_del__wsa5__EndpointReference(&a->wsa5__EndpointReference);
	soap_del_wsdd__QNameListType(&a->Types);
	soap_del_PointerTowsdd__ScopesType(&a->Scopes);
	soap_del_wsdd__UriListType(&a->XAddrs);
	soap_del_PointerTounsignedInt(&a->MetadataVersion);
}

SOAP_FMAC1 struct wsdd__ByeType * SOAP_FMAC2 soap_instantiate_wsdd__ByeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ByeType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__ByeType *p;
	size_t k = sizeof(struct wsdd__ByeType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__ByeType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__ByeType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__ByeType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__ByeType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__ByeType(soap, tag ? tag : "wsdd:ByeType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_get_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__EndpointReference(soap, &a->wsa5__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, (char*const*)&a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, (char*const*)&a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__HelloType(struct soap *soap, const char *tag, int id, const struct wsdd__HelloType *a, const char *type)
{
	const char *soap_tmp_Types;
	soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__HelloType), type))
		return soap->error;
	if (soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", -1, &a->wsa5__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)(void*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, (char*const*)&a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_in_wsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType *a, const char *type)
{
	size_t soap_flag_wsa5__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsdd__HelloType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__HelloType(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in__wsa5__EndpointReference(soap, "wsa5:EndpointReference", &a->wsa5__EndpointReference, ""))
				{	soap_flag_wsa5__EndpointReference--;
					continue;
				}
			}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", (char**)&a->Types, "xsd:QName"))
				{	soap_flag_Types--;
					continue;
				}
			}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", (char**)&a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap_flag_wsa5__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsdd__HelloType * SOAP_FMAC2 soap_dup_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *d, struct wsdd__HelloType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsdd__HelloType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsdd__HelloType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsdd__HelloType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__EndpointReference(soap, &d->wsa5__EndpointReference, &a->wsa5__EndpointReference);
	soap_dup_wsdd__QNameListType(soap, &d->Types, &a->Types);
	soap_dup_PointerTowsdd__ScopesType(soap, &d->Scopes, &a->Scopes);
	soap_dup_wsdd__UriListType(soap, &d->XAddrs, &a->XAddrs);
	d->MetadataVersion = a->MetadataVersion;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsdd__HelloType(struct wsdd__HelloType const*a)
{
	if (!a)
		return;
	soap_del__wsa5__EndpointReference(&a->wsa5__EndpointReference);
	soap_del_wsdd__QNameListType(&a->Types);
	soap_del_PointerTowsdd__ScopesType(&a->Scopes);
	soap_del_wsdd__UriListType(&a->XAddrs);
	/* MetadataVersion skipped */
}

SOAP_FMAC1 struct wsdd__HelloType * SOAP_FMAC2 soap_instantiate_wsdd__HelloType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__HelloType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsdd__HelloType *p;
	size_t k = sizeof(struct wsdd__HelloType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsdd__HelloType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsdd__HelloType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsdd__HelloType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsdd__HelloType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	if (soap_out_wsdd__HelloType(soap, tag ? tag : "wsdd:HelloType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_dup_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *d, struct SOAP_ENV__Fault const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Fault*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Fault, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Fault(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__QName(soap, &d->faultcode, &a->faultcode);
	soap_dup_string(soap, &d->faultstring, &a->faultstring);
	soap_dup_string(soap, &d->faultactor, &a->faultactor);
	soap_dup_PointerToSOAP_ENV__Detail(soap, &d->detail, &a->detail);
	soap_dup_PointerToSOAP_ENV__Code(soap, &d->SOAP_ENV__Code, &a->SOAP_ENV__Code);
	soap_dup_PointerToSOAP_ENV__Reason(soap, &d->SOAP_ENV__Reason, &a->SOAP_ENV__Reason);
	soap_dup_string(soap, &d->SOAP_ENV__Node, &a->SOAP_ENV__Node);
	soap_dup_string(soap, &d->SOAP_ENV__Role, &a->SOAP_ENV__Role);
	soap_dup_PointerToSOAP_ENV__Detail(soap, &d->SOAP_ENV__Detail, &a->SOAP_ENV__Detail);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Fault(struct SOAP_ENV__Fault const*a)
{
	if (!a)
		return;
	soap_del__QName(&a->faultcode);
	soap_del_string(&a->faultstring);
	soap_del_string(&a->faultactor);
	soap_del_PointerToSOAP_ENV__Detail(&a->detail);
	soap_del_PointerToSOAP_ENV__Code(&a->SOAP_ENV__Code);
	soap_del_PointerToSOAP_ENV__Reason(&a->SOAP_ENV__Reason);
	soap_del_string(&a->SOAP_ENV__Node);
	soap_del_string(&a->SOAP_ENV__Role);
	soap_del_PointerToSOAP_ENV__Detail(&a->SOAP_ENV__Detail);
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_dup_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *d, struct SOAP_ENV__Reason const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Reason*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Reason, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Reason(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->SOAP_ENV__Text, &a->SOAP_ENV__Text);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Reason(struct SOAP_ENV__Reason const*a)
{
	if (!a)
		return;
	soap_del_string(&a->SOAP_ENV__Text);
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_dup_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *d, struct SOAP_ENV__Code const*a)
{
	struct soap_plist *pp = NULL;
	char *mark = NULL;
	if (!a)
		return NULL;
	if (!d && ((d = (struct SOAP_ENV__Code*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Code, &pp, &mark)) || soap_mark_cycle(soap, pp)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Code(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__QName(soap, &d->SOAP_ENV__Value, &a->SOAP_ENV__Value);
	soap_dup_PointerToSOAP_ENV__Code(soap, &d->SOAP_ENV__Subcode, &a->SOAP_ENV__Subcode);
	soap_unmark(soap, mark);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Code(struct SOAP_ENV__Code const*a)
{
	if (!a)
		return;
	soap_del__QName(&a->SOAP_ENV__Value);
	soap_del_PointerToSOAP_ENV__Code(&a->SOAP_ENV__Subcode);
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_dup_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *d, struct SOAP_ENV__Detail const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Detail*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Detail, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Detail(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__any = soap_strdup(soap, (char*)a->__any);
	d->fault = soap_dupelement(soap, a->fault, d->__type = a->__type);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Detail(struct SOAP_ENV__Detail const*a)
{
	if (!a)
		return;
	if (a->__any)
		SOAP_FREE(NULL, a->__any);
	soap_delelement(a->fault, a->__type);
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
	a->wsdd__AppSequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_dup_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *d, struct SOAP_ENV__Header const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct SOAP_ENV__Header*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_SOAP_ENV__Header, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_SOAP_ENV__Header(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup__wsa5__MessageID(soap, &d->wsa5__MessageID, &a->wsa5__MessageID);
	soap_dup_PointerTo_wsa5__RelatesTo(soap, &d->wsa5__RelatesTo, &a->wsa5__RelatesTo);
	soap_dup_PointerTo_wsa5__From(soap, &d->wsa5__From, &a->wsa5__From);
	soap_dup_PointerTo_wsa5__ReplyTo(soap, &d->wsa5__ReplyTo, &a->wsa5__ReplyTo);
	soap_dup_PointerTo_wsa5__FaultTo(soap, &d->wsa5__FaultTo, &a->wsa5__FaultTo);
	soap_dup__wsa5__To(soap, &d->wsa5__To, &a->wsa5__To);
	soap_dup__wsa5__Action(soap, &d->wsa5__Action, &a->wsa5__Action);
	soap_dup_PointerTochan__ChannelInstanceType(soap, &d->chan__ChannelInstance, &a->chan__ChannelInstance);
	soap_dup_PointerTowsdd__AppSequenceType(soap, &d->wsdd__AppSequence, &a->wsdd__AppSequence);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_SOAP_ENV__Header(struct SOAP_ENV__Header const*a)
{
	if (!a)
		return;
	soap_del__wsa5__MessageID(&a->wsa5__MessageID);
	soap_del_PointerTo_wsa5__RelatesTo(&a->wsa5__RelatesTo);
	soap_del_PointerTo_wsa5__From(&a->wsa5__From);
	soap_del_PointerTo_wsa5__ReplyTo(&a->wsa5__ReplyTo);
	soap_del_PointerTo_wsa5__FaultTo(&a->wsa5__FaultTo);
	soap_del__wsa5__To(&a->wsa5__To);
	soap_del__wsa5__Action(&a->wsa5__Action);
	soap_del_PointerTochan__ChannelInstanceType(&a->chan__ChannelInstance);
	soap_del_PointerTowsdd__AppSequenceType(&a->wsdd__AppSequence);
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_dup_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *d, struct chan__ChannelInstanceType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct chan__ChannelInstanceType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_chan__ChannelInstanceType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_chan__ChannelInstanceType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__item = a->__item;
	d->wsa5__IsReferenceParameter = a->wsa5__IsReferenceParameter;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_chan__ChannelInstanceType(struct chan__ChannelInstanceType const*a)
{
	if (!a)
		return;
	/* __item skipped */
	/* wsa5__IsReferenceParameter skipped */
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_dup_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *d, struct wsa5__ProblemActionType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsa5__ProblemActionType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__ProblemActionType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__ProblemActionType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->Action, &a->Action);
	soap_dup_string(soap, &d->SoapAction, &a->SoapAction);
	d->__anyAttribute = soap_strdup(soap, (char*)a->__anyAttribute);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__ProblemActionType(struct wsa5__ProblemActionType const*a)
{
	if (!a)
		return;
	soap_del_string(&a->Action);
	soap_del_string(&a->SoapAction);
	if (a->__anyAttribute)
		SOAP_FREE(NULL, a->__anyAttribute);
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_dup_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *d, struct wsa5__RelatesToType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsa5__RelatesToType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__RelatesToType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__RelatesToType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->__item, &a->__item);
	soap_dup_wsa5__RelationshipTypeOpenEnum(soap, &d->RelationshipType, &a->RelationshipType);
	d->__anyAttribute = soap_strdup(soap, (char*)a->__anyAttribute);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__RelatesToType(struct wsa5__RelatesToType const*a)
{
	if (!a)
		return;
	soap_del_string(&a->__item);
	soap_del_wsa5__RelationshipTypeOpenEnum(&a->RelationshipType);
	if (a->__anyAttribute)
		SOAP_FREE(NULL, a->__anyAttribute);
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_dup_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *d, struct wsa5__MetadataType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsa5__MetadataType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__MetadataType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__MetadataType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	d->__size = a->__size;
	if (a->__size > 0 && a->__any)
	{	int i;
		d->__any = (char **)soap_malloc(soap, a->__size * sizeof(char *));
		if (!d->__any)
			return NULL;
		for (i = 0; i < (int)a->__size; i++)
			d->__any[i] = soap_strdup(soap, a->__any[i]);
	}
	else
		d->__any = NULL;
	d->__anyAttribute = soap_strdup(soap, (char*)a->__anyAttribute);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__MetadataType(struct wsa5__MetadataType const*a)
{
	if (!a)
		return;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			SOAP_FREE(NULL, a->__any[i]);
		SOAP_FREE(NULL, a->__any);
	}
	if (a->__anyAttribute)
		SOAP_FREE(NULL, a->__anyAttribute);
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_dup_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *d, struct wsa5__ReferenceParametersType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsa5__ReferenceParametersType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__ReferenceParametersType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__ReferenceParametersType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_PointerToint(soap, &d->chan__ChannelInstance, &a->chan__ChannelInstance);
	d->__size = a->__size;
	if (a->__size > 0 && a->__any)
	{	int i;
		d->__any = (char **)soap_malloc(soap, a->__size * sizeof(char *));
		if (!d->__any)
			return NULL;
		for (i = 0; i < (int)a->__size; i++)
			d->__any[i] = soap_strdup(soap, a->__any[i]);
	}
	else
		d->__any = NULL;
	d->__anyAttribute = soap_strdup(soap, (char*)a->__anyAttribute);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__ReferenceParametersType(struct wsa5__ReferenceParametersType const*a)
{
	if (!a)
		return;
	soap_del_PointerToint(&a->chan__ChannelInstance);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			SOAP_FREE(NULL, a->__any[i]);
		SOAP_FREE(NULL, a->__any);
	}
	if (a->__anyAttribute)
		SOAP_FREE(NULL, a->__anyAttribute);
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if (*soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_dup_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *d, struct wsa5__EndpointReferenceType const*a)
{
	struct soap_plist *pp = NULL;
	if (!a)
		return NULL;
	if (!d && (d = (struct wsa5__EndpointReferenceType*)soap_mark_lookup(soap, (const void*)a, SOAP_TYPE_wsa5__EndpointReferenceType, &pp, NULL)))
		return d;
	if (!d && !(d = soap_new_wsa5__EndpointReferenceType(soap)))
		return NULL; /* ERROR */
	soap_mark_dup(soap, (void*)d, pp);
	soap_dup_string(soap, &d->Address, &a->Address);
	soap_dup_PointerTowsa5__ReferenceParametersType(soap, &d->ReferenceParameters, &a->ReferenceParameters);
	soap_dup_PointerTowsa5__MetadataType(soap, &d->Metadata, &a->Metadata);
	d->__size = a->__size;
	if (a->__size > 0 && a->__any)
	{	int i;
		d->__any = (char **)soap_malloc(soap, a->__size * sizeof(char *));
		if (!d->__any)
			return NULL;
		for (i = 0; i < (int)a->__size; i++)
			d->__any[i] = soap_strdup(soap, a->__any[i]);
	}
	else
		d->__any = NULL;
	d->__anyAttribute = soap_strdup(soap, (char*)a->__anyAttribute);
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_wsa5__EndpointReferenceType(struct wsa5__EndpointReferenceType const*a)
{
	if (!a)
		return;
	soap_del_string(&a->Address);
	soap_del_PointerTowsa5__ReferenceParametersType(&a->ReferenceParameters);
	soap_del_PointerTowsa5__MetadataType(&a->Metadata);
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			SOAP_FREE(NULL, a->__any[i]);
		SOAP_FREE(NULL, a->__any);
	}
	if (a->__anyAttribute)
		SOAP_FREE(NULL, a->__anyAttribute);
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_ColorOptions(struct soap *soap, int choice, const union _tt__union_ColorOptions *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_ColorOptions_ColorList:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTott__Color(soap, &a->ColorList);
		break;
	case SOAP_UNION__tt__union_ColorOptions_ColorspaceRange:
		soap_serialize_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, &a->ColorspaceRange);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_ColorOptions(struct soap *soap, int choice, const union _tt__union_ColorOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_ColorOptions_ColorList:
		return soap_out_PointerTostd__vectorTemplateOfPointerTott__Color(soap, "tt:ColorList", -1, &a->ColorList, "");
	case SOAP_UNION__tt__union_ColorOptions_ColorspaceRange:
		return soap_out_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, "tt:ColorspaceRange", -1, &a->ColorspaceRange, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_ColorOptions * SOAP_FMAC4 soap_in__tt__union_ColorOptions(struct soap *soap, int *choice, union _tt__union_ColorOptions *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->ColorList = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTott__Color(soap, "tt:ColorList", &a->ColorList, "tt:Color"))
	{	*choice = SOAP_UNION__tt__union_ColorOptions_ColorList;
		return a;
	}
	a->ColorspaceRange = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange(soap, "tt:ColorspaceRange", &a->ColorspaceRange, "tt:ColorspaceRange"))
	{	*choice = SOAP_UNION__tt__union_ColorOptions_ColorspaceRange;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteOSD(struct soap *soap, _trt__DeleteOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteOSD))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteOSD(struct soap *soap, const char *tag, int id, _trt__DeleteOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteOSD, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__DeleteOSD ? type : NULL);
}

SOAP_FMAC3 _trt__DeleteOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteOSD(struct soap *soap, const char *tag, _trt__DeleteOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__DeleteOSD **)soap_malloc(soap, sizeof(_trt__DeleteOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__DeleteOSD *)soap_instantiate__trt__DeleteOSD(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__DeleteOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteOSD, sizeof(_trt__DeleteOSD), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__DeleteOSD * * SOAP_FMAC2 soap_dup_PointerTo_trt__DeleteOSD(struct soap *soap, _trt__DeleteOSD * *d, _trt__DeleteOSD *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__DeleteOSD **)soap_malloc(soap, sizeof(_trt__DeleteOSD *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__DeleteOSD(_trt__DeleteOSD *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__DeleteOSD);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteOSD(struct soap *soap, _trt__DeleteOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__DeleteOSD(soap, tag ? tag : "trt:DeleteOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__DeleteOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteOSD(struct soap *soap, _trt__DeleteOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateOSD(struct soap *soap, _trt__CreateOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateOSD))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateOSD(struct soap *soap, const char *tag, int id, _trt__CreateOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateOSD, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__CreateOSD ? type : NULL);
}

SOAP_FMAC3 _trt__CreateOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateOSD(struct soap *soap, const char *tag, _trt__CreateOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__CreateOSD **)soap_malloc(soap, sizeof(_trt__CreateOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__CreateOSD *)soap_instantiate__trt__CreateOSD(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__CreateOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateOSD, sizeof(_trt__CreateOSD), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__CreateOSD * * SOAP_FMAC2 soap_dup_PointerTo_trt__CreateOSD(struct soap *soap, _trt__CreateOSD * *d, _trt__CreateOSD *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__CreateOSD **)soap_malloc(soap, sizeof(_trt__CreateOSD *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__CreateOSD(_trt__CreateOSD *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__CreateOSD);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateOSD(struct soap *soap, _trt__CreateOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__CreateOSD(soap, tag ? tag : "trt:CreateOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__CreateOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateOSD(struct soap *soap, _trt__CreateOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetOSD(struct soap *soap, _trt__SetOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetOSD))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetOSD(struct soap *soap, const char *tag, int id, _trt__SetOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetOSD, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetOSD ? type : NULL);
}

SOAP_FMAC3 _trt__SetOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__SetOSD(struct soap *soap, const char *tag, _trt__SetOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetOSD **)soap_malloc(soap, sizeof(_trt__SetOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetOSD *)soap_instantiate__trt__SetOSD(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetOSD, sizeof(_trt__SetOSD), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetOSD * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetOSD(struct soap *soap, _trt__SetOSD * *d, _trt__SetOSD *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetOSD **)soap_malloc(soap, sizeof(_trt__SetOSD *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetOSD(_trt__SetOSD *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetOSD);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetOSD(struct soap *soap, _trt__SetOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetOSD(soap, tag ? tag : "trt:SetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__SetOSD(struct soap *soap, _trt__SetOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDOptions(struct soap *soap, _trt__GetOSDOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDOptions(struct soap *soap, const char *tag, int id, _trt__GetOSDOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetOSDOptions ? type : NULL);
}

SOAP_FMAC3 _trt__GetOSDOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDOptions(struct soap *soap, const char *tag, _trt__GetOSDOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetOSDOptions **)soap_malloc(soap, sizeof(_trt__GetOSDOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetOSDOptions *)soap_instantiate__trt__GetOSDOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetOSDOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDOptions, sizeof(_trt__GetOSDOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetOSDOptions * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetOSDOptions(struct soap *soap, _trt__GetOSDOptions * *d, _trt__GetOSDOptions *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetOSDOptions **)soap_malloc(soap, sizeof(_trt__GetOSDOptions *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetOSDOptions(_trt__GetOSDOptions *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetOSDOptions);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDOptions(struct soap *soap, _trt__GetOSDOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDOptions(soap, tag ? tag : "trt:GetOSDOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetOSDOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDOptions(struct soap *soap, _trt__GetOSDOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSD(struct soap *soap, _trt__GetOSD *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSD))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSD(struct soap *soap, const char *tag, int id, _trt__GetOSD *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSD, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetOSD ? type : NULL);
}

SOAP_FMAC3 _trt__GetOSD ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSD(struct soap *soap, const char *tag, _trt__GetOSD **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetOSD **)soap_malloc(soap, sizeof(_trt__GetOSD *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetOSD *)soap_instantiate__trt__GetOSD(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetOSD **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSD, sizeof(_trt__GetOSD), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetOSD * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetOSD(struct soap *soap, _trt__GetOSD * *d, _trt__GetOSD *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetOSD **)soap_malloc(soap, sizeof(_trt__GetOSD *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetOSD(_trt__GetOSD *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetOSD);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSD(struct soap *soap, _trt__GetOSD *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSD(soap, tag ? tag : "trt:GetOSD", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetOSD ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSD(struct soap *soap, _trt__GetOSD **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSD(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetOSDs(struct soap *soap, _trt__GetOSDs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetOSDs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetOSDs(struct soap *soap, const char *tag, int id, _trt__GetOSDs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetOSDs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetOSDs ? type : NULL);
}

SOAP_FMAC3 _trt__GetOSDs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetOSDs(struct soap *soap, const char *tag, _trt__GetOSDs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetOSDs **)soap_malloc(soap, sizeof(_trt__GetOSDs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetOSDs *)soap_instantiate__trt__GetOSDs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetOSDs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetOSDs, sizeof(_trt__GetOSDs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetOSDs * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetOSDs(struct soap *soap, _trt__GetOSDs * *d, _trt__GetOSDs *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetOSDs **)soap_malloc(soap, sizeof(_trt__GetOSDs *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetOSDs(_trt__GetOSDs *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetOSDs);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetOSDs(struct soap *soap, _trt__GetOSDs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetOSDs(soap, tag ? tag : "trt:GetOSDs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetOSDs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetOSDs(struct soap *soap, _trt__GetOSDs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetOSDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceMode(struct soap *soap, _trt__SetVideoSourceMode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceMode(struct soap *soap, const char *tag, int id, _trt__SetVideoSourceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceMode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__SetVideoSourceMode ? type : NULL);
}

SOAP_FMAC3 _trt__SetVideoSourceMode ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceMode(struct soap *soap, const char *tag, _trt__SetVideoSourceMode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoSourceMode **)soap_malloc(soap, sizeof(_trt__SetVideoSourceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoSourceMode *)soap_instantiate__trt__SetVideoSourceMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__SetVideoSourceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceMode, sizeof(_trt__SetVideoSourceMode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__SetVideoSourceMode * * SOAP_FMAC2 soap_dup_PointerTo_trt__SetVideoSourceMode(struct soap *soap, _trt__SetVideoSourceMode * *d, _trt__SetVideoSourceMode *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__SetVideoSourceMode **)soap_malloc(soap, sizeof(_trt__SetVideoSourceMode *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__SetVideoSourceMode(_trt__SetVideoSourceMode *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__SetVideoSourceMode);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceMode(struct soap *soap, _trt__SetVideoSourceMode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__SetVideoSourceMode(soap, tag ? tag : "trt:SetVideoSourceMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoSourceMode ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceMode(struct soap *soap, _trt__SetVideoSourceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceModes(struct soap *soap, _trt__GetVideoSourceModes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceModes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceModes(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceModes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceModes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__trt__GetVideoSourceModes ? type : NULL);
}

SOAP_FMAC3 _trt__GetVideoSourceModes ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceModes(struct soap *soap, const char *tag, _trt__GetVideoSourceModes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceModes **)soap_malloc(soap, sizeof(_trt__GetVideoSourceModes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceModes *)soap_instantiate__trt__GetVideoSourceModes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_trt__GetVideoSourceModes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceModes, sizeof(_trt__GetVideoSourceModes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _trt__GetVideoSourceModes * * SOAP_FMAC2 soap_dup_PointerTo_trt__GetVideoSourceModes(struct soap *soap, _trt__GetVideoSourceModes * *d, _trt__GetVideoSourceModes *const*a)
{
	if (!a)
		return NULL;
	if (!d && !(d = (_trt__GetVideoSourceModes **)soap_malloc(soap, sizeof(_trt__GetVideoSourceModes *))))
		return NULL; /* ERROR */
	if (*a)
		*d = (*a)->soap_dup(soap);
	else
		*d = NULL;
	return d;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_del_PointerTo_trt__GetVideoSourceModes(_trt__GetVideoSourceModes *const*a)
{
	if (!a)
		return;
	if (*a)
	{	(*a)->soap_del();
		SOAP_DELETE(NULL, *a, _trt__GetVideoSourceModes);
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceModes(struct soap *soap, _trt__GetVideoSourceModes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_trt__GetVideoSourceModes(soap, tag ? tag : "trt:GetVideoSourceModes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceModes ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceModes(struct soap *soap, _trt__GetVideoSourceModes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceModes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC_nnn.cpp */
